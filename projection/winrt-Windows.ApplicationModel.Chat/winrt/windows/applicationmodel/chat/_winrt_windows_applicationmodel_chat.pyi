# WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

import datetime
import sys
import types
import typing
import uuid as _uuid

import winrt.system
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.media.mediaproperties
import winrt.windows.security.credentials
import winrt.windows.storage.streams

from . import ChatConversationThreadingKind, ChatItemKind, ChatMessageChangeType, ChatMessageKind, ChatMessageOperatorKind, ChatMessageStatus, ChatMessageTransportKind, ChatMessageValidationStatus, ChatRestoreHistorySpan, ChatStoreChangedEventKind, ChatTransportErrorCodeCategory, ChatTransportInterpretedErrorCode, RcsServiceKind

Self = typing.TypeVar('Self')

class ChatCapabilities(winrt.system.Object):
    is_chat_capable: bool
    is_file_transfer_capable: bool
    is_geo_location_push_capable: bool
    is_integrated_messaging_capable: bool
    is_online: bool
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatCapabilities: ...

class ChatCapabilitiesManager(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatCapabilitiesManager: ...
    @typing.overload
    @staticmethod
    def get_cached_capabilities_async(address: str, /) -> winrt.windows.foundation.IAsyncOperation[ChatCapabilities]: ...
    @typing.overload
    @staticmethod
    def get_cached_capabilities_async(address: str, transport_id: str, /) -> winrt.windows.foundation.IAsyncOperation[ChatCapabilities]: ...
    @typing.overload
    @staticmethod
    def get_capabilities_from_network_async(address: str, /) -> winrt.windows.foundation.IAsyncOperation[ChatCapabilities]: ...
    @typing.overload
    @staticmethod
    def get_capabilities_from_network_async(address: str, transport_id: str, /) -> winrt.windows.foundation.IAsyncOperation[ChatCapabilities]: ...

class ChatConversation(winrt.system.Object):
    subject: str
    is_conversation_muted: bool
    has_unread_messages: bool
    id: str
    most_recent_message_id: str
    participants: typing.Optional[winrt.windows.foundation.collections.IVector[str]]
    threading_info: typing.Optional[ChatConversationThreadingInfo]
    can_modify_participants: bool
    item_kind: ChatItemKind
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatConversation: ...
    def delete_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def get_message_reader(self) -> typing.Optional[ChatMessageReader]: ...
    @typing.overload
    def mark_messages_as_read_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def mark_messages_as_read_async(self, value: datetime.datetime, /) -> winrt.windows.foundation.IAsyncAction: ...
    def notify_local_participant_composing(self, transport_id: str, participant_address: str, is_composing: bool, /) -> None: ...
    def notify_remote_participant_composing(self, transport_id: str, participant_address: str, is_composing: bool, /) -> None: ...
    def save_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def add_remote_participant_composing_changed(self, handler: winrt.windows.foundation.TypedEventHandler[ChatConversation, RemoteParticipantComposingChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_remote_participant_composing_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class ChatConversationReader(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatConversationReader: ...
    @typing.overload
    def read_batch_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[ChatConversation]]: ...
    @typing.overload
    def read_batch_async(self, count: winrt.system.Int32, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[ChatConversation]]: ...

class ChatConversationThreadingInfo(winrt.system.Object):
    kind: ChatConversationThreadingKind
    custom: str
    conversation_id: str
    contact_id: str
    participants: typing.Optional[winrt.windows.foundation.collections.IVector[str]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatConversationThreadingInfo: ...
    def __new__(cls: typing.Type[ChatConversationThreadingInfo]) -> ChatConversationThreadingInfo:...

class ChatMessage(winrt.system.Object):
    item_kind: ChatItemKind
    is_incoming: bool
    is_forwarding_disabled: bool
    transport_id: str
    status: ChatMessageStatus
    from_: str
    body: str
    subject: str
    is_read: bool
    network_timestamp: datetime.datetime
    local_timestamp: datetime.datetime
    recipient_send_statuses: typing.Optional[winrt.windows.foundation.collections.IMapView[str, ChatMessageStatus]]
    recipients: typing.Optional[winrt.windows.foundation.collections.IVector[str]]
    transport_friendly_name: str
    attachments: typing.Optional[winrt.windows.foundation.collections.IVector[ChatMessageAttachment]]
    id: str
    is_seen: bool
    message_kind: ChatMessageKind
    is_received_during_quiet_hours: bool
    is_auto_reply: bool
    estimated_download_size: winrt.system.UInt64
    threading_info: typing.Optional[ChatConversationThreadingInfo]
    should_suppress_notification: bool
    remote_id: str
    message_operator_kind: ChatMessageOperatorKind
    is_reply_disabled: bool
    is_sim_message: bool
    recipients_delivery_infos: typing.Optional[winrt.windows.foundation.collections.IVector[ChatRecipientDeliveryInfo]]
    sync_id: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatMessage: ...
    def __new__(cls: typing.Type[ChatMessage]) -> ChatMessage:...

class ChatMessageAttachment(winrt.system.Object):
    text: str
    mime_type: str
    group_id: winrt.system.UInt32
    data_stream_reference: typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference]
    transfer_progress: winrt.system.Double
    thumbnail: typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference]
    original_file_name: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatMessageAttachment: ...
    def __new__(cls: typing.Type[ChatMessageAttachment], mime_type: str, data_stream_reference: typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference]) -> ChatMessageAttachment:...

class ChatMessageBlocking(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatMessageBlocking: ...
    @staticmethod
    def mark_message_as_blocked_async(local_chat_message_id: str, blocked: bool, /) -> winrt.windows.foundation.IAsyncAction: ...

class ChatMessageChange(winrt.system.Object):
    change_type: ChatMessageChangeType
    message: typing.Optional[ChatMessage]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatMessageChange: ...

class ChatMessageChangeReader(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatMessageChangeReader: ...
    def accept_changes(self) -> None: ...
    def accept_changes_through(self, last_change_to_acknowledge: typing.Optional[ChatMessageChange], /) -> None: ...
    def read_batch_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[ChatMessageChange]]: ...

class ChatMessageChangeTracker(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatMessageChangeTracker: ...
    def enable(self) -> None: ...
    def get_change_reader(self) -> typing.Optional[ChatMessageChangeReader]: ...
    def reset(self) -> None: ...

class ChatMessageChangedDeferral(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatMessageChangedDeferral: ...
    def complete(self) -> None: ...

class ChatMessageChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatMessageChangedEventArgs: ...
    def get_deferral(self) -> typing.Optional[ChatMessageChangedDeferral]: ...

class ChatMessageManager(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatMessageManager: ...
    @staticmethod
    def get_transport_async(transport_id: str, /) -> winrt.windows.foundation.IAsyncOperation[ChatMessageTransport]: ...
    @staticmethod
    def get_transports_async() -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[ChatMessageTransport]]: ...
    @staticmethod
    def register_transport_async() -> winrt.windows.foundation.IAsyncOperation[str]: ...
    @staticmethod
    def request_store_async() -> winrt.windows.foundation.IAsyncOperation[ChatMessageStore]: ...
    @staticmethod
    def request_sync_manager_async() -> winrt.windows.foundation.IAsyncOperation[ChatSyncManager]: ...
    @staticmethod
    def show_compose_sms_message_async(message: typing.Optional[ChatMessage], /) -> winrt.windows.foundation.IAsyncAction: ...
    @staticmethod
    def show_sms_settings() -> None: ...

class ChatMessageNotificationTriggerDetails(winrt.system.Object):
    chat_message: typing.Optional[ChatMessage]
    should_display_toast: bool
    should_update_action_center: bool
    should_update_badge: bool
    should_update_detail_text: bool
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatMessageNotificationTriggerDetails: ...

class ChatMessageReader(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatMessageReader: ...
    @typing.overload
    def read_batch_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[ChatMessage]]: ...
    @typing.overload
    def read_batch_async(self, count: winrt.system.Int32, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[ChatMessage]]: ...

class ChatMessageStore(winrt.system.Object):
    change_tracker: typing.Optional[ChatMessageChangeTracker]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatMessageStore: ...
    def delete_message_async(self, local_message_id: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    def download_message_async(self, local_chat_message_id: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    def forward_message_async(self, local_chat_message_id: str, addresses: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncOperation[ChatMessage]: ...
    @typing.overload
    def get_conversation_async(self, conversation_id: str, /) -> winrt.windows.foundation.IAsyncOperation[ChatConversation]: ...
    @typing.overload
    def get_conversation_async(self, conversation_id: str, transport_ids: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncOperation[ChatConversation]: ...
    def get_conversation_from_threading_info_async(self, threading_info: typing.Optional[ChatConversationThreadingInfo], /) -> winrt.windows.foundation.IAsyncOperation[ChatConversation]: ...
    @typing.overload
    def get_conversation_reader(self) -> typing.Optional[ChatConversationReader]: ...
    @typing.overload
    def get_conversation_reader(self, transport_ids: typing.Iterable[str], /) -> typing.Optional[ChatConversationReader]: ...
    def get_message_async(self, local_chat_message_id: str, /) -> winrt.windows.foundation.IAsyncOperation[ChatMessage]: ...
    def get_message_by_remote_id_async(self, transport_id: str, remote_id: str, /) -> winrt.windows.foundation.IAsyncOperation[ChatMessage]: ...
    def get_message_by_sync_id_async(self, sync_id: str, /) -> winrt.windows.foundation.IAsyncOperation[ChatMessage]: ...
    @typing.overload
    def get_message_reader(self) -> typing.Optional[ChatMessageReader]: ...
    @typing.overload
    def get_message_reader(self, recent_time_limit: datetime.timedelta, /) -> typing.Optional[ChatMessageReader]: ...
    def get_search_reader(self, value: typing.Optional[ChatQueryOptions], /) -> typing.Optional[ChatSearchReader]: ...
    @typing.overload
    def get_unseen_count_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Int32]: ...
    @typing.overload
    def get_unseen_count_async(self, transport_ids: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Int32]: ...
    @typing.overload
    def mark_as_seen_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def mark_as_seen_async(self, transport_ids: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncAction: ...
    def mark_message_read_async(self, local_chat_message_id: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    def retry_send_message_async(self, local_chat_message_id: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    def save_message_async(self, chat_message: typing.Optional[ChatMessage], /) -> winrt.windows.foundation.IAsyncAction: ...
    def send_message_async(self, chat_message: typing.Optional[ChatMessage], /) -> winrt.windows.foundation.IAsyncAction: ...
    def try_cancel_download_message_async(self, local_chat_message_id: str, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def try_cancel_send_message_async(self, local_chat_message_id: str, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def validate_message(self, chat_message: typing.Optional[ChatMessage], /) -> typing.Optional[ChatMessageValidationResult]: ...
    def add_message_changed(self, value: winrt.windows.foundation.TypedEventHandler[ChatMessageStore, ChatMessageChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_message_changed(self, value: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_store_changed(self, handler: winrt.windows.foundation.TypedEventHandler[ChatMessageStore, ChatMessageStoreChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_store_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class ChatMessageStoreChangedEventArgs(winrt.system.Object):
    id: str
    kind: ChatStoreChangedEventKind
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatMessageStoreChangedEventArgs: ...

class ChatMessageTransport(winrt.system.Object):
    is_active: bool
    is_app_set_as_notification_provider: bool
    transport_friendly_name: str
    transport_id: str
    configuration: typing.Optional[ChatMessageTransportConfiguration]
    transport_kind: ChatMessageTransportKind
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatMessageTransport: ...
    def request_set_as_notification_provider_async(self) -> winrt.windows.foundation.IAsyncAction: ...

class ChatMessageTransportConfiguration(winrt.system.Object):
    extended_properties: typing.Optional[winrt.windows.foundation.collections.IMapView[str, winrt.system.Object]]
    max_attachment_count: winrt.system.Int32
    max_message_size_in_kilobytes: winrt.system.Int32
    max_recipient_count: winrt.system.Int32
    supported_video_format: typing.Optional[winrt.windows.media.mediaproperties.MediaEncodingProfile]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatMessageTransportConfiguration: ...

class ChatMessageValidationResult(winrt.system.Object):
    max_part_count: typing.Optional[typing.Optional[winrt.system.UInt32]]
    part_count: typing.Optional[typing.Optional[winrt.system.UInt32]]
    remaining_character_count_in_part: typing.Optional[typing.Optional[winrt.system.UInt32]]
    status: ChatMessageValidationStatus
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatMessageValidationResult: ...

class ChatQueryOptions(winrt.system.Object):
    search_string: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatQueryOptions: ...
    def __new__(cls: typing.Type[ChatQueryOptions]) -> ChatQueryOptions:...

class ChatRecipientDeliveryInfo(winrt.system.Object):
    transport_address: str
    read_time: typing.Optional[typing.Optional[datetime.datetime]]
    delivery_time: typing.Optional[typing.Optional[datetime.datetime]]
    is_error_permanent: bool
    status: ChatMessageStatus
    transport_error_code: winrt.system.Int32
    transport_error_code_category: ChatTransportErrorCodeCategory
    transport_interpreted_error_code: ChatTransportInterpretedErrorCode
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatRecipientDeliveryInfo: ...
    def __new__(cls: typing.Type[ChatRecipientDeliveryInfo]) -> ChatRecipientDeliveryInfo:...

class ChatSearchReader(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatSearchReader: ...
    @typing.overload
    def read_batch_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[IChatItem]]: ...
    @typing.overload
    def read_batch_async(self, count: winrt.system.Int32, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[IChatItem]]: ...

class ChatSyncConfiguration(winrt.system.Object):
    restore_history_span: ChatRestoreHistorySpan
    is_sync_enabled: bool
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatSyncConfiguration: ...

class ChatSyncManager(winrt.system.Object):
    configuration: typing.Optional[ChatSyncConfiguration]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatSyncManager: ...
    def associate_account_async(self, web_account: typing.Optional[winrt.windows.security.credentials.WebAccount], /) -> winrt.windows.foundation.IAsyncAction: ...
    def is_account_associated(self, web_account: typing.Optional[winrt.windows.security.credentials.WebAccount], /) -> bool: ...
    def set_configuration_async(self, configuration: typing.Optional[ChatSyncConfiguration], /) -> winrt.windows.foundation.IAsyncAction: ...
    def start_sync(self) -> None: ...
    def unassociate_account_async(self) -> winrt.windows.foundation.IAsyncAction: ...

class RcsEndUserMessage(winrt.system.Object):
    actions: typing.Optional[winrt.windows.foundation.collections.IVectorView[RcsEndUserMessageAction]]
    is_pin_required: bool
    text: str
    title: str
    transport_id: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RcsEndUserMessage: ...
    def send_response_async(self, action: typing.Optional[RcsEndUserMessageAction], /) -> winrt.windows.foundation.IAsyncAction: ...
    def send_response_with_pin_async(self, action: typing.Optional[RcsEndUserMessageAction], pin: str, /) -> winrt.windows.foundation.IAsyncAction: ...

class RcsEndUserMessageAction(winrt.system.Object):
    label: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RcsEndUserMessageAction: ...

class RcsEndUserMessageAvailableEventArgs(winrt.system.Object):
    is_message_available: bool
    message: typing.Optional[RcsEndUserMessage]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RcsEndUserMessageAvailableEventArgs: ...

class RcsEndUserMessageAvailableTriggerDetails(winrt.system.Object):
    text: str
    title: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RcsEndUserMessageAvailableTriggerDetails: ...

class RcsEndUserMessageManager(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RcsEndUserMessageManager: ...
    def add_message_available_changed(self, handler: winrt.windows.foundation.TypedEventHandler[RcsEndUserMessageManager, RcsEndUserMessageAvailableEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_message_available_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class RcsManager(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RcsManager: ...
    @staticmethod
    def get_end_user_message_manager() -> typing.Optional[RcsEndUserMessageManager]: ...
    @staticmethod
    def get_transport_async(transport_id: str, /) -> winrt.windows.foundation.IAsyncOperation[RcsTransport]: ...
    @staticmethod
    def get_transports_async() -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[RcsTransport]]: ...
    @staticmethod
    def leave_conversation_async(conversation: typing.Optional[ChatConversation], /) -> winrt.windows.foundation.IAsyncAction: ...
    @staticmethod
    def add_transport_list_changed(handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    @staticmethod
    def remove_transport_list_changed(token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class RcsServiceKindSupportedChangedEventArgs(winrt.system.Object):
    service_kind: RcsServiceKind
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RcsServiceKindSupportedChangedEventArgs: ...

class RcsTransport(winrt.system.Object):
    configuration: typing.Optional[RcsTransportConfiguration]
    extended_properties: typing.Optional[winrt.windows.foundation.collections.IMapView[str, winrt.system.Object]]
    is_active: bool
    transport_friendly_name: str
    transport_id: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RcsTransport: ...
    def is_service_kind_supported(self, service_kind: RcsServiceKind, /) -> bool: ...
    def is_store_and_forward_enabled(self, service_kind: RcsServiceKind, /) -> bool: ...
    def add_service_kind_supported_changed(self, handler: winrt.windows.foundation.TypedEventHandler[RcsTransport, RcsServiceKindSupportedChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_service_kind_supported_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class RcsTransportConfiguration(winrt.system.Object):
    max_attachment_count: winrt.system.Int32
    max_file_size_in_kilobytes: winrt.system.Int32
    max_group_message_size_in_kilobytes: winrt.system.Int32
    max_message_size_in_kilobytes: winrt.system.Int32
    max_recipient_count: winrt.system.Int32
    warning_file_size_in_kilobytes: winrt.system.Int32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RcsTransportConfiguration: ...

class RemoteParticipantComposingChangedEventArgs(winrt.system.Object):
    is_composing: bool
    participant_address: str
    transport_id: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RemoteParticipantComposingChangedEventArgs: ...

class IChatItem(winrt.system.Object):
    item_kind: ChatItemKind
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IChatItem: ...

