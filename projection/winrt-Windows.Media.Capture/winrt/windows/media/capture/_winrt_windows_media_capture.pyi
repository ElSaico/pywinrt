# WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

import datetime
import sys
import types
import typing
import uuid

import winrt.system
import winrt.windows.devices.enumeration
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.graphics.directx.direct3d11
import winrt.windows.graphics.imaging
import winrt.windows.media
import winrt.windows.media.capture.core
import winrt.windows.media.capture.frames
import winrt.windows.media.core
import winrt.windows.media.devices
import winrt.windows.media.effects
import winrt.windows.media.mediaproperties
import winrt.windows.security.authentication.web
import winrt.windows.security.credentials
import winrt.windows.storage
import winrt.windows.storage.streams
import winrt.windows.system
import winrt.windows.ui.windowmanagement

from . import AppBroadcastCameraCaptureState, AppBroadcastCameraOverlayLocation, AppBroadcastCameraOverlaySize, AppBroadcastCaptureTargetType, AppBroadcastExitBroadcastModeReason, AppBroadcastMicrophoneCaptureState, AppBroadcastPlugInState, AppBroadcastPreviewState, AppBroadcastSignInResult, AppBroadcastSignInState, AppBroadcastStreamState, AppBroadcastTerminationReason, AppBroadcastVideoEncodingBitrateMode, AppBroadcastVideoEncodingResolutionMode, AppCaptureHistoricalBufferLengthUnit, AppCaptureMetadataPriority, AppCaptureMicrophoneCaptureState, AppCaptureRecordingState, AppCaptureVideoEncodingBitrateMode, AppCaptureVideoEncodingFrameRateMode, AppCaptureVideoEncodingResolutionMode, CameraCaptureUIMaxPhotoResolution, CameraCaptureUIMaxVideoResolution, CameraCaptureUIMode, CameraCaptureUIPhotoFormat, CameraCaptureUIVideoFormat, ForegroundActivationArgument, GameBarCommand, GameBarCommandOrigin, GameBarServicesDisplayMode, GameBarTargetCapturePolicy, KnownVideoProfile, MediaCaptureDeviceExclusiveControlReleaseMode, MediaCaptureDeviceExclusiveControlStatus, MediaCaptureMemoryPreference, MediaCaptureSharingMode, MediaCaptureThermalStatus, MediaCategory, MediaStreamType, PhotoCaptureSource, PowerlineFrequency, StreamingCaptureMode, VideoDeviceCharacteristic, VideoRotation
from . import MediaCaptureFailedEventHandler, RecordLimitationExceededEventHandler

Self = typing.TypeVar('Self')

class WhiteBalanceGain:
    r: winrt.system.Double
    g: winrt.system.Double
    b: winrt.system.Double
    def __new__(cls: typing.Type[WhiteBalanceGain], r: winrt.system.Double, g: winrt.system.Double, b: winrt.system.Double) -> WhiteBalanceGain: ...

class AdvancedCapturedPhoto(winrt.system.Object):
    context: typing.Optional[winrt.system.Object]
    frame: typing.Optional[CapturedFrame]
    mode: winrt.windows.media.devices.AdvancedPhotoMode
    frame_bounds_relative_to_reference_photo: typing.Optional[typing.Optional[winrt.windows.foundation.Rect]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AdvancedCapturedPhoto: ...

class AdvancedPhotoCapture(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AdvancedPhotoCapture: ...
    @typing.overload
    def capture_async(self) -> winrt.windows.foundation.IAsyncOperation[AdvancedCapturedPhoto]: ...
    @typing.overload
    def capture_async(self, context: typing.Optional[winrt.system.Object], /) -> winrt.windows.foundation.IAsyncOperation[AdvancedCapturedPhoto]: ...
    def finish_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def add_all_photos_captured(self, handler: winrt.windows.foundation.TypedEventHandler[AdvancedPhotoCapture, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_all_photos_captured(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_optional_reference_photo_captured(self, handler: winrt.windows.foundation.TypedEventHandler[AdvancedPhotoCapture, OptionalReferencePhotoCapturedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_optional_reference_photo_captured(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class AppBroadcastBackgroundService(winrt.system.Object):
    viewer_count: winrt.system.UInt32
    stream_info: typing.Optional[AppBroadcastBackgroundServiceStreamInfo]
    sign_in_info: typing.Optional[AppBroadcastBackgroundServiceSignInInfo]
    plug_in_state: AppBroadcastPlugInState
    broadcast_title: str
    app_id: str
    title_id: str
    broadcast_language: str
    broadcast_channel: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppBroadcastBackgroundService: ...
    def terminate_broadcast(self, reason: AppBroadcastTerminationReason, provider_specific_reason: winrt.system.UInt32, /) -> None: ...
    def add_heartbeat_requested(self, handler: winrt.windows.foundation.TypedEventHandler[AppBroadcastBackgroundService, AppBroadcastHeartbeatRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_heartbeat_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_broadcast_channel_changed(self, handler: winrt.windows.foundation.TypedEventHandler[AppBroadcastBackgroundService, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_broadcast_channel_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_broadcast_language_changed(self, handler: winrt.windows.foundation.TypedEventHandler[AppBroadcastBackgroundService, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_broadcast_language_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_broadcast_title_changed(self, handler: winrt.windows.foundation.TypedEventHandler[AppBroadcastBackgroundService, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_broadcast_title_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class AppBroadcastBackgroundServiceSignInInfo(winrt.system.Object):
    user_name: str
    o_auth_request_uri: typing.Optional[winrt.windows.foundation.Uri]
    o_auth_callback_uri: typing.Optional[winrt.windows.foundation.Uri]
    authentication_result: typing.Optional[winrt.windows.security.authentication.web.WebAuthenticationResult]
    sign_in_state: AppBroadcastSignInState
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppBroadcastBackgroundServiceSignInInfo: ...
    def add_sign_in_state_changed(self, handler: winrt.windows.foundation.TypedEventHandler[AppBroadcastBackgroundServiceSignInInfo, AppBroadcastSignInStateChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_sign_in_state_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_user_name_changed(self, handler: winrt.windows.foundation.TypedEventHandler[AppBroadcastBackgroundServiceSignInInfo, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_user_name_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class AppBroadcastBackgroundServiceStreamInfo(winrt.system.Object):
    desired_video_encoding_bitrate: winrt.system.UInt64
    bandwidth_test_bitrate: winrt.system.UInt64
    audio_codec: str
    broadcast_stream_reader: typing.Optional[AppBroadcastStreamReader]
    stream_state: AppBroadcastStreamState
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppBroadcastBackgroundServiceStreamInfo: ...
    def report_problem_with_stream(self) -> None: ...
    def add_stream_state_changed(self, handler: winrt.windows.foundation.TypedEventHandler[AppBroadcastBackgroundServiceStreamInfo, AppBroadcastStreamStateChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_stream_state_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_video_encoding_bitrate_changed(self, handler: winrt.windows.foundation.TypedEventHandler[AppBroadcastBackgroundServiceStreamInfo, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_video_encoding_bitrate_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_video_encoding_resolution_changed(self, handler: winrt.windows.foundation.TypedEventHandler[AppBroadcastBackgroundServiceStreamInfo, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_video_encoding_resolution_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class AppBroadcastCameraCaptureStateChangedEventArgs(winrt.system.Object):
    error_code: winrt.system.UInt32
    state: AppBroadcastCameraCaptureState
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppBroadcastCameraCaptureStateChangedEventArgs: ...

class AppBroadcastGlobalSettings(winrt.system.Object):
    system_audio_gain: winrt.system.Double
    selected_camera_id: str
    microphone_gain: winrt.system.Double
    is_microphone_capture_enabled_by_default: bool
    is_echo_cancellation_enabled: bool
    is_cursor_image_capture_enabled: bool
    is_camera_capture_enabled_by_default: bool
    is_audio_capture_enabled: bool
    camera_overlay_size: AppBroadcastCameraOverlaySize
    camera_overlay_location: AppBroadcastCameraOverlayLocation
    has_hardware_encoder: bool
    is_broadcast_enabled: bool
    is_disabled_by_policy: bool
    is_gpu_constrained: bool
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppBroadcastGlobalSettings: ...

class AppBroadcastHeartbeatRequestedEventArgs(winrt.system.Object):
    handled: bool
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppBroadcastHeartbeatRequestedEventArgs: ...

class AppBroadcastManager(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppBroadcastManager: ...
    @staticmethod
    def apply_global_settings(value: typing.Optional[AppBroadcastGlobalSettings], /) -> None: ...
    @staticmethod
    def apply_provider_settings(value: typing.Optional[AppBroadcastProviderSettings], /) -> None: ...
    @staticmethod
    def get_global_settings() -> typing.Optional[AppBroadcastGlobalSettings]: ...
    @staticmethod
    def get_provider_settings() -> typing.Optional[AppBroadcastProviderSettings]: ...

class AppBroadcastMicrophoneCaptureStateChangedEventArgs(winrt.system.Object):
    error_code: winrt.system.UInt32
    state: AppBroadcastMicrophoneCaptureState
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppBroadcastMicrophoneCaptureStateChangedEventArgs: ...

class AppBroadcastPlugIn(winrt.system.Object):
    app_id: str
    display_name: str
    logo: typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference]
    provider_settings: typing.Optional[AppBroadcastProviderSettings]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppBroadcastPlugIn: ...

class AppBroadcastPlugInManager(winrt.system.Object):
    default_plug_in: typing.Optional[AppBroadcastPlugIn]
    is_broadcast_provider_available: bool
    plug_in_list: typing.Optional[winrt.windows.foundation.collections.IVectorView[AppBroadcastPlugIn]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppBroadcastPlugInManager: ...
    @staticmethod
    def get_default() -> typing.Optional[AppBroadcastPlugInManager]: ...
    @staticmethod
    def get_for_user(user: typing.Optional[winrt.windows.system.User], /) -> typing.Optional[AppBroadcastPlugInManager]: ...

class AppBroadcastPlugInStateChangedEventArgs(winrt.system.Object):
    plug_in_state: AppBroadcastPlugInState
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppBroadcastPlugInStateChangedEventArgs: ...

class AppBroadcastPreview(winrt.system.Object):
    error_code: typing.Optional[typing.Optional[winrt.system.UInt32]]
    preview_state: AppBroadcastPreviewState
    preview_stream_reader: typing.Optional[AppBroadcastPreviewStreamReader]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppBroadcastPreview: ...
    def stop_preview(self) -> None: ...
    def add_preview_state_changed(self, value: winrt.windows.foundation.TypedEventHandler[AppBroadcastPreview, AppBroadcastPreviewStateChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_preview_state_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class AppBroadcastPreviewStateChangedEventArgs(winrt.system.Object):
    error_code: winrt.system.UInt32
    preview_state: AppBroadcastPreviewState
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppBroadcastPreviewStateChangedEventArgs: ...

class AppBroadcastPreviewStreamReader(winrt.system.Object):
    video_bitmap_alpha_mode: winrt.windows.graphics.imaging.BitmapAlphaMode
    video_bitmap_pixel_format: winrt.windows.graphics.imaging.BitmapPixelFormat
    video_height: winrt.system.UInt32
    video_stride: winrt.system.UInt32
    video_width: winrt.system.UInt32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppBroadcastPreviewStreamReader: ...
    def try_get_next_video_frame(self) -> typing.Optional[AppBroadcastPreviewStreamVideoFrame]: ...
    def add_video_frame_arrived(self, value: winrt.windows.foundation.TypedEventHandler[AppBroadcastPreviewStreamReader, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_video_frame_arrived(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class AppBroadcastPreviewStreamVideoFrame(winrt.system.Object):
    video_buffer: typing.Optional[winrt.windows.storage.streams.IBuffer]
    video_header: typing.Optional[AppBroadcastPreviewStreamVideoHeader]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppBroadcastPreviewStreamVideoFrame: ...

class AppBroadcastPreviewStreamVideoHeader(winrt.system.Object):
    absolute_timestamp: datetime.datetime
    duration: datetime.timedelta
    frame_id: winrt.system.UInt64
    relative_timestamp: datetime.timedelta
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppBroadcastPreviewStreamVideoHeader: ...

class AppBroadcastProviderSettings(winrt.system.Object):
    video_encoding_resolution_mode: AppBroadcastVideoEncodingResolutionMode
    video_encoding_bitrate_mode: AppBroadcastVideoEncodingBitrateMode
    default_broadcast_title: str
    custom_video_encoding_width: winrt.system.UInt32
    custom_video_encoding_height: winrt.system.UInt32
    custom_video_encoding_bitrate: winrt.system.UInt32
    audio_encoding_bitrate: winrt.system.UInt32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppBroadcastProviderSettings: ...

class AppBroadcastServices(winrt.system.Object):
    capture_target_type: AppBroadcastCaptureTargetType
    broadcast_title: str
    broadcast_language: str
    can_capture: bool
    state: typing.Optional[AppBroadcastState]
    user_name: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppBroadcastServices: ...
    def enter_broadcast_mode_async(self, plug_in: typing.Optional[AppBroadcastPlugIn], /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.UInt32]: ...
    def exit_broadcast_mode(self, reason: AppBroadcastExitBroadcastModeReason, /) -> None: ...
    def pause_broadcast(self) -> None: ...
    def resume_broadcast(self) -> None: ...
    def start_broadcast(self) -> None: ...
    def start_preview(self, desired_size: winrt.windows.foundation.Size, /) -> typing.Optional[AppBroadcastPreview]: ...

class AppBroadcastSignInStateChangedEventArgs(winrt.system.Object):
    result: AppBroadcastSignInResult
    sign_in_state: AppBroadcastSignInState
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppBroadcastSignInStateChangedEventArgs: ...

class AppBroadcastState(winrt.system.Object):
    sign_in_state: AppBroadcastSignInState
    should_capture_microphone: bool
    should_capture_camera: bool
    authentication_result: typing.Optional[winrt.windows.security.authentication.web.WebAuthenticationResult]
    is_capture_target_running: bool
    microphone_capture_error: winrt.system.UInt32
    microphone_capture_state: AppBroadcastMicrophoneCaptureState
    o_auth_callback_uri: typing.Optional[winrt.windows.foundation.Uri]
    o_auth_request_uri: typing.Optional[winrt.windows.foundation.Uri]
    plug_in_state: AppBroadcastPlugInState
    camera_capture_error: winrt.system.UInt32
    camera_capture_state: AppBroadcastCameraCaptureState
    encoded_video_size: winrt.windows.foundation.Size
    stream_state: AppBroadcastStreamState
    termination_reason: AppBroadcastTerminationReason
    termination_reason_plug_in_specific: winrt.system.UInt32
    viewer_count: winrt.system.UInt32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppBroadcastState: ...
    def restart_camera_capture(self) -> None: ...
    def restart_microphone_capture(self) -> None: ...
    def add_camera_capture_state_changed(self, value: winrt.windows.foundation.TypedEventHandler[AppBroadcastState, AppBroadcastCameraCaptureStateChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_camera_capture_state_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_capture_target_closed(self, value: winrt.windows.foundation.TypedEventHandler[AppBroadcastState, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_capture_target_closed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_microphone_capture_state_changed(self, value: winrt.windows.foundation.TypedEventHandler[AppBroadcastState, AppBroadcastMicrophoneCaptureStateChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_microphone_capture_state_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_plug_in_state_changed(self, handler: winrt.windows.foundation.TypedEventHandler[AppBroadcastState, AppBroadcastPlugInStateChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_plug_in_state_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_stream_state_changed(self, handler: winrt.windows.foundation.TypedEventHandler[AppBroadcastState, AppBroadcastStreamStateChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_stream_state_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_viewer_count_changed(self, value: winrt.windows.foundation.TypedEventHandler[AppBroadcastState, AppBroadcastViewerCountChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_viewer_count_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class AppBroadcastStreamAudioFrame(winrt.system.Object):
    audio_buffer: typing.Optional[winrt.windows.storage.streams.IBuffer]
    audio_header: typing.Optional[AppBroadcastStreamAudioHeader]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppBroadcastStreamAudioFrame: ...

class AppBroadcastStreamAudioHeader(winrt.system.Object):
    absolute_timestamp: datetime.datetime
    duration: datetime.timedelta
    frame_id: winrt.system.UInt64
    has_discontinuity: bool
    relative_timestamp: datetime.timedelta
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppBroadcastStreamAudioHeader: ...

class AppBroadcastStreamReader(winrt.system.Object):
    audio_aac_sequence: typing.Optional[winrt.windows.storage.streams.IBuffer]
    audio_bitrate: winrt.system.UInt32
    audio_channels: winrt.system.UInt32
    audio_sample_rate: winrt.system.UInt32
    video_bitrate: winrt.system.UInt32
    video_height: winrt.system.UInt32
    video_width: winrt.system.UInt32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppBroadcastStreamReader: ...
    def try_get_next_audio_frame(self) -> typing.Optional[AppBroadcastStreamAudioFrame]: ...
    def try_get_next_video_frame(self) -> typing.Optional[AppBroadcastStreamVideoFrame]: ...
    def add_audio_frame_arrived(self, value: winrt.windows.foundation.TypedEventHandler[AppBroadcastStreamReader, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_audio_frame_arrived(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_video_frame_arrived(self, value: winrt.windows.foundation.TypedEventHandler[AppBroadcastStreamReader, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_video_frame_arrived(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class AppBroadcastStreamStateChangedEventArgs(winrt.system.Object):
    stream_state: AppBroadcastStreamState
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppBroadcastStreamStateChangedEventArgs: ...

class AppBroadcastStreamVideoFrame(winrt.system.Object):
    video_buffer: typing.Optional[winrt.windows.storage.streams.IBuffer]
    video_header: typing.Optional[AppBroadcastStreamVideoHeader]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppBroadcastStreamVideoFrame: ...

class AppBroadcastStreamVideoHeader(winrt.system.Object):
    absolute_timestamp: datetime.datetime
    duration: datetime.timedelta
    frame_id: winrt.system.UInt64
    has_discontinuity: bool
    is_key_frame: bool
    relative_timestamp: datetime.timedelta
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppBroadcastStreamVideoHeader: ...

class AppBroadcastTriggerDetails(winrt.system.Object):
    background_service: typing.Optional[AppBroadcastBackgroundService]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppBroadcastTriggerDetails: ...

class AppBroadcastViewerCountChangedEventArgs(winrt.system.Object):
    viewer_count: winrt.system.UInt32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppBroadcastViewerCountChangedEventArgs: ...

class AppCapture(winrt.system.Object):
    is_capturing_audio: bool
    is_capturing_video: bool
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppCapture: ...
    @staticmethod
    def get_for_current_view() -> typing.Optional[AppCapture]: ...
    @staticmethod
    def set_allowed_async(allowed: bool, /) -> winrt.windows.foundation.IAsyncAction: ...
    def add_capturing_changed(self, handler: winrt.windows.foundation.TypedEventHandler[AppCapture, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_capturing_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class AppCaptureAlternateShortcutKeys(winrt.system.Object):
    toggle_recording_key_modifiers: winrt.windows.system.VirtualKeyModifiers
    toggle_recording_key: winrt.windows.system.VirtualKey
    toggle_recording_indicator_key_modifiers: winrt.windows.system.VirtualKeyModifiers
    toggle_recording_indicator_key: winrt.windows.system.VirtualKey
    toggle_game_bar_key_modifiers: winrt.windows.system.VirtualKeyModifiers
    toggle_game_bar_key: winrt.windows.system.VirtualKey
    take_screenshot_key_modifiers: winrt.windows.system.VirtualKeyModifiers
    take_screenshot_key: winrt.windows.system.VirtualKey
    save_historical_video_key_modifiers: winrt.windows.system.VirtualKeyModifiers
    save_historical_video_key: winrt.windows.system.VirtualKey
    toggle_microphone_capture_key_modifiers: winrt.windows.system.VirtualKeyModifiers
    toggle_microphone_capture_key: winrt.windows.system.VirtualKey
    toggle_camera_capture_key_modifiers: winrt.windows.system.VirtualKeyModifiers
    toggle_camera_capture_key: winrt.windows.system.VirtualKey
    toggle_broadcast_key_modifiers: winrt.windows.system.VirtualKeyModifiers
    toggle_broadcast_key: winrt.windows.system.VirtualKey
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppCaptureAlternateShortcutKeys: ...

class AppCaptureDurationGeneratedEventArgs(winrt.system.Object):
    duration: datetime.timedelta
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppCaptureDurationGeneratedEventArgs: ...

class AppCaptureFileGeneratedEventArgs(winrt.system.Object):
    file: typing.Optional[winrt.windows.storage.StorageFile]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppCaptureFileGeneratedEventArgs: ...

class AppCaptureManager(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppCaptureManager: ...
    @staticmethod
    def apply_settings(app_capture_settings: typing.Optional[AppCaptureSettings], /) -> None: ...
    @staticmethod
    def get_current_settings() -> typing.Optional[AppCaptureSettings]: ...

class AppCaptureMetadataWriter(winrt.system.Object):
    remaining_storage_bytes_available: winrt.system.UInt64
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppCaptureMetadataWriter: ...
    def __new__(cls: typing.Type[AppCaptureMetadataWriter]) -> AppCaptureMetadataWriter:...
    def add_double_event(self, name: str, value: winrt.system.Double, priority: AppCaptureMetadataPriority, /) -> None: ...
    def add_int32_event(self, name: str, value: winrt.system.Int32, priority: AppCaptureMetadataPriority, /) -> None: ...
    def add_string_event(self, name: str, value: str, priority: AppCaptureMetadataPriority, /) -> None: ...
    def close(self) -> None: ...
    def start_double_state(self, name: str, value: winrt.system.Double, priority: AppCaptureMetadataPriority, /) -> None: ...
    def start_int32_state(self, name: str, value: winrt.system.Int32, priority: AppCaptureMetadataPriority, /) -> None: ...
    def start_string_state(self, name: str, value: str, priority: AppCaptureMetadataPriority, /) -> None: ...
    def stop_all_states(self) -> None: ...
    def stop_state(self, name: str, /) -> None: ...
    def add_metadata_purged(self, handler: winrt.windows.foundation.TypedEventHandler[AppCaptureMetadataWriter, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_metadata_purged(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class AppCaptureMicrophoneCaptureStateChangedEventArgs(winrt.system.Object):
    error_code: winrt.system.UInt32
    state: AppCaptureMicrophoneCaptureState
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppCaptureMicrophoneCaptureStateChangedEventArgs: ...

class AppCaptureRecordOperation(winrt.system.Object):
    duration: typing.Optional[typing.Optional[datetime.timedelta]]
    error_code: typing.Optional[typing.Optional[winrt.system.UInt32]]
    file: typing.Optional[winrt.windows.storage.StorageFile]
    is_file_truncated: typing.Optional[typing.Optional[bool]]
    state: AppCaptureRecordingState
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppCaptureRecordOperation: ...
    def stop_recording(self) -> None: ...
    def add_duration_generated(self, value: winrt.windows.foundation.TypedEventHandler[AppCaptureRecordOperation, AppCaptureDurationGeneratedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_duration_generated(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_file_generated(self, value: winrt.windows.foundation.TypedEventHandler[AppCaptureRecordOperation, AppCaptureFileGeneratedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_file_generated(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_state_changed(self, value: winrt.windows.foundation.TypedEventHandler[AppCaptureRecordOperation, AppCaptureRecordingStateChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_state_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class AppCaptureRecordingStateChangedEventArgs(winrt.system.Object):
    error_code: winrt.system.UInt32
    state: AppCaptureRecordingState
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppCaptureRecordingStateChangedEventArgs: ...

class AppCaptureServices(winrt.system.Object):
    can_capture: bool
    state: typing.Optional[AppCaptureState]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppCaptureServices: ...
    def record(self) -> typing.Optional[AppCaptureRecordOperation]: ...
    def record_time_span(self, start_time: datetime.datetime, duration: datetime.timedelta, /) -> typing.Optional[AppCaptureRecordOperation]: ...

class AppCaptureSettings(winrt.system.Object):
    is_historical_capture_on_wireless_display_allowed: bool
    video_encoding_bitrate_mode: AppCaptureVideoEncodingBitrateMode
    is_historical_capture_on_battery_allowed: bool
    is_audio_capture_enabled: bool
    is_app_capture_enabled: bool
    app_capture_destination_folder: typing.Optional[winrt.windows.storage.StorageFolder]
    historical_buffer_length: winrt.system.UInt32
    is_historical_capture_enabled: bool
    custom_video_encoding_width: winrt.system.UInt32
    custom_video_encoding_height: winrt.system.UInt32
    custom_video_encoding_bitrate: winrt.system.UInt32
    audio_encoding_bitrate: winrt.system.UInt32
    historical_buffer_length_unit: AppCaptureHistoricalBufferLengthUnit
    video_encoding_resolution_mode: AppCaptureVideoEncodingResolutionMode
    screenshot_destination_folder: typing.Optional[winrt.windows.storage.StorageFolder]
    maximum_record_length: datetime.timedelta
    has_hardware_encoder: bool
    is_cpu_constrained: bool
    is_memory_constrained: bool
    is_disabled_by_policy: bool
    alternate_shortcut_keys: typing.Optional[AppCaptureAlternateShortcutKeys]
    is_gpu_constrained: bool
    is_microphone_capture_enabled: bool
    video_encoding_frame_rate_mode: AppCaptureVideoEncodingFrameRateMode
    system_audio_gain: winrt.system.Double
    microphone_gain: winrt.system.Double
    is_microphone_capture_enabled_by_default: bool
    is_echo_cancellation_enabled: bool
    is_cursor_image_capture_enabled: bool
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppCaptureSettings: ...

class AppCaptureState(winrt.system.Object):
    should_capture_microphone: bool
    is_historical_capture_enabled: bool
    is_target_running: bool
    microphone_capture_error: winrt.system.UInt32
    microphone_capture_state: AppCaptureMicrophoneCaptureState
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppCaptureState: ...
    def restart_microphone_capture(self) -> None: ...
    def add_capture_target_closed(self, value: winrt.windows.foundation.TypedEventHandler[AppCaptureState, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_capture_target_closed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_microphone_capture_state_changed(self, value: winrt.windows.foundation.TypedEventHandler[AppCaptureState, AppCaptureMicrophoneCaptureStateChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_microphone_capture_state_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class CameraCaptureUI(winrt.system.Object):
    photo_settings: typing.Optional[CameraCaptureUIPhotoCaptureSettings]
    video_settings: typing.Optional[CameraCaptureUIVideoCaptureSettings]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CameraCaptureUI: ...
    def __new__(cls: typing.Type[CameraCaptureUI]) -> CameraCaptureUI:...
    def capture_file_async(self, mode: CameraCaptureUIMode, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.StorageFile]: ...

class CameraCaptureUIPhotoCaptureSettings(winrt.system.Object):
    max_resolution: CameraCaptureUIMaxPhotoResolution
    format: CameraCaptureUIPhotoFormat
    cropped_size_in_pixels: winrt.windows.foundation.Size
    cropped_aspect_ratio: winrt.windows.foundation.Size
    allow_cropping: bool
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CameraCaptureUIPhotoCaptureSettings: ...

class CameraCaptureUIVideoCaptureSettings(winrt.system.Object):
    max_resolution: CameraCaptureUIMaxVideoResolution
    max_duration_in_seconds: winrt.system.Single
    format: CameraCaptureUIVideoFormat
    allow_trimming: bool
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CameraCaptureUIVideoCaptureSettings: ...

class CameraOptionsUI(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CameraOptionsUI: ...
    @staticmethod
    def show(media_capture: typing.Optional[MediaCapture], /) -> None: ...

class CapturedFrame(winrt.system.Object):
    height: winrt.system.UInt32
    width: winrt.system.UInt32
    bitmap_properties: typing.Optional[winrt.windows.graphics.imaging.BitmapPropertySet]
    control_values: typing.Optional[CapturedFrameControlValues]
    software_bitmap: typing.Optional[winrt.windows.graphics.imaging.SoftwareBitmap]
    content_type: str
    size: winrt.system.UInt64
    can_read: bool
    can_write: bool
    position: winrt.system.UInt64
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CapturedFrame: ...
    def clone_stream(self) -> typing.Optional[winrt.windows.storage.streams.IRandomAccessStream]: ...
    def close(self) -> None: ...
    def flush_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def get_input_stream_at(self, position: winrt.system.UInt64, /) -> typing.Optional[winrt.windows.storage.streams.IInputStream]: ...
    def get_output_stream_at(self, position: winrt.system.UInt64, /) -> typing.Optional[winrt.windows.storage.streams.IOutputStream]: ...
    def read_async(self, buffer: typing.Optional[winrt.windows.storage.streams.IBuffer], count: winrt.system.UInt32, options: winrt.windows.storage.streams.InputStreamOptions, /) -> winrt.windows.foundation.IAsyncOperationWithProgress[winrt.windows.storage.streams.IBuffer, winrt.system.UInt32]: ...
    def seek(self, position: winrt.system.UInt64, /) -> None: ...
    def write_async(self, buffer: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[winrt.system.UInt32, winrt.system.UInt32]: ...

class CapturedFrameControlValues(winrt.system.Object):
    exposure: typing.Optional[typing.Optional[datetime.timedelta]]
    exposure_compensation: typing.Optional[typing.Optional[winrt.system.Single]]
    flash_power_percent: typing.Optional[typing.Optional[winrt.system.Single]]
    flashed: typing.Optional[typing.Optional[bool]]
    focus: typing.Optional[typing.Optional[winrt.system.UInt32]]
    iso_speed: typing.Optional[typing.Optional[winrt.system.UInt32]]
    scene_mode: typing.Optional[typing.Optional[winrt.windows.media.devices.CaptureSceneMode]]
    white_balance: typing.Optional[typing.Optional[winrt.system.UInt32]]
    zoom_factor: typing.Optional[typing.Optional[winrt.system.Single]]
    focus_state: typing.Optional[typing.Optional[winrt.windows.media.devices.MediaCaptureFocusState]]
    iso_analog_gain: typing.Optional[typing.Optional[winrt.system.Double]]
    iso_digital_gain: typing.Optional[typing.Optional[winrt.system.Double]]
    sensor_frame_rate: typing.Optional[winrt.windows.media.mediaproperties.MediaRatio]
    white_balance_gain: typing.Optional[typing.Optional[WhiteBalanceGain]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CapturedFrameControlValues: ...

class CapturedPhoto(winrt.system.Object):
    frame: typing.Optional[CapturedFrame]
    thumbnail: typing.Optional[CapturedFrame]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CapturedPhoto: ...

class GameBarServices(winrt.system.Object):
    app_broadcast_services: typing.Optional[AppBroadcastServices]
    app_capture_services: typing.Optional[AppCaptureServices]
    session_id: str
    target_capture_policy: GameBarTargetCapturePolicy
    target_info: typing.Optional[GameBarServicesTargetInfo]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GameBarServices: ...
    def disable_capture(self) -> None: ...
    def enable_capture(self) -> None: ...
    def add_command_received(self, value: winrt.windows.foundation.TypedEventHandler[GameBarServices, GameBarServicesCommandEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_command_received(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class GameBarServicesCommandEventArgs(winrt.system.Object):
    command: GameBarCommand
    origin: GameBarCommandOrigin
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GameBarServicesCommandEventArgs: ...

class GameBarServicesManager(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GameBarServicesManager: ...
    @staticmethod
    def get_default() -> typing.Optional[GameBarServicesManager]: ...
    def add_game_bar_services_created(self, value: winrt.windows.foundation.TypedEventHandler[GameBarServicesManager, GameBarServicesManagerGameBarServicesCreatedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_game_bar_services_created(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class GameBarServicesManagerGameBarServicesCreatedEventArgs(winrt.system.Object):
    game_bar_services: typing.Optional[GameBarServices]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GameBarServicesManagerGameBarServicesCreatedEventArgs: ...

class GameBarServicesTargetInfo(winrt.system.Object):
    app_id: str
    display_mode: GameBarServicesDisplayMode
    display_name: str
    title_id: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GameBarServicesTargetInfo: ...

class LowLagMediaRecording(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LowLagMediaRecording: ...
    def finish_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def pause_async(self, behavior: winrt.windows.media.devices.MediaCapturePauseBehavior, /) -> winrt.windows.foundation.IAsyncAction: ...
    def pause_with_result_async(self, behavior: winrt.windows.media.devices.MediaCapturePauseBehavior, /) -> winrt.windows.foundation.IAsyncOperation[MediaCapturePauseResult]: ...
    def resume_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def start_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def stop_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def stop_with_result_async(self) -> winrt.windows.foundation.IAsyncOperation[MediaCaptureStopResult]: ...

class LowLagPhotoCapture(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LowLagPhotoCapture: ...
    def capture_async(self) -> winrt.windows.foundation.IAsyncOperation[CapturedPhoto]: ...
    def finish_async(self) -> winrt.windows.foundation.IAsyncAction: ...

class LowLagPhotoSequenceCapture(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LowLagPhotoSequenceCapture: ...
    def finish_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def start_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def stop_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def add_photo_captured(self, handler: winrt.windows.foundation.TypedEventHandler[LowLagPhotoSequenceCapture, PhotoCapturedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_photo_captured(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class MediaCapture(winrt.system.Object):
    audio_device_controller: typing.Optional[winrt.windows.media.devices.AudioDeviceController]
    media_capture_settings: typing.Optional[MediaCaptureSettings]
    video_device_controller: typing.Optional[winrt.windows.media.devices.VideoDeviceController]
    camera_stream_state: winrt.windows.media.devices.CameraStreamState
    thermal_status: MediaCaptureThermalStatus
    frame_sources: typing.Optional[winrt.windows.foundation.collections.IMapView[str, winrt.windows.media.capture.frames.MediaFrameSource]]
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaCapture: ...
    def __new__(cls: typing.Type[MediaCapture]) -> MediaCapture:...
    def add_audio_effect_async(self, definition: typing.Optional[winrt.windows.media.effects.IAudioEffectDefinition], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.media.IMediaExtension]: ...
    def add_effect_async(self, media_stream_type: MediaStreamType, effect_activation_i_d: str, effect_settings: typing.Optional[winrt.windows.foundation.collections.IPropertySet], /) -> winrt.windows.foundation.IAsyncAction: ...
    def add_video_effect_async(self, definition: typing.Optional[winrt.windows.media.effects.IVideoEffectDefinition], media_stream_type: MediaStreamType, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.media.IMediaExtension]: ...
    def capture_photo_to_storage_file_async(self, type: typing.Optional[winrt.windows.media.mediaproperties.ImageEncodingProperties], file: typing.Optional[winrt.windows.storage.IStorageFile], /) -> winrt.windows.foundation.IAsyncAction: ...
    def capture_photo_to_stream_async(self, type: typing.Optional[winrt.windows.media.mediaproperties.ImageEncodingProperties], stream: typing.Optional[winrt.windows.storage.streams.IRandomAccessStream], /) -> winrt.windows.foundation.IAsyncAction: ...
    def clear_effects_async(self, media_stream_type: MediaStreamType, /) -> winrt.windows.foundation.IAsyncAction: ...
    def close(self) -> None: ...
    @typing.overload
    def create_frame_reader_async(self, input_source: typing.Optional[winrt.windows.media.capture.frames.MediaFrameSource], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.media.capture.frames.MediaFrameReader]: ...
    @typing.overload
    def create_frame_reader_async(self, input_source: typing.Optional[winrt.windows.media.capture.frames.MediaFrameSource], output_subtype: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.media.capture.frames.MediaFrameReader]: ...
    @typing.overload
    def create_frame_reader_async(self, input_source: typing.Optional[winrt.windows.media.capture.frames.MediaFrameSource], output_subtype: str, output_size: winrt.windows.graphics.imaging.BitmapSize, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.media.capture.frames.MediaFrameReader]: ...
    def create_multi_source_frame_reader_async(self, input_sources: typing.Iterable[winrt.windows.media.capture.frames.MediaFrameSource], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.media.capture.frames.MultiSourceMediaFrameReader]: ...
    def create_relative_panel_watcher(self, capture_mode: StreamingCaptureMode, display_region: typing.Optional[winrt.windows.ui.windowmanagement.DisplayRegion], /) -> typing.Optional[MediaCaptureRelativePanelWatcher]: ...
    @staticmethod
    def find_all_video_profiles(video_device_id: str, /) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[MediaCaptureVideoProfile]]: ...
    @staticmethod
    def find_concurrent_profiles(video_device_id: str, /) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[MediaCaptureVideoProfile]]: ...
    @staticmethod
    def find_known_video_profiles(video_device_id: str, name: KnownVideoProfile, /) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[MediaCaptureVideoProfile]]: ...
    def get_encoder_property(self, media_stream_type: MediaStreamType, property_id: uuid.UUID, /) -> typing.Optional[winrt.system.Object]: ...
    @typing.overload
    def get_preview_frame_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.media.VideoFrame]: ...
    @typing.overload
    def get_preview_frame_async(self, destination: typing.Optional[winrt.windows.media.VideoFrame], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.media.VideoFrame]: ...
    def get_preview_mirroring(self) -> bool: ...
    def get_preview_rotation(self) -> VideoRotation: ...
    def get_record_rotation(self) -> VideoRotation: ...
    @typing.overload
    def initialize_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def initialize_async(self, media_capture_initialization_settings: typing.Optional[MediaCaptureInitializationSettings], /) -> winrt.windows.foundation.IAsyncAction: ...
    @staticmethod
    def is_video_profile_supported(video_device_id: str, /) -> bool: ...
    def pause_record_async(self, behavior: winrt.windows.media.devices.MediaCapturePauseBehavior, /) -> winrt.windows.foundation.IAsyncAction: ...
    def pause_record_with_result_async(self, behavior: winrt.windows.media.devices.MediaCapturePauseBehavior, /) -> winrt.windows.foundation.IAsyncOperation[MediaCapturePauseResult]: ...
    def prepare_advanced_photo_capture_async(self, encoding_properties: typing.Optional[winrt.windows.media.mediaproperties.ImageEncodingProperties], /) -> winrt.windows.foundation.IAsyncOperation[AdvancedPhotoCapture]: ...
    def prepare_low_lag_photo_capture_async(self, type: typing.Optional[winrt.windows.media.mediaproperties.ImageEncodingProperties], /) -> winrt.windows.foundation.IAsyncOperation[LowLagPhotoCapture]: ...
    def prepare_low_lag_photo_sequence_capture_async(self, type: typing.Optional[winrt.windows.media.mediaproperties.ImageEncodingProperties], /) -> winrt.windows.foundation.IAsyncOperation[LowLagPhotoSequenceCapture]: ...
    @typing.overload
    def prepare_low_lag_record_to_custom_sink_async(self, encoding_profile: typing.Optional[winrt.windows.media.mediaproperties.MediaEncodingProfile], custom_media_sink: typing.Optional[winrt.windows.media.IMediaExtension], /) -> winrt.windows.foundation.IAsyncOperation[LowLagMediaRecording]: ...
    @typing.overload
    def prepare_low_lag_record_to_custom_sink_async(self, encoding_profile: typing.Optional[winrt.windows.media.mediaproperties.MediaEncodingProfile], custom_sink_activation_id: str, custom_sink_settings: typing.Optional[winrt.windows.foundation.collections.IPropertySet], /) -> winrt.windows.foundation.IAsyncOperation[LowLagMediaRecording]: ...
    def prepare_low_lag_record_to_storage_file_async(self, encoding_profile: typing.Optional[winrt.windows.media.mediaproperties.MediaEncodingProfile], file: typing.Optional[winrt.windows.storage.IStorageFile], /) -> winrt.windows.foundation.IAsyncOperation[LowLagMediaRecording]: ...
    def prepare_low_lag_record_to_stream_async(self, encoding_profile: typing.Optional[winrt.windows.media.mediaproperties.MediaEncodingProfile], stream: typing.Optional[winrt.windows.storage.streams.IRandomAccessStream], /) -> winrt.windows.foundation.IAsyncOperation[LowLagMediaRecording]: ...
    def prepare_variable_photo_sequence_capture_async(self, type: typing.Optional[winrt.windows.media.mediaproperties.ImageEncodingProperties], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.media.capture.core.VariablePhotoSequenceCapture]: ...
    def remove_effect_async(self, effect: typing.Optional[winrt.windows.media.IMediaExtension], /) -> winrt.windows.foundation.IAsyncAction: ...
    def resume_record_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def set_encoder_property(self, media_stream_type: MediaStreamType, property_id: uuid.UUID, property_value: typing.Optional[winrt.system.Object], /) -> None: ...
    def set_encoding_properties_async(self, media_stream_type: MediaStreamType, media_encoding_properties: typing.Optional[winrt.windows.media.mediaproperties.IMediaEncodingProperties], encoder_properties: typing.Optional[winrt.windows.media.mediaproperties.MediaPropertySet], /) -> winrt.windows.foundation.IAsyncAction: ...
    def set_preview_mirroring(self, value: bool, /) -> None: ...
    def set_preview_rotation(self, value: VideoRotation, /) -> None: ...
    def set_record_rotation(self, value: VideoRotation, /) -> None: ...
    def start_preview_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def start_preview_to_custom_sink_async(self, encoding_profile: typing.Optional[winrt.windows.media.mediaproperties.MediaEncodingProfile], custom_media_sink: typing.Optional[winrt.windows.media.IMediaExtension], /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def start_preview_to_custom_sink_async(self, encoding_profile: typing.Optional[winrt.windows.media.mediaproperties.MediaEncodingProfile], custom_sink_activation_id: str, custom_sink_settings: typing.Optional[winrt.windows.foundation.collections.IPropertySet], /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def start_record_to_custom_sink_async(self, encoding_profile: typing.Optional[winrt.windows.media.mediaproperties.MediaEncodingProfile], custom_media_sink: typing.Optional[winrt.windows.media.IMediaExtension], /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def start_record_to_custom_sink_async(self, encoding_profile: typing.Optional[winrt.windows.media.mediaproperties.MediaEncodingProfile], custom_sink_activation_id: str, custom_sink_settings: typing.Optional[winrt.windows.foundation.collections.IPropertySet], /) -> winrt.windows.foundation.IAsyncAction: ...
    def start_record_to_storage_file_async(self, encoding_profile: typing.Optional[winrt.windows.media.mediaproperties.MediaEncodingProfile], file: typing.Optional[winrt.windows.storage.IStorageFile], /) -> winrt.windows.foundation.IAsyncAction: ...
    def start_record_to_stream_async(self, encoding_profile: typing.Optional[winrt.windows.media.mediaproperties.MediaEncodingProfile], stream: typing.Optional[winrt.windows.storage.streams.IRandomAccessStream], /) -> winrt.windows.foundation.IAsyncAction: ...
    def stop_preview_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def stop_record_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def stop_record_with_result_async(self) -> winrt.windows.foundation.IAsyncOperation[MediaCaptureStopResult]: ...
    def add_failed(self, error_event_handler: typing.Optional[MediaCaptureFailedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_failed(self, event_cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_record_limitation_exceeded(self, record_limitation_exceeded_event_handler: typing.Optional[RecordLimitationExceededEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_record_limitation_exceeded(self, event_cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_focus_changed(self, handler: winrt.windows.foundation.TypedEventHandler[MediaCapture, MediaCaptureFocusChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_focus_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_photo_confirmation_captured(self, handler: winrt.windows.foundation.TypedEventHandler[MediaCapture, PhotoConfirmationCapturedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_photo_confirmation_captured(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_camera_stream_state_changed(self, handler: winrt.windows.foundation.TypedEventHandler[MediaCapture, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_camera_stream_state_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_thermal_status_changed(self, handler: winrt.windows.foundation.TypedEventHandler[MediaCapture, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_thermal_status_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_capture_device_exclusive_control_status_changed(self, handler: winrt.windows.foundation.TypedEventHandler[MediaCapture, MediaCaptureDeviceExclusiveControlStatusChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_capture_device_exclusive_control_status_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class MediaCaptureDeviceExclusiveControlStatusChangedEventArgs(winrt.system.Object):
    device_id: str
    status: MediaCaptureDeviceExclusiveControlStatus
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaCaptureDeviceExclusiveControlStatusChangedEventArgs: ...

class MediaCaptureFailedEventArgs(winrt.system.Object):
    code: winrt.system.UInt32
    message: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaCaptureFailedEventArgs: ...

class MediaCaptureFocusChangedEventArgs(winrt.system.Object):
    focus_state: winrt.windows.media.devices.MediaCaptureFocusState
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaCaptureFocusChangedEventArgs: ...

class MediaCaptureInitializationSettings(winrt.system.Object):
    video_device_id: str
    streaming_capture_mode: StreamingCaptureMode
    photo_capture_source: PhotoCaptureSource
    audio_device_id: str
    media_category: MediaCategory
    audio_processing: winrt.windows.media.AudioProcessing
    video_source: typing.Optional[winrt.windows.media.core.IMediaSource]
    audio_source: typing.Optional[winrt.windows.media.core.IMediaSource]
    video_profile: typing.Optional[MediaCaptureVideoProfile]
    record_media_description: typing.Optional[MediaCaptureVideoProfileMediaDescription]
    preview_media_description: typing.Optional[MediaCaptureVideoProfileMediaDescription]
    photo_media_description: typing.Optional[MediaCaptureVideoProfileMediaDescription]
    source_group: typing.Optional[winrt.windows.media.capture.frames.MediaFrameSourceGroup]
    sharing_mode: MediaCaptureSharingMode
    memory_preference: MediaCaptureMemoryPreference
    always_play_system_shutter_sound: bool
    device_uri_password_credential: typing.Optional[winrt.windows.security.credentials.PasswordCredential]
    device_uri: typing.Optional[winrt.windows.foundation.Uri]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaCaptureInitializationSettings: ...
    def __new__(cls: typing.Type[MediaCaptureInitializationSettings]) -> MediaCaptureInitializationSettings:...

class MediaCapturePauseResult(winrt.system.Object):
    last_frame: typing.Optional[winrt.windows.media.VideoFrame]
    record_duration: datetime.timedelta
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaCapturePauseResult: ...
    def close(self) -> None: ...

class MediaCaptureRelativePanelWatcher(winrt.system.Object):
    relative_panel: winrt.windows.devices.enumeration.Panel
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaCaptureRelativePanelWatcher: ...
    def close(self) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def add_changed(self, handler: winrt.windows.foundation.TypedEventHandler[MediaCaptureRelativePanelWatcher, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class MediaCaptureSettings(winrt.system.Object):
    audio_device_id: str
    photo_capture_source: PhotoCaptureSource
    streaming_capture_mode: StreamingCaptureMode
    video_device_characteristic: VideoDeviceCharacteristic
    video_device_id: str
    audio_processing: winrt.windows.media.AudioProcessing
    camera_sound_required_for_region: bool
    concurrent_record_and_photo_sequence_supported: bool
    concurrent_record_and_photo_supported: bool
    horizontal35mm_equivalent_focal_length: typing.Optional[typing.Optional[winrt.system.UInt32]]
    media_category: MediaCategory
    pitch_offset_degrees: typing.Optional[typing.Optional[winrt.system.Int32]]
    vertical35mm_equivalent_focal_length: typing.Optional[typing.Optional[winrt.system.UInt32]]
    direct3_d11_device: typing.Optional[winrt.windows.graphics.directx.direct3d11.IDirect3DDevice]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaCaptureSettings: ...

class MediaCaptureStopResult(winrt.system.Object):
    last_frame: typing.Optional[winrt.windows.media.VideoFrame]
    record_duration: datetime.timedelta
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaCaptureStopResult: ...
    def close(self) -> None: ...

class MediaCaptureVideoProfile(winrt.system.Object):
    id: str
    supported_photo_media_description: typing.Optional[winrt.windows.foundation.collections.IVectorView[MediaCaptureVideoProfileMediaDescription]]
    supported_preview_media_description: typing.Optional[winrt.windows.foundation.collections.IVectorView[MediaCaptureVideoProfileMediaDescription]]
    supported_record_media_description: typing.Optional[winrt.windows.foundation.collections.IVectorView[MediaCaptureVideoProfileMediaDescription]]
    video_device_id: str
    frame_source_infos: typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.media.capture.frames.MediaFrameSourceInfo]]
    properties: typing.Optional[winrt.windows.foundation.collections.IMapView[uuid.UUID, winrt.system.Object]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaCaptureVideoProfile: ...
    def get_concurrency(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[MediaCaptureVideoProfile]]: ...

class MediaCaptureVideoProfileMediaDescription(winrt.system.Object):
    frame_rate: winrt.system.Double
    height: winrt.system.UInt32
    is_hdr_video_supported: bool
    is_variable_photo_sequence_supported: bool
    width: winrt.system.UInt32
    properties: typing.Optional[winrt.windows.foundation.collections.IMapView[uuid.UUID, winrt.system.Object]]
    subtype: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaCaptureVideoProfileMediaDescription: ...

class OptionalReferencePhotoCapturedEventArgs(winrt.system.Object):
    context: typing.Optional[winrt.system.Object]
    frame: typing.Optional[CapturedFrame]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> OptionalReferencePhotoCapturedEventArgs: ...

class PhotoCapturedEventArgs(winrt.system.Object):
    capture_time_offset: datetime.timedelta
    frame: typing.Optional[CapturedFrame]
    thumbnail: typing.Optional[CapturedFrame]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PhotoCapturedEventArgs: ...

class PhotoConfirmationCapturedEventArgs(winrt.system.Object):
    capture_time_offset: datetime.timedelta
    frame: typing.Optional[CapturedFrame]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PhotoConfirmationCapturedEventArgs: ...

class ScreenCapture(winrt.system.Object):
    audio_source: typing.Optional[winrt.windows.media.core.IMediaSource]
    is_audio_suspended: bool
    is_video_suspended: bool
    video_source: typing.Optional[winrt.windows.media.core.IMediaSource]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ScreenCapture: ...
    @staticmethod
    def get_for_current_view() -> typing.Optional[ScreenCapture]: ...
    def add_source_suspension_changed(self, handler: winrt.windows.foundation.TypedEventHandler[ScreenCapture, SourceSuspensionChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_source_suspension_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class SourceSuspensionChangedEventArgs(winrt.system.Object):
    is_audio_suspended: bool
    is_video_suspended: bool
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SourceSuspensionChangedEventArgs: ...

class VideoStreamConfiguration(winrt.system.Object):
    input_properties: typing.Optional[winrt.windows.media.mediaproperties.VideoEncodingProperties]
    output_properties: typing.Optional[winrt.windows.media.mediaproperties.VideoEncodingProperties]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VideoStreamConfiguration: ...

