# WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

import datetime
import sys
import types
import typing
import uuid

import winrt.system
import winrt.windows.devices.display
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.foundation.numerics
import winrt.windows.graphics
import winrt.windows.graphics.directx
import winrt.windows.graphics.directx.direct3d11
import winrt.windows.storage.streams

from . import DisplayBitsPerChannel, DisplayDeviceCapability, DisplayManagerOptions, DisplayManagerResult, DisplayModeQueryOptions, DisplayPathScaling, DisplayPathStatus, DisplayPresentStatus, DisplayRotation, DisplayScanoutOptions, DisplaySourceStatus, DisplayStateApplyOptions, DisplayStateFunctionalizeOptions, DisplayStateOperationStatus, DisplayTargetPersistence, DisplayTaskSignalKind, DisplayWireFormatColorSpace, DisplayWireFormatEotf, DisplayWireFormatHdrMetadata, DisplayWireFormatPixelEncoding

Self = typing.TypeVar('Self')

class DisplayPresentationRate:
    vertical_sync_rate: winrt.windows.foundation.numerics.Rational
    vertical_syncs_per_presentation: winrt.system.Int32
    def __new__(cls: typing.Type[DisplayPresentationRate], vertical_sync_rate: winrt.windows.foundation.numerics.Rational, vertical_syncs_per_presentation: winrt.system.Int32) -> DisplayPresentationRate: ...

class DisplayAdapter(winrt.system.Object):
    device_interface_path: str
    id: winrt.windows.graphics.DisplayAdapterId
    pci_device_id: winrt.system.UInt32
    pci_revision: winrt.system.UInt32
    pci_sub_system_id: winrt.system.UInt32
    pci_vendor_id: winrt.system.UInt32
    properties: typing.Optional[winrt.windows.foundation.collections.IMapView[uuid.UUID, winrt.system.Object]]
    source_count: winrt.system.UInt32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DisplayAdapter: ...
    @staticmethod
    def from_id(id: winrt.windows.graphics.DisplayAdapterId, /) -> typing.Optional[DisplayAdapter]: ...

class DisplayDevice(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DisplayDevice: ...
    def create_periodic_fence(self, target: typing.Optional[DisplayTarget], offset_from_v_blank: datetime.timedelta, /) -> typing.Optional[DisplayFence]: ...
    def create_primary(self, target: typing.Optional[DisplayTarget], desc: typing.Optional[DisplayPrimaryDescription], /) -> typing.Optional[DisplaySurface]: ...
    def create_scanout_source(self, target: typing.Optional[DisplayTarget], /) -> typing.Optional[DisplaySource]: ...
    def create_simple_scanout(self, p_source: typing.Optional[DisplaySource], p_surface: typing.Optional[DisplaySurface], sub_resource_index: winrt.system.UInt32, sync_interval: winrt.system.UInt32, /) -> typing.Optional[DisplayScanout]: ...
    def create_simple_scanout_with_dirty_rects_and_options(self, source: typing.Optional[DisplaySource], surface: typing.Optional[DisplaySurface], subresource_index: winrt.system.UInt32, sync_interval: winrt.system.UInt32, dirty_rects: typing.Iterable[winrt.windows.graphics.RectInt32], options: DisplayScanoutOptions, /) -> typing.Optional[DisplayScanout]: ...
    def create_task_pool(self) -> typing.Optional[DisplayTaskPool]: ...
    def is_capability_supported(self, capability: DisplayDeviceCapability, /) -> bool: ...
    def wait_for_v_blank(self, source: typing.Optional[DisplaySource], /) -> None: ...

class DisplayFence(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DisplayFence: ...

class DisplayManager(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DisplayManager: ...
    def close(self) -> None: ...
    @staticmethod
    def create(options: DisplayManagerOptions, /) -> typing.Optional[DisplayManager]: ...
    def create_display_device(self, adapter: typing.Optional[DisplayAdapter], /) -> typing.Optional[DisplayDevice]: ...
    def get_current_adapters(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[DisplayAdapter]]: ...
    def get_current_targets(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[DisplayTarget]]: ...
    def release_target(self, target: typing.Optional[DisplayTarget], /) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def try_acquire_target(self, target: typing.Optional[DisplayTarget], /) -> DisplayManagerResult: ...
    def try_acquire_targets_and_create_empty_state(self, targets: typing.Iterable[DisplayTarget], /) -> typing.Optional[DisplayManagerResultWithState]: ...
    def try_acquire_targets_and_create_substate(self, existing_state: typing.Optional[DisplayState], targets: typing.Iterable[DisplayTarget], /) -> typing.Optional[DisplayManagerResultWithState]: ...
    def try_acquire_targets_and_read_current_state(self, targets: typing.Iterable[DisplayTarget], /) -> typing.Optional[DisplayManagerResultWithState]: ...
    def try_read_current_state_for_all_targets(self) -> typing.Optional[DisplayManagerResultWithState]: ...
    def add_changed(self, handler: winrt.windows.foundation.TypedEventHandler[DisplayManager, DisplayManagerChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_disabled(self, handler: winrt.windows.foundation.TypedEventHandler[DisplayManager, DisplayManagerDisabledEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_disabled(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_enabled(self, handler: winrt.windows.foundation.TypedEventHandler[DisplayManager, DisplayManagerEnabledEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_enabled(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_paths_failed_or_invalidated(self, handler: winrt.windows.foundation.TypedEventHandler[DisplayManager, DisplayManagerPathsFailedOrInvalidatedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_paths_failed_or_invalidated(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class DisplayManagerChangedEventArgs(winrt.system.Object):
    handled: bool
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DisplayManagerChangedEventArgs: ...
    def get_deferral(self) -> typing.Optional[winrt.windows.foundation.Deferral]: ...

class DisplayManagerDisabledEventArgs(winrt.system.Object):
    handled: bool
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DisplayManagerDisabledEventArgs: ...
    def get_deferral(self) -> typing.Optional[winrt.windows.foundation.Deferral]: ...

class DisplayManagerEnabledEventArgs(winrt.system.Object):
    handled: bool
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DisplayManagerEnabledEventArgs: ...
    def get_deferral(self) -> typing.Optional[winrt.windows.foundation.Deferral]: ...

class DisplayManagerPathsFailedOrInvalidatedEventArgs(winrt.system.Object):
    handled: bool
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DisplayManagerPathsFailedOrInvalidatedEventArgs: ...
    def get_deferral(self) -> typing.Optional[winrt.windows.foundation.Deferral]: ...

class DisplayManagerResultWithState(winrt.system.Object):
    error_code: DisplayManagerResult
    extended_error_code: winrt.windows.foundation.HResult
    state: typing.Optional[DisplayState]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DisplayManagerResultWithState: ...

class DisplayModeInfo(winrt.system.Object):
    is_interlaced: bool
    is_stereo: bool
    presentation_rate: DisplayPresentationRate
    properties: typing.Optional[winrt.windows.foundation.collections.IMapView[uuid.UUID, winrt.system.Object]]
    source_pixel_format: winrt.windows.graphics.directx.DirectXPixelFormat
    source_resolution: winrt.windows.graphics.SizeInt32
    target_resolution: winrt.windows.graphics.SizeInt32
    physical_presentation_rate: DisplayPresentationRate
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DisplayModeInfo: ...
    def get_wire_format_supported_bits_per_channel(self, encoding: DisplayWireFormatPixelEncoding, /) -> DisplayBitsPerChannel: ...
    def is_wire_format_supported(self, wire_format: typing.Optional[DisplayWireFormat], /) -> bool: ...

class DisplayPath(winrt.system.Object):
    wire_format: typing.Optional[DisplayWireFormat]
    target_resolution: typing.Optional[typing.Optional[winrt.windows.graphics.SizeInt32]]
    source_resolution: typing.Optional[typing.Optional[winrt.windows.graphics.SizeInt32]]
    source_pixel_format: winrt.windows.graphics.directx.DirectXPixelFormat
    scaling: DisplayPathScaling
    rotation: DisplayRotation
    presentation_rate: typing.Optional[typing.Optional[DisplayPresentationRate]]
    is_stereo: bool
    is_interlaced: typing.Optional[typing.Optional[bool]]
    properties: typing.Optional[winrt.windows.foundation.collections.IMap[uuid.UUID, winrt.system.Object]]
    status: DisplayPathStatus
    target: typing.Optional[DisplayTarget]
    view: typing.Optional[DisplayView]
    physical_presentation_rate: typing.Optional[typing.Optional[DisplayPresentationRate]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DisplayPath: ...
    def apply_properties_from_mode(self, mode_result: typing.Optional[DisplayModeInfo], /) -> None: ...
    def find_modes(self, flags: DisplayModeQueryOptions, /) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[DisplayModeInfo]]: ...

class DisplayPrimaryDescription(winrt.system.Object):
    color_space: winrt.windows.graphics.directx.DirectXColorSpace
    format: winrt.windows.graphics.directx.DirectXPixelFormat
    height: winrt.system.UInt32
    is_stereo: bool
    multisample_description: winrt.windows.graphics.directx.direct3d11.Direct3DMultisampleDescription
    properties: typing.Optional[winrt.windows.foundation.collections.IMapView[uuid.UUID, winrt.system.Object]]
    width: winrt.system.UInt32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DisplayPrimaryDescription: ...
    def __new__(cls: typing.Type[DisplayPrimaryDescription], width: winrt.system.UInt32, height: winrt.system.UInt32, pixel_format: winrt.windows.graphics.directx.DirectXPixelFormat, color_space: winrt.windows.graphics.directx.DirectXColorSpace, is_stereo: bool, multisample_description: winrt.windows.graphics.directx.direct3d11.Direct3DMultisampleDescription) -> DisplayPrimaryDescription:...
    @staticmethod
    def create_with_properties(extra_properties: typing.Iterable[winrt.windows.foundation.collections.IKeyValuePair[uuid.UUID, winrt.system.Object]], width: winrt.system.UInt32, height: winrt.system.UInt32, pixel_format: winrt.windows.graphics.directx.DirectXPixelFormat, color_space: winrt.windows.graphics.directx.DirectXColorSpace, is_stereo: bool, multisample_description: winrt.windows.graphics.directx.direct3d11.Direct3DMultisampleDescription, /) -> typing.Optional[DisplayPrimaryDescription]: ...

class DisplayScanout(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DisplayScanout: ...

class DisplaySource(winrt.system.Object):
    adapter_id: winrt.windows.graphics.DisplayAdapterId
    source_id: winrt.system.UInt32
    status: DisplaySourceStatus
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DisplaySource: ...
    def get_metadata(self, key: uuid.UUID, /) -> typing.Optional[winrt.windows.storage.streams.IBuffer]: ...
    def add_status_changed(self, handler: winrt.windows.foundation.TypedEventHandler[DisplaySource, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_status_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class DisplayState(winrt.system.Object):
    is_read_only: bool
    is_stale: bool
    properties: typing.Optional[winrt.windows.foundation.collections.IMap[uuid.UUID, winrt.system.Object]]
    targets: typing.Optional[winrt.windows.foundation.collections.IVectorView[DisplayTarget]]
    views: typing.Optional[winrt.windows.foundation.collections.IVectorView[DisplayView]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DisplayState: ...
    def can_connect_target_to_view(self, target: typing.Optional[DisplayTarget], view: typing.Optional[DisplayView], /) -> bool: ...
    def clone(self) -> typing.Optional[DisplayState]: ...
    @typing.overload
    def connect_target(self, target: typing.Optional[DisplayTarget], /) -> typing.Optional[DisplayPath]: ...
    @typing.overload
    def connect_target(self, target: typing.Optional[DisplayTarget], view: typing.Optional[DisplayView], /) -> typing.Optional[DisplayPath]: ...
    def disconnect_target(self, target: typing.Optional[DisplayTarget], /) -> None: ...
    def get_path_for_target(self, target: typing.Optional[DisplayTarget], /) -> typing.Optional[DisplayPath]: ...
    def get_view_for_target(self, target: typing.Optional[DisplayTarget], /) -> typing.Optional[DisplayView]: ...
    def try_apply(self, options: DisplayStateApplyOptions, /) -> typing.Optional[DisplayStateOperationResult]: ...
    def try_functionalize(self, options: DisplayStateFunctionalizeOptions, /) -> typing.Optional[DisplayStateOperationResult]: ...

class DisplayStateOperationResult(winrt.system.Object):
    extended_error_code: winrt.windows.foundation.HResult
    status: DisplayStateOperationStatus
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DisplayStateOperationResult: ...

class DisplaySurface(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DisplaySurface: ...

class DisplayTarget(winrt.system.Object):
    adapter: typing.Optional[DisplayAdapter]
    adapter_relative_id: winrt.system.UInt32
    device_interface_path: str
    is_connected: bool
    is_stale: bool
    is_virtual_mode_enabled: bool
    is_virtual_topology_enabled: bool
    monitor_persistence: DisplayTargetPersistence
    properties: typing.Optional[winrt.windows.foundation.collections.IMapView[uuid.UUID, winrt.system.Object]]
    stable_monitor_id: str
    usage_kind: winrt.windows.devices.display.DisplayMonitorUsageKind
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DisplayTarget: ...
    def is_equal(self, other_target: typing.Optional[DisplayTarget], /) -> bool: ...
    def is_same(self, other_target: typing.Optional[DisplayTarget], /) -> bool: ...
    def try_get_monitor(self) -> typing.Optional[winrt.windows.devices.display.DisplayMonitor]: ...

class DisplayTask(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DisplayTask: ...
    def set_scanout(self, scanout: typing.Optional[DisplayScanout], /) -> None: ...
    def set_signal(self, signal_kind: DisplayTaskSignalKind, fence: typing.Optional[DisplayFence], /) -> None: ...
    def set_wait(self, ready_fence: typing.Optional[DisplayFence], ready_fence_value: winrt.system.UInt64, /) -> None: ...

class DisplayTaskPool(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DisplayTaskPool: ...
    def create_task(self) -> typing.Optional[DisplayTask]: ...
    def execute_task(self, task: typing.Optional[DisplayTask], /) -> None: ...
    def try_execute_task(self, task: typing.Optional[DisplayTask], /) -> typing.Optional[DisplayTaskResult]: ...

class DisplayTaskResult(winrt.system.Object):
    present_id: winrt.system.UInt64
    present_status: DisplayPresentStatus
    source_status: DisplaySourceStatus
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DisplayTaskResult: ...

class DisplayView(winrt.system.Object):
    content_resolution: typing.Optional[typing.Optional[winrt.windows.graphics.SizeInt32]]
    paths: typing.Optional[winrt.windows.foundation.collections.IVectorView[DisplayPath]]
    properties: typing.Optional[winrt.windows.foundation.collections.IMap[uuid.UUID, winrt.system.Object]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DisplayView: ...
    def set_primary_path(self, path: typing.Optional[DisplayPath], /) -> None: ...

class DisplayWireFormat(winrt.system.Object):
    bits_per_channel: winrt.system.Int32
    color_space: DisplayWireFormatColorSpace
    eotf: DisplayWireFormatEotf
    hdr_metadata: DisplayWireFormatHdrMetadata
    pixel_encoding: DisplayWireFormatPixelEncoding
    properties: typing.Optional[winrt.windows.foundation.collections.IMapView[uuid.UUID, winrt.system.Object]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DisplayWireFormat: ...
    def __new__(cls: typing.Type[DisplayWireFormat], pixel_encoding: DisplayWireFormatPixelEncoding, bits_per_channel: winrt.system.Int32, color_space: DisplayWireFormatColorSpace, eotf: DisplayWireFormatEotf, hdr_metadata: DisplayWireFormatHdrMetadata) -> DisplayWireFormat:...
    @staticmethod
    def create_with_properties(extra_properties: typing.Iterable[winrt.windows.foundation.collections.IKeyValuePair[uuid.UUID, winrt.system.Object]], pixel_encoding: DisplayWireFormatPixelEncoding, bits_per_channel: winrt.system.Int32, color_space: DisplayWireFormatColorSpace, eotf: DisplayWireFormatEotf, hdr_metadata: DisplayWireFormatHdrMetadata, /) -> typing.Optional[DisplayWireFormat]: ...

