# WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

import enum
import datetime
import sys
import types
import typing

import winrt.system
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.foundation.numerics
import winrt.windows.perception
import winrt.windows.storage.streams
import winrt.windows.system.remotesystems

class SpatialAnchorExportPurpose(enum.IntEnum):
    RELOCALIZATION = 0
    SHARING = 1

class SpatialEntityWatcherStatus(enum.IntEnum):
    CREATED = 0
    STARTED = 1
    ENUMERATION_COMPLETED = 2
    STOPPING = 3
    STOPPED = 4
    ABORTED = 5

class SpatialLocatability(enum.IntEnum):
    UNAVAILABLE = 0
    ORIENTATION_ONLY = 1
    POSITIONAL_TRACKING_ACTIVATING = 2
    POSITIONAL_TRACKING_ACTIVE = 3
    POSITIONAL_TRACKING_INHIBITED = 4

class SpatialLookDirectionRange(enum.IntEnum):
    FORWARD_ONLY = 0
    OMNIDIRECTIONAL = 1

class SpatialMovementRange(enum.IntEnum):
    NO_MOVEMENT = 0
    BOUNDED = 1

class SpatialPerceptionAccessStatus(enum.IntEnum):
    UNSPECIFIED = 0
    ALLOWED = 1
    DENIED_BY_USER = 2
    DENIED_BY_SYSTEM = 3

Self = typing.TypeVar('Self')

class SpatialBoundingBox:
    center: winrt.windows.foundation.numerics.Vector3
    extents: winrt.windows.foundation.numerics.Vector3
    def __new__(cls: typing.Type[SpatialBoundingBox], center: winrt.windows.foundation.numerics.Vector3, extents: winrt.windows.foundation.numerics.Vector3) -> SpatialBoundingBox: ...

class SpatialBoundingFrustum:
    near: winrt.windows.foundation.numerics.Plane
    far: winrt.windows.foundation.numerics.Plane
    right: winrt.windows.foundation.numerics.Plane
    left: winrt.windows.foundation.numerics.Plane
    top: winrt.windows.foundation.numerics.Plane
    bottom: winrt.windows.foundation.numerics.Plane
    def __new__(cls: typing.Type[SpatialBoundingFrustum], near: winrt.windows.foundation.numerics.Plane, far: winrt.windows.foundation.numerics.Plane, right: winrt.windows.foundation.numerics.Plane, left: winrt.windows.foundation.numerics.Plane, top: winrt.windows.foundation.numerics.Plane, bottom: winrt.windows.foundation.numerics.Plane) -> SpatialBoundingFrustum: ...

class SpatialBoundingOrientedBox:
    center: winrt.windows.foundation.numerics.Vector3
    extents: winrt.windows.foundation.numerics.Vector3
    orientation: winrt.windows.foundation.numerics.Quaternion
    def __new__(cls: typing.Type[SpatialBoundingOrientedBox], center: winrt.windows.foundation.numerics.Vector3, extents: winrt.windows.foundation.numerics.Vector3, orientation: winrt.windows.foundation.numerics.Quaternion) -> SpatialBoundingOrientedBox: ...

class SpatialBoundingSphere:
    center: winrt.windows.foundation.numerics.Vector3
    radius: winrt.system.Single
    def __new__(cls: typing.Type[SpatialBoundingSphere], center: winrt.windows.foundation.numerics.Vector3, radius: winrt.system.Single) -> SpatialBoundingSphere: ...

class SpatialRay:
    origin: winrt.windows.foundation.numerics.Vector3
    direction: winrt.windows.foundation.numerics.Vector3
    def __new__(cls: typing.Type[SpatialRay], origin: winrt.windows.foundation.numerics.Vector3, direction: winrt.windows.foundation.numerics.Vector3) -> SpatialRay: ...

class SpatialAnchor(winrt.system.Object):
    coordinate_system: typing.Optional[SpatialCoordinateSystem]
    raw_coordinate_system: typing.Optional[SpatialCoordinateSystem]
    removed_by_user: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpatialAnchor: ...
    @typing.overload
    @staticmethod
    def try_create_relative_to(coordinate_system: typing.Optional[SpatialCoordinateSystem], /) -> typing.Optional[SpatialAnchor]: ...
    @typing.overload
    @staticmethod
    def try_create_relative_to(coordinate_system: typing.Optional[SpatialCoordinateSystem], position: winrt.windows.foundation.numerics.Vector3, /) -> typing.Optional[SpatialAnchor]: ...
    @typing.overload
    @staticmethod
    def try_create_relative_to(coordinate_system: typing.Optional[SpatialCoordinateSystem], position: winrt.windows.foundation.numerics.Vector3, orientation: winrt.windows.foundation.numerics.Quaternion, /) -> typing.Optional[SpatialAnchor]: ...
    def add_raw_coordinate_system_adjusted(self, handler: winrt.windows.foundation.TypedEventHandler[SpatialAnchor, SpatialAnchorRawCoordinateSystemAdjustedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_raw_coordinate_system_adjusted(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class SpatialAnchorExportSufficiency(winrt.system.Object):
    is_minimally_sufficient: winrt.system.Boolean
    recommended_sufficiency_level: winrt.system.Double
    sufficiency_level: winrt.system.Double
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpatialAnchorExportSufficiency: ...

class SpatialAnchorExporter(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpatialAnchorExporter: ...
    def get_anchor_export_sufficiency_async(self, anchor: typing.Optional[SpatialAnchor], purpose: SpatialAnchorExportPurpose, /) -> winrt.windows.foundation.IAsyncOperation[SpatialAnchorExportSufficiency]: ...
    @staticmethod
    def get_default() -> typing.Optional[SpatialAnchorExporter]: ...
    @staticmethod
    def request_access_async() -> winrt.windows.foundation.IAsyncOperation[SpatialPerceptionAccessStatus]: ...
    def try_export_anchor_async(self, anchor: typing.Optional[SpatialAnchor], purpose: SpatialAnchorExportPurpose, stream: typing.Optional[winrt.windows.storage.streams.IOutputStream], /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...

class SpatialAnchorManager(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpatialAnchorManager: ...
    @staticmethod
    def request_store_async() -> winrt.windows.foundation.IAsyncOperation[SpatialAnchorStore]: ...

class SpatialAnchorRawCoordinateSystemAdjustedEventArgs(winrt.system.Object):
    old_raw_coordinate_system_to_new_raw_coordinate_system_transform: winrt.windows.foundation.numerics.Matrix4x4
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpatialAnchorRawCoordinateSystemAdjustedEventArgs: ...

class SpatialAnchorStore(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpatialAnchorStore: ...
    def clear(self) -> None: ...
    def get_all_saved_anchors(self) -> typing.Optional[winrt.windows.foundation.collections.IMapView[str, SpatialAnchor]]: ...
    def remove(self, id: str, /) -> None: ...
    def try_save(self, id: str, anchor: typing.Optional[SpatialAnchor], /) -> winrt.system.Boolean: ...

class SpatialAnchorTransferManager(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpatialAnchorTransferManager: ...
    @staticmethod
    def request_access_async() -> winrt.windows.foundation.IAsyncOperation[SpatialPerceptionAccessStatus]: ...
    @staticmethod
    def try_export_anchors_async(anchors: typing.Iterable[winrt.windows.foundation.collections.IKeyValuePair[str, SpatialAnchor]], stream: typing.Optional[winrt.windows.storage.streams.IOutputStream], /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...
    @staticmethod
    def try_import_anchors_async(stream: typing.Optional[winrt.windows.storage.streams.IInputStream], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IMapView[str, SpatialAnchor]]: ...

class SpatialBoundingVolume(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpatialBoundingVolume: ...
    @staticmethod
    def from_box(coordinate_system: typing.Optional[SpatialCoordinateSystem], box: SpatialBoundingBox, /) -> typing.Optional[SpatialBoundingVolume]: ...
    @staticmethod
    def from_frustum(coordinate_system: typing.Optional[SpatialCoordinateSystem], frustum: SpatialBoundingFrustum, /) -> typing.Optional[SpatialBoundingVolume]: ...
    @staticmethod
    def from_oriented_box(coordinate_system: typing.Optional[SpatialCoordinateSystem], box: SpatialBoundingOrientedBox, /) -> typing.Optional[SpatialBoundingVolume]: ...
    @staticmethod
    def from_sphere(coordinate_system: typing.Optional[SpatialCoordinateSystem], sphere: SpatialBoundingSphere, /) -> typing.Optional[SpatialBoundingVolume]: ...

class SpatialCoordinateSystem(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpatialCoordinateSystem: ...
    def try_get_transform_to(self, target: typing.Optional[SpatialCoordinateSystem], /) -> typing.Optional[typing.Optional[winrt.windows.foundation.numerics.Matrix4x4]]: ...

class SpatialEntity(winrt.system.Object):
    anchor: typing.Optional[SpatialAnchor]
    id: str
    properties: typing.Optional[winrt.windows.foundation.collections.ValueSet]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpatialEntity: ...
    @typing.overload
    def __new__(cls: typing.Type[SpatialEntity], spatial_anchor: typing.Optional[SpatialAnchor]) -> SpatialEntity:...
    @typing.overload
    def __new__(cls: typing.Type[SpatialEntity], spatial_anchor: typing.Optional[SpatialAnchor], property_set: typing.Optional[winrt.windows.foundation.collections.ValueSet]) -> SpatialEntity:...

class SpatialEntityAddedEventArgs(winrt.system.Object):
    entity: typing.Optional[SpatialEntity]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpatialEntityAddedEventArgs: ...

class SpatialEntityRemovedEventArgs(winrt.system.Object):
    entity: typing.Optional[SpatialEntity]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpatialEntityRemovedEventArgs: ...

class SpatialEntityStore(winrt.system.Object):
    is_supported: typing.ClassVar[winrt.system.Boolean]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpatialEntityStore: ...
    def create_entity_watcher(self) -> typing.Optional[SpatialEntityWatcher]: ...
    def remove_async(self, entity: typing.Optional[SpatialEntity], /) -> winrt.windows.foundation.IAsyncAction: ...
    def save_async(self, entity: typing.Optional[SpatialEntity], /) -> winrt.windows.foundation.IAsyncAction: ...
    @staticmethod
    def try_get(session: typing.Optional[winrt.windows.system.remotesystems.RemoteSystemSession], /) -> typing.Optional[SpatialEntityStore]: ...

class SpatialEntityUpdatedEventArgs(winrt.system.Object):
    entity: typing.Optional[SpatialEntity]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpatialEntityUpdatedEventArgs: ...

class SpatialEntityWatcher(winrt.system.Object):
    status: SpatialEntityWatcherStatus
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpatialEntityWatcher: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def add_added(self, handler: winrt.windows.foundation.TypedEventHandler[SpatialEntityWatcher, SpatialEntityAddedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_added(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_enumeration_completed(self, handler: winrt.windows.foundation.TypedEventHandler[SpatialEntityWatcher, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_enumeration_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_removed(self, handler: winrt.windows.foundation.TypedEventHandler[SpatialEntityWatcher, SpatialEntityRemovedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_removed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_updated(self, handler: winrt.windows.foundation.TypedEventHandler[SpatialEntityWatcher, SpatialEntityUpdatedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_updated(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class SpatialLocation(winrt.system.Object):
    absolute_angular_acceleration: winrt.windows.foundation.numerics.Quaternion
    absolute_angular_velocity: winrt.windows.foundation.numerics.Quaternion
    absolute_linear_acceleration: winrt.windows.foundation.numerics.Vector3
    absolute_linear_velocity: winrt.windows.foundation.numerics.Vector3
    orientation: winrt.windows.foundation.numerics.Quaternion
    position: winrt.windows.foundation.numerics.Vector3
    absolute_angular_acceleration_axis_angle: winrt.windows.foundation.numerics.Vector3
    absolute_angular_velocity_axis_angle: winrt.windows.foundation.numerics.Vector3
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpatialLocation: ...

class SpatialLocator(winrt.system.Object):
    locatability: SpatialLocatability
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpatialLocator: ...
    @typing.overload
    def create_attached_frame_of_reference_at_current_heading(self) -> typing.Optional[SpatialLocatorAttachedFrameOfReference]: ...
    @typing.overload
    def create_attached_frame_of_reference_at_current_heading(self, relative_position: winrt.windows.foundation.numerics.Vector3, /) -> typing.Optional[SpatialLocatorAttachedFrameOfReference]: ...
    @typing.overload
    def create_attached_frame_of_reference_at_current_heading(self, relative_position: winrt.windows.foundation.numerics.Vector3, relative_orientation: winrt.windows.foundation.numerics.Quaternion, /) -> typing.Optional[SpatialLocatorAttachedFrameOfReference]: ...
    @typing.overload
    def create_attached_frame_of_reference_at_current_heading(self, relative_position: winrt.windows.foundation.numerics.Vector3, relative_orientation: winrt.windows.foundation.numerics.Quaternion, relative_heading_in_radians: winrt.system.Double, /) -> typing.Optional[SpatialLocatorAttachedFrameOfReference]: ...
    @typing.overload
    def create_stationary_frame_of_reference_at_current_location(self) -> typing.Optional[SpatialStationaryFrameOfReference]: ...
    @typing.overload
    def create_stationary_frame_of_reference_at_current_location(self, relative_position: winrt.windows.foundation.numerics.Vector3, /) -> typing.Optional[SpatialStationaryFrameOfReference]: ...
    @typing.overload
    def create_stationary_frame_of_reference_at_current_location(self, relative_position: winrt.windows.foundation.numerics.Vector3, relative_orientation: winrt.windows.foundation.numerics.Quaternion, /) -> typing.Optional[SpatialStationaryFrameOfReference]: ...
    @typing.overload
    def create_stationary_frame_of_reference_at_current_location(self, relative_position: winrt.windows.foundation.numerics.Vector3, relative_orientation: winrt.windows.foundation.numerics.Quaternion, relative_heading_in_radians: winrt.system.Double, /) -> typing.Optional[SpatialStationaryFrameOfReference]: ...
    @staticmethod
    def get_default() -> typing.Optional[SpatialLocator]: ...
    def try_locate_at_timestamp(self, timestamp: typing.Optional[winrt.windows.perception.PerceptionTimestamp], coordinate_system: typing.Optional[SpatialCoordinateSystem], /) -> typing.Optional[SpatialLocation]: ...
    def add_locatability_changed(self, handler: winrt.windows.foundation.TypedEventHandler[SpatialLocator, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_locatability_changed(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_positional_tracking_deactivating(self, handler: winrt.windows.foundation.TypedEventHandler[SpatialLocator, SpatialLocatorPositionalTrackingDeactivatingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_positional_tracking_deactivating(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class SpatialLocatorAttachedFrameOfReference(winrt.system.Object):
    relative_position: winrt.windows.foundation.numerics.Vector3
    relative_orientation: winrt.windows.foundation.numerics.Quaternion
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpatialLocatorAttachedFrameOfReference: ...
    def adjust_heading(self, heading_offset_in_radians: winrt.system.Double, /) -> None: ...
    def get_stationary_coordinate_system_at_timestamp(self, timestamp: typing.Optional[winrt.windows.perception.PerceptionTimestamp], /) -> typing.Optional[SpatialCoordinateSystem]: ...
    def try_get_relative_heading_at_timestamp(self, timestamp: typing.Optional[winrt.windows.perception.PerceptionTimestamp], /) -> typing.Optional[typing.Optional[winrt.system.Double]]: ...

class SpatialLocatorPositionalTrackingDeactivatingEventArgs(winrt.system.Object):
    canceled: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpatialLocatorPositionalTrackingDeactivatingEventArgs: ...

class SpatialStageFrameOfReference(winrt.system.Object):
    coordinate_system: typing.Optional[SpatialCoordinateSystem]
    look_direction_range: SpatialLookDirectionRange
    movement_range: SpatialMovementRange
    current: typing.ClassVar[typing.Optional[SpatialStageFrameOfReference]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpatialStageFrameOfReference: ...
    def get_coordinate_system_at_current_location(self, locator: typing.Optional[SpatialLocator], /) -> typing.Optional[SpatialCoordinateSystem]: ...
    @staticmethod
    def request_new_stage_async() -> winrt.windows.foundation.IAsyncOperation[SpatialStageFrameOfReference]: ...
    def try_get_movement_bounds(self, coordinate_system: typing.Optional[SpatialCoordinateSystem], /) -> winrt.windows.foundation.numerics.Vector3: ...
    @staticmethod
    def add_current_changed(handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    @staticmethod
    def remove_current_changed(cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class SpatialStationaryFrameOfReference(winrt.system.Object):
    coordinate_system: typing.Optional[SpatialCoordinateSystem]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpatialStationaryFrameOfReference: ...

