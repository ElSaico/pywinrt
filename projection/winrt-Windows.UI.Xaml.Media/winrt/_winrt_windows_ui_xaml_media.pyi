# WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt.system
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.media.playback
import winrt.windows.storage.streams
import winrt.windows.ui
import winrt.windows.ui.composition
import winrt.windows.ui.xaml
import winrt.windows.ui.xaml.controls.primitives
import winrt.windows.ui.xaml.media.media3d

from winrt.windows.ui.xaml.media import AcrylicBackgroundSource, AlignmentX, AlignmentY, AudioCategory, AudioDeviceType, BrushMappingMode, ColorInterpolationMode, ElementCompositeMode, FastPlayFallbackBehaviour, FillRule, GradientSpreadMethod, LoadedImageSourceLoadStatus, MediaCanPlayResponse, MediaElementState, PenLineCap, PenLineJoin, RevealBrushState, Stereo3DVideoPackingMode, Stereo3DVideoRenderMode, Stretch, StyleSimulations, SweepDirection
from winrt.windows.ui.xaml.media import RateChangedRoutedEventHandler, TimelineMarkerRoutedEventHandler

Self = typing.TypeVar('Self')

class Matrix:
    m11: winrt.system.Double
    m12: winrt.system.Double
    m21: winrt.system.Double
    m22: winrt.system.Double
    offset_x: winrt.system.Double
    offset_y: winrt.system.Double
    def __init__(self, m11: winrt.system.Double, m12: winrt.system.Double, m21: winrt.system.Double, m22: winrt.system.Double, offset_x: winrt.system.Double, offset_y: winrt.system.Double) -> None: ...

class AcrylicBrush(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AcrylicBrush: ...
    def __new__(cls: typing.Type[AcrylicBrush]) -> AcrylicBrush:...
    @_property
    def tint_transition_duration(self) -> datetime.timedelta: ...
    @tint_transition_duration.setter
    def tint_transition_duration(self, value: datetime.timedelta) -> None: ...
    @_property
    def tint_opacity(self) -> winrt.system.Double: ...
    @tint_opacity.setter
    def tint_opacity(self, value: winrt.system.Double) -> None: ...
    @_property
    def tint_color(self) -> winrt.windows.ui.Color: ...
    @tint_color.setter
    def tint_color(self, value: winrt.windows.ui.Color) -> None: ...
    @_property
    def background_source(self) -> AcrylicBackgroundSource: ...
    @background_source.setter
    def background_source(self, value: AcrylicBackgroundSource) -> None: ...
    @_property
    def always_use_fallback(self) -> bool: ...
    @always_use_fallback.setter
    def always_use_fallback(self, value: bool) -> None: ...
    @_property
    def tint_luminosity_opacity(self) -> typing.Optional[typing.Optional[winrt.system.Double]]: ...
    @tint_luminosity_opacity.setter
    def tint_luminosity_opacity(self, value: typing.Optional[typing.Optional[winrt.system.Double]]) -> None: ...
    always_use_fallback_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    background_source_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    tint_color_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    tint_opacity_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    tint_transition_duration_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    tint_luminosity_opacity_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class ArcSegment(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ArcSegment: ...
    def __new__(cls: typing.Type[ArcSegment]) -> ArcSegment:...
    @_property
    def sweep_direction(self) -> SweepDirection: ...
    @sweep_direction.setter
    def sweep_direction(self, value: SweepDirection) -> None: ...
    @_property
    def size(self) -> winrt.windows.foundation.Size: ...
    @size.setter
    def size(self, value: winrt.windows.foundation.Size) -> None: ...
    @_property
    def rotation_angle(self) -> winrt.system.Double: ...
    @rotation_angle.setter
    def rotation_angle(self, value: winrt.system.Double) -> None: ...
    @_property
    def point(self) -> winrt.windows.foundation.Point: ...
    @point.setter
    def point(self, value: winrt.windows.foundation.Point) -> None: ...
    @_property
    def is_large_arc(self) -> bool: ...
    @is_large_arc.setter
    def is_large_arc(self, value: bool) -> None: ...
    is_large_arc_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    point_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    rotation_angle_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    size_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    sweep_direction_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class BezierSegment(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BezierSegment: ...
    def __new__(cls: typing.Type[BezierSegment]) -> BezierSegment:...
    @_property
    def point3(self) -> winrt.windows.foundation.Point: ...
    @point3.setter
    def point3(self, value: winrt.windows.foundation.Point) -> None: ...
    @_property
    def point2(self) -> winrt.windows.foundation.Point: ...
    @point2.setter
    def point2(self, value: winrt.windows.foundation.Point) -> None: ...
    @_property
    def point1(self) -> winrt.windows.foundation.Point: ...
    @point1.setter
    def point1(self, value: winrt.windows.foundation.Point) -> None: ...
    point1_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    point2_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    point3_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class BitmapCache(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BitmapCache: ...
    def __new__(cls: typing.Type[BitmapCache]) -> BitmapCache:...

class Brush(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Brush: ...
    def populate_property_info(self, property_name: str, property_info: typing.Optional[winrt.windows.ui.composition.AnimationPropertyInfo], /) -> None: ...
    def populate_property_info_override(self, property_name: str, animation_property_info: typing.Optional[winrt.windows.ui.composition.AnimationPropertyInfo], /) -> None: ...
    @_property
    def transform(self) -> typing.Optional[Transform]: ...
    @transform.setter
    def transform(self, value: typing.Optional[Transform]) -> None: ...
    @_property
    def relative_transform(self) -> typing.Optional[Transform]: ...
    @relative_transform.setter
    def relative_transform(self, value: typing.Optional[Transform]) -> None: ...
    @_property
    def opacity(self) -> winrt.system.Double: ...
    @opacity.setter
    def opacity(self, value: winrt.system.Double) -> None: ...
    opacity_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    relative_transform_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    transform_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class BrushCollection(winrt.system.Object, typing.MutableSequence[Brush]):
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> Brush: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[Brush]: ...
    def insert(self, index: int, value: Brush) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: Brush) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[Brush]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BrushCollection: ...
    def __new__(cls: typing.Type[BrushCollection]) -> BrushCollection:...
    def append(self, value: typing.Optional[Brush], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[Brush]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[Brush]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[Brush], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[Brush]]: ...
    def index_of(self, value: typing.Optional[Brush], /) -> typing.Tuple[bool, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[Brush], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[Brush], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[Brush], /) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

class CacheMode(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CacheMode: ...

class CompositeTransform(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositeTransform: ...
    def __new__(cls: typing.Type[CompositeTransform]) -> CompositeTransform:...
    @_property
    def translate_y(self) -> winrt.system.Double: ...
    @translate_y.setter
    def translate_y(self, value: winrt.system.Double) -> None: ...
    @_property
    def translate_x(self) -> winrt.system.Double: ...
    @translate_x.setter
    def translate_x(self, value: winrt.system.Double) -> None: ...
    @_property
    def skew_y(self) -> winrt.system.Double: ...
    @skew_y.setter
    def skew_y(self, value: winrt.system.Double) -> None: ...
    @_property
    def skew_x(self) -> winrt.system.Double: ...
    @skew_x.setter
    def skew_x(self, value: winrt.system.Double) -> None: ...
    @_property
    def scale_y(self) -> winrt.system.Double: ...
    @scale_y.setter
    def scale_y(self, value: winrt.system.Double) -> None: ...
    @_property
    def scale_x(self) -> winrt.system.Double: ...
    @scale_x.setter
    def scale_x(self, value: winrt.system.Double) -> None: ...
    @_property
    def rotation(self) -> winrt.system.Double: ...
    @rotation.setter
    def rotation(self, value: winrt.system.Double) -> None: ...
    @_property
    def center_y(self) -> winrt.system.Double: ...
    @center_y.setter
    def center_y(self, value: winrt.system.Double) -> None: ...
    @_property
    def center_x(self) -> winrt.system.Double: ...
    @center_x.setter
    def center_x(self, value: winrt.system.Double) -> None: ...
    center_x_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    center_y_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    rotation_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    scale_x_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    scale_y_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    skew_x_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    skew_y_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    translate_x_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    translate_y_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class CompositionTarget(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionTarget: ...
    @staticmethod
    def add_rendered(handler: winrt.windows.foundation.EventHandler[RenderedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    @staticmethod
    def remove_rendered(token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @staticmethod
    def add_rendering(handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    @staticmethod
    def remove_rendering(token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @staticmethod
    def add_surface_contents_lost(handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    @staticmethod
    def remove_surface_contents_lost(token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class DoubleCollection(winrt.system.Object, typing.MutableSequence[winrt.system.Double]):
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> winrt.system.Double: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[winrt.system.Double]: ...
    def insert(self, index: int, value: winrt.system.Double) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: winrt.system.Double) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[winrt.system.Double]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DoubleCollection: ...
    def __new__(cls: typing.Type[DoubleCollection]) -> DoubleCollection:...
    def append(self, value: winrt.system.Double, /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[winrt.system.Double]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> winrt.system.Double: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[winrt.system.Double], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Double]]: ...
    def index_of(self, value: winrt.system.Double, /) -> typing.Tuple[bool, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: winrt.system.Double, /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[winrt.system.Double], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: winrt.system.Double, /) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

class EllipseGeometry(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EllipseGeometry: ...
    def __new__(cls: typing.Type[EllipseGeometry]) -> EllipseGeometry:...
    @_property
    def radius_y(self) -> winrt.system.Double: ...
    @radius_y.setter
    def radius_y(self, value: winrt.system.Double) -> None: ...
    @_property
    def radius_x(self) -> winrt.system.Double: ...
    @radius_x.setter
    def radius_x(self, value: winrt.system.Double) -> None: ...
    @_property
    def center(self) -> winrt.windows.foundation.Point: ...
    @center.setter
    def center(self, value: winrt.windows.foundation.Point) -> None: ...
    center_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    radius_x_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    radius_y_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class FontFamily(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FontFamily: ...
    def __new__(cls: typing.Type[FontFamily], family_name: str) -> FontFamily:...
    @_property
    def source(self) -> str: ...
    xaml_auto_font_family: typing.ClassVar[typing.Optional[FontFamily]]

class GeneralTransform(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GeneralTransform: ...
    def transform_bounds(self, rect: winrt.windows.foundation.Rect, /) -> winrt.windows.foundation.Rect: ...
    def transform_bounds_core(self, rect: winrt.windows.foundation.Rect, /) -> winrt.windows.foundation.Rect: ...
    def transform_point(self, point: winrt.windows.foundation.Point, /) -> winrt.windows.foundation.Point: ...
    def try_transform(self, in_point: winrt.windows.foundation.Point, /) -> typing.Tuple[bool, winrt.windows.foundation.Point]: ...
    def try_transform_core(self, in_point: winrt.windows.foundation.Point, /) -> typing.Tuple[bool, winrt.windows.foundation.Point]: ...
    @_property
    def inverse(self) -> typing.Optional[GeneralTransform]: ...
    @_property
    def inverse_core(self) -> typing.Optional[GeneralTransform]: ...

class Geometry(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Geometry: ...
    @_property
    def transform(self) -> typing.Optional[Transform]: ...
    @transform.setter
    def transform(self, value: typing.Optional[Transform]) -> None: ...
    @_property
    def bounds(self) -> winrt.windows.foundation.Rect: ...
    empty: typing.ClassVar[typing.Optional[Geometry]]
    standard_flattening_tolerance: typing.ClassVar[winrt.system.Double]
    transform_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class GeometryCollection(winrt.system.Object, typing.MutableSequence[Geometry]):
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> Geometry: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[Geometry]: ...
    def insert(self, index: int, value: Geometry) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: Geometry) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[Geometry]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GeometryCollection: ...
    def __new__(cls: typing.Type[GeometryCollection]) -> GeometryCollection:...
    def append(self, value: typing.Optional[Geometry], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[Geometry]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[Geometry]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[Geometry], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[Geometry]]: ...
    def index_of(self, value: typing.Optional[Geometry], /) -> typing.Tuple[bool, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[Geometry], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[Geometry], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[Geometry], /) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

class GeometryGroup(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GeometryGroup: ...
    def __new__(cls: typing.Type[GeometryGroup]) -> GeometryGroup:...
    @_property
    def fill_rule(self) -> FillRule: ...
    @fill_rule.setter
    def fill_rule(self, value: FillRule) -> None: ...
    @_property
    def children(self) -> typing.Optional[GeometryCollection]: ...
    @children.setter
    def children(self, value: typing.Optional[GeometryCollection]) -> None: ...
    children_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    fill_rule_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class GradientBrush(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GradientBrush: ...
    @_property
    def spread_method(self) -> GradientSpreadMethod: ...
    @spread_method.setter
    def spread_method(self, value: GradientSpreadMethod) -> None: ...
    @_property
    def mapping_mode(self) -> BrushMappingMode: ...
    @mapping_mode.setter
    def mapping_mode(self, value: BrushMappingMode) -> None: ...
    @_property
    def gradient_stops(self) -> typing.Optional[GradientStopCollection]: ...
    @gradient_stops.setter
    def gradient_stops(self, value: typing.Optional[GradientStopCollection]) -> None: ...
    @_property
    def color_interpolation_mode(self) -> ColorInterpolationMode: ...
    @color_interpolation_mode.setter
    def color_interpolation_mode(self, value: ColorInterpolationMode) -> None: ...
    color_interpolation_mode_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    gradient_stops_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    mapping_mode_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    spread_method_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class GradientStop(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GradientStop: ...
    def __new__(cls: typing.Type[GradientStop]) -> GradientStop:...
    @_property
    def offset(self) -> winrt.system.Double: ...
    @offset.setter
    def offset(self, value: winrt.system.Double) -> None: ...
    @_property
    def color(self) -> winrt.windows.ui.Color: ...
    @color.setter
    def color(self, value: winrt.windows.ui.Color) -> None: ...
    color_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    offset_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class GradientStopCollection(winrt.system.Object, typing.MutableSequence[GradientStop]):
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> GradientStop: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[GradientStop]: ...
    def insert(self, index: int, value: GradientStop) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: GradientStop) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[GradientStop]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GradientStopCollection: ...
    def __new__(cls: typing.Type[GradientStopCollection]) -> GradientStopCollection:...
    def append(self, value: typing.Optional[GradientStop], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[GradientStop]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[GradientStop]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[GradientStop], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[GradientStop]]: ...
    def index_of(self, value: typing.Optional[GradientStop], /) -> typing.Tuple[bool, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[GradientStop], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[GradientStop], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[GradientStop], /) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

class ImageBrush(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ImageBrush: ...
    def __new__(cls: typing.Type[ImageBrush]) -> ImageBrush:...
    def add_image_failed(self, handler: typing.Optional[winrt.windows.ui.xaml.ExceptionRoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_image_failed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_image_opened(self, handler: typing.Optional[winrt.windows.ui.xaml.RoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_image_opened(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def image_source(self) -> typing.Optional[ImageSource]: ...
    @image_source.setter
    def image_source(self, value: typing.Optional[ImageSource]) -> None: ...
    image_source_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class ImageSource(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ImageSource: ...

class LineGeometry(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LineGeometry: ...
    def __new__(cls: typing.Type[LineGeometry]) -> LineGeometry:...
    @_property
    def start_point(self) -> winrt.windows.foundation.Point: ...
    @start_point.setter
    def start_point(self, value: winrt.windows.foundation.Point) -> None: ...
    @_property
    def end_point(self) -> winrt.windows.foundation.Point: ...
    @end_point.setter
    def end_point(self, value: winrt.windows.foundation.Point) -> None: ...
    end_point_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    start_point_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class LineSegment(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LineSegment: ...
    def __new__(cls: typing.Type[LineSegment]) -> LineSegment:...
    @_property
    def point(self) -> winrt.windows.foundation.Point: ...
    @point.setter
    def point(self, value: winrt.windows.foundation.Point) -> None: ...
    point_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class LinearGradientBrush(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LinearGradientBrush: ...
    @typing.overload
    def __new__(cls: typing.Type[LinearGradientBrush], gradient_stop_collection: typing.Optional[GradientStopCollection], angle: winrt.system.Double) -> LinearGradientBrush:...
    @typing.overload
    def __new__(cls: typing.Type[LinearGradientBrush]) -> LinearGradientBrush:...
    @_property
    def start_point(self) -> winrt.windows.foundation.Point: ...
    @start_point.setter
    def start_point(self, value: winrt.windows.foundation.Point) -> None: ...
    @_property
    def end_point(self) -> winrt.windows.foundation.Point: ...
    @end_point.setter
    def end_point(self, value: winrt.windows.foundation.Point) -> None: ...
    end_point_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    start_point_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class LoadedImageSourceLoadCompletedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LoadedImageSourceLoadCompletedEventArgs: ...
    @_property
    def status(self) -> LoadedImageSourceLoadStatus: ...

class LoadedImageSurface(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LoadedImageSurface: ...
    def close(self) -> None: ...
    @typing.overload
    @staticmethod
    def start_load_from_stream(stream: typing.Optional[winrt.windows.storage.streams.IRandomAccessStream], /) -> typing.Optional[LoadedImageSurface]: ...
    @typing.overload
    @staticmethod
    def start_load_from_stream(stream: typing.Optional[winrt.windows.storage.streams.IRandomAccessStream], desired_max_size: winrt.windows.foundation.Size, /) -> typing.Optional[LoadedImageSurface]: ...
    @typing.overload
    @staticmethod
    def start_load_from_uri(uri: typing.Optional[winrt.windows.foundation.Uri], /) -> typing.Optional[LoadedImageSurface]: ...
    @typing.overload
    @staticmethod
    def start_load_from_uri(uri: typing.Optional[winrt.windows.foundation.Uri], desired_max_size: winrt.windows.foundation.Size, /) -> typing.Optional[LoadedImageSurface]: ...
    def add_load_completed(self, handler: winrt.windows.foundation.TypedEventHandler[LoadedImageSurface, LoadedImageSourceLoadCompletedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_load_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def decoded_physical_size(self) -> winrt.windows.foundation.Size: ...
    @_property
    def decoded_size(self) -> winrt.windows.foundation.Size: ...
    @_property
    def natural_size(self) -> winrt.windows.foundation.Size: ...

class Matrix3DProjection(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Matrix3DProjection: ...
    def __new__(cls: typing.Type[Matrix3DProjection]) -> Matrix3DProjection:...
    @_property
    def projection_matrix(self) -> winrt.windows.ui.xaml.media.media3d.Matrix3D: ...
    @projection_matrix.setter
    def projection_matrix(self, value: winrt.windows.ui.xaml.media.media3d.Matrix3D) -> None: ...
    projection_matrix_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class MatrixHelper(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MatrixHelper: ...
    @staticmethod
    def from_elements(m11: winrt.system.Double, m12: winrt.system.Double, m21: winrt.system.Double, m22: winrt.system.Double, offset_x: winrt.system.Double, offset_y: winrt.system.Double, /) -> Matrix: ...
    @staticmethod
    def get_is_identity(target: Matrix, /) -> bool: ...
    @staticmethod
    def transform(target: Matrix, point: winrt.windows.foundation.Point, /) -> winrt.windows.foundation.Point: ...
    identity: typing.ClassVar[Matrix]

class MatrixTransform(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MatrixTransform: ...
    def __new__(cls: typing.Type[MatrixTransform]) -> MatrixTransform:...
    @_property
    def matrix(self) -> Matrix: ...
    @matrix.setter
    def matrix(self, value: Matrix) -> None: ...
    matrix_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class MediaTransportControlsThumbnailRequestedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaTransportControlsThumbnailRequestedEventArgs: ...
    def get_deferral(self) -> typing.Optional[winrt.windows.foundation.Deferral]: ...
    def set_thumbnail_image(self, source: typing.Optional[winrt.windows.storage.streams.IInputStream], /) -> None: ...

class PartialMediaFailureDetectedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PartialMediaFailureDetectedEventArgs: ...
    def __new__(cls: typing.Type[PartialMediaFailureDetectedEventArgs]) -> PartialMediaFailureDetectedEventArgs:...
    @_property
    def stream_kind(self) -> winrt.windows.media.playback.FailedMediaStreamKind: ...
    @_property
    def extended_error(self) -> winrt.windows.foundation.HResult: ...

class PathFigure(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PathFigure: ...
    def __new__(cls: typing.Type[PathFigure]) -> PathFigure:...
    @_property
    def start_point(self) -> winrt.windows.foundation.Point: ...
    @start_point.setter
    def start_point(self, value: winrt.windows.foundation.Point) -> None: ...
    @_property
    def segments(self) -> typing.Optional[PathSegmentCollection]: ...
    @segments.setter
    def segments(self, value: typing.Optional[PathSegmentCollection]) -> None: ...
    @_property
    def is_filled(self) -> bool: ...
    @is_filled.setter
    def is_filled(self, value: bool) -> None: ...
    @_property
    def is_closed(self) -> bool: ...
    @is_closed.setter
    def is_closed(self, value: bool) -> None: ...
    is_closed_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_filled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    segments_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    start_point_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class PathFigureCollection(winrt.system.Object, typing.MutableSequence[PathFigure]):
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> PathFigure: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[PathFigure]: ...
    def insert(self, index: int, value: PathFigure) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: PathFigure) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[PathFigure]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PathFigureCollection: ...
    def __new__(cls: typing.Type[PathFigureCollection]) -> PathFigureCollection:...
    def append(self, value: typing.Optional[PathFigure], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[PathFigure]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[PathFigure]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[PathFigure], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[PathFigure]]: ...
    def index_of(self, value: typing.Optional[PathFigure], /) -> typing.Tuple[bool, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[PathFigure], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[PathFigure], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[PathFigure], /) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

class PathGeometry(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PathGeometry: ...
    def __new__(cls: typing.Type[PathGeometry]) -> PathGeometry:...
    @_property
    def fill_rule(self) -> FillRule: ...
    @fill_rule.setter
    def fill_rule(self, value: FillRule) -> None: ...
    @_property
    def figures(self) -> typing.Optional[PathFigureCollection]: ...
    @figures.setter
    def figures(self, value: typing.Optional[PathFigureCollection]) -> None: ...
    figures_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    fill_rule_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class PathSegment(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PathSegment: ...

class PathSegmentCollection(winrt.system.Object, typing.MutableSequence[PathSegment]):
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> PathSegment: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[PathSegment]: ...
    def insert(self, index: int, value: PathSegment) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: PathSegment) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[PathSegment]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PathSegmentCollection: ...
    def __new__(cls: typing.Type[PathSegmentCollection]) -> PathSegmentCollection:...
    def append(self, value: typing.Optional[PathSegment], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[PathSegment]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[PathSegment]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[PathSegment], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[PathSegment]]: ...
    def index_of(self, value: typing.Optional[PathSegment], /) -> typing.Tuple[bool, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[PathSegment], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[PathSegment], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[PathSegment], /) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

class PlaneProjection(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PlaneProjection: ...
    def __new__(cls: typing.Type[PlaneProjection]) -> PlaneProjection:...
    @_property
    def rotation_z(self) -> winrt.system.Double: ...
    @rotation_z.setter
    def rotation_z(self, value: winrt.system.Double) -> None: ...
    @_property
    def rotation_y(self) -> winrt.system.Double: ...
    @rotation_y.setter
    def rotation_y(self, value: winrt.system.Double) -> None: ...
    @_property
    def rotation_x(self) -> winrt.system.Double: ...
    @rotation_x.setter
    def rotation_x(self, value: winrt.system.Double) -> None: ...
    @_property
    def local_offset_z(self) -> winrt.system.Double: ...
    @local_offset_z.setter
    def local_offset_z(self, value: winrt.system.Double) -> None: ...
    @_property
    def local_offset_y(self) -> winrt.system.Double: ...
    @local_offset_y.setter
    def local_offset_y(self, value: winrt.system.Double) -> None: ...
    @_property
    def local_offset_x(self) -> winrt.system.Double: ...
    @local_offset_x.setter
    def local_offset_x(self, value: winrt.system.Double) -> None: ...
    @_property
    def global_offset_z(self) -> winrt.system.Double: ...
    @global_offset_z.setter
    def global_offset_z(self, value: winrt.system.Double) -> None: ...
    @_property
    def global_offset_y(self) -> winrt.system.Double: ...
    @global_offset_y.setter
    def global_offset_y(self, value: winrt.system.Double) -> None: ...
    @_property
    def global_offset_x(self) -> winrt.system.Double: ...
    @global_offset_x.setter
    def global_offset_x(self, value: winrt.system.Double) -> None: ...
    @_property
    def center_of_rotation_z(self) -> winrt.system.Double: ...
    @center_of_rotation_z.setter
    def center_of_rotation_z(self, value: winrt.system.Double) -> None: ...
    @_property
    def center_of_rotation_y(self) -> winrt.system.Double: ...
    @center_of_rotation_y.setter
    def center_of_rotation_y(self, value: winrt.system.Double) -> None: ...
    @_property
    def center_of_rotation_x(self) -> winrt.system.Double: ...
    @center_of_rotation_x.setter
    def center_of_rotation_x(self, value: winrt.system.Double) -> None: ...
    @_property
    def projection_matrix(self) -> winrt.windows.ui.xaml.media.media3d.Matrix3D: ...
    center_of_rotation_x_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    center_of_rotation_y_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    center_of_rotation_z_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    global_offset_x_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    global_offset_y_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    global_offset_z_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    local_offset_x_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    local_offset_y_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    local_offset_z_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    projection_matrix_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    rotation_x_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    rotation_y_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    rotation_z_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class PointCollection(winrt.system.Object, typing.MutableSequence[winrt.windows.foundation.Point]):
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> winrt.windows.foundation.Point: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[winrt.windows.foundation.Point]: ...
    def insert(self, index: int, value: winrt.windows.foundation.Point) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: winrt.windows.foundation.Point) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[winrt.windows.foundation.Point]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PointCollection: ...
    def __new__(cls: typing.Type[PointCollection]) -> PointCollection:...
    def append(self, value: winrt.windows.foundation.Point, /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[winrt.windows.foundation.Point]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> winrt.windows.foundation.Point: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[winrt.windows.foundation.Point], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.foundation.Point]]: ...
    def index_of(self, value: winrt.windows.foundation.Point, /) -> typing.Tuple[bool, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: winrt.windows.foundation.Point, /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[winrt.windows.foundation.Point], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: winrt.windows.foundation.Point, /) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

class PolyBezierSegment(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PolyBezierSegment: ...
    def __new__(cls: typing.Type[PolyBezierSegment]) -> PolyBezierSegment:...
    @_property
    def points(self) -> typing.Optional[PointCollection]: ...
    @points.setter
    def points(self, value: typing.Optional[PointCollection]) -> None: ...
    points_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class PolyLineSegment(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PolyLineSegment: ...
    def __new__(cls: typing.Type[PolyLineSegment]) -> PolyLineSegment:...
    @_property
    def points(self) -> typing.Optional[PointCollection]: ...
    @points.setter
    def points(self, value: typing.Optional[PointCollection]) -> None: ...
    points_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class PolyQuadraticBezierSegment(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PolyQuadraticBezierSegment: ...
    def __new__(cls: typing.Type[PolyQuadraticBezierSegment]) -> PolyQuadraticBezierSegment:...
    @_property
    def points(self) -> typing.Optional[PointCollection]: ...
    @points.setter
    def points(self, value: typing.Optional[PointCollection]) -> None: ...
    points_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class Projection(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Projection: ...

class QuadraticBezierSegment(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> QuadraticBezierSegment: ...
    def __new__(cls: typing.Type[QuadraticBezierSegment]) -> QuadraticBezierSegment:...
    @_property
    def point2(self) -> winrt.windows.foundation.Point: ...
    @point2.setter
    def point2(self, value: winrt.windows.foundation.Point) -> None: ...
    @_property
    def point1(self) -> winrt.windows.foundation.Point: ...
    @point1.setter
    def point1(self, value: winrt.windows.foundation.Point) -> None: ...
    point1_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    point2_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class RateChangedRoutedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RateChangedRoutedEventArgs: ...
    def __new__(cls: typing.Type[RateChangedRoutedEventArgs]) -> RateChangedRoutedEventArgs:...

class RectangleGeometry(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RectangleGeometry: ...
    def __new__(cls: typing.Type[RectangleGeometry]) -> RectangleGeometry:...
    @_property
    def rect(self) -> winrt.windows.foundation.Rect: ...
    @rect.setter
    def rect(self, value: winrt.windows.foundation.Rect) -> None: ...
    rect_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class RenderedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RenderedEventArgs: ...
    @_property
    def frame_duration(self) -> datetime.timedelta: ...

class RenderingEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RenderingEventArgs: ...
    @_property
    def rendering_time(self) -> datetime.timedelta: ...

class RevealBackgroundBrush(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RevealBackgroundBrush: ...
    def __new__(cls: typing.Type[RevealBackgroundBrush]) -> RevealBackgroundBrush:...

class RevealBorderBrush(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RevealBorderBrush: ...
    def __new__(cls: typing.Type[RevealBorderBrush]) -> RevealBorderBrush:...

class RevealBrush(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RevealBrush: ...
    @staticmethod
    def get_state(element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> RevealBrushState: ...
    @staticmethod
    def set_state(element: typing.Optional[winrt.windows.ui.xaml.UIElement], value: RevealBrushState, /) -> None: ...
    @_property
    def target_theme(self) -> winrt.windows.ui.xaml.ApplicationTheme: ...
    @target_theme.setter
    def target_theme(self, value: winrt.windows.ui.xaml.ApplicationTheme) -> None: ...
    @_property
    def color(self) -> winrt.windows.ui.Color: ...
    @color.setter
    def color(self, value: winrt.windows.ui.Color) -> None: ...
    @_property
    def always_use_fallback(self) -> bool: ...
    @always_use_fallback.setter
    def always_use_fallback(self, value: bool) -> None: ...
    always_use_fallback_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    color_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    state_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    target_theme_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class RotateTransform(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RotateTransform: ...
    def __new__(cls: typing.Type[RotateTransform]) -> RotateTransform:...
    @_property
    def center_y(self) -> winrt.system.Double: ...
    @center_y.setter
    def center_y(self, value: winrt.system.Double) -> None: ...
    @_property
    def center_x(self) -> winrt.system.Double: ...
    @center_x.setter
    def center_x(self, value: winrt.system.Double) -> None: ...
    @_property
    def angle(self) -> winrt.system.Double: ...
    @angle.setter
    def angle(self, value: winrt.system.Double) -> None: ...
    angle_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    center_x_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    center_y_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class ScaleTransform(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ScaleTransform: ...
    def __new__(cls: typing.Type[ScaleTransform]) -> ScaleTransform:...
    @_property
    def scale_y(self) -> winrt.system.Double: ...
    @scale_y.setter
    def scale_y(self, value: winrt.system.Double) -> None: ...
    @_property
    def scale_x(self) -> winrt.system.Double: ...
    @scale_x.setter
    def scale_x(self, value: winrt.system.Double) -> None: ...
    @_property
    def center_y(self) -> winrt.system.Double: ...
    @center_y.setter
    def center_y(self, value: winrt.system.Double) -> None: ...
    @_property
    def center_x(self) -> winrt.system.Double: ...
    @center_x.setter
    def center_x(self, value: winrt.system.Double) -> None: ...
    center_x_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    center_y_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    scale_x_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    scale_y_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class Shadow(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Shadow: ...

class SkewTransform(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SkewTransform: ...
    def __new__(cls: typing.Type[SkewTransform]) -> SkewTransform:...
    @_property
    def center_y(self) -> winrt.system.Double: ...
    @center_y.setter
    def center_y(self, value: winrt.system.Double) -> None: ...
    @_property
    def center_x(self) -> winrt.system.Double: ...
    @center_x.setter
    def center_x(self, value: winrt.system.Double) -> None: ...
    @_property
    def angle_y(self) -> winrt.system.Double: ...
    @angle_y.setter
    def angle_y(self, value: winrt.system.Double) -> None: ...
    @_property
    def angle_x(self) -> winrt.system.Double: ...
    @angle_x.setter
    def angle_x(self, value: winrt.system.Double) -> None: ...
    angle_x_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    angle_y_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    center_x_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    center_y_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class SolidColorBrush(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SolidColorBrush: ...
    @typing.overload
    def __new__(cls: typing.Type[SolidColorBrush], color: winrt.windows.ui.Color) -> SolidColorBrush:...
    @typing.overload
    def __new__(cls: typing.Type[SolidColorBrush]) -> SolidColorBrush:...
    @_property
    def color(self) -> winrt.windows.ui.Color: ...
    @color.setter
    def color(self, value: winrt.windows.ui.Color) -> None: ...
    color_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class ThemeShadow(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ThemeShadow: ...
    def __new__(cls: typing.Type[ThemeShadow]) -> ThemeShadow:...
    @_property
    def receivers(self) -> typing.Optional[winrt.windows.ui.xaml.UIElementWeakCollection]: ...

class TileBrush(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TileBrush: ...
    @_property
    def stretch(self) -> Stretch: ...
    @stretch.setter
    def stretch(self, value: Stretch) -> None: ...
    @_property
    def alignment_y(self) -> AlignmentY: ...
    @alignment_y.setter
    def alignment_y(self, value: AlignmentY) -> None: ...
    @_property
    def alignment_x(self) -> AlignmentX: ...
    @alignment_x.setter
    def alignment_x(self, value: AlignmentX) -> None: ...
    alignment_x_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    alignment_y_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    stretch_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class TimelineMarker(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TimelineMarker: ...
    def __new__(cls: typing.Type[TimelineMarker]) -> TimelineMarker:...
    @_property
    def type(self) -> str: ...
    @type.setter
    def type(self, value: str) -> None: ...
    @_property
    def time(self) -> datetime.timedelta: ...
    @time.setter
    def time(self, value: datetime.timedelta) -> None: ...
    @_property
    def text(self) -> str: ...
    @text.setter
    def text(self, value: str) -> None: ...
    text_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    time_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    type_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class TimelineMarkerCollection(winrt.system.Object, typing.MutableSequence[TimelineMarker]):
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> TimelineMarker: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[TimelineMarker]: ...
    def insert(self, index: int, value: TimelineMarker) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: TimelineMarker) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[TimelineMarker]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TimelineMarkerCollection: ...
    def __new__(cls: typing.Type[TimelineMarkerCollection]) -> TimelineMarkerCollection:...
    def append(self, value: typing.Optional[TimelineMarker], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[TimelineMarker]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[TimelineMarker]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[TimelineMarker], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[TimelineMarker]]: ...
    def index_of(self, value: typing.Optional[TimelineMarker], /) -> typing.Tuple[bool, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[TimelineMarker], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[TimelineMarker], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[TimelineMarker], /) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

class TimelineMarkerRoutedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TimelineMarkerRoutedEventArgs: ...
    def __new__(cls: typing.Type[TimelineMarkerRoutedEventArgs]) -> TimelineMarkerRoutedEventArgs:...
    @_property
    def marker(self) -> typing.Optional[TimelineMarker]: ...
    @marker.setter
    def marker(self, value: typing.Optional[TimelineMarker]) -> None: ...

class Transform(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Transform: ...

class TransformCollection(winrt.system.Object, typing.MutableSequence[Transform]):
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> Transform: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[Transform]: ...
    def insert(self, index: int, value: Transform) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: Transform) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[Transform]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TransformCollection: ...
    def __new__(cls: typing.Type[TransformCollection]) -> TransformCollection:...
    def append(self, value: typing.Optional[Transform], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[Transform]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[Transform]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[Transform], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[Transform]]: ...
    def index_of(self, value: typing.Optional[Transform], /) -> typing.Tuple[bool, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[Transform], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[Transform], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[Transform], /) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

class TransformGroup(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TransformGroup: ...
    def __new__(cls: typing.Type[TransformGroup]) -> TransformGroup:...
    @_property
    def children(self) -> typing.Optional[TransformCollection]: ...
    @children.setter
    def children(self, value: typing.Optional[TransformCollection]) -> None: ...
    @_property
    def value(self) -> Matrix: ...
    children_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class TranslateTransform(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TranslateTransform: ...
    def __new__(cls: typing.Type[TranslateTransform]) -> TranslateTransform:...
    @_property
    def y(self) -> winrt.system.Double: ...
    @y.setter
    def y(self, value: winrt.system.Double) -> None: ...
    @_property
    def x(self) -> winrt.system.Double: ...
    @x.setter
    def x(self, value: winrt.system.Double) -> None: ...
    x_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    y_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class VisualTreeHelper(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VisualTreeHelper: ...
    @staticmethod
    def disconnect_children_recursive(element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> None: ...
    @typing.overload
    @staticmethod
    def find_elements_in_host_coordinates(intersecting_point: winrt.windows.foundation.Point, subtree: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> typing.Optional[winrt.windows.foundation.collections.IIterable[winrt.windows.ui.xaml.UIElement]]: ...
    @typing.overload
    @staticmethod
    def find_elements_in_host_coordinates(intersecting_point: winrt.windows.foundation.Point, subtree: typing.Optional[winrt.windows.ui.xaml.UIElement], include_all_elements: bool, /) -> typing.Optional[winrt.windows.foundation.collections.IIterable[winrt.windows.ui.xaml.UIElement]]: ...
    @staticmethod
    def get_child(reference: typing.Optional[winrt.windows.ui.xaml.DependencyObject], child_index: winrt.system.Int32, /) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    @staticmethod
    def get_children_count(reference: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> winrt.system.Int32: ...
    @staticmethod
    def get_open_popups(window: typing.Optional[winrt.windows.ui.xaml.Window], /) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.ui.xaml.controls.primitives.Popup]]: ...
    @staticmethod
    def get_open_popups_for_xaml_root(xaml_root: typing.Optional[winrt.windows.ui.xaml.XamlRoot], /) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.ui.xaml.controls.primitives.Popup]]: ...
    @staticmethod
    def get_parent(reference: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...

class XamlCompositionBrushBase(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> XamlCompositionBrushBase: ...
    def on_connected(self) -> None: ...
    def on_disconnected(self) -> None: ...
    @_property
    def fallback_color(self) -> winrt.windows.ui.Color: ...
    @fallback_color.setter
    def fallback_color(self, value: winrt.windows.ui.Color) -> None: ...
    @_property
    def composition_brush(self) -> typing.Optional[winrt.windows.ui.composition.CompositionBrush]: ...
    @composition_brush.setter
    def composition_brush(self, value: typing.Optional[winrt.windows.ui.composition.CompositionBrush]) -> None: ...
    fallback_color_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class XamlLight(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> XamlLight: ...
    def __new__(cls: typing.Type[XamlLight]) -> XamlLight:...
    @staticmethod
    def add_target_brush(light_id: str, brush: typing.Optional[Brush], /) -> None: ...
    @staticmethod
    def add_target_element(light_id: str, element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> None: ...
    def get_id(self) -> str: ...
    def on_connected(self, new_element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> None: ...
    def on_disconnected(self, old_element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> None: ...
    @staticmethod
    def remove_target_brush(light_id: str, brush: typing.Optional[Brush], /) -> None: ...
    @staticmethod
    def remove_target_element(light_id: str, element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> None: ...
    @_property
    def composition_light(self) -> typing.Optional[winrt.windows.ui.composition.CompositionLight]: ...
    @composition_light.setter
    def composition_light(self, value: typing.Optional[winrt.windows.ui.composition.CompositionLight]) -> None: ...

