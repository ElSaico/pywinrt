# WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

import enum
import datetime
import sys
import types
import typing

import winrt.system
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.media.playback
import winrt.windows.storage.streams
import winrt.windows.ui
import winrt.windows.ui.composition
import winrt.windows.ui.xaml
import winrt.windows.ui.xaml.controls.primitives
import winrt.windows.ui.xaml.media.media3d

class AcrylicBackgroundSource(enum.IntEnum):
    HOST_BACKDROP = 0
    BACKDROP = 1

class AlignmentX(enum.IntEnum):
    LEFT = 0
    CENTER = 1
    RIGHT = 2

class AlignmentY(enum.IntEnum):
    TOP = 0
    CENTER = 1
    BOTTOM = 2

class AudioCategory(enum.IntEnum):
    OTHER = 0
    FOREGROUND_ONLY_MEDIA = 1
    BACKGROUND_CAPABLE_MEDIA = 2
    COMMUNICATIONS = 3
    ALERTS = 4
    SOUND_EFFECTS = 5
    GAME_EFFECTS = 6
    GAME_MEDIA = 7
    GAME_CHAT = 8
    SPEECH = 9
    MOVIE = 10
    MEDIA = 11

class AudioDeviceType(enum.IntEnum):
    CONSOLE = 0
    MULTIMEDIA = 1
    COMMUNICATIONS = 2

class BrushMappingMode(enum.IntEnum):
    ABSOLUTE = 0
    RELATIVE_TO_BOUNDING_BOX = 1

class ColorInterpolationMode(enum.IntEnum):
    SC_RGB_LINEAR_INTERPOLATION = 0
    S_RGB_LINEAR_INTERPOLATION = 1

class ElementCompositeMode(enum.IntEnum):
    INHERIT = 0
    SOURCE_OVER = 1
    MIN_BLEND = 2

class FastPlayFallbackBehaviour(enum.IntEnum):
    SKIP = 0
    HIDE = 1
    DISABLE = 2

class FillRule(enum.IntEnum):
    EVEN_ODD = 0
    NONZERO = 1

class GradientSpreadMethod(enum.IntEnum):
    PAD = 0
    REFLECT = 1
    REPEAT = 2

class LoadedImageSourceLoadStatus(enum.IntEnum):
    SUCCESS = 0
    NETWORK_ERROR = 1
    INVALID_FORMAT = 2
    OTHER = 3

class MediaCanPlayResponse(enum.IntEnum):
    NOT_SUPPORTED = 0
    MAYBE = 1
    PROBABLY = 2

class MediaElementState(enum.IntEnum):
    CLOSED = 0
    OPENING = 1
    BUFFERING = 2
    PLAYING = 3
    PAUSED = 4
    STOPPED = 5

class PenLineCap(enum.IntEnum):
    FLAT = 0
    SQUARE = 1
    ROUND = 2
    TRIANGLE = 3

class PenLineJoin(enum.IntEnum):
    MITER = 0
    BEVEL = 1
    ROUND = 2

class RevealBrushState(enum.IntEnum):
    NORMAL = 0
    POINTER_OVER = 1
    PRESSED = 2

class Stereo3DVideoPackingMode(enum.IntEnum):
    NONE = 0
    SIDE_BY_SIDE = 1
    TOP_BOTTOM = 2

class Stereo3DVideoRenderMode(enum.IntEnum):
    MONO = 0
    STEREO = 1

class Stretch(enum.IntEnum):
    NONE = 0
    FILL = 1
    UNIFORM = 2
    UNIFORM_TO_FILL = 3

class StyleSimulations(enum.IntEnum):
    NONE = 0
    BOLD_SIMULATION = 1
    ITALIC_SIMULATION = 2
    BOLD_ITALIC_SIMULATION = 3

class SweepDirection(enum.IntEnum):
    COUNTERCLOCKWISE = 0
    CLOCKWISE = 1

Self = typing.TypeVar('Self')

class Matrix:
    m11: winrt.system.Double
    m12: winrt.system.Double
    m21: winrt.system.Double
    m22: winrt.system.Double
    offset_x: winrt.system.Double
    offset_y: winrt.system.Double
    def __new__(cls: typing.Type[Matrix], m11: winrt.system.Double, m12: winrt.system.Double, m21: winrt.system.Double, m22: winrt.system.Double, offset_x: winrt.system.Double, offset_y: winrt.system.Double) -> Matrix: ...

class AcrylicBrush(winrt.system.Object):
    tint_transition_duration: datetime.timedelta
    tint_opacity: winrt.system.Double
    tint_color: winrt.windows.ui.Color
    background_source: AcrylicBackgroundSource
    always_use_fallback: winrt.system.Boolean
    tint_luminosity_opacity: typing.Optional[typing.Optional[winrt.system.Double]]
    always_use_fallback_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    background_source_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    tint_color_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    tint_opacity_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    tint_transition_duration_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    tint_luminosity_opacity_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AcrylicBrush: ...
    def __new__(cls: typing.Type[AcrylicBrush]) -> AcrylicBrush:...

class ArcSegment(winrt.system.Object):
    sweep_direction: SweepDirection
    size: winrt.windows.foundation.Size
    rotation_angle: winrt.system.Double
    point: winrt.windows.foundation.Point
    is_large_arc: winrt.system.Boolean
    is_large_arc_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    point_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    rotation_angle_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    size_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    sweep_direction_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ArcSegment: ...
    def __new__(cls: typing.Type[ArcSegment]) -> ArcSegment:...

class BezierSegment(winrt.system.Object):
    point3: winrt.windows.foundation.Point
    point2: winrt.windows.foundation.Point
    point1: winrt.windows.foundation.Point
    point1_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    point2_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    point3_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BezierSegment: ...
    def __new__(cls: typing.Type[BezierSegment]) -> BezierSegment:...

class BitmapCache(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BitmapCache: ...
    def __new__(cls: typing.Type[BitmapCache]) -> BitmapCache:...

class Brush(winrt.system.Object):
    transform: typing.Optional[Transform]
    relative_transform: typing.Optional[Transform]
    opacity: winrt.system.Double
    opacity_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    relative_transform_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    transform_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Brush: ...
    def populate_property_info(self, property_name: str, property_info: typing.Optional[winrt.windows.ui.composition.AnimationPropertyInfo], /) -> None: ...
    def populate_property_info_override(self, property_name: str, animation_property_info: typing.Optional[winrt.windows.ui.composition.AnimationPropertyInfo], /) -> None: ...

class BrushCollection(winrt.system.Object, typing.MutableSequence[Brush]):
    size: winrt.system.UInt32
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> Brush: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[Brush]: ...
    def insert(self, index: int, value: Brush) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: Brush) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[Brush]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BrushCollection: ...
    def __new__(cls: typing.Type[BrushCollection]) -> BrushCollection:...
    def append(self, value: typing.Optional[Brush], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[Brush]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[Brush]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[Brush], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[Brush]]: ...
    def index_of(self, value: typing.Optional[Brush], /) -> typing.Tuple[winrt.system.Boolean, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[Brush], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[Brush], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[Brush], /) -> None: ...

class CacheMode(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CacheMode: ...

class CompositeTransform(winrt.system.Object):
    translate_y: winrt.system.Double
    translate_x: winrt.system.Double
    skew_y: winrt.system.Double
    skew_x: winrt.system.Double
    scale_y: winrt.system.Double
    scale_x: winrt.system.Double
    rotation: winrt.system.Double
    center_y: winrt.system.Double
    center_x: winrt.system.Double
    center_x_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    center_y_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    rotation_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    scale_x_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    scale_y_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    skew_x_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    skew_y_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    translate_x_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    translate_y_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositeTransform: ...
    def __new__(cls: typing.Type[CompositeTransform]) -> CompositeTransform:...

class CompositionTarget(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionTarget: ...
    @staticmethod
    def add_rendered(handler: winrt.windows.foundation.EventHandler[RenderedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    @staticmethod
    def remove_rendered(token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @staticmethod
    def add_rendering(handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    @staticmethod
    def remove_rendering(token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @staticmethod
    def add_surface_contents_lost(handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    @staticmethod
    def remove_surface_contents_lost(token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class DoubleCollection(winrt.system.Object, typing.MutableSequence[winrt.system.Double]):
    size: winrt.system.UInt32
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> winrt.system.Double: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[winrt.system.Double]: ...
    def insert(self, index: int, value: winrt.system.Double) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: winrt.system.Double) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[winrt.system.Double]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DoubleCollection: ...
    def __new__(cls: typing.Type[DoubleCollection]) -> DoubleCollection:...
    def append(self, value: winrt.system.Double, /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[winrt.system.Double]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> winrt.system.Double: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[winrt.system.Double], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Double]]: ...
    def index_of(self, value: winrt.system.Double, /) -> typing.Tuple[winrt.system.Boolean, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: winrt.system.Double, /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[winrt.system.Double], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: winrt.system.Double, /) -> None: ...

class EllipseGeometry(winrt.system.Object):
    radius_y: winrt.system.Double
    radius_x: winrt.system.Double
    center: winrt.windows.foundation.Point
    center_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    radius_x_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    radius_y_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EllipseGeometry: ...
    def __new__(cls: typing.Type[EllipseGeometry]) -> EllipseGeometry:...

class FontFamily(winrt.system.Object):
    source: str
    xaml_auto_font_family: typing.ClassVar[typing.Optional[FontFamily]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FontFamily: ...
    def __new__(cls: typing.Type[FontFamily], family_name: str) -> FontFamily:...

class GeneralTransform(winrt.system.Object):
    inverse: typing.Optional[GeneralTransform]
    inverse_core: typing.Optional[GeneralTransform]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GeneralTransform: ...
    def transform_bounds(self, rect: winrt.windows.foundation.Rect, /) -> winrt.windows.foundation.Rect: ...
    def transform_bounds_core(self, rect: winrt.windows.foundation.Rect, /) -> winrt.windows.foundation.Rect: ...
    def transform_point(self, point: winrt.windows.foundation.Point, /) -> winrt.windows.foundation.Point: ...
    def try_transform(self, in_point: winrt.windows.foundation.Point, /) -> typing.Tuple[winrt.system.Boolean, winrt.windows.foundation.Point]: ...
    def try_transform_core(self, in_point: winrt.windows.foundation.Point, /) -> typing.Tuple[winrt.system.Boolean, winrt.windows.foundation.Point]: ...

class Geometry(winrt.system.Object):
    transform: typing.Optional[Transform]
    bounds: winrt.windows.foundation.Rect
    empty: typing.ClassVar[typing.Optional[Geometry]]
    standard_flattening_tolerance: typing.ClassVar[winrt.system.Double]
    transform_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Geometry: ...

class GeometryCollection(winrt.system.Object, typing.MutableSequence[Geometry]):
    size: winrt.system.UInt32
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> Geometry: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[Geometry]: ...
    def insert(self, index: int, value: Geometry) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: Geometry) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[Geometry]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GeometryCollection: ...
    def __new__(cls: typing.Type[GeometryCollection]) -> GeometryCollection:...
    def append(self, value: typing.Optional[Geometry], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[Geometry]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[Geometry]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[Geometry], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[Geometry]]: ...
    def index_of(self, value: typing.Optional[Geometry], /) -> typing.Tuple[winrt.system.Boolean, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[Geometry], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[Geometry], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[Geometry], /) -> None: ...

class GeometryGroup(winrt.system.Object):
    fill_rule: FillRule
    children: typing.Optional[GeometryCollection]
    children_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    fill_rule_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GeometryGroup: ...
    def __new__(cls: typing.Type[GeometryGroup]) -> GeometryGroup:...

class GradientBrush(winrt.system.Object):
    spread_method: GradientSpreadMethod
    mapping_mode: BrushMappingMode
    gradient_stops: typing.Optional[GradientStopCollection]
    color_interpolation_mode: ColorInterpolationMode
    color_interpolation_mode_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    gradient_stops_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    mapping_mode_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    spread_method_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GradientBrush: ...

class GradientStop(winrt.system.Object):
    offset: winrt.system.Double
    color: winrt.windows.ui.Color
    color_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    offset_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GradientStop: ...
    def __new__(cls: typing.Type[GradientStop]) -> GradientStop:...

class GradientStopCollection(winrt.system.Object, typing.MutableSequence[GradientStop]):
    size: winrt.system.UInt32
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> GradientStop: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[GradientStop]: ...
    def insert(self, index: int, value: GradientStop) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: GradientStop) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[GradientStop]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GradientStopCollection: ...
    def __new__(cls: typing.Type[GradientStopCollection]) -> GradientStopCollection:...
    def append(self, value: typing.Optional[GradientStop], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[GradientStop]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[GradientStop]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[GradientStop], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[GradientStop]]: ...
    def index_of(self, value: typing.Optional[GradientStop], /) -> typing.Tuple[winrt.system.Boolean, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[GradientStop], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[GradientStop], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[GradientStop], /) -> None: ...

class ImageBrush(winrt.system.Object):
    image_source: typing.Optional[ImageSource]
    image_source_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ImageBrush: ...
    def __new__(cls: typing.Type[ImageBrush]) -> ImageBrush:...
    def add_image_failed(self, handler: typing.Optional[winrt.windows.ui.xaml.ExceptionRoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_image_failed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_image_opened(self, handler: typing.Optional[winrt.windows.ui.xaml.RoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_image_opened(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class ImageSource(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ImageSource: ...

class LineGeometry(winrt.system.Object):
    start_point: winrt.windows.foundation.Point
    end_point: winrt.windows.foundation.Point
    end_point_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    start_point_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LineGeometry: ...
    def __new__(cls: typing.Type[LineGeometry]) -> LineGeometry:...

class LineSegment(winrt.system.Object):
    point: winrt.windows.foundation.Point
    point_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LineSegment: ...
    def __new__(cls: typing.Type[LineSegment]) -> LineSegment:...

class LinearGradientBrush(winrt.system.Object):
    start_point: winrt.windows.foundation.Point
    end_point: winrt.windows.foundation.Point
    end_point_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    start_point_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LinearGradientBrush: ...
    @typing.overload
    def __new__(cls: typing.Type[LinearGradientBrush], gradient_stop_collection: typing.Optional[GradientStopCollection], angle: winrt.system.Double) -> LinearGradientBrush:...
    @typing.overload
    def __new__(cls: typing.Type[LinearGradientBrush]) -> LinearGradientBrush:...

class LoadedImageSourceLoadCompletedEventArgs(winrt.system.Object):
    status: LoadedImageSourceLoadStatus
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LoadedImageSourceLoadCompletedEventArgs: ...

class LoadedImageSurface(winrt.system.Object):
    decoded_physical_size: winrt.windows.foundation.Size
    decoded_size: winrt.windows.foundation.Size
    natural_size: winrt.windows.foundation.Size
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LoadedImageSurface: ...
    def close(self) -> None: ...
    @typing.overload
    @staticmethod
    def start_load_from_stream(stream: typing.Optional[winrt.windows.storage.streams.IRandomAccessStream], /) -> typing.Optional[LoadedImageSurface]: ...
    @typing.overload
    @staticmethod
    def start_load_from_stream(stream: typing.Optional[winrt.windows.storage.streams.IRandomAccessStream], desired_max_size: winrt.windows.foundation.Size, /) -> typing.Optional[LoadedImageSurface]: ...
    @typing.overload
    @staticmethod
    def start_load_from_uri(uri: typing.Optional[winrt.windows.foundation.Uri], /) -> typing.Optional[LoadedImageSurface]: ...
    @typing.overload
    @staticmethod
    def start_load_from_uri(uri: typing.Optional[winrt.windows.foundation.Uri], desired_max_size: winrt.windows.foundation.Size, /) -> typing.Optional[LoadedImageSurface]: ...
    def add_load_completed(self, handler: winrt.windows.foundation.TypedEventHandler[LoadedImageSurface, LoadedImageSourceLoadCompletedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_load_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class Matrix3DProjection(winrt.system.Object):
    projection_matrix: winrt.windows.ui.xaml.media.media3d.Matrix3D
    projection_matrix_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Matrix3DProjection: ...
    def __new__(cls: typing.Type[Matrix3DProjection]) -> Matrix3DProjection:...

class MatrixHelper(winrt.system.Object):
    identity: typing.ClassVar[Matrix]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MatrixHelper: ...
    @staticmethod
    def from_elements(m11: winrt.system.Double, m12: winrt.system.Double, m21: winrt.system.Double, m22: winrt.system.Double, offset_x: winrt.system.Double, offset_y: winrt.system.Double, /) -> Matrix: ...
    @staticmethod
    def get_is_identity(target: Matrix, /) -> winrt.system.Boolean: ...
    @staticmethod
    def transform(target: Matrix, point: winrt.windows.foundation.Point, /) -> winrt.windows.foundation.Point: ...

class MatrixTransform(winrt.system.Object):
    matrix: Matrix
    matrix_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MatrixTransform: ...
    def __new__(cls: typing.Type[MatrixTransform]) -> MatrixTransform:...

class MediaTransportControlsThumbnailRequestedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaTransportControlsThumbnailRequestedEventArgs: ...
    def get_deferral(self) -> typing.Optional[winrt.windows.foundation.Deferral]: ...
    def set_thumbnail_image(self, source: typing.Optional[winrt.windows.storage.streams.IInputStream], /) -> None: ...

class PartialMediaFailureDetectedEventArgs(winrt.system.Object):
    stream_kind: winrt.windows.media.playback.FailedMediaStreamKind
    extended_error: winrt.windows.foundation.HResult
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PartialMediaFailureDetectedEventArgs: ...
    def __new__(cls: typing.Type[PartialMediaFailureDetectedEventArgs]) -> PartialMediaFailureDetectedEventArgs:...

class PathFigure(winrt.system.Object):
    start_point: winrt.windows.foundation.Point
    segments: typing.Optional[PathSegmentCollection]
    is_filled: winrt.system.Boolean
    is_closed: winrt.system.Boolean
    is_closed_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_filled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    segments_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    start_point_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PathFigure: ...
    def __new__(cls: typing.Type[PathFigure]) -> PathFigure:...

class PathFigureCollection(winrt.system.Object, typing.MutableSequence[PathFigure]):
    size: winrt.system.UInt32
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> PathFigure: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[PathFigure]: ...
    def insert(self, index: int, value: PathFigure) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: PathFigure) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[PathFigure]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PathFigureCollection: ...
    def __new__(cls: typing.Type[PathFigureCollection]) -> PathFigureCollection:...
    def append(self, value: typing.Optional[PathFigure], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[PathFigure]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[PathFigure]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[PathFigure], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[PathFigure]]: ...
    def index_of(self, value: typing.Optional[PathFigure], /) -> typing.Tuple[winrt.system.Boolean, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[PathFigure], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[PathFigure], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[PathFigure], /) -> None: ...

class PathGeometry(winrt.system.Object):
    fill_rule: FillRule
    figures: typing.Optional[PathFigureCollection]
    figures_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    fill_rule_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PathGeometry: ...
    def __new__(cls: typing.Type[PathGeometry]) -> PathGeometry:...

class PathSegment(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PathSegment: ...

class PathSegmentCollection(winrt.system.Object, typing.MutableSequence[PathSegment]):
    size: winrt.system.UInt32
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> PathSegment: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[PathSegment]: ...
    def insert(self, index: int, value: PathSegment) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: PathSegment) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[PathSegment]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PathSegmentCollection: ...
    def __new__(cls: typing.Type[PathSegmentCollection]) -> PathSegmentCollection:...
    def append(self, value: typing.Optional[PathSegment], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[PathSegment]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[PathSegment]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[PathSegment], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[PathSegment]]: ...
    def index_of(self, value: typing.Optional[PathSegment], /) -> typing.Tuple[winrt.system.Boolean, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[PathSegment], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[PathSegment], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[PathSegment], /) -> None: ...

class PlaneProjection(winrt.system.Object):
    rotation_z: winrt.system.Double
    rotation_y: winrt.system.Double
    rotation_x: winrt.system.Double
    local_offset_z: winrt.system.Double
    local_offset_y: winrt.system.Double
    local_offset_x: winrt.system.Double
    global_offset_z: winrt.system.Double
    global_offset_y: winrt.system.Double
    global_offset_x: winrt.system.Double
    center_of_rotation_z: winrt.system.Double
    center_of_rotation_y: winrt.system.Double
    center_of_rotation_x: winrt.system.Double
    projection_matrix: winrt.windows.ui.xaml.media.media3d.Matrix3D
    center_of_rotation_x_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    center_of_rotation_y_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    center_of_rotation_z_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    global_offset_x_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    global_offset_y_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    global_offset_z_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    local_offset_x_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    local_offset_y_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    local_offset_z_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    projection_matrix_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    rotation_x_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    rotation_y_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    rotation_z_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PlaneProjection: ...
    def __new__(cls: typing.Type[PlaneProjection]) -> PlaneProjection:...

class PointCollection(winrt.system.Object, typing.MutableSequence[winrt.windows.foundation.Point]):
    size: winrt.system.UInt32
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> winrt.windows.foundation.Point: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[winrt.windows.foundation.Point]: ...
    def insert(self, index: int, value: winrt.windows.foundation.Point) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: winrt.windows.foundation.Point) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[winrt.windows.foundation.Point]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PointCollection: ...
    def __new__(cls: typing.Type[PointCollection]) -> PointCollection:...
    def append(self, value: winrt.windows.foundation.Point, /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[winrt.windows.foundation.Point]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> winrt.windows.foundation.Point: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[winrt.windows.foundation.Point], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.foundation.Point]]: ...
    def index_of(self, value: winrt.windows.foundation.Point, /) -> typing.Tuple[winrt.system.Boolean, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: winrt.windows.foundation.Point, /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[winrt.windows.foundation.Point], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: winrt.windows.foundation.Point, /) -> None: ...

class PolyBezierSegment(winrt.system.Object):
    points: typing.Optional[PointCollection]
    points_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PolyBezierSegment: ...
    def __new__(cls: typing.Type[PolyBezierSegment]) -> PolyBezierSegment:...

class PolyLineSegment(winrt.system.Object):
    points: typing.Optional[PointCollection]
    points_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PolyLineSegment: ...
    def __new__(cls: typing.Type[PolyLineSegment]) -> PolyLineSegment:...

class PolyQuadraticBezierSegment(winrt.system.Object):
    points: typing.Optional[PointCollection]
    points_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PolyQuadraticBezierSegment: ...
    def __new__(cls: typing.Type[PolyQuadraticBezierSegment]) -> PolyQuadraticBezierSegment:...

class Projection(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Projection: ...

class QuadraticBezierSegment(winrt.system.Object):
    point2: winrt.windows.foundation.Point
    point1: winrt.windows.foundation.Point
    point1_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    point2_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> QuadraticBezierSegment: ...
    def __new__(cls: typing.Type[QuadraticBezierSegment]) -> QuadraticBezierSegment:...

class RateChangedRoutedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RateChangedRoutedEventArgs: ...
    def __new__(cls: typing.Type[RateChangedRoutedEventArgs]) -> RateChangedRoutedEventArgs:...

class RectangleGeometry(winrt.system.Object):
    rect: winrt.windows.foundation.Rect
    rect_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RectangleGeometry: ...
    def __new__(cls: typing.Type[RectangleGeometry]) -> RectangleGeometry:...

class RenderedEventArgs(winrt.system.Object):
    frame_duration: datetime.timedelta
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RenderedEventArgs: ...

class RenderingEventArgs(winrt.system.Object):
    rendering_time: datetime.timedelta
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RenderingEventArgs: ...

class RevealBackgroundBrush(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RevealBackgroundBrush: ...
    def __new__(cls: typing.Type[RevealBackgroundBrush]) -> RevealBackgroundBrush:...

class RevealBorderBrush(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RevealBorderBrush: ...
    def __new__(cls: typing.Type[RevealBorderBrush]) -> RevealBorderBrush:...

class RevealBrush(winrt.system.Object):
    target_theme: winrt.windows.ui.xaml.ApplicationTheme
    color: winrt.windows.ui.Color
    always_use_fallback: winrt.system.Boolean
    always_use_fallback_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    color_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    state_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    target_theme_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RevealBrush: ...
    @staticmethod
    def get_state(element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> RevealBrushState: ...
    @staticmethod
    def set_state(element: typing.Optional[winrt.windows.ui.xaml.UIElement], value: RevealBrushState, /) -> None: ...

class RotateTransform(winrt.system.Object):
    center_y: winrt.system.Double
    center_x: winrt.system.Double
    angle: winrt.system.Double
    angle_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    center_x_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    center_y_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RotateTransform: ...
    def __new__(cls: typing.Type[RotateTransform]) -> RotateTransform:...

class ScaleTransform(winrt.system.Object):
    scale_y: winrt.system.Double
    scale_x: winrt.system.Double
    center_y: winrt.system.Double
    center_x: winrt.system.Double
    center_x_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    center_y_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    scale_x_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    scale_y_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ScaleTransform: ...
    def __new__(cls: typing.Type[ScaleTransform]) -> ScaleTransform:...

class Shadow(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Shadow: ...

class SkewTransform(winrt.system.Object):
    center_y: winrt.system.Double
    center_x: winrt.system.Double
    angle_y: winrt.system.Double
    angle_x: winrt.system.Double
    angle_x_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    angle_y_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    center_x_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    center_y_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SkewTransform: ...
    def __new__(cls: typing.Type[SkewTransform]) -> SkewTransform:...

class SolidColorBrush(winrt.system.Object):
    color: winrt.windows.ui.Color
    color_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SolidColorBrush: ...
    @typing.overload
    def __new__(cls: typing.Type[SolidColorBrush], color: winrt.windows.ui.Color) -> SolidColorBrush:...
    @typing.overload
    def __new__(cls: typing.Type[SolidColorBrush]) -> SolidColorBrush:...

class ThemeShadow(winrt.system.Object):
    receivers: typing.Optional[winrt.windows.ui.xaml.UIElementWeakCollection]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ThemeShadow: ...
    def __new__(cls: typing.Type[ThemeShadow]) -> ThemeShadow:...

class TileBrush(winrt.system.Object):
    stretch: Stretch
    alignment_y: AlignmentY
    alignment_x: AlignmentX
    alignment_x_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    alignment_y_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    stretch_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TileBrush: ...

class TimelineMarker(winrt.system.Object):
    type: str
    time: datetime.timedelta
    text: str
    text_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    time_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    type_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TimelineMarker: ...
    def __new__(cls: typing.Type[TimelineMarker]) -> TimelineMarker:...

class TimelineMarkerCollection(winrt.system.Object, typing.MutableSequence[TimelineMarker]):
    size: winrt.system.UInt32
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> TimelineMarker: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[TimelineMarker]: ...
    def insert(self, index: int, value: TimelineMarker) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: TimelineMarker) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[TimelineMarker]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TimelineMarkerCollection: ...
    def __new__(cls: typing.Type[TimelineMarkerCollection]) -> TimelineMarkerCollection:...
    def append(self, value: typing.Optional[TimelineMarker], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[TimelineMarker]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[TimelineMarker]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[TimelineMarker], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[TimelineMarker]]: ...
    def index_of(self, value: typing.Optional[TimelineMarker], /) -> typing.Tuple[winrt.system.Boolean, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[TimelineMarker], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[TimelineMarker], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[TimelineMarker], /) -> None: ...

class TimelineMarkerRoutedEventArgs(winrt.system.Object):
    marker: typing.Optional[TimelineMarker]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TimelineMarkerRoutedEventArgs: ...
    def __new__(cls: typing.Type[TimelineMarkerRoutedEventArgs]) -> TimelineMarkerRoutedEventArgs:...

class Transform(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Transform: ...

class TransformCollection(winrt.system.Object, typing.MutableSequence[Transform]):
    size: winrt.system.UInt32
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> Transform: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[Transform]: ...
    def insert(self, index: int, value: Transform) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: Transform) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[Transform]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TransformCollection: ...
    def __new__(cls: typing.Type[TransformCollection]) -> TransformCollection:...
    def append(self, value: typing.Optional[Transform], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[Transform]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[Transform]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[Transform], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[Transform]]: ...
    def index_of(self, value: typing.Optional[Transform], /) -> typing.Tuple[winrt.system.Boolean, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[Transform], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[Transform], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[Transform], /) -> None: ...

class TransformGroup(winrt.system.Object):
    children: typing.Optional[TransformCollection]
    value: Matrix
    children_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TransformGroup: ...
    def __new__(cls: typing.Type[TransformGroup]) -> TransformGroup:...

class TranslateTransform(winrt.system.Object):
    y: winrt.system.Double
    x: winrt.system.Double
    x_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    y_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TranslateTransform: ...
    def __new__(cls: typing.Type[TranslateTransform]) -> TranslateTransform:...

class VisualTreeHelper(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VisualTreeHelper: ...
    @staticmethod
    def disconnect_children_recursive(element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> None: ...
    @typing.overload
    @staticmethod
    def find_elements_in_host_coordinates(intersecting_point: winrt.windows.foundation.Point, subtree: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> typing.Optional[winrt.windows.foundation.collections.IIterable[winrt.windows.ui.xaml.UIElement]]: ...
    @typing.overload
    @staticmethod
    def find_elements_in_host_coordinates(intersecting_point: winrt.windows.foundation.Point, subtree: typing.Optional[winrt.windows.ui.xaml.UIElement], include_all_elements: winrt.system.Boolean, /) -> typing.Optional[winrt.windows.foundation.collections.IIterable[winrt.windows.ui.xaml.UIElement]]: ...
    @staticmethod
    def get_child(reference: typing.Optional[winrt.windows.ui.xaml.DependencyObject], child_index: winrt.system.Int32, /) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    @staticmethod
    def get_children_count(reference: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> winrt.system.Int32: ...
    @staticmethod
    def get_open_popups(window: typing.Optional[winrt.windows.ui.xaml.Window], /) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.ui.xaml.controls.primitives.Popup]]: ...
    @staticmethod
    def get_open_popups_for_xaml_root(xaml_root: typing.Optional[winrt.windows.ui.xaml.XamlRoot], /) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.ui.xaml.controls.primitives.Popup]]: ...
    @staticmethod
    def get_parent(reference: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...

class XamlCompositionBrushBase(winrt.system.Object):
    fallback_color: winrt.windows.ui.Color
    composition_brush: typing.Optional[winrt.windows.ui.composition.CompositionBrush]
    fallback_color_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> XamlCompositionBrushBase: ...
    def on_connected(self) -> None: ...
    def on_disconnected(self) -> None: ...

class XamlLight(winrt.system.Object):
    composition_light: typing.Optional[winrt.windows.ui.composition.CompositionLight]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> XamlLight: ...
    def __new__(cls: typing.Type[XamlLight]) -> XamlLight:...
    @staticmethod
    def add_target_brush(light_id: str, brush: typing.Optional[Brush], /) -> None: ...
    @staticmethod
    def add_target_element(light_id: str, element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> None: ...
    def get_id(self) -> str: ...
    def on_connected(self, new_element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> None: ...
    def on_disconnected(self, old_element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> None: ...
    @staticmethod
    def remove_target_brush(light_id: str, brush: typing.Optional[Brush], /) -> None: ...
    @staticmethod
    def remove_target_element(light_id: str, element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> None: ...

RateChangedRoutedEventHandler = typing.Callable[[typing.Optional[winrt.system.Object], typing.Optional[RateChangedRoutedEventArgs]], None]

TimelineMarkerRoutedEventHandler = typing.Callable[[typing.Optional[winrt.system.Object], typing.Optional[TimelineMarkerRoutedEventArgs]], None]

