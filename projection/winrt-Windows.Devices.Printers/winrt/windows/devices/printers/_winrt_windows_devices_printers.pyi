# WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

import datetime
import sys
import types
import typing
import uuid

import winrt.system
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.graphics.printing
import winrt.windows.storage.streams

from . import IppAttributeErrorReason, IppAttributeValueKind, IppResolutionUnit, PageConfigurationSource

Self = typing.TypeVar('Self')

class IppAttributeError(winrt.system.Object):
    extended_error: winrt.windows.foundation.HResult
    reason: IppAttributeErrorReason
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IppAttributeError: ...
    def get_unsupported_values(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[IppAttributeValue]]: ...

class IppAttributeValue(winrt.system.Object):
    kind: IppAttributeValueKind
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IppAttributeValue: ...
    @staticmethod
    def create_boolean(value: winrt.system.Boolean, /) -> typing.Optional[IppAttributeValue]: ...
    @staticmethod
    def create_boolean_array(values: typing.Iterable[winrt.system.Boolean], /) -> typing.Optional[IppAttributeValue]: ...
    @staticmethod
    def create_charset(value: str, /) -> typing.Optional[IppAttributeValue]: ...
    @staticmethod
    def create_charset_array(values: typing.Iterable[str], /) -> typing.Optional[IppAttributeValue]: ...
    @staticmethod
    def create_collection(member_attributes: typing.Iterable[winrt.windows.foundation.collections.IKeyValuePair[str, IppAttributeValue]], /) -> typing.Optional[IppAttributeValue]: ...
    @staticmethod
    def create_collection_array(member_attributes_array: typing.Iterable[winrt.windows.foundation.collections.IIterable[winrt.windows.foundation.collections.IKeyValuePair[str, IppAttributeValue]]], /) -> typing.Optional[IppAttributeValue]: ...
    @staticmethod
    def create_date_time(value: datetime.datetime, /) -> typing.Optional[IppAttributeValue]: ...
    @staticmethod
    def create_date_time_array(values: typing.Iterable[datetime.datetime], /) -> typing.Optional[IppAttributeValue]: ...
    @staticmethod
    def create_enum(value: winrt.system.Int32, /) -> typing.Optional[IppAttributeValue]: ...
    @staticmethod
    def create_enum_array(values: typing.Iterable[winrt.system.Int32], /) -> typing.Optional[IppAttributeValue]: ...
    @staticmethod
    def create_integer(value: winrt.system.Int32, /) -> typing.Optional[IppAttributeValue]: ...
    @staticmethod
    def create_integer_array(values: typing.Iterable[winrt.system.Int32], /) -> typing.Optional[IppAttributeValue]: ...
    @staticmethod
    def create_keyword(value: str, /) -> typing.Optional[IppAttributeValue]: ...
    @staticmethod
    def create_keyword_array(values: typing.Iterable[str], /) -> typing.Optional[IppAttributeValue]: ...
    @staticmethod
    def create_mime_media(value: str, /) -> typing.Optional[IppAttributeValue]: ...
    @staticmethod
    def create_mime_media_array(values: typing.Iterable[str], /) -> typing.Optional[IppAttributeValue]: ...
    @staticmethod
    def create_name_with_language(value: typing.Optional[IppTextWithLanguage], /) -> typing.Optional[IppAttributeValue]: ...
    @staticmethod
    def create_name_with_language_array(values: typing.Iterable[IppTextWithLanguage], /) -> typing.Optional[IppAttributeValue]: ...
    @staticmethod
    def create_name_without_language(value: str, /) -> typing.Optional[IppAttributeValue]: ...
    @staticmethod
    def create_name_without_language_array(values: typing.Iterable[str], /) -> typing.Optional[IppAttributeValue]: ...
    @staticmethod
    def create_natural_language(value: str, /) -> typing.Optional[IppAttributeValue]: ...
    @staticmethod
    def create_natural_language_array(values: typing.Iterable[str], /) -> typing.Optional[IppAttributeValue]: ...
    @staticmethod
    def create_no_value() -> typing.Optional[IppAttributeValue]: ...
    @staticmethod
    def create_octet_string(value: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> typing.Optional[IppAttributeValue]: ...
    @staticmethod
    def create_octet_string_array(values: typing.Iterable[winrt.windows.storage.streams.IBuffer], /) -> typing.Optional[IppAttributeValue]: ...
    @staticmethod
    def create_range_of_integer(value: typing.Optional[IppIntegerRange], /) -> typing.Optional[IppAttributeValue]: ...
    @staticmethod
    def create_range_of_integer_array(values: typing.Iterable[IppIntegerRange], /) -> typing.Optional[IppAttributeValue]: ...
    @staticmethod
    def create_resolution(value: typing.Optional[IppResolution], /) -> typing.Optional[IppAttributeValue]: ...
    @staticmethod
    def create_resolution_array(values: typing.Iterable[IppResolution], /) -> typing.Optional[IppAttributeValue]: ...
    @staticmethod
    def create_text_with_language(value: typing.Optional[IppTextWithLanguage], /) -> typing.Optional[IppAttributeValue]: ...
    @staticmethod
    def create_text_with_language_array(values: typing.Iterable[IppTextWithLanguage], /) -> typing.Optional[IppAttributeValue]: ...
    @staticmethod
    def create_text_without_language(value: str, /) -> typing.Optional[IppAttributeValue]: ...
    @staticmethod
    def create_text_without_language_array(values: typing.Iterable[str], /) -> typing.Optional[IppAttributeValue]: ...
    @staticmethod
    def create_unknown() -> typing.Optional[IppAttributeValue]: ...
    @staticmethod
    def create_unsupported() -> typing.Optional[IppAttributeValue]: ...
    @staticmethod
    def create_uri(value: typing.Optional[winrt.windows.foundation.Uri], /) -> typing.Optional[IppAttributeValue]: ...
    @staticmethod
    def create_uri_array(values: typing.Iterable[winrt.windows.foundation.Uri], /) -> typing.Optional[IppAttributeValue]: ...
    @staticmethod
    def create_uri_schema(value: str, /) -> typing.Optional[IppAttributeValue]: ...
    @staticmethod
    def create_uri_schema_array(values: typing.Iterable[str], /) -> typing.Optional[IppAttributeValue]: ...
    def get_boolean_array(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.system.Boolean]]: ...
    def get_charset_array(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[str]]: ...
    def get_collection_array(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.foundation.collections.IMapView[str, IppAttributeValue]]]: ...
    def get_date_time_array(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[datetime.datetime]]: ...
    def get_enum_array(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.system.Int32]]: ...
    def get_integer_array(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.system.Int32]]: ...
    def get_keyword_array(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[str]]: ...
    def get_mime_media_type_array(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[str]]: ...
    def get_name_with_language_array(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[IppTextWithLanguage]]: ...
    def get_name_without_language_array(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[str]]: ...
    def get_natural_language_array(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[str]]: ...
    def get_octet_string_array(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.storage.streams.IBuffer]]: ...
    def get_range_of_integer_array(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[IppIntegerRange]]: ...
    def get_resolution_array(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[IppResolution]]: ...
    def get_text_with_language_array(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[IppTextWithLanguage]]: ...
    def get_text_without_language_array(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[str]]: ...
    def get_uri_array(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.foundation.Uri]]: ...
    def get_uri_schema_array(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[str]]: ...

class IppIntegerRange(winrt.system.Object):
    end: winrt.system.Int32
    start: winrt.system.Int32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IppIntegerRange: ...
    def __new__(cls: typing.Type[IppIntegerRange], start: winrt.system.Int32, end: winrt.system.Int32) -> IppIntegerRange:...

class IppPrintDevice(winrt.system.Object):
    printer_name: str
    printer_uri: typing.Optional[winrt.windows.foundation.Uri]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IppPrintDevice: ...
    @staticmethod
    def from_id(device_id: str, /) -> typing.Optional[IppPrintDevice]: ...
    @staticmethod
    def from_printer_name(printer_name: str, /) -> typing.Optional[IppPrintDevice]: ...
    @staticmethod
    def get_device_selector() -> str: ...
    def get_max_supported_pdf_size(self) -> winrt.system.UInt64: ...
    def get_max_supported_pdf_version(self) -> str: ...
    def get_pdl_passthrough_provider(self) -> typing.Optional[PdlPassthroughProvider]: ...
    def get_printer_attributes(self, attribute_names: typing.Iterable[str], /) -> typing.Optional[winrt.windows.foundation.collections.IMap[str, IppAttributeValue]]: ...
    def get_printer_attributes_as_buffer(self, attribute_names: typing.Iterable[str], /) -> typing.Optional[winrt.windows.storage.streams.IBuffer]: ...
    @staticmethod
    def is_ipp_printer(printer_name: str, /) -> winrt.system.Boolean: ...
    def is_pdl_passthrough_supported(self, pdl_content_type: str, /) -> winrt.system.Boolean: ...
    def set_printer_attributes(self, printer_attributes: typing.Iterable[winrt.windows.foundation.collections.IKeyValuePair[str, IppAttributeValue]], /) -> typing.Optional[IppSetAttributesResult]: ...
    def set_printer_attributes_from_buffer(self, printer_attributes_buffer: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> typing.Optional[IppSetAttributesResult]: ...

class IppResolution(winrt.system.Object):
    height: winrt.system.Int32
    unit: IppResolutionUnit
    width: winrt.system.Int32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IppResolution: ...
    def __new__(cls: typing.Type[IppResolution], width: winrt.system.Int32, height: winrt.system.Int32, unit: IppResolutionUnit) -> IppResolution:...

class IppSetAttributesResult(winrt.system.Object):
    attribute_errors: typing.Optional[winrt.windows.foundation.collections.IMapView[str, IppAttributeError]]
    succeeded: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IppSetAttributesResult: ...

class IppTextWithLanguage(winrt.system.Object):
    language: str
    value: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IppTextWithLanguage: ...
    def __new__(cls: typing.Type[IppTextWithLanguage], language: str, text: str) -> IppTextWithLanguage:...

class PageConfigurationSettings(winrt.system.Object):
    size_source: PageConfigurationSource
    orientation_source: PageConfigurationSource
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PageConfigurationSettings: ...
    def __new__(cls: typing.Type[PageConfigurationSettings]) -> PageConfigurationSettings:...

class PdlPassthroughProvider(winrt.system.Object):
    supported_pdl_content_types: typing.Optional[winrt.windows.foundation.collections.IVectorView[str]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PdlPassthroughProvider: ...
    def start_print_job_with_print_ticket(self, job_name: str, pdl_content_type: str, print_ticket: typing.Optional[winrt.windows.storage.streams.IInputStream], page_configuration_settings: typing.Optional[PageConfigurationSettings], /) -> typing.Optional[PdlPassthroughTarget]: ...
    def start_print_job_with_task_options(self, job_name: str, pdl_content_type: str, task_options: typing.Optional[winrt.windows.graphics.printing.PrintTaskOptions], page_configuration_settings: typing.Optional[PageConfigurationSettings], /) -> typing.Optional[PdlPassthroughTarget]: ...

class PdlPassthroughTarget(winrt.system.Object):
    print_job_id: winrt.system.Int32
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PdlPassthroughTarget: ...
    def close(self) -> None: ...
    def get_output_stream(self) -> typing.Optional[winrt.windows.storage.streams.IOutputStream]: ...
    def submit(self) -> None: ...

class Print3DDevice(winrt.system.Object):
    print_schema: typing.Optional[PrintSchema]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Print3DDevice: ...
    @staticmethod
    def from_id_async(device_id: str, /) -> winrt.windows.foundation.IAsyncOperation[Print3DDevice]: ...
    @staticmethod
    def get_device_selector() -> str: ...

class PrintSchema(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PrintSchema: ...
    def get_capabilities_async(self, constrain_ticket: typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamWithContentType], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.streams.IRandomAccessStreamWithContentType]: ...
    def get_default_print_ticket_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.streams.IRandomAccessStreamWithContentType]: ...
    def merge_and_validate_with_default_print_ticket_async(self, delta_ticket: typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamWithContentType], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.streams.IRandomAccessStreamWithContentType]: ...

