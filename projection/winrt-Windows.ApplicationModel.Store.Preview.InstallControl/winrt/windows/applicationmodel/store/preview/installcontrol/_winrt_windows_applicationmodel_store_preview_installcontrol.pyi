# WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

import enum
import datetime
import sys
import types
import typing

import winrt.system
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.management.deployment
import winrt.windows.system

class AppInstallState(enum.IntEnum):
    PENDING = 0
    STARTING = 1
    ACQUIRING_LICENSE = 2
    DOWNLOADING = 3
    RESTORING_DATA = 4
    INSTALLING = 5
    COMPLETED = 6
    CANCELED = 7
    PAUSED = 8
    ERROR = 9
    PAUSED_LOW_BATTERY = 10
    PAUSED_WI_FI_RECOMMENDED = 11
    PAUSED_WI_FI_REQUIRED = 12
    READY_TO_DOWNLOAD = 13

class AppInstallType(enum.IntEnum):
    INSTALL = 0
    UPDATE = 1
    REPAIR = 2

class AppInstallationToastNotificationMode(enum.IntEnum):
    DEFAULT = 0
    TOAST = 1
    TOAST_WITHOUT_POPUP = 2
    NO_TOAST = 3

class AutoUpdateSetting(enum.IntEnum):
    DISABLED = 0
    ENABLED = 1
    DISABLED_BY_POLICY = 2
    ENABLED_BY_POLICY = 3

class GetEntitlementStatus(enum.IntEnum):
    SUCCEEDED = 0
    NO_STORE_ACCOUNT = 1
    NETWORK_ERROR = 2
    SERVER_ERROR = 3

Self = typing.TypeVar('Self')

class AppInstallItem(winrt.system.Object):
    install_type: AppInstallType
    is_user_initiated: winrt.system.Boolean
    package_family_name: str
    product_id: str
    children: typing.Optional[winrt.windows.foundation.collections.IVectorView[AppInstallItem]]
    item_operations_might_affect_other_items: winrt.system.Boolean
    launch_after_install: winrt.system.Boolean
    pin_to_taskbar_after_install: winrt.system.Boolean
    pin_to_start_after_install: winrt.system.Boolean
    pin_to_desktop_after_install: winrt.system.Boolean
    install_in_progress_toast_notification_mode: AppInstallationToastNotificationMode
    completed_install_toast_notification_mode: AppInstallationToastNotificationMode
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppInstallItem: ...
    @typing.overload
    def cancel(self) -> None: ...
    @typing.overload
    def cancel(self, correlation_vector: str, /) -> None: ...
    def get_current_status(self) -> typing.Optional[AppInstallStatus]: ...
    @typing.overload
    def pause(self) -> None: ...
    @typing.overload
    def pause(self, correlation_vector: str, /) -> None: ...
    @typing.overload
    def restart(self) -> None: ...
    @typing.overload
    def restart(self, correlation_vector: str, /) -> None: ...
    def add_completed(self, handler: winrt.windows.foundation.TypedEventHandler[AppInstallItem, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_status_changed(self, handler: winrt.windows.foundation.TypedEventHandler[AppInstallItem, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_status_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class AppInstallManager(winrt.system.Object):
    auto_update_setting: AutoUpdateSetting
    acquisition_identity: str
    app_install_items: typing.Optional[winrt.windows.foundation.collections.IVectorView[AppInstallItem]]
    app_install_items_with_group_support: typing.Optional[winrt.windows.foundation.collections.IVectorView[AppInstallItem]]
    can_install_for_all_users: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppInstallManager: ...
    def __new__(cls: typing.Type[AppInstallManager]) -> AppInstallManager:...
    @typing.overload
    def cancel(self, product_id: str, /) -> None: ...
    @typing.overload
    def cancel(self, product_id: str, correlation_vector: str, /) -> None: ...
    def get_free_device_entitlement_async(self, store_id: str, campaign_id: str, correlation_vector: str, /) -> winrt.windows.foundation.IAsyncOperation[GetEntitlementResult]: ...
    def get_free_user_entitlement_async(self, store_id: str, campaign_id: str, correlation_vector: str, /) -> winrt.windows.foundation.IAsyncOperation[GetEntitlementResult]: ...
    def get_free_user_entitlement_for_user_async(self, user: typing.Optional[winrt.windows.system.User], store_id: str, campaign_id: str, correlation_vector: str, /) -> winrt.windows.foundation.IAsyncOperation[GetEntitlementResult]: ...
    @typing.overload
    def get_is_app_allowed_to_install_async(self, product_id: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...
    @typing.overload
    def get_is_app_allowed_to_install_async(self, product_id: str, sku_id: str, catalog_id: str, correlation_vector: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...
    def get_is_app_allowed_to_install_for_user_async(self, user: typing.Optional[winrt.windows.system.User], product_id: str, sku_id: str, catalog_id: str, correlation_vector: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...
    def get_is_applicable_async(self, product_id: str, sku_id: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...
    def get_is_applicable_for_user_async(self, user: typing.Optional[winrt.windows.system.User], product_id: str, sku_id: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...
    def get_is_package_identity_allowed_to_install_async(self, correlation_vector: str, package_identity_name: str, publisher_certificate_name: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...
    def get_is_package_identity_allowed_to_install_for_user_async(self, user: typing.Optional[winrt.windows.system.User], correlation_vector: str, package_identity_name: str, publisher_certificate_name: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...
    def is_store_blocked_by_policy_async(self, store_client_name: str, store_client_publisher: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...
    def move_to_front_of_download_queue(self, product_id: str, correlation_vector: str, /) -> None: ...
    @typing.overload
    def pause(self, product_id: str, /) -> None: ...
    @typing.overload
    def pause(self, product_id: str, correlation_vector: str, /) -> None: ...
    @typing.overload
    def restart(self, product_id: str, /) -> None: ...
    @typing.overload
    def restart(self, product_id: str, correlation_vector: str, /) -> None: ...
    @typing.overload
    def search_for_all_updates_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[AppInstallItem]]: ...
    @typing.overload
    def search_for_all_updates_async(self, correlation_vector: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[AppInstallItem]]: ...
    @typing.overload
    def search_for_all_updates_async(self, correlation_vector: str, client_id: str, update_options: typing.Optional[AppUpdateOptions], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[AppInstallItem]]: ...
    @typing.overload
    def search_for_all_updates_for_user_async(self, user: typing.Optional[winrt.windows.system.User], correlation_vector: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[AppInstallItem]]: ...
    @typing.overload
    def search_for_all_updates_for_user_async(self, user: typing.Optional[winrt.windows.system.User], correlation_vector: str, client_id: str, update_options: typing.Optional[AppUpdateOptions], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[AppInstallItem]]: ...
    @typing.overload
    def search_for_updates_async(self, product_id: str, sku_id: str, /) -> winrt.windows.foundation.IAsyncOperation[AppInstallItem]: ...
    @typing.overload
    def search_for_updates_async(self, product_id: str, sku_id: str, catalog_id: str, correlation_vector: str, /) -> winrt.windows.foundation.IAsyncOperation[AppInstallItem]: ...
    @typing.overload
    def search_for_updates_async(self, product_id: str, sku_id: str, correlation_vector: str, client_id: str, update_options: typing.Optional[AppUpdateOptions], /) -> winrt.windows.foundation.IAsyncOperation[AppInstallItem]: ...
    @typing.overload
    def search_for_updates_for_user_async(self, user: typing.Optional[winrt.windows.system.User], product_id: str, sku_id: str, catalog_id: str, correlation_vector: str, /) -> winrt.windows.foundation.IAsyncOperation[AppInstallItem]: ...
    @typing.overload
    def search_for_updates_for_user_async(self, user: typing.Optional[winrt.windows.system.User], product_id: str, sku_id: str, correlation_vector: str, client_id: str, update_options: typing.Optional[AppUpdateOptions], /) -> winrt.windows.foundation.IAsyncOperation[AppInstallItem]: ...
    @typing.overload
    def start_app_install_async(self, product_id: str, sku_id: str, repair: winrt.system.Boolean, force_use_of_non_removable_storage: winrt.system.Boolean, /) -> winrt.windows.foundation.IAsyncOperation[AppInstallItem]: ...
    @typing.overload
    def start_app_install_async(self, product_id: str, sku_id: str, repair: winrt.system.Boolean, force_use_of_non_removable_storage: winrt.system.Boolean, catalog_id: str, bundle_id: str, correlation_vector: str, /) -> winrt.windows.foundation.IAsyncOperation[AppInstallItem]: ...
    @typing.overload
    def start_product_install_async(self, product_id: str, flight_id: str, client_id: str, correlation_vector: str, install_options: typing.Optional[AppInstallOptions], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[AppInstallItem]]: ...
    @typing.overload
    def start_product_install_async(self, product_id: str, catalog_id: str, flight_id: str, client_id: str, repair: winrt.system.Boolean, force_use_of_non_removable_storage: winrt.system.Boolean, correlation_vector: str, target_volume: typing.Optional[winrt.windows.management.deployment.PackageVolume], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[AppInstallItem]]: ...
    @typing.overload
    def start_product_install_for_user_async(self, user: typing.Optional[winrt.windows.system.User], product_id: str, flight_id: str, client_id: str, correlation_vector: str, install_options: typing.Optional[AppInstallOptions], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[AppInstallItem]]: ...
    @typing.overload
    def start_product_install_for_user_async(self, user: typing.Optional[winrt.windows.system.User], product_id: str, catalog_id: str, flight_id: str, client_id: str, repair: winrt.system.Boolean, force_use_of_non_removable_storage: winrt.system.Boolean, correlation_vector: str, target_volume: typing.Optional[winrt.windows.management.deployment.PackageVolume], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[AppInstallItem]]: ...
    @typing.overload
    def update_app_by_package_family_name_async(self, package_family_name: str, /) -> winrt.windows.foundation.IAsyncOperation[AppInstallItem]: ...
    @typing.overload
    def update_app_by_package_family_name_async(self, package_family_name: str, correlation_vector: str, /) -> winrt.windows.foundation.IAsyncOperation[AppInstallItem]: ...
    def update_app_by_package_family_name_for_user_async(self, user: typing.Optional[winrt.windows.system.User], package_family_name: str, correlation_vector: str, /) -> winrt.windows.foundation.IAsyncOperation[AppInstallItem]: ...
    def add_item_completed(self, handler: winrt.windows.foundation.TypedEventHandler[AppInstallManager, AppInstallManagerItemEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_item_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_item_status_changed(self, handler: winrt.windows.foundation.TypedEventHandler[AppInstallManager, AppInstallManagerItemEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_item_status_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class AppInstallManagerItemEventArgs(winrt.system.Object):
    item: typing.Optional[AppInstallItem]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppInstallManagerItemEventArgs: ...

class AppInstallOptions(winrt.system.Object):
    target_volume: typing.Optional[winrt.windows.management.deployment.PackageVolume]
    repair: winrt.system.Boolean
    launch_after_install: winrt.system.Boolean
    force_use_of_non_removable_storage: winrt.system.Boolean
    catalog_id: str
    allow_forced_app_restart: winrt.system.Boolean
    stage_but_do_not_install: winrt.system.Boolean
    pin_to_taskbar_after_install: winrt.system.Boolean
    pin_to_start_after_install: winrt.system.Boolean
    pin_to_desktop_after_install: winrt.system.Boolean
    install_in_progress_toast_notification_mode: AppInstallationToastNotificationMode
    install_for_all_users: winrt.system.Boolean
    extended_campaign_id: str
    completed_install_toast_notification_mode: AppInstallationToastNotificationMode
    campaign_id: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppInstallOptions: ...
    def __new__(cls: typing.Type[AppInstallOptions]) -> AppInstallOptions:...

class AppInstallStatus(winrt.system.Object):
    bytes_downloaded: winrt.system.UInt64
    download_size_in_bytes: winrt.system.UInt64
    error_code: winrt.windows.foundation.HResult
    install_state: AppInstallState
    percent_complete: winrt.system.Double
    ready_for_launch: winrt.system.Boolean
    user: typing.Optional[winrt.windows.system.User]
    is_staged: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppInstallStatus: ...

class AppUpdateOptions(winrt.system.Object):
    catalog_id: str
    allow_forced_app_restart: winrt.system.Boolean
    automatically_download_and_install_update_if_found: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppUpdateOptions: ...
    def __new__(cls: typing.Type[AppUpdateOptions]) -> AppUpdateOptions:...

class GetEntitlementResult(winrt.system.Object):
    status: GetEntitlementStatus
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GetEntitlementResult: ...

