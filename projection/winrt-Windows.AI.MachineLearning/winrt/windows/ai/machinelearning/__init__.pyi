# WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

import enum
import datetime
import sys
import types
import typing

import winrt.system
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.graphics
import winrt.windows.graphics.directx.direct3d11
import winrt.windows.graphics.imaging
import winrt.windows.media
import winrt.windows.storage
import winrt.windows.storage.streams

class LearningModelDeviceKind(enum.IntEnum):
    DEFAULT = 0
    CPU = 1
    DIRECT_X = 2
    DIRECT_X_HIGH_PERFORMANCE = 3
    DIRECT_X_MIN_POWER = 4

class LearningModelFeatureKind(enum.IntEnum):
    TENSOR = 0
    SEQUENCE = 1
    MAP = 2
    IMAGE = 3

class LearningModelPixelRange(enum.IntEnum):
    ZERO_TO255 = 0
    ZERO_TO_ONE = 1
    MINUS_ONE_TO_ONE = 2

class TensorKind(enum.IntEnum):
    UNDEFINED = 0
    FLOAT = 1
    UINT8 = 2
    INT8 = 3
    UINT16 = 4
    INT16 = 5
    INT32 = 6
    INT64 = 7
    STRING = 8
    BOOLEAN = 9
    FLOAT16 = 10
    DOUBLE = 11
    UINT32 = 12
    UINT64 = 13
    COMPLEX64 = 14
    COMPLEX128 = 15

Self = typing.TypeVar('Self')

class ImageFeatureDescriptor(winrt.system.Object):
    bitmap_alpha_mode: winrt.windows.graphics.imaging.BitmapAlphaMode
    bitmap_pixel_format: winrt.windows.graphics.imaging.BitmapPixelFormat
    height: winrt.system.UInt32
    width: winrt.system.UInt32
    pixel_range: LearningModelPixelRange
    description: str
    is_required: winrt.system.Boolean
    kind: LearningModelFeatureKind
    name: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ImageFeatureDescriptor: ...

class ImageFeatureValue(winrt.system.Object):
    video_frame: typing.Optional[winrt.windows.media.VideoFrame]
    kind: LearningModelFeatureKind
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ImageFeatureValue: ...
    @staticmethod
    def create_from_video_frame(image: typing.Optional[winrt.windows.media.VideoFrame], /) -> typing.Optional[ImageFeatureValue]: ...

class LearningModel(winrt.system.Object):
    author: str
    description: str
    domain: str
    input_features: typing.Optional[winrt.windows.foundation.collections.IVectorView[ILearningModelFeatureDescriptor]]
    metadata: typing.Optional[winrt.windows.foundation.collections.IMapView[str, str]]
    name: str
    output_features: typing.Optional[winrt.windows.foundation.collections.IVectorView[ILearningModelFeatureDescriptor]]
    version: winrt.system.Int64
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LearningModel: ...
    def close(self) -> None: ...
    @typing.overload
    @staticmethod
    def load_from_file_path(file_path: str, /) -> typing.Optional[LearningModel]: ...
    @typing.overload
    @staticmethod
    def load_from_file_path(file_path: str, operator_provider: typing.Optional[ILearningModelOperatorProvider], /) -> typing.Optional[LearningModel]: ...
    @typing.overload
    @staticmethod
    def load_from_storage_file_async(model_file: typing.Optional[winrt.windows.storage.IStorageFile], /) -> winrt.windows.foundation.IAsyncOperation[LearningModel]: ...
    @typing.overload
    @staticmethod
    def load_from_storage_file_async(model_file: typing.Optional[winrt.windows.storage.IStorageFile], operator_provider: typing.Optional[ILearningModelOperatorProvider], /) -> winrt.windows.foundation.IAsyncOperation[LearningModel]: ...
    @typing.overload
    @staticmethod
    def load_from_stream(model_stream: typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference], /) -> typing.Optional[LearningModel]: ...
    @typing.overload
    @staticmethod
    def load_from_stream(model_stream: typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference], operator_provider: typing.Optional[ILearningModelOperatorProvider], /) -> typing.Optional[LearningModel]: ...
    @typing.overload
    @staticmethod
    def load_from_stream_async(model_stream: typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference], /) -> winrt.windows.foundation.IAsyncOperation[LearningModel]: ...
    @typing.overload
    @staticmethod
    def load_from_stream_async(model_stream: typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference], operator_provider: typing.Optional[ILearningModelOperatorProvider], /) -> winrt.windows.foundation.IAsyncOperation[LearningModel]: ...

class LearningModelBinding(winrt.system.Object, typing.Mapping[str, winrt.system.Object]):
    size: winrt.system.UInt32
    def __len__(self) -> int: ...
    def __iter__(self) -> typing.Iterator[str]: ...
    def __contains__(self, key: object) -> bool:...
    def __getitem__(self, key: str) -> winrt.system.Object: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LearningModelBinding: ...
    def __new__(cls: typing.Type[LearningModelBinding], session: typing.Optional[LearningModelSession]) -> LearningModelBinding:...
    @typing.overload
    def bind(self, name: str, value: typing.Optional[winrt.system.Object], /) -> None: ...
    @typing.overload
    def bind(self, name: str, value: typing.Optional[winrt.system.Object], props: typing.Optional[winrt.windows.foundation.collections.IPropertySet], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[winrt.windows.foundation.collections.IKeyValuePair[str, winrt.system.Object]]]: ...
    def has_key(self, key: str, /) -> winrt.system.Boolean: ...
    def lookup(self, key: str, /) -> typing.Optional[winrt.system.Object]: ...
    def split(self) -> typing.Tuple[typing.Optional[winrt.windows.foundation.collections.IMapView[str, winrt.system.Object]], typing.Optional[winrt.windows.foundation.collections.IMapView[str, winrt.system.Object]]]: ...

class LearningModelDevice(winrt.system.Object):
    adapter_id: winrt.windows.graphics.DisplayAdapterId
    direct3_d11_device: typing.Optional[winrt.windows.graphics.directx.direct3d11.IDirect3DDevice]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LearningModelDevice: ...
    def __new__(cls: typing.Type[LearningModelDevice], device_kind: LearningModelDeviceKind) -> LearningModelDevice:...
    @staticmethod
    def create_from_direct3_d11_device(device: typing.Optional[winrt.windows.graphics.directx.direct3d11.IDirect3DDevice], /) -> typing.Optional[LearningModelDevice]: ...

class LearningModelEvaluationResult(winrt.system.Object):
    correlation_id: str
    error_status: winrt.system.Int32
    outputs: typing.Optional[winrt.windows.foundation.collections.IMapView[str, winrt.system.Object]]
    succeeded: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LearningModelEvaluationResult: ...

class LearningModelSession(winrt.system.Object):
    device: typing.Optional[LearningModelDevice]
    evaluation_properties: typing.Optional[winrt.windows.foundation.collections.IPropertySet]
    model: typing.Optional[LearningModel]
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LearningModelSession: ...
    @typing.overload
    def __new__(cls: typing.Type[LearningModelSession], model: typing.Optional[LearningModel], device_to_run_on: typing.Optional[LearningModelDevice], learning_model_session_options: typing.Optional[LearningModelSessionOptions]) -> LearningModelSession:...
    @typing.overload
    def __new__(cls: typing.Type[LearningModelSession], model: typing.Optional[LearningModel]) -> LearningModelSession:...
    @typing.overload
    def __new__(cls: typing.Type[LearningModelSession], model: typing.Optional[LearningModel], device_to_run_on: typing.Optional[LearningModelDevice]) -> LearningModelSession:...
    def close(self) -> None: ...
    def evaluate(self, bindings: typing.Optional[LearningModelBinding], correlation_id: str, /) -> typing.Optional[LearningModelEvaluationResult]: ...
    def evaluate_async(self, bindings: typing.Optional[LearningModelBinding], correlation_id: str, /) -> winrt.windows.foundation.IAsyncOperation[LearningModelEvaluationResult]: ...
    def evaluate_features(self, features: winrt.windows.foundation.collections.IMap[str, winrt.system.Object], correlation_id: str, /) -> typing.Optional[LearningModelEvaluationResult]: ...
    def evaluate_features_async(self, features: winrt.windows.foundation.collections.IMap[str, winrt.system.Object], correlation_id: str, /) -> winrt.windows.foundation.IAsyncOperation[LearningModelEvaluationResult]: ...

class LearningModelSessionOptions(winrt.system.Object):
    batch_size_override: winrt.system.UInt32
    close_model_on_session_creation: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LearningModelSessionOptions: ...
    def __new__(cls: typing.Type[LearningModelSessionOptions]) -> LearningModelSessionOptions:...
    def override_named_dimension(self, name: str, dimension: winrt.system.UInt32, /) -> None: ...

class MapFeatureDescriptor(winrt.system.Object):
    description: str
    is_required: winrt.system.Boolean
    kind: LearningModelFeatureKind
    name: str
    key_kind: TensorKind
    value_descriptor: typing.Optional[ILearningModelFeatureDescriptor]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapFeatureDescriptor: ...

class SequenceFeatureDescriptor(winrt.system.Object):
    description: str
    is_required: winrt.system.Boolean
    kind: LearningModelFeatureKind
    name: str
    element_descriptor: typing.Optional[ILearningModelFeatureDescriptor]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SequenceFeatureDescriptor: ...

class TensorBoolean(winrt.system.Object):
    kind: LearningModelFeatureKind
    shape: typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Int64]]
    tensor_kind: TensorKind
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TensorBoolean: ...
    def close(self) -> None: ...
    @typing.overload
    @staticmethod
    def create() -> typing.Optional[TensorBoolean]: ...
    @typing.overload
    @staticmethod
    def create(shape: typing.Iterable[winrt.system.Int64], /) -> typing.Optional[TensorBoolean]: ...
    @staticmethod
    def create_from_array(shape: typing.Iterable[winrt.system.Int64], data: winrt.system.Array[winrt.system.Boolean], /) -> typing.Optional[TensorBoolean]: ...
    @staticmethod
    def create_from_buffer(shape: winrt.system.Array[winrt.system.Int64], buffer: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> typing.Optional[TensorBoolean]: ...
    @staticmethod
    def create_from_iterable(shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[winrt.system.Boolean], /) -> typing.Optional[TensorBoolean]: ...
    @staticmethod
    def create_from_shape_array_and_data_array(shape: winrt.system.Array[winrt.system.Int64], data: winrt.system.Array[winrt.system.Boolean], /) -> typing.Optional[TensorBoolean]: ...
    def create_reference(self) -> typing.Optional[winrt.windows.foundation.IMemoryBufferReference]: ...
    def get_as_vector_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Boolean]]: ...

class TensorDouble(winrt.system.Object):
    kind: LearningModelFeatureKind
    shape: typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Int64]]
    tensor_kind: TensorKind
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TensorDouble: ...
    def close(self) -> None: ...
    @typing.overload
    @staticmethod
    def create() -> typing.Optional[TensorDouble]: ...
    @typing.overload
    @staticmethod
    def create(shape: typing.Iterable[winrt.system.Int64], /) -> typing.Optional[TensorDouble]: ...
    @staticmethod
    def create_from_array(shape: typing.Iterable[winrt.system.Int64], data: winrt.system.Array[winrt.system.Double], /) -> typing.Optional[TensorDouble]: ...
    @staticmethod
    def create_from_buffer(shape: winrt.system.Array[winrt.system.Int64], buffer: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> typing.Optional[TensorDouble]: ...
    @staticmethod
    def create_from_iterable(shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[winrt.system.Double], /) -> typing.Optional[TensorDouble]: ...
    @staticmethod
    def create_from_shape_array_and_data_array(shape: winrt.system.Array[winrt.system.Int64], data: winrt.system.Array[winrt.system.Double], /) -> typing.Optional[TensorDouble]: ...
    def create_reference(self) -> typing.Optional[winrt.windows.foundation.IMemoryBufferReference]: ...
    def get_as_vector_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Double]]: ...

class TensorFeatureDescriptor(winrt.system.Object):
    description: str
    is_required: winrt.system.Boolean
    kind: LearningModelFeatureKind
    name: str
    shape: typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Int64]]
    tensor_kind: TensorKind
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TensorFeatureDescriptor: ...

class TensorFloat(winrt.system.Object):
    kind: LearningModelFeatureKind
    shape: typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Int64]]
    tensor_kind: TensorKind
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TensorFloat: ...
    def close(self) -> None: ...
    @typing.overload
    @staticmethod
    def create() -> typing.Optional[TensorFloat]: ...
    @typing.overload
    @staticmethod
    def create(shape: typing.Iterable[winrt.system.Int64], /) -> typing.Optional[TensorFloat]: ...
    @staticmethod
    def create_from_array(shape: typing.Iterable[winrt.system.Int64], data: winrt.system.Array[winrt.system.Single], /) -> typing.Optional[TensorFloat]: ...
    @staticmethod
    def create_from_buffer(shape: winrt.system.Array[winrt.system.Int64], buffer: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> typing.Optional[TensorFloat]: ...
    @staticmethod
    def create_from_iterable(shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[winrt.system.Single], /) -> typing.Optional[TensorFloat]: ...
    @staticmethod
    def create_from_shape_array_and_data_array(shape: winrt.system.Array[winrt.system.Int64], data: winrt.system.Array[winrt.system.Single], /) -> typing.Optional[TensorFloat]: ...
    def create_reference(self) -> typing.Optional[winrt.windows.foundation.IMemoryBufferReference]: ...
    def get_as_vector_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Single]]: ...

class TensorFloat16Bit(winrt.system.Object):
    kind: LearningModelFeatureKind
    shape: typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Int64]]
    tensor_kind: TensorKind
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TensorFloat16Bit: ...
    def close(self) -> None: ...
    @typing.overload
    @staticmethod
    def create() -> typing.Optional[TensorFloat16Bit]: ...
    @typing.overload
    @staticmethod
    def create(shape: typing.Iterable[winrt.system.Int64], /) -> typing.Optional[TensorFloat16Bit]: ...
    @staticmethod
    def create_from_array(shape: typing.Iterable[winrt.system.Int64], data: winrt.system.Array[winrt.system.Single], /) -> typing.Optional[TensorFloat16Bit]: ...
    @staticmethod
    def create_from_buffer(shape: winrt.system.Array[winrt.system.Int64], buffer: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> typing.Optional[TensorFloat16Bit]: ...
    @staticmethod
    def create_from_iterable(shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[winrt.system.Single], /) -> typing.Optional[TensorFloat16Bit]: ...
    @staticmethod
    def create_from_shape_array_and_data_array(shape: winrt.system.Array[winrt.system.Int64], data: winrt.system.Array[winrt.system.Single], /) -> typing.Optional[TensorFloat16Bit]: ...
    def create_reference(self) -> typing.Optional[winrt.windows.foundation.IMemoryBufferReference]: ...
    def get_as_vector_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Single]]: ...

class TensorInt16Bit(winrt.system.Object):
    kind: LearningModelFeatureKind
    shape: typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Int64]]
    tensor_kind: TensorKind
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TensorInt16Bit: ...
    def close(self) -> None: ...
    @typing.overload
    @staticmethod
    def create() -> typing.Optional[TensorInt16Bit]: ...
    @typing.overload
    @staticmethod
    def create(shape: typing.Iterable[winrt.system.Int64], /) -> typing.Optional[TensorInt16Bit]: ...
    @staticmethod
    def create_from_array(shape: typing.Iterable[winrt.system.Int64], data: winrt.system.Array[winrt.system.Int16], /) -> typing.Optional[TensorInt16Bit]: ...
    @staticmethod
    def create_from_buffer(shape: winrt.system.Array[winrt.system.Int64], buffer: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> typing.Optional[TensorInt16Bit]: ...
    @staticmethod
    def create_from_iterable(shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[winrt.system.Int16], /) -> typing.Optional[TensorInt16Bit]: ...
    @staticmethod
    def create_from_shape_array_and_data_array(shape: winrt.system.Array[winrt.system.Int64], data: winrt.system.Array[winrt.system.Int16], /) -> typing.Optional[TensorInt16Bit]: ...
    def create_reference(self) -> typing.Optional[winrt.windows.foundation.IMemoryBufferReference]: ...
    def get_as_vector_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Int16]]: ...

class TensorInt32Bit(winrt.system.Object):
    kind: LearningModelFeatureKind
    shape: typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Int64]]
    tensor_kind: TensorKind
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TensorInt32Bit: ...
    def close(self) -> None: ...
    @typing.overload
    @staticmethod
    def create() -> typing.Optional[TensorInt32Bit]: ...
    @typing.overload
    @staticmethod
    def create(shape: typing.Iterable[winrt.system.Int64], /) -> typing.Optional[TensorInt32Bit]: ...
    @staticmethod
    def create_from_array(shape: typing.Iterable[winrt.system.Int64], data: winrt.system.Array[winrt.system.Int32], /) -> typing.Optional[TensorInt32Bit]: ...
    @staticmethod
    def create_from_buffer(shape: winrt.system.Array[winrt.system.Int64], buffer: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> typing.Optional[TensorInt32Bit]: ...
    @staticmethod
    def create_from_iterable(shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[winrt.system.Int32], /) -> typing.Optional[TensorInt32Bit]: ...
    @staticmethod
    def create_from_shape_array_and_data_array(shape: winrt.system.Array[winrt.system.Int64], data: winrt.system.Array[winrt.system.Int32], /) -> typing.Optional[TensorInt32Bit]: ...
    def create_reference(self) -> typing.Optional[winrt.windows.foundation.IMemoryBufferReference]: ...
    def get_as_vector_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Int32]]: ...

class TensorInt64Bit(winrt.system.Object):
    kind: LearningModelFeatureKind
    shape: typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Int64]]
    tensor_kind: TensorKind
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TensorInt64Bit: ...
    def close(self) -> None: ...
    @typing.overload
    @staticmethod
    def create() -> typing.Optional[TensorInt64Bit]: ...
    @typing.overload
    @staticmethod
    def create(shape: typing.Iterable[winrt.system.Int64], /) -> typing.Optional[TensorInt64Bit]: ...
    @staticmethod
    def create_from_array(shape: typing.Iterable[winrt.system.Int64], data: winrt.system.Array[winrt.system.Int64], /) -> typing.Optional[TensorInt64Bit]: ...
    @staticmethod
    def create_from_buffer(shape: winrt.system.Array[winrt.system.Int64], buffer: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> typing.Optional[TensorInt64Bit]: ...
    @staticmethod
    def create_from_iterable(shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[winrt.system.Int64], /) -> typing.Optional[TensorInt64Bit]: ...
    @staticmethod
    def create_from_shape_array_and_data_array(shape: winrt.system.Array[winrt.system.Int64], data: winrt.system.Array[winrt.system.Int64], /) -> typing.Optional[TensorInt64Bit]: ...
    def create_reference(self) -> typing.Optional[winrt.windows.foundation.IMemoryBufferReference]: ...
    def get_as_vector_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Int64]]: ...

class TensorInt8Bit(winrt.system.Object):
    kind: LearningModelFeatureKind
    shape: typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Int64]]
    tensor_kind: TensorKind
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TensorInt8Bit: ...
    def close(self) -> None: ...
    @typing.overload
    @staticmethod
    def create() -> typing.Optional[TensorInt8Bit]: ...
    @typing.overload
    @staticmethod
    def create(shape: typing.Iterable[winrt.system.Int64], /) -> typing.Optional[TensorInt8Bit]: ...
    @staticmethod
    def create_from_array(shape: typing.Iterable[winrt.system.Int64], data: winrt.system.Array[winrt.system.UInt8], /) -> typing.Optional[TensorInt8Bit]: ...
    @staticmethod
    def create_from_buffer(shape: winrt.system.Array[winrt.system.Int64], buffer: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> typing.Optional[TensorInt8Bit]: ...
    @staticmethod
    def create_from_iterable(shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[winrt.system.UInt8], /) -> typing.Optional[TensorInt8Bit]: ...
    @staticmethod
    def create_from_shape_array_and_data_array(shape: winrt.system.Array[winrt.system.Int64], data: winrt.system.Array[winrt.system.UInt8], /) -> typing.Optional[TensorInt8Bit]: ...
    def create_reference(self) -> typing.Optional[winrt.windows.foundation.IMemoryBufferReference]: ...
    def get_as_vector_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt8]]: ...

class TensorString(winrt.system.Object):
    kind: LearningModelFeatureKind
    shape: typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Int64]]
    tensor_kind: TensorKind
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TensorString: ...
    def close(self) -> None: ...
    @typing.overload
    @staticmethod
    def create() -> typing.Optional[TensorString]: ...
    @typing.overload
    @staticmethod
    def create(shape: typing.Iterable[winrt.system.Int64], /) -> typing.Optional[TensorString]: ...
    @staticmethod
    def create_from_array(shape: typing.Iterable[winrt.system.Int64], data: winrt.system.Array[str], /) -> typing.Optional[TensorString]: ...
    @staticmethod
    def create_from_iterable(shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[str], /) -> typing.Optional[TensorString]: ...
    @staticmethod
    def create_from_shape_array_and_data_array(shape: winrt.system.Array[winrt.system.Int64], data: winrt.system.Array[str], /) -> typing.Optional[TensorString]: ...
    def create_reference(self) -> typing.Optional[winrt.windows.foundation.IMemoryBufferReference]: ...
    def get_as_vector_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[str]]: ...

class TensorUInt16Bit(winrt.system.Object):
    kind: LearningModelFeatureKind
    shape: typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Int64]]
    tensor_kind: TensorKind
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TensorUInt16Bit: ...
    def close(self) -> None: ...
    @typing.overload
    @staticmethod
    def create() -> typing.Optional[TensorUInt16Bit]: ...
    @typing.overload
    @staticmethod
    def create(shape: typing.Iterable[winrt.system.Int64], /) -> typing.Optional[TensorUInt16Bit]: ...
    @staticmethod
    def create_from_array(shape: typing.Iterable[winrt.system.Int64], data: winrt.system.Array[winrt.system.UInt16], /) -> typing.Optional[TensorUInt16Bit]: ...
    @staticmethod
    def create_from_buffer(shape: winrt.system.Array[winrt.system.Int64], buffer: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> typing.Optional[TensorUInt16Bit]: ...
    @staticmethod
    def create_from_iterable(shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[winrt.system.UInt16], /) -> typing.Optional[TensorUInt16Bit]: ...
    @staticmethod
    def create_from_shape_array_and_data_array(shape: winrt.system.Array[winrt.system.Int64], data: winrt.system.Array[winrt.system.UInt16], /) -> typing.Optional[TensorUInt16Bit]: ...
    def create_reference(self) -> typing.Optional[winrt.windows.foundation.IMemoryBufferReference]: ...
    def get_as_vector_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt16]]: ...

class TensorUInt32Bit(winrt.system.Object):
    kind: LearningModelFeatureKind
    shape: typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Int64]]
    tensor_kind: TensorKind
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TensorUInt32Bit: ...
    def close(self) -> None: ...
    @typing.overload
    @staticmethod
    def create() -> typing.Optional[TensorUInt32Bit]: ...
    @typing.overload
    @staticmethod
    def create(shape: typing.Iterable[winrt.system.Int64], /) -> typing.Optional[TensorUInt32Bit]: ...
    @staticmethod
    def create_from_array(shape: typing.Iterable[winrt.system.Int64], data: winrt.system.Array[winrt.system.UInt32], /) -> typing.Optional[TensorUInt32Bit]: ...
    @staticmethod
    def create_from_buffer(shape: winrt.system.Array[winrt.system.Int64], buffer: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> typing.Optional[TensorUInt32Bit]: ...
    @staticmethod
    def create_from_iterable(shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[winrt.system.UInt32], /) -> typing.Optional[TensorUInt32Bit]: ...
    @staticmethod
    def create_from_shape_array_and_data_array(shape: winrt.system.Array[winrt.system.Int64], data: winrt.system.Array[winrt.system.UInt32], /) -> typing.Optional[TensorUInt32Bit]: ...
    def create_reference(self) -> typing.Optional[winrt.windows.foundation.IMemoryBufferReference]: ...
    def get_as_vector_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]: ...

class TensorUInt64Bit(winrt.system.Object):
    kind: LearningModelFeatureKind
    shape: typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Int64]]
    tensor_kind: TensorKind
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TensorUInt64Bit: ...
    def close(self) -> None: ...
    @typing.overload
    @staticmethod
    def create() -> typing.Optional[TensorUInt64Bit]: ...
    @typing.overload
    @staticmethod
    def create(shape: typing.Iterable[winrt.system.Int64], /) -> typing.Optional[TensorUInt64Bit]: ...
    @staticmethod
    def create_from_array(shape: typing.Iterable[winrt.system.Int64], data: winrt.system.Array[winrt.system.UInt64], /) -> typing.Optional[TensorUInt64Bit]: ...
    @staticmethod
    def create_from_buffer(shape: winrt.system.Array[winrt.system.Int64], buffer: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> typing.Optional[TensorUInt64Bit]: ...
    @staticmethod
    def create_from_iterable(shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[winrt.system.UInt64], /) -> typing.Optional[TensorUInt64Bit]: ...
    @staticmethod
    def create_from_shape_array_and_data_array(shape: winrt.system.Array[winrt.system.Int64], data: winrt.system.Array[winrt.system.UInt64], /) -> typing.Optional[TensorUInt64Bit]: ...
    def create_reference(self) -> typing.Optional[winrt.windows.foundation.IMemoryBufferReference]: ...
    def get_as_vector_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt64]]: ...

class TensorUInt8Bit(winrt.system.Object):
    kind: LearningModelFeatureKind
    shape: typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Int64]]
    tensor_kind: TensorKind
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TensorUInt8Bit: ...
    def close(self) -> None: ...
    @typing.overload
    @staticmethod
    def create() -> typing.Optional[TensorUInt8Bit]: ...
    @typing.overload
    @staticmethod
    def create(shape: typing.Iterable[winrt.system.Int64], /) -> typing.Optional[TensorUInt8Bit]: ...
    @staticmethod
    def create_from_array(shape: typing.Iterable[winrt.system.Int64], data: winrt.system.Array[winrt.system.UInt8], /) -> typing.Optional[TensorUInt8Bit]: ...
    @staticmethod
    def create_from_buffer(shape: winrt.system.Array[winrt.system.Int64], buffer: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> typing.Optional[TensorUInt8Bit]: ...
    @staticmethod
    def create_from_iterable(shape: typing.Iterable[winrt.system.Int64], data: typing.Iterable[winrt.system.UInt8], /) -> typing.Optional[TensorUInt8Bit]: ...
    @staticmethod
    def create_from_shape_array_and_data_array(shape: winrt.system.Array[winrt.system.Int64], data: winrt.system.Array[winrt.system.UInt8], /) -> typing.Optional[TensorUInt8Bit]: ...
    def create_reference(self) -> typing.Optional[winrt.windows.foundation.IMemoryBufferReference]: ...
    def get_as_vector_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt8]]: ...

class ILearningModelFeatureDescriptor(winrt.system.Object):
    description: str
    is_required: winrt.system.Boolean
    kind: LearningModelFeatureKind
    name: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ILearningModelFeatureDescriptor: ...

class ILearningModelFeatureValue(winrt.system.Object):
    kind: LearningModelFeatureKind
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ILearningModelFeatureValue: ...

class ILearningModelOperatorProvider(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ILearningModelOperatorProvider: ...

class ITensor(winrt.system.Object):
    shape: typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Int64]]
    tensor_kind: TensorKind
    kind: LearningModelFeatureKind
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ITensor: ...

