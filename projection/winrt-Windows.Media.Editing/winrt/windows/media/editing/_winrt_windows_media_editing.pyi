# WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

import datetime
import sys
import types
import typing
import uuid

import winrt.system
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.graphics.directx.direct3d11
import winrt.windows.graphics.imaging
import winrt.windows.media.core
import winrt.windows.media.effects
import winrt.windows.media.mediaproperties
import winrt.windows.media.transcoding
import winrt.windows.storage
import winrt.windows.ui

from . import MediaTrimmingPreference, VideoFramePrecision

Self = typing.TypeVar('Self')

class BackgroundAudioTrack(winrt.system.Object):
    volume: winrt.system.Double
    trim_time_from_start: datetime.timedelta
    trim_time_from_end: datetime.timedelta
    delay: datetime.timedelta
    audio_effect_definitions: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.media.effects.IAudioEffectDefinition]]
    original_duration: datetime.timedelta
    trimmed_duration: datetime.timedelta
    user_data: typing.Optional[winrt.windows.foundation.collections.IMap[str, str]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BackgroundAudioTrack: ...
    def clone(self) -> typing.Optional[BackgroundAudioTrack]: ...
    @staticmethod
    def create_from_embedded_audio_track(embedded_audio_track: typing.Optional[EmbeddedAudioTrack], /) -> typing.Optional[BackgroundAudioTrack]: ...
    @staticmethod
    def create_from_file_async(file: typing.Optional[winrt.windows.storage.IStorageFile], /) -> winrt.windows.foundation.IAsyncOperation[BackgroundAudioTrack]: ...
    def get_audio_encoding_properties(self) -> typing.Optional[winrt.windows.media.mediaproperties.AudioEncodingProperties]: ...

class EmbeddedAudioTrack(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EmbeddedAudioTrack: ...
    def get_audio_encoding_properties(self) -> typing.Optional[winrt.windows.media.mediaproperties.AudioEncodingProperties]: ...

class MediaClip(winrt.system.Object):
    selected_embedded_audio_track_index: winrt.system.UInt32
    trim_time_from_end: datetime.timedelta
    volume: winrt.system.Double
    trim_time_from_start: datetime.timedelta
    embedded_audio_tracks: typing.Optional[winrt.windows.foundation.collections.IVectorView[EmbeddedAudioTrack]]
    end_time_in_composition: datetime.timedelta
    original_duration: datetime.timedelta
    start_time_in_composition: datetime.timedelta
    trimmed_duration: datetime.timedelta
    user_data: typing.Optional[winrt.windows.foundation.collections.IMap[str, str]]
    video_effect_definitions: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.media.effects.IVideoEffectDefinition]]
    audio_effect_definitions: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.media.effects.IAudioEffectDefinition]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaClip: ...
    def clone(self) -> typing.Optional[MediaClip]: ...
    @staticmethod
    def create_from_color(color: winrt.windows.ui.Color, original_duration: datetime.timedelta, /) -> typing.Optional[MediaClip]: ...
    @staticmethod
    def create_from_file_async(file: typing.Optional[winrt.windows.storage.IStorageFile], /) -> winrt.windows.foundation.IAsyncOperation[MediaClip]: ...
    @staticmethod
    def create_from_image_file_async(file: typing.Optional[winrt.windows.storage.IStorageFile], original_duration: datetime.timedelta, /) -> winrt.windows.foundation.IAsyncOperation[MediaClip]: ...
    @staticmethod
    def create_from_surface(surface: typing.Optional[winrt.windows.graphics.directx.direct3d11.IDirect3DSurface], original_duration: datetime.timedelta, /) -> typing.Optional[MediaClip]: ...
    def get_video_encoding_properties(self) -> typing.Optional[winrt.windows.media.mediaproperties.VideoEncodingProperties]: ...

class MediaComposition(winrt.system.Object):
    background_audio_tracks: typing.Optional[winrt.windows.foundation.collections.IVector[BackgroundAudioTrack]]
    clips: typing.Optional[winrt.windows.foundation.collections.IVector[MediaClip]]
    duration: datetime.timedelta
    user_data: typing.Optional[winrt.windows.foundation.collections.IMap[str, str]]
    overlay_layers: typing.Optional[winrt.windows.foundation.collections.IVector[MediaOverlayLayer]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaComposition: ...
    def __new__(cls: typing.Type[MediaComposition]) -> MediaComposition:...
    def clone(self) -> typing.Optional[MediaComposition]: ...
    def create_default_encoding_profile(self) -> typing.Optional[winrt.windows.media.mediaproperties.MediaEncodingProfile]: ...
    @typing.overload
    def generate_media_stream_source(self) -> typing.Optional[winrt.windows.media.core.MediaStreamSource]: ...
    @typing.overload
    def generate_media_stream_source(self, encoding_profile: typing.Optional[winrt.windows.media.mediaproperties.MediaEncodingProfile], /) -> typing.Optional[winrt.windows.media.core.MediaStreamSource]: ...
    def generate_preview_media_stream_source(self, scaled_width: winrt.system.Int32, scaled_height: winrt.system.Int32, /) -> typing.Optional[winrt.windows.media.core.MediaStreamSource]: ...
    def get_thumbnail_async(self, time_from_start: datetime.timedelta, scaled_width: winrt.system.Int32, scaled_height: winrt.system.Int32, frame_precision: VideoFramePrecision, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.graphics.imaging.ImageStream]: ...
    def get_thumbnails_async(self, times_from_start: typing.Iterable[datetime.timedelta], scaled_width: winrt.system.Int32, scaled_height: winrt.system.Int32, frame_precision: VideoFramePrecision, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[winrt.windows.graphics.imaging.ImageStream]]: ...
    @staticmethod
    def load_async(file: typing.Optional[winrt.windows.storage.StorageFile], /) -> winrt.windows.foundation.IAsyncOperation[MediaComposition]: ...
    @typing.overload
    def render_to_file_async(self, destination: typing.Optional[winrt.windows.storage.IStorageFile], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[winrt.windows.media.transcoding.TranscodeFailureReason, winrt.system.Double]: ...
    @typing.overload
    def render_to_file_async(self, destination: typing.Optional[winrt.windows.storage.IStorageFile], trimming_preference: MediaTrimmingPreference, /) -> winrt.windows.foundation.IAsyncOperationWithProgress[winrt.windows.media.transcoding.TranscodeFailureReason, winrt.system.Double]: ...
    @typing.overload
    def render_to_file_async(self, destination: typing.Optional[winrt.windows.storage.IStorageFile], trimming_preference: MediaTrimmingPreference, encoding_profile: typing.Optional[winrt.windows.media.mediaproperties.MediaEncodingProfile], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[winrt.windows.media.transcoding.TranscodeFailureReason, winrt.system.Double]: ...
    def save_async(self, file: typing.Optional[winrt.windows.storage.IStorageFile], /) -> winrt.windows.foundation.IAsyncAction: ...

class MediaOverlay(winrt.system.Object):
    position: winrt.windows.foundation.Rect
    opacity: winrt.system.Double
    delay: datetime.timedelta
    audio_enabled: winrt.system.Boolean
    clip: typing.Optional[MediaClip]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaOverlay: ...
    @typing.overload
    def __new__(cls: typing.Type[MediaOverlay], clip: typing.Optional[MediaClip]) -> MediaOverlay:...
    @typing.overload
    def __new__(cls: typing.Type[MediaOverlay], clip: typing.Optional[MediaClip], position: winrt.windows.foundation.Rect, opacity: winrt.system.Double) -> MediaOverlay:...
    def clone(self) -> typing.Optional[MediaOverlay]: ...

class MediaOverlayLayer(winrt.system.Object):
    custom_compositor_definition: typing.Optional[winrt.windows.media.effects.IVideoCompositorDefinition]
    overlays: typing.Optional[winrt.windows.foundation.collections.IVector[MediaOverlay]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaOverlayLayer: ...
    @typing.overload
    def __new__(cls: typing.Type[MediaOverlayLayer], compositor_definition: typing.Optional[winrt.windows.media.effects.IVideoCompositorDefinition]) -> MediaOverlayLayer:...
    @typing.overload
    def __new__(cls: typing.Type[MediaOverlayLayer]) -> MediaOverlayLayer:...
    def clone(self) -> typing.Optional[MediaOverlayLayer]: ...

