# WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

import datetime
import sys
import types
import typing
import uuid

import winrt.system
import winrt.windows.data.xml.dom
import winrt.windows.devices.sms
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.networking
import winrt.windows.networking.connectivity
import winrt.windows.storage.streams

from . import DataClasses, ESimAuthenticationPreference, ESimDiscoverResultKind, ESimOperationStatus, ESimProfileClass, ESimProfileMetadataState, ESimProfileState, ESimState, ESimWatcherStatus, HotspotAuthenticationResponseCode, MobileBroadbandAccountWatcherStatus, MobileBroadbandDeviceType, MobileBroadbandModemStatus, MobileBroadbandPinFormat, MobileBroadbandPinLockState, MobileBroadbandPinType, MobileBroadbandRadioState, MobileBroadbandSlotState, MobileBroadbandUiccAppOperationStatus, NetworkDeviceStatus, NetworkOperatorDataUsageNotificationKind, NetworkOperatorEventMessageType, NetworkRegistrationState, ProfileMediaType, TetheringCapability, TetheringOperationStatus, TetheringOperationalState, TetheringWiFiBand, UiccAccessCondition, UiccAppKind, UiccAppRecordKind, UssdResultCode

Self = typing.TypeVar('Self')

class ESimProfileInstallProgress:
    total_size_in_bytes: winrt.system.Int32
    installed_size_in_bytes: winrt.system.Int32
    def __new__(cls: typing.Type[ESimProfileInstallProgress], total_size_in_bytes: winrt.system.Int32, installed_size_in_bytes: winrt.system.Int32) -> ESimProfileInstallProgress: ...

class ProfileUsage:
    usage_in_megabytes: winrt.system.UInt32
    last_sync_time: datetime.datetime
    def __new__(cls: typing.Type[ProfileUsage], usage_in_megabytes: winrt.system.UInt32, last_sync_time: datetime.datetime) -> ProfileUsage: ...

class ESim(winrt.system.Object):
    available_memory_in_bytes: typing.Optional[typing.Optional[winrt.system.Int32]]
    eid: str
    firmware_version: str
    mobile_broadband_modem_device_id: str
    policy: typing.Optional[ESimPolicy]
    state: ESimState
    slot_index: typing.Optional[typing.Optional[winrt.system.Int32]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ESim: ...
    def delete_profile_async(self, profile_id: str, /) -> winrt.windows.foundation.IAsyncOperation[ESimOperationResult]: ...
    @typing.overload
    def discover(self) -> typing.Optional[ESimDiscoverResult]: ...
    @typing.overload
    def discover(self, server_address: str, matching_id: str, /) -> typing.Optional[ESimDiscoverResult]: ...
    @typing.overload
    def discover_async(self) -> winrt.windows.foundation.IAsyncOperation[ESimDiscoverResult]: ...
    @typing.overload
    def discover_async(self, server_address: str, matching_id: str, /) -> winrt.windows.foundation.IAsyncOperation[ESimDiscoverResult]: ...
    def download_profile_metadata_async(self, activation_code: str, /) -> winrt.windows.foundation.IAsyncOperation[ESimDownloadProfileMetadataResult]: ...
    def get_profiles(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[ESimProfile]]: ...
    def reset_async(self) -> winrt.windows.foundation.IAsyncOperation[ESimOperationResult]: ...
    def add_profile_changed(self, handler: winrt.windows.foundation.TypedEventHandler[ESim, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_profile_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class ESimAddedEventArgs(winrt.system.Object):
    e_sim: typing.Optional[ESim]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ESimAddedEventArgs: ...

class ESimDiscoverEvent(winrt.system.Object):
    matching_id: str
    rsp_server_address: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ESimDiscoverEvent: ...

class ESimDiscoverResult(winrt.system.Object):
    events: typing.Optional[winrt.windows.foundation.collections.IVectorView[ESimDiscoverEvent]]
    kind: ESimDiscoverResultKind
    profile_metadata: typing.Optional[ESimProfileMetadata]
    result: typing.Optional[ESimOperationResult]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ESimDiscoverResult: ...

class ESimDownloadProfileMetadataResult(winrt.system.Object):
    profile_metadata: typing.Optional[ESimProfileMetadata]
    result: typing.Optional[ESimOperationResult]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ESimDownloadProfileMetadataResult: ...

class ESimManager(winrt.system.Object):
    service_info: typing.ClassVar[typing.Optional[ESimServiceInfo]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ESimManager: ...
    @staticmethod
    def try_create_e_sim_watcher() -> typing.Optional[ESimWatcher]: ...
    @staticmethod
    def add_service_info_changed(handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    @staticmethod
    def remove_service_info_changed(token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class ESimOperationResult(winrt.system.Object):
    status: ESimOperationStatus
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ESimOperationResult: ...

class ESimPolicy(winrt.system.Object):
    should_enable_managing_ui: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ESimPolicy: ...

class ESimProfile(winrt.system.Object):
    class_: ESimProfileClass
    id: str
    nickname: str
    policy: typing.Optional[ESimProfilePolicy]
    provider_icon: typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference]
    provider_id: str
    provider_name: str
    state: ESimProfileState
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ESimProfile: ...
    def disable_async(self) -> winrt.windows.foundation.IAsyncOperation[ESimOperationResult]: ...
    def enable_async(self) -> winrt.windows.foundation.IAsyncOperation[ESimOperationResult]: ...
    def set_nickname_async(self, new_nickname: str, /) -> winrt.windows.foundation.IAsyncOperation[ESimOperationResult]: ...

class ESimProfileMetadata(winrt.system.Object):
    id: str
    is_confirmation_code_required: winrt.system.Boolean
    policy: typing.Optional[ESimProfilePolicy]
    provider_icon: typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference]
    provider_id: str
    provider_name: str
    state: ESimProfileMetadataState
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ESimProfileMetadata: ...
    @typing.overload
    def confirm_install_async(self) -> winrt.windows.foundation.IAsyncOperationWithProgress[ESimOperationResult, ESimProfileInstallProgress]: ...
    @typing.overload
    def confirm_install_async(self, confirmation_code: str, /) -> winrt.windows.foundation.IAsyncOperationWithProgress[ESimOperationResult, ESimProfileInstallProgress]: ...
    def deny_install_async(self) -> winrt.windows.foundation.IAsyncOperation[ESimOperationResult]: ...
    def postpone_install_async(self) -> winrt.windows.foundation.IAsyncOperation[ESimOperationResult]: ...
    def add_state_changed(self, handler: winrt.windows.foundation.TypedEventHandler[ESimProfileMetadata, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_state_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class ESimProfilePolicy(winrt.system.Object):
    can_delete: winrt.system.Boolean
    can_disable: winrt.system.Boolean
    is_managed_by_enterprise: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ESimProfilePolicy: ...

class ESimRemovedEventArgs(winrt.system.Object):
    e_sim: typing.Optional[ESim]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ESimRemovedEventArgs: ...

class ESimServiceInfo(winrt.system.Object):
    authentication_preference: ESimAuthenticationPreference
    is_e_sim_ui_enabled: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ESimServiceInfo: ...

class ESimUpdatedEventArgs(winrt.system.Object):
    e_sim: typing.Optional[ESim]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ESimUpdatedEventArgs: ...

class ESimWatcher(winrt.system.Object):
    status: ESimWatcherStatus
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ESimWatcher: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def add_added(self, handler: winrt.windows.foundation.TypedEventHandler[ESimWatcher, ESimAddedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_added(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_enumeration_completed(self, handler: winrt.windows.foundation.TypedEventHandler[ESimWatcher, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_enumeration_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_removed(self, handler: winrt.windows.foundation.TypedEventHandler[ESimWatcher, ESimRemovedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_removed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_stopped(self, handler: winrt.windows.foundation.TypedEventHandler[ESimWatcher, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_stopped(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_updated(self, handler: winrt.windows.foundation.TypedEventHandler[ESimWatcher, ESimUpdatedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_updated(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class FdnAccessManager(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FdnAccessManager: ...
    @staticmethod
    def request_unlock_async(contact_list_id: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...

class HotspotAuthenticationContext(winrt.system.Object):
    authentication_url: typing.Optional[winrt.windows.foundation.Uri]
    network_adapter: typing.Optional[winrt.windows.networking.connectivity.NetworkAdapter]
    redirect_message_url: typing.Optional[winrt.windows.foundation.Uri]
    redirect_message_xml: typing.Optional[winrt.windows.data.xml.dom.XmlDocument]
    wireless_network_id: winrt.system.UInt8
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HotspotAuthenticationContext: ...
    def abort_authentication(self, mark_as_manual: winrt.system.Boolean, /) -> None: ...
    def issue_credentials(self, user_name: str, password: str, extra_parameters: str, mark_as_manual_connect_on_failure: winrt.system.Boolean, /) -> None: ...
    def issue_credentials_async(self, user_name: str, password: str, extra_parameters: str, mark_as_manual_connect_on_failure: winrt.system.Boolean, /) -> winrt.windows.foundation.IAsyncOperation[HotspotCredentialsAuthenticationResult]: ...
    def skip_authentication(self) -> None: ...
    def trigger_attention_required(self, package_relative_application_id: str, application_parameters: str, /) -> None: ...
    @staticmethod
    def try_get_authentication_context(even_token: str, /) -> typing.Tuple[winrt.system.Boolean, typing.Optional[HotspotAuthenticationContext]]: ...

class HotspotAuthenticationEventDetails(winrt.system.Object):
    event_token: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HotspotAuthenticationEventDetails: ...

class HotspotCredentialsAuthenticationResult(winrt.system.Object):
    authentication_reply_xml: typing.Optional[winrt.windows.data.xml.dom.XmlDocument]
    has_network_error_occurred: winrt.system.Boolean
    logoff_url: typing.Optional[winrt.windows.foundation.Uri]
    response_code: HotspotAuthenticationResponseCode
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HotspotCredentialsAuthenticationResult: ...

class KnownCSimFilePaths(winrt.system.Object):
    e_f_spn: typing.ClassVar[typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]]
    gid1: typing.ClassVar[typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]]
    gid2: typing.ClassVar[typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> KnownCSimFilePaths: ...

class KnownRuimFilePaths(winrt.system.Object):
    e_f_spn: typing.ClassVar[typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]]
    gid1: typing.ClassVar[typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]]
    gid2: typing.ClassVar[typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> KnownRuimFilePaths: ...

class KnownSimFilePaths(winrt.system.Object):
    e_f_ons: typing.ClassVar[typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]]
    e_f_spn: typing.ClassVar[typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]]
    gid1: typing.ClassVar[typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]]
    gid2: typing.ClassVar[typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> KnownSimFilePaths: ...

class KnownUSimFilePaths(winrt.system.Object):
    e_f_opl: typing.ClassVar[typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]]
    e_f_pnn: typing.ClassVar[typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]]
    e_f_spn: typing.ClassVar[typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]]
    gid1: typing.ClassVar[typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]]
    gid2: typing.ClassVar[typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> KnownUSimFilePaths: ...

class MobileBroadbandAccount(winrt.system.Object):
    current_device_information: typing.Optional[MobileBroadbandDeviceInformation]
    current_network: typing.Optional[MobileBroadbandNetwork]
    network_account_id: str
    service_provider_guid: uuid.UUID
    service_provider_name: str
    account_experience_url: typing.Optional[winrt.windows.foundation.Uri]
    available_network_account_ids: typing.ClassVar[typing.Optional[winrt.windows.foundation.collections.IVectorView[str]]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandAccount: ...
    @staticmethod
    def create_from_network_account_id(network_account_id: str, /) -> typing.Optional[MobileBroadbandAccount]: ...
    def get_connection_profiles(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.networking.connectivity.ConnectionProfile]]: ...

class MobileBroadbandAccountEventArgs(winrt.system.Object):
    network_account_id: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandAccountEventArgs: ...

class MobileBroadbandAccountUpdatedEventArgs(winrt.system.Object):
    has_device_information_changed: winrt.system.Boolean
    has_network_changed: winrt.system.Boolean
    network_account_id: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandAccountUpdatedEventArgs: ...

class MobileBroadbandAccountWatcher(winrt.system.Object):
    status: MobileBroadbandAccountWatcherStatus
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandAccountWatcher: ...
    def __new__(cls: typing.Type[MobileBroadbandAccountWatcher]) -> MobileBroadbandAccountWatcher:...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def add_account_added(self, handler: winrt.windows.foundation.TypedEventHandler[MobileBroadbandAccountWatcher, MobileBroadbandAccountEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_account_added(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_account_removed(self, handler: winrt.windows.foundation.TypedEventHandler[MobileBroadbandAccountWatcher, MobileBroadbandAccountEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_account_removed(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_account_updated(self, handler: winrt.windows.foundation.TypedEventHandler[MobileBroadbandAccountWatcher, MobileBroadbandAccountUpdatedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_account_updated(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_enumeration_completed(self, handler: winrt.windows.foundation.TypedEventHandler[MobileBroadbandAccountWatcher, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_enumeration_completed(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_stopped(self, handler: winrt.windows.foundation.TypedEventHandler[MobileBroadbandAccountWatcher, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_stopped(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class MobileBroadbandAntennaSar(winrt.system.Object):
    antenna_index: winrt.system.Int32
    sar_backoff_index: winrt.system.Int32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandAntennaSar: ...
    def __new__(cls: typing.Type[MobileBroadbandAntennaSar], antenna_index: winrt.system.Int32, sar_backoff_index: winrt.system.Int32) -> MobileBroadbandAntennaSar:...

class MobileBroadbandCellCdma(winrt.system.Object):
    base_station_id: typing.Optional[typing.Optional[winrt.system.Int32]]
    base_station_last_broadcast_gps_time: typing.Optional[typing.Optional[datetime.timedelta]]
    base_station_latitude: typing.Optional[typing.Optional[winrt.system.Double]]
    base_station_longitude: typing.Optional[typing.Optional[winrt.system.Double]]
    base_station_p_n_code: typing.Optional[typing.Optional[winrt.system.Int32]]
    network_id: typing.Optional[typing.Optional[winrt.system.Int32]]
    pilot_signal_strength_in_d_b: typing.Optional[typing.Optional[winrt.system.Double]]
    system_id: typing.Optional[typing.Optional[winrt.system.Int32]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandCellCdma: ...

class MobileBroadbandCellGsm(winrt.system.Object):
    base_station_id: typing.Optional[typing.Optional[winrt.system.Int32]]
    cell_id: typing.Optional[typing.Optional[winrt.system.Int32]]
    channel_number: typing.Optional[typing.Optional[winrt.system.Int32]]
    location_area_code: typing.Optional[typing.Optional[winrt.system.Int32]]
    provider_id: str
    received_signal_strength_in_d_bm: typing.Optional[typing.Optional[winrt.system.Double]]
    timing_advance_in_bit_periods: typing.Optional[typing.Optional[winrt.system.Int32]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandCellGsm: ...

class MobileBroadbandCellLte(winrt.system.Object):
    cell_id: typing.Optional[typing.Optional[winrt.system.Int32]]
    channel_number: typing.Optional[typing.Optional[winrt.system.Int32]]
    physical_cell_id: typing.Optional[typing.Optional[winrt.system.Int32]]
    provider_id: str
    reference_signal_received_power_in_d_bm: typing.Optional[typing.Optional[winrt.system.Double]]
    reference_signal_received_quality_in_d_bm: typing.Optional[typing.Optional[winrt.system.Double]]
    timing_advance_in_bit_periods: typing.Optional[typing.Optional[winrt.system.Int32]]
    tracking_area_code: typing.Optional[typing.Optional[winrt.system.Int32]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandCellLte: ...

class MobileBroadbandCellNR(winrt.system.Object):
    cell_id: typing.Optional[typing.Optional[winrt.system.Int64]]
    channel_number: typing.Optional[typing.Optional[winrt.system.Int32]]
    physical_cell_id: typing.Optional[typing.Optional[winrt.system.Int32]]
    provider_id: str
    reference_signal_received_power_in_d_bm: typing.Optional[typing.Optional[winrt.system.Double]]
    reference_signal_received_quality_in_d_bm: typing.Optional[typing.Optional[winrt.system.Double]]
    signal_to_noise_ratio_in_d_b: typing.Optional[typing.Optional[winrt.system.Double]]
    timing_advance_in_nanoseconds: typing.Optional[typing.Optional[winrt.system.Int32]]
    tracking_area_code: typing.Optional[typing.Optional[winrt.system.Int32]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandCellNR: ...

class MobileBroadbandCellTdscdma(winrt.system.Object):
    cell_id: typing.Optional[typing.Optional[winrt.system.Int32]]
    cell_parameter_id: typing.Optional[typing.Optional[winrt.system.Int32]]
    channel_number: typing.Optional[typing.Optional[winrt.system.Int32]]
    location_area_code: typing.Optional[typing.Optional[winrt.system.Int32]]
    path_loss_in_d_b: typing.Optional[typing.Optional[winrt.system.Double]]
    provider_id: str
    received_signal_code_power_in_d_bm: typing.Optional[typing.Optional[winrt.system.Double]]
    timing_advance_in_bit_periods: typing.Optional[typing.Optional[winrt.system.Int32]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandCellTdscdma: ...

class MobileBroadbandCellUmts(winrt.system.Object):
    cell_id: typing.Optional[typing.Optional[winrt.system.Int32]]
    channel_number: typing.Optional[typing.Optional[winrt.system.Int32]]
    location_area_code: typing.Optional[typing.Optional[winrt.system.Int32]]
    path_loss_in_d_b: typing.Optional[typing.Optional[winrt.system.Double]]
    primary_scrambling_code: typing.Optional[typing.Optional[winrt.system.Int32]]
    provider_id: str
    received_signal_code_power_in_d_bm: typing.Optional[typing.Optional[winrt.system.Double]]
    signal_to_noise_ratio_in_d_b: typing.Optional[typing.Optional[winrt.system.Double]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandCellUmts: ...

class MobileBroadbandCellsInfo(winrt.system.Object):
    neighboring_cells_cdma: typing.Optional[winrt.windows.foundation.collections.IVectorView[MobileBroadbandCellCdma]]
    neighboring_cells_gsm: typing.Optional[winrt.windows.foundation.collections.IVectorView[MobileBroadbandCellGsm]]
    neighboring_cells_lte: typing.Optional[winrt.windows.foundation.collections.IVectorView[MobileBroadbandCellLte]]
    neighboring_cells_tdscdma: typing.Optional[winrt.windows.foundation.collections.IVectorView[MobileBroadbandCellTdscdma]]
    neighboring_cells_umts: typing.Optional[winrt.windows.foundation.collections.IVectorView[MobileBroadbandCellUmts]]
    serving_cells_cdma: typing.Optional[winrt.windows.foundation.collections.IVectorView[MobileBroadbandCellCdma]]
    serving_cells_gsm: typing.Optional[winrt.windows.foundation.collections.IVectorView[MobileBroadbandCellGsm]]
    serving_cells_lte: typing.Optional[winrt.windows.foundation.collections.IVectorView[MobileBroadbandCellLte]]
    serving_cells_tdscdma: typing.Optional[winrt.windows.foundation.collections.IVectorView[MobileBroadbandCellTdscdma]]
    serving_cells_umts: typing.Optional[winrt.windows.foundation.collections.IVectorView[MobileBroadbandCellUmts]]
    neighboring_cells_n_r: typing.Optional[winrt.windows.foundation.collections.IVectorView[MobileBroadbandCellNR]]
    serving_cells_n_r: typing.Optional[winrt.windows.foundation.collections.IVectorView[MobileBroadbandCellNR]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandCellsInfo: ...

class MobileBroadbandCurrentSlotIndexChangedEventArgs(winrt.system.Object):
    current_slot_index: winrt.system.Int32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandCurrentSlotIndexChangedEventArgs: ...

class MobileBroadbandDeviceInformation(winrt.system.Object):
    cellular_class: winrt.windows.devices.sms.CellularClass
    current_radio_state: MobileBroadbandRadioState
    custom_data_class: str
    data_classes: DataClasses
    device_id: str
    device_type: MobileBroadbandDeviceType
    firmware_information: str
    manufacturer: str
    mobile_equipment_id: str
    model: str
    network_device_status: NetworkDeviceStatus
    sim_icc_id: str
    subscriber_id: str
    telephone_numbers: typing.Optional[winrt.windows.foundation.collections.IVectorView[str]]
    pin_manager: typing.Optional[MobileBroadbandPinManager]
    revision: str
    serial_number: str
    sim_gid1: str
    sim_pnn: str
    sim_spn: str
    slot_manager: typing.Optional[MobileBroadbandSlotManager]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandDeviceInformation: ...

class MobileBroadbandDeviceService(winrt.system.Object):
    device_service_id: uuid.UUID
    supported_commands: typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandDeviceService: ...
    def open_command_session(self) -> typing.Optional[MobileBroadbandDeviceServiceCommandSession]: ...
    def open_data_session(self) -> typing.Optional[MobileBroadbandDeviceServiceDataSession]: ...

class MobileBroadbandDeviceServiceCommandResult(winrt.system.Object):
    response_data: typing.Optional[winrt.windows.storage.streams.IBuffer]
    status_code: winrt.system.UInt32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandDeviceServiceCommandResult: ...

class MobileBroadbandDeviceServiceCommandSession(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandDeviceServiceCommandSession: ...
    def close_session(self) -> None: ...
    def send_query_command_async(self, command_id: winrt.system.UInt32, data: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> winrt.windows.foundation.IAsyncOperation[MobileBroadbandDeviceServiceCommandResult]: ...
    def send_set_command_async(self, command_id: winrt.system.UInt32, data: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> winrt.windows.foundation.IAsyncOperation[MobileBroadbandDeviceServiceCommandResult]: ...

class MobileBroadbandDeviceServiceDataReceivedEventArgs(winrt.system.Object):
    received_data: typing.Optional[winrt.windows.storage.streams.IBuffer]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandDeviceServiceDataReceivedEventArgs: ...

class MobileBroadbandDeviceServiceDataSession(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandDeviceServiceDataSession: ...
    def close_session(self) -> None: ...
    def write_data_async(self, value: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> winrt.windows.foundation.IAsyncAction: ...
    def add_data_received(self, event_handler: winrt.windows.foundation.TypedEventHandler[MobileBroadbandDeviceServiceDataSession, MobileBroadbandDeviceServiceDataReceivedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_data_received(self, event_cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class MobileBroadbandDeviceServiceInformation(winrt.system.Object):
    device_service_id: uuid.UUID
    is_data_read_supported: winrt.system.Boolean
    is_data_write_supported: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandDeviceServiceInformation: ...

class MobileBroadbandDeviceServiceTriggerDetails(winrt.system.Object):
    device_id: str
    device_service_id: uuid.UUID
    received_data: typing.Optional[winrt.windows.storage.streams.IBuffer]
    event_id: winrt.system.UInt32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandDeviceServiceTriggerDetails: ...

class MobileBroadbandModem(winrt.system.Object):
    current_account: typing.Optional[MobileBroadbandAccount]
    current_network: typing.Optional[MobileBroadbandNetwork]
    device_information: typing.Optional[MobileBroadbandDeviceInformation]
    device_services: typing.Optional[winrt.windows.foundation.collections.IVectorView[MobileBroadbandDeviceServiceInformation]]
    is_reset_supported: winrt.system.Boolean
    max_device_service_command_size_in_bytes: winrt.system.UInt32
    max_device_service_data_size_in_bytes: winrt.system.UInt32
    is_in_emergency_call_mode: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandModem: ...
    @staticmethod
    def from_id(device_id: str, /) -> typing.Optional[MobileBroadbandModem]: ...
    def get_current_configuration_async(self) -> winrt.windows.foundation.IAsyncOperation[MobileBroadbandModemConfiguration]: ...
    @staticmethod
    def get_default() -> typing.Optional[MobileBroadbandModem]: ...
    @staticmethod
    def get_device_selector() -> str: ...
    def get_device_service(self, device_service_id: uuid.UUID, /) -> typing.Optional[MobileBroadbandDeviceService]: ...
    def get_is_passthrough_enabled(self, slotindex: winrt.system.Int32, /) -> winrt.system.Boolean: ...
    @typing.overload
    def get_is_passthrough_enabled_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...
    @typing.overload
    def get_is_passthrough_enabled_async(self, slotindex: winrt.system.Int32, /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...
    def reset_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def set_is_passthrough_enabled(self, value: winrt.system.Boolean, slotindex: winrt.system.Int32, /) -> MobileBroadbandModemStatus: ...
    @typing.overload
    def set_is_passthrough_enabled_async(self, value: winrt.system.Boolean, /) -> winrt.windows.foundation.IAsyncOperation[MobileBroadbandModemStatus]: ...
    @typing.overload
    def set_is_passthrough_enabled_async(self, value: winrt.system.Boolean, slotindex: winrt.system.Int32, /) -> winrt.windows.foundation.IAsyncOperation[MobileBroadbandModemStatus]: ...
    def try_get_pco_async(self) -> winrt.windows.foundation.IAsyncOperation[MobileBroadbandPco]: ...
    def add_is_in_emergency_call_mode_changed(self, handler: winrt.windows.foundation.TypedEventHandler[MobileBroadbandModem, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_is_in_emergency_call_mode_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class MobileBroadbandModemConfiguration(winrt.system.Object):
    home_provider_id: str
    home_provider_name: str
    uicc: typing.Optional[MobileBroadbandUicc]
    sar_manager: typing.Optional[MobileBroadbandSarManager]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandModemConfiguration: ...

class MobileBroadbandModemIsolation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandModemIsolation: ...
    def __new__(cls: typing.Type[MobileBroadbandModemIsolation], modem_device_id: str, rule_group_id: str) -> MobileBroadbandModemIsolation:...
    def add_allowed_host(self, host: typing.Optional[winrt.windows.networking.HostName], /) -> None: ...
    def add_allowed_host_range(self, first: typing.Optional[winrt.windows.networking.HostName], last: typing.Optional[winrt.windows.networking.HostName], /) -> None: ...
    def apply_configuration_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def clear_configuration_async(self) -> winrt.windows.foundation.IAsyncAction: ...

class MobileBroadbandNetwork(winrt.system.Object):
    access_point_name: str
    activation_network_error: winrt.system.UInt32
    network_adapter: typing.Optional[winrt.windows.networking.connectivity.NetworkAdapter]
    network_registration_state: NetworkRegistrationState
    packet_attach_network_error: winrt.system.UInt32
    registered_data_class: DataClasses
    registered_provider_id: str
    registered_provider_name: str
    registration_network_error: winrt.system.UInt32
    registration_uicc_apps: typing.Optional[winrt.windows.foundation.collections.IVectorView[MobileBroadbandUiccApp]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandNetwork: ...
    def get_cells_info_async(self) -> winrt.windows.foundation.IAsyncOperation[MobileBroadbandCellsInfo]: ...
    def get_voice_call_support_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...
    def show_connection_u_i(self) -> None: ...

class MobileBroadbandNetworkRegistrationStateChange(winrt.system.Object):
    device_id: str
    network: typing.Optional[MobileBroadbandNetwork]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandNetworkRegistrationStateChange: ...

class MobileBroadbandNetworkRegistrationStateChangeTriggerDetails(winrt.system.Object):
    network_registration_state_changes: typing.Optional[winrt.windows.foundation.collections.IVectorView[MobileBroadbandNetworkRegistrationStateChange]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandNetworkRegistrationStateChangeTriggerDetails: ...

class MobileBroadbandPco(winrt.system.Object):
    data: typing.Optional[winrt.windows.storage.streams.IBuffer]
    device_id: str
    is_complete: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandPco: ...

class MobileBroadbandPcoDataChangeTriggerDetails(winrt.system.Object):
    updated_data: typing.Optional[MobileBroadbandPco]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandPcoDataChangeTriggerDetails: ...

class MobileBroadbandPin(winrt.system.Object):
    attempts_remaining: winrt.system.UInt32
    enabled: winrt.system.Boolean
    format: MobileBroadbandPinFormat
    lock_state: MobileBroadbandPinLockState
    max_length: winrt.system.UInt32
    min_length: winrt.system.UInt32
    type: MobileBroadbandPinType
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandPin: ...
    def change_async(self, current_pin: str, new_pin: str, /) -> winrt.windows.foundation.IAsyncOperation[MobileBroadbandPinOperationResult]: ...
    def disable_async(self, current_pin: str, /) -> winrt.windows.foundation.IAsyncOperation[MobileBroadbandPinOperationResult]: ...
    def enable_async(self, current_pin: str, /) -> winrt.windows.foundation.IAsyncOperation[MobileBroadbandPinOperationResult]: ...
    def enter_async(self, current_pin: str, /) -> winrt.windows.foundation.IAsyncOperation[MobileBroadbandPinOperationResult]: ...
    def unblock_async(self, pin_unblock_key: str, new_pin: str, /) -> winrt.windows.foundation.IAsyncOperation[MobileBroadbandPinOperationResult]: ...

class MobileBroadbandPinLockStateChange(winrt.system.Object):
    device_id: str
    pin_lock_state: MobileBroadbandPinLockState
    pin_type: MobileBroadbandPinType
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandPinLockStateChange: ...

class MobileBroadbandPinLockStateChangeTriggerDetails(winrt.system.Object):
    pin_lock_state_changes: typing.Optional[winrt.windows.foundation.collections.IVectorView[MobileBroadbandPinLockStateChange]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandPinLockStateChangeTriggerDetails: ...

class MobileBroadbandPinManager(winrt.system.Object):
    supported_pins: typing.Optional[winrt.windows.foundation.collections.IVectorView[MobileBroadbandPinType]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandPinManager: ...
    def get_pin(self, pin_type: MobileBroadbandPinType, /) -> typing.Optional[MobileBroadbandPin]: ...

class MobileBroadbandPinOperationResult(winrt.system.Object):
    attempts_remaining: winrt.system.UInt32
    is_successful: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandPinOperationResult: ...

class MobileBroadbandRadioStateChange(winrt.system.Object):
    device_id: str
    radio_state: MobileBroadbandRadioState
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandRadioStateChange: ...

class MobileBroadbandRadioStateChangeTriggerDetails(winrt.system.Object):
    radio_state_changes: typing.Optional[winrt.windows.foundation.collections.IVectorView[MobileBroadbandRadioStateChange]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandRadioStateChangeTriggerDetails: ...

class MobileBroadbandSarManager(winrt.system.Object):
    antennas: typing.Optional[winrt.windows.foundation.collections.IVectorView[MobileBroadbandAntennaSar]]
    hysteresis_timer_period: datetime.timedelta
    is_backoff_enabled: winrt.system.Boolean
    is_sar_controlled_by_hardware: winrt.system.Boolean
    is_wi_fi_hardware_integrated: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandSarManager: ...
    def disable_backoff_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def enable_backoff_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def get_is_transmitting_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...
    def revert_sar_to_hardware_control_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def set_configuration_async(self, antennas: typing.Iterable[MobileBroadbandAntennaSar], /) -> winrt.windows.foundation.IAsyncAction: ...
    def set_transmission_state_changed_hysteresis_async(self, timer_period: datetime.timedelta, /) -> winrt.windows.foundation.IAsyncAction: ...
    def start_transmission_state_monitoring(self) -> None: ...
    def stop_transmission_state_monitoring(self) -> None: ...
    def add_transmission_state_changed(self, handler: winrt.windows.foundation.TypedEventHandler[MobileBroadbandSarManager, MobileBroadbandTransmissionStateChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_transmission_state_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class MobileBroadbandSlotInfo(winrt.system.Object):
    index: winrt.system.Int32
    state: MobileBroadbandSlotState
    icc_id: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandSlotInfo: ...

class MobileBroadbandSlotInfoChangedEventArgs(winrt.system.Object):
    slot_info: typing.Optional[MobileBroadbandSlotInfo]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandSlotInfoChangedEventArgs: ...

class MobileBroadbandSlotManager(winrt.system.Object):
    current_slot_index: winrt.system.Int32
    slot_infos: typing.Optional[winrt.windows.foundation.collections.IVectorView[MobileBroadbandSlotInfo]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandSlotManager: ...
    def set_current_slot(self, slot_index: winrt.system.Int32, /) -> MobileBroadbandModemStatus: ...
    def set_current_slot_async(self, slot_index: winrt.system.Int32, /) -> winrt.windows.foundation.IAsyncOperation[MobileBroadbandModemStatus]: ...
    def add_current_slot_index_changed(self, handler: winrt.windows.foundation.TypedEventHandler[MobileBroadbandSlotManager, MobileBroadbandCurrentSlotIndexChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_current_slot_index_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_slot_info_changed(self, handler: winrt.windows.foundation.TypedEventHandler[MobileBroadbandSlotManager, MobileBroadbandSlotInfoChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_slot_info_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class MobileBroadbandTransmissionStateChangedEventArgs(winrt.system.Object):
    is_transmitting: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandTransmissionStateChangedEventArgs: ...

class MobileBroadbandUicc(winrt.system.Object):
    sim_icc_id: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandUicc: ...
    def get_uicc_apps_async(self) -> winrt.windows.foundation.IAsyncOperation[MobileBroadbandUiccAppsResult]: ...

class MobileBroadbandUiccApp(winrt.system.Object):
    id: typing.Optional[winrt.windows.storage.streams.IBuffer]
    kind: UiccAppKind
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandUiccApp: ...
    def get_record_details_async(self, uicc_file_path: typing.Iterable[winrt.system.UInt32], /) -> winrt.windows.foundation.IAsyncOperation[MobileBroadbandUiccAppRecordDetailsResult]: ...
    def read_record_async(self, uicc_file_path: typing.Iterable[winrt.system.UInt32], record_index: winrt.system.Int32, /) -> winrt.windows.foundation.IAsyncOperation[MobileBroadbandUiccAppReadRecordResult]: ...

class MobileBroadbandUiccAppReadRecordResult(winrt.system.Object):
    data: typing.Optional[winrt.windows.storage.streams.IBuffer]
    status: MobileBroadbandUiccAppOperationStatus
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandUiccAppReadRecordResult: ...

class MobileBroadbandUiccAppRecordDetailsResult(winrt.system.Object):
    kind: UiccAppRecordKind
    read_access_condition: UiccAccessCondition
    record_count: winrt.system.Int32
    record_size: winrt.system.Int32
    status: MobileBroadbandUiccAppOperationStatus
    write_access_condition: UiccAccessCondition
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandUiccAppRecordDetailsResult: ...

class MobileBroadbandUiccAppsResult(winrt.system.Object):
    status: MobileBroadbandUiccAppOperationStatus
    uicc_apps: typing.Optional[winrt.windows.foundation.collections.IVectorView[MobileBroadbandUiccApp]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MobileBroadbandUiccAppsResult: ...

class NetworkOperatorDataUsageTriggerDetails(winrt.system.Object):
    notification_kind: NetworkOperatorDataUsageNotificationKind
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NetworkOperatorDataUsageTriggerDetails: ...

class NetworkOperatorNotificationEventDetails(winrt.system.Object):
    encoding_type: winrt.system.UInt8
    message: str
    network_account_id: str
    notification_type: NetworkOperatorEventMessageType
    rule_id: str
    sms_message: typing.Optional[winrt.windows.devices.sms.ISmsMessage]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NetworkOperatorNotificationEventDetails: ...
    def authorize_tethering(self, allow: winrt.system.Boolean, entitlement_failure_reason: str, /) -> None: ...

class NetworkOperatorTetheringAccessPointConfiguration(winrt.system.Object):
    ssid: str
    passphrase: str
    band: TetheringWiFiBand
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NetworkOperatorTetheringAccessPointConfiguration: ...
    def __new__(cls: typing.Type[NetworkOperatorTetheringAccessPointConfiguration]) -> NetworkOperatorTetheringAccessPointConfiguration:...
    def is_band_supported(self, band: TetheringWiFiBand, /) -> winrt.system.Boolean: ...
    def is_band_supported_async(self, band: TetheringWiFiBand, /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...

class NetworkOperatorTetheringClient(winrt.system.Object):
    host_names: typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.networking.HostName]]
    mac_address: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NetworkOperatorTetheringClient: ...

class NetworkOperatorTetheringManager(winrt.system.Object):
    client_count: winrt.system.UInt32
    max_client_count: winrt.system.UInt32
    tethering_operational_state: TetheringOperationalState
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NetworkOperatorTetheringManager: ...
    def configure_access_point_async(self, configuration: typing.Optional[NetworkOperatorTetheringAccessPointConfiguration], /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    @staticmethod
    def create_from_connection_profile(profile: typing.Optional[winrt.windows.networking.connectivity.ConnectionProfile], /) -> typing.Optional[NetworkOperatorTetheringManager]: ...
    @typing.overload
    @staticmethod
    def create_from_connection_profile(profile: typing.Optional[winrt.windows.networking.connectivity.ConnectionProfile], adapter: typing.Optional[winrt.windows.networking.connectivity.NetworkAdapter], /) -> typing.Optional[NetworkOperatorTetheringManager]: ...
    @staticmethod
    def create_from_network_account_id(network_account_id: str, /) -> typing.Optional[NetworkOperatorTetheringManager]: ...
    @staticmethod
    def disable_no_connections_timeout() -> None: ...
    @staticmethod
    def disable_no_connections_timeout_async() -> winrt.windows.foundation.IAsyncAction: ...
    @staticmethod
    def enable_no_connections_timeout() -> None: ...
    @staticmethod
    def enable_no_connections_timeout_async() -> winrt.windows.foundation.IAsyncAction: ...
    def get_current_access_point_configuration(self) -> typing.Optional[NetworkOperatorTetheringAccessPointConfiguration]: ...
    @staticmethod
    def get_tethering_capability(network_account_id: str, /) -> TetheringCapability: ...
    @staticmethod
    def get_tethering_capability_from_connection_profile(profile: typing.Optional[winrt.windows.networking.connectivity.ConnectionProfile], /) -> TetheringCapability: ...
    def get_tethering_clients(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[NetworkOperatorTetheringClient]]: ...
    @staticmethod
    def is_no_connections_timeout_enabled() -> winrt.system.Boolean: ...
    def start_tethering_async(self) -> winrt.windows.foundation.IAsyncOperation[NetworkOperatorTetheringOperationResult]: ...
    def stop_tethering_async(self) -> winrt.windows.foundation.IAsyncOperation[NetworkOperatorTetheringOperationResult]: ...

class NetworkOperatorTetheringOperationResult(winrt.system.Object):
    additional_error_message: str
    status: TetheringOperationStatus
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NetworkOperatorTetheringOperationResult: ...

class ProvisionFromXmlDocumentResults(winrt.system.Object):
    all_elements_provisioned: winrt.system.Boolean
    provision_results_xml: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProvisionFromXmlDocumentResults: ...

class ProvisionedProfile(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProvisionedProfile: ...
    def update_cost(self, value: winrt.windows.networking.connectivity.NetworkCostType, /) -> None: ...
    def update_usage(self, value: ProfileUsage, /) -> None: ...

class ProvisioningAgent(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProvisioningAgent: ...
    def __new__(cls: typing.Type[ProvisioningAgent]) -> ProvisioningAgent:...
    @staticmethod
    def create_from_network_account_id(network_account_id: str, /) -> typing.Optional[ProvisioningAgent]: ...
    def get_provisioned_profile(self, media_type: ProfileMediaType, profile_name: str, /) -> typing.Optional[ProvisionedProfile]: ...
    def provision_from_xml_document_async(self, provisioning_xml_document: str, /) -> winrt.windows.foundation.IAsyncOperation[ProvisionFromXmlDocumentResults]: ...

class TetheringEntitlementCheckTriggerDetails(winrt.system.Object):
    network_account_id: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TetheringEntitlementCheckTriggerDetails: ...
    def allow_tethering(self) -> None: ...
    def deny_tethering(self, entitlement_failure_reason: str, /) -> None: ...

class UssdMessage(winrt.system.Object):
    payload_as_text: str
    data_coding_scheme: winrt.system.UInt8
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UssdMessage: ...
    def __new__(cls: typing.Type[UssdMessage], message_text: str) -> UssdMessage:...
    def get_payload(self) -> winrt.system.UInt8: ...
    def set_payload(self, value: winrt.system.Array[winrt.system.UInt8], /) -> None: ...

class UssdReply(winrt.system.Object):
    message: typing.Optional[UssdMessage]
    result_code: UssdResultCode
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UssdReply: ...

class UssdSession(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UssdSession: ...
    def close(self) -> None: ...
    @staticmethod
    def create_from_network_account_id(network_account_id: str, /) -> typing.Optional[UssdSession]: ...
    @staticmethod
    def create_from_network_interface_id(network_interface_id: str, /) -> typing.Optional[UssdSession]: ...
    def send_message_and_get_reply_async(self, message: typing.Optional[UssdMessage], /) -> winrt.windows.foundation.IAsyncOperation[UssdReply]: ...

