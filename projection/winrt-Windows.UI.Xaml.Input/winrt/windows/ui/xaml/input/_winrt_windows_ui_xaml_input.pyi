# WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

import datetime
import sys
import types
import typing
import uuid

import winrt.system
import winrt.windows.devices.input
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.system
import winrt.windows.ui.core
import winrt.windows.ui.input
import winrt.windows.ui.xaml
import winrt.windows.ui.xaml.controls

from . import FocusInputDeviceKind, FocusNavigationDirection, InputScopeNameValue, KeyTipPlacementMode, KeyboardAcceleratorPlacementMode, KeyboardNavigationMode, ManipulationModes, StandardUICommandKind, XYFocusKeyboardNavigationMode, XYFocusNavigationStrategy, XYFocusNavigationStrategyOverride
from . import DoubleTappedEventHandler, HoldingEventHandler, KeyEventHandler, ManipulationCompletedEventHandler, ManipulationDeltaEventHandler, ManipulationInertiaStartingEventHandler, ManipulationStartedEventHandler, ManipulationStartingEventHandler, PointerEventHandler, RightTappedEventHandler, TappedEventHandler

Self = typing.TypeVar('Self')

class AccessKeyDisplayDismissedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AccessKeyDisplayDismissedEventArgs: ...
    def __new__(cls: typing.Type[AccessKeyDisplayDismissedEventArgs]) -> AccessKeyDisplayDismissedEventArgs:...

class AccessKeyDisplayRequestedEventArgs(winrt.system.Object):
    pressed_keys: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AccessKeyDisplayRequestedEventArgs: ...
    def __new__(cls: typing.Type[AccessKeyDisplayRequestedEventArgs]) -> AccessKeyDisplayRequestedEventArgs:...

class AccessKeyInvokedEventArgs(winrt.system.Object):
    handled: bool
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AccessKeyInvokedEventArgs: ...
    def __new__(cls: typing.Type[AccessKeyInvokedEventArgs]) -> AccessKeyInvokedEventArgs:...

class AccessKeyManager(winrt.system.Object):
    is_display_mode_enabled: typing.ClassVar[bool]
    are_key_tips_enabled: typing.ClassVar[bool]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AccessKeyManager: ...
    @staticmethod
    def exit_display_mode() -> None: ...
    @staticmethod
    def add_is_display_mode_enabled_changed(handler: winrt.windows.foundation.TypedEventHandler[winrt.system.Object, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    @staticmethod
    def remove_is_display_mode_enabled_changed(token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class CanExecuteRequestedEventArgs(winrt.system.Object):
    can_execute: bool
    parameter: typing.Optional[winrt.system.Object]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CanExecuteRequestedEventArgs: ...

class CharacterReceivedRoutedEventArgs(winrt.system.Object):
    handled: bool
    character: winrt.system.Char16
    key_status: winrt.windows.ui.core.CorePhysicalKeyStatus
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CharacterReceivedRoutedEventArgs: ...

class ContextRequestedEventArgs(winrt.system.Object):
    handled: bool
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ContextRequestedEventArgs: ...
    def __new__(cls: typing.Type[ContextRequestedEventArgs]) -> ContextRequestedEventArgs:...
    def try_get_position(self, relative_to: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> typing.Tuple[bool, winrt.windows.foundation.Point]: ...

class DoubleTappedRoutedEventArgs(winrt.system.Object):
    handled: bool
    pointer_device_type: winrt.windows.devices.input.PointerDeviceType
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DoubleTappedRoutedEventArgs: ...
    def __new__(cls: typing.Type[DoubleTappedRoutedEventArgs]) -> DoubleTappedRoutedEventArgs:...
    def get_position(self, relative_to: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> winrt.windows.foundation.Point: ...

class ExecuteRequestedEventArgs(winrt.system.Object):
    parameter: typing.Optional[winrt.system.Object]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ExecuteRequestedEventArgs: ...

class FindNextElementOptions(winrt.system.Object):
    x_y_focus_navigation_strategy_override: XYFocusNavigationStrategyOverride
    search_root: typing.Optional[winrt.windows.ui.xaml.DependencyObject]
    hint_rect: winrt.windows.foundation.Rect
    exclusion_rect: winrt.windows.foundation.Rect
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FindNextElementOptions: ...
    def __new__(cls: typing.Type[FindNextElementOptions]) -> FindNextElementOptions:...

class FocusManager(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FocusManager: ...
    @staticmethod
    def find_first_focusable_element(search_scope: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    @staticmethod
    def find_last_focusable_element(search_scope: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    @typing.overload
    @staticmethod
    def find_next_element(focus_navigation_direction: FocusNavigationDirection, /) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    @typing.overload
    @staticmethod
    def find_next_element(focus_navigation_direction: FocusNavigationDirection, focus_navigation_options: typing.Optional[FindNextElementOptions], /) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    @typing.overload
    @staticmethod
    def find_next_focusable_element(focus_navigation_direction: FocusNavigationDirection, /) -> typing.Optional[winrt.windows.ui.xaml.UIElement]: ...
    @typing.overload
    @staticmethod
    def find_next_focusable_element(focus_navigation_direction: FocusNavigationDirection, hint_rect: winrt.windows.foundation.Rect, /) -> typing.Optional[winrt.windows.ui.xaml.UIElement]: ...
    @typing.overload
    @staticmethod
    def get_focused_element() -> typing.Optional[winrt.system.Object]: ...
    @typing.overload
    @staticmethod
    def get_focused_element(xaml_root: typing.Optional[winrt.windows.ui.xaml.XamlRoot], /) -> typing.Optional[winrt.system.Object]: ...
    @staticmethod
    def try_focus_async(element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], value: winrt.windows.ui.xaml.FocusState, /) -> winrt.windows.foundation.IAsyncOperation[FocusMovementResult]: ...
    @typing.overload
    @staticmethod
    def try_move_focus(focus_navigation_direction: FocusNavigationDirection, /) -> bool: ...
    @typing.overload
    @staticmethod
    def try_move_focus(focus_navigation_direction: FocusNavigationDirection, focus_navigation_options: typing.Optional[FindNextElementOptions], /) -> bool: ...
    @typing.overload
    @staticmethod
    def try_move_focus_async(focus_navigation_direction: FocusNavigationDirection, /) -> winrt.windows.foundation.IAsyncOperation[FocusMovementResult]: ...
    @typing.overload
    @staticmethod
    def try_move_focus_async(focus_navigation_direction: FocusNavigationDirection, focus_navigation_options: typing.Optional[FindNextElementOptions], /) -> winrt.windows.foundation.IAsyncOperation[FocusMovementResult]: ...
    @staticmethod
    def add_getting_focus(handler: winrt.windows.foundation.EventHandler[GettingFocusEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    @staticmethod
    def remove_getting_focus(token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @staticmethod
    def add_got_focus(handler: winrt.windows.foundation.EventHandler[FocusManagerGotFocusEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    @staticmethod
    def remove_got_focus(token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @staticmethod
    def add_losing_focus(handler: winrt.windows.foundation.EventHandler[LosingFocusEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    @staticmethod
    def remove_losing_focus(token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @staticmethod
    def add_lost_focus(handler: winrt.windows.foundation.EventHandler[FocusManagerLostFocusEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    @staticmethod
    def remove_lost_focus(token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class FocusManagerGotFocusEventArgs(winrt.system.Object):
    correlation_id: uuid.UUID
    new_focused_element: typing.Optional[winrt.windows.ui.xaml.DependencyObject]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FocusManagerGotFocusEventArgs: ...

class FocusManagerLostFocusEventArgs(winrt.system.Object):
    correlation_id: uuid.UUID
    old_focused_element: typing.Optional[winrt.windows.ui.xaml.DependencyObject]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FocusManagerLostFocusEventArgs: ...

class FocusMovementResult(winrt.system.Object):
    succeeded: bool
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FocusMovementResult: ...

class GettingFocusEventArgs(winrt.system.Object):
    new_focused_element: typing.Optional[winrt.windows.ui.xaml.DependencyObject]
    handled: bool
    cancel: bool
    direction: FocusNavigationDirection
    focus_state: winrt.windows.ui.xaml.FocusState
    input_device: FocusInputDeviceKind
    old_focused_element: typing.Optional[winrt.windows.ui.xaml.DependencyObject]
    correlation_id: uuid.UUID
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GettingFocusEventArgs: ...
    def try_cancel(self) -> bool: ...
    def try_set_new_focused_element(self, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> bool: ...

class HoldingRoutedEventArgs(winrt.system.Object):
    handled: bool
    holding_state: winrt.windows.ui.input.HoldingState
    pointer_device_type: winrt.windows.devices.input.PointerDeviceType
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HoldingRoutedEventArgs: ...
    def __new__(cls: typing.Type[HoldingRoutedEventArgs]) -> HoldingRoutedEventArgs:...
    def get_position(self, relative_to: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> winrt.windows.foundation.Point: ...

class InertiaExpansionBehavior(winrt.system.Object):
    desired_expansion: winrt.system.Double
    desired_deceleration: winrt.system.Double
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InertiaExpansionBehavior: ...

class InertiaRotationBehavior(winrt.system.Object):
    desired_rotation: winrt.system.Double
    desired_deceleration: winrt.system.Double
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InertiaRotationBehavior: ...

class InertiaTranslationBehavior(winrt.system.Object):
    desired_displacement: winrt.system.Double
    desired_deceleration: winrt.system.Double
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InertiaTranslationBehavior: ...

class InputScope(winrt.system.Object):
    names: typing.Optional[winrt.windows.foundation.collections.IVector[InputScopeName]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InputScope: ...
    def __new__(cls: typing.Type[InputScope]) -> InputScope:...

class InputScopeName(winrt.system.Object):
    name_value: InputScopeNameValue
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InputScopeName: ...
    @typing.overload
    def __new__(cls: typing.Type[InputScopeName], name_value: InputScopeNameValue) -> InputScopeName:...
    @typing.overload
    def __new__(cls: typing.Type[InputScopeName]) -> InputScopeName:...

class KeyRoutedEventArgs(winrt.system.Object):
    handled: bool
    key: winrt.windows.system.VirtualKey
    key_status: winrt.windows.ui.core.CorePhysicalKeyStatus
    original_key: winrt.windows.system.VirtualKey
    device_id: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> KeyRoutedEventArgs: ...

class KeyboardAccelerator(winrt.system.Object):
    scope_owner: typing.Optional[winrt.windows.ui.xaml.DependencyObject]
    modifiers: winrt.windows.system.VirtualKeyModifiers
    key: winrt.windows.system.VirtualKey
    is_enabled: bool
    is_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    key_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    modifiers_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    scope_owner_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> KeyboardAccelerator: ...
    def __new__(cls: typing.Type[KeyboardAccelerator]) -> KeyboardAccelerator:...
    def add_invoked(self, handler: winrt.windows.foundation.TypedEventHandler[KeyboardAccelerator, KeyboardAcceleratorInvokedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_invoked(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class KeyboardAcceleratorInvokedEventArgs(winrt.system.Object):
    handled: bool
    element: typing.Optional[winrt.windows.ui.xaml.DependencyObject]
    keyboard_accelerator: typing.Optional[KeyboardAccelerator]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> KeyboardAcceleratorInvokedEventArgs: ...

class LosingFocusEventArgs(winrt.system.Object):
    new_focused_element: typing.Optional[winrt.windows.ui.xaml.DependencyObject]
    handled: bool
    cancel: bool
    direction: FocusNavigationDirection
    focus_state: winrt.windows.ui.xaml.FocusState
    input_device: FocusInputDeviceKind
    old_focused_element: typing.Optional[winrt.windows.ui.xaml.DependencyObject]
    correlation_id: uuid.UUID
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LosingFocusEventArgs: ...
    def try_cancel(self) -> bool: ...
    def try_set_new_focused_element(self, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> bool: ...

class ManipulationCompletedRoutedEventArgs(winrt.system.Object):
    handled: bool
    container: typing.Optional[winrt.windows.ui.xaml.UIElement]
    cumulative: winrt.windows.ui.input.ManipulationDelta
    is_inertial: bool
    pointer_device_type: winrt.windows.devices.input.PointerDeviceType
    position: winrt.windows.foundation.Point
    velocities: winrt.windows.ui.input.ManipulationVelocities
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ManipulationCompletedRoutedEventArgs: ...
    def __new__(cls: typing.Type[ManipulationCompletedRoutedEventArgs]) -> ManipulationCompletedRoutedEventArgs:...

class ManipulationDeltaRoutedEventArgs(winrt.system.Object):
    handled: bool
    container: typing.Optional[winrt.windows.ui.xaml.UIElement]
    cumulative: winrt.windows.ui.input.ManipulationDelta
    delta: winrt.windows.ui.input.ManipulationDelta
    is_inertial: bool
    pointer_device_type: winrt.windows.devices.input.PointerDeviceType
    position: winrt.windows.foundation.Point
    velocities: winrt.windows.ui.input.ManipulationVelocities
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ManipulationDeltaRoutedEventArgs: ...
    def __new__(cls: typing.Type[ManipulationDeltaRoutedEventArgs]) -> ManipulationDeltaRoutedEventArgs:...
    def complete(self) -> None: ...

class ManipulationInertiaStartingRoutedEventArgs(winrt.system.Object):
    translation_behavior: typing.Optional[InertiaTranslationBehavior]
    rotation_behavior: typing.Optional[InertiaRotationBehavior]
    handled: bool
    expansion_behavior: typing.Optional[InertiaExpansionBehavior]
    container: typing.Optional[winrt.windows.ui.xaml.UIElement]
    cumulative: winrt.windows.ui.input.ManipulationDelta
    delta: winrt.windows.ui.input.ManipulationDelta
    pointer_device_type: winrt.windows.devices.input.PointerDeviceType
    velocities: winrt.windows.ui.input.ManipulationVelocities
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ManipulationInertiaStartingRoutedEventArgs: ...
    def __new__(cls: typing.Type[ManipulationInertiaStartingRoutedEventArgs]) -> ManipulationInertiaStartingRoutedEventArgs:...

class ManipulationPivot(winrt.system.Object):
    radius: winrt.system.Double
    center: winrt.windows.foundation.Point
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ManipulationPivot: ...
    @typing.overload
    def __new__(cls: typing.Type[ManipulationPivot], center: winrt.windows.foundation.Point, radius: winrt.system.Double) -> ManipulationPivot:...
    @typing.overload
    def __new__(cls: typing.Type[ManipulationPivot]) -> ManipulationPivot:...

class ManipulationStartedRoutedEventArgs(winrt.system.Object):
    handled: bool
    container: typing.Optional[winrt.windows.ui.xaml.UIElement]
    cumulative: winrt.windows.ui.input.ManipulationDelta
    pointer_device_type: winrt.windows.devices.input.PointerDeviceType
    position: winrt.windows.foundation.Point
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ManipulationStartedRoutedEventArgs: ...
    def __new__(cls: typing.Type[ManipulationStartedRoutedEventArgs]) -> ManipulationStartedRoutedEventArgs:...
    def complete(self) -> None: ...

class ManipulationStartingRoutedEventArgs(winrt.system.Object):
    pivot: typing.Optional[ManipulationPivot]
    mode: ManipulationModes
    handled: bool
    container: typing.Optional[winrt.windows.ui.xaml.UIElement]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ManipulationStartingRoutedEventArgs: ...
    def __new__(cls: typing.Type[ManipulationStartingRoutedEventArgs]) -> ManipulationStartingRoutedEventArgs:...

class NoFocusCandidateFoundEventArgs(winrt.system.Object):
    handled: bool
    direction: FocusNavigationDirection
    input_device: FocusInputDeviceKind
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NoFocusCandidateFoundEventArgs: ...

class Pointer(winrt.system.Object):
    is_in_contact: bool
    is_in_range: bool
    pointer_device_type: winrt.windows.devices.input.PointerDeviceType
    pointer_id: winrt.system.UInt32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Pointer: ...

class PointerRoutedEventArgs(winrt.system.Object):
    handled: bool
    key_modifiers: winrt.windows.system.VirtualKeyModifiers
    pointer: typing.Optional[Pointer]
    is_generated: bool
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PointerRoutedEventArgs: ...
    def get_current_point(self, relative_to: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> typing.Optional[winrt.windows.ui.input.PointerPoint]: ...
    def get_intermediate_points(self, relative_to: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.ui.input.PointerPoint]]: ...

class ProcessKeyboardAcceleratorEventArgs(winrt.system.Object):
    handled: bool
    key: winrt.windows.system.VirtualKey
    modifiers: winrt.windows.system.VirtualKeyModifiers
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProcessKeyboardAcceleratorEventArgs: ...

class RightTappedRoutedEventArgs(winrt.system.Object):
    handled: bool
    pointer_device_type: winrt.windows.devices.input.PointerDeviceType
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RightTappedRoutedEventArgs: ...
    def __new__(cls: typing.Type[RightTappedRoutedEventArgs]) -> RightTappedRoutedEventArgs:...
    def get_position(self, relative_to: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> winrt.windows.foundation.Point: ...

class StandardUICommand(winrt.system.Object):
    kind: StandardUICommandKind
    kind_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StandardUICommand: ...
    @typing.overload
    def __new__(cls: typing.Type[StandardUICommand]) -> StandardUICommand:...
    @typing.overload
    def __new__(cls: typing.Type[StandardUICommand], kind: StandardUICommandKind) -> StandardUICommand:...

class TappedRoutedEventArgs(winrt.system.Object):
    handled: bool
    pointer_device_type: winrt.windows.devices.input.PointerDeviceType
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TappedRoutedEventArgs: ...
    def __new__(cls: typing.Type[TappedRoutedEventArgs]) -> TappedRoutedEventArgs:...
    def get_position(self, relative_to: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> winrt.windows.foundation.Point: ...

class XamlUICommand(winrt.system.Object):
    label: str
    icon_source: typing.Optional[winrt.windows.ui.xaml.controls.IconSource]
    description: str
    command: typing.Optional[ICommand]
    access_key: str
    keyboard_accelerators: typing.Optional[winrt.windows.foundation.collections.IVector[KeyboardAccelerator]]
    access_key_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    command_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    description_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    icon_source_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    keyboard_accelerators_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    label_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> XamlUICommand: ...
    def __new__(cls: typing.Type[XamlUICommand]) -> XamlUICommand:...
    def can_execute(self, parameter: typing.Optional[winrt.system.Object], /) -> bool: ...
    def execute(self, parameter: typing.Optional[winrt.system.Object], /) -> None: ...
    def notify_can_execute_changed(self) -> None: ...
    def add_can_execute_requested(self, handler: winrt.windows.foundation.TypedEventHandler[XamlUICommand, CanExecuteRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_can_execute_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_execute_requested(self, handler: winrt.windows.foundation.TypedEventHandler[XamlUICommand, ExecuteRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_execute_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_can_execute_changed(self, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_can_execute_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class ICommand(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ICommand: ...
    def can_execute(self, parameter: typing.Optional[winrt.system.Object], /) -> bool: ...
    def execute(self, parameter: typing.Optional[winrt.system.Object], /) -> None: ...
    def add_can_execute_changed(self, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_can_execute_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

