# WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

import enum
import datetime
import sys
import types
import typing

import winrt.system
import winrt.windows.devices.input
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.system
import winrt.windows.ui.core
import winrt.windows.ui.input
import winrt.windows.ui.xaml
import winrt.windows.ui.xaml.controls

class FocusInputDeviceKind(enum.IntEnum):
    NONE = 0
    MOUSE = 1
    TOUCH = 2
    PEN = 3
    KEYBOARD = 4
    GAME_CONTROLLER = 5

class FocusNavigationDirection(enum.IntEnum):
    NEXT = 0
    PREVIOUS = 1
    UP = 2
    DOWN = 3
    LEFT = 4
    RIGHT = 5
    NONE = 6

class InputScopeNameValue(enum.IntEnum):
    DEFAULT = 0
    URL = 1
    EMAIL_SMTP_ADDRESS = 5
    PERSONAL_FULL_NAME = 7
    CURRENCY_AMOUNT_AND_SYMBOL = 20
    CURRENCY_AMOUNT = 21
    DATE_MONTH_NUMBER = 23
    DATE_DAY_NUMBER = 24
    DATE_YEAR = 25
    DIGITS = 28
    NUMBER = 29
    PASSWORD = 31
    TELEPHONE_NUMBER = 32
    TELEPHONE_COUNTRY_CODE = 33
    TELEPHONE_AREA_CODE = 34
    TELEPHONE_LOCAL_NUMBER = 35
    TIME_HOUR = 37
    TIME_MINUTES_OR_SECONDS = 38
    NUMBER_FULL_WIDTH = 39
    ALPHANUMERIC_HALF_WIDTH = 40
    ALPHANUMERIC_FULL_WIDTH = 41
    HIRAGANA = 44
    KATAKANA_HALF_WIDTH = 45
    KATAKANA_FULL_WIDTH = 46
    HANJA = 47
    HANGUL_HALF_WIDTH = 48
    HANGUL_FULL_WIDTH = 49
    SEARCH = 50
    FORMULA = 51
    SEARCH_INCREMENTAL = 52
    CHINESE_HALF_WIDTH = 53
    CHINESE_FULL_WIDTH = 54
    NATIVE_SCRIPT = 55
    TEXT = 57
    CHAT = 58
    NAME_OR_PHONE_NUMBER = 59
    EMAIL_NAME_OR_ADDRESS = 60
    PRIVATE = 61
    MAPS = 62
    NUMERIC_PASSWORD = 63
    NUMERIC_PIN = 64
    ALPHANUMERIC_PIN = 65
    FORMULA_NUMBER = 67
    CHAT_WITHOUT_EMOJI = 68

class KeyTipPlacementMode(enum.IntEnum):
    AUTO = 0
    BOTTOM = 1
    TOP = 2
    LEFT = 3
    RIGHT = 4
    CENTER = 5
    HIDDEN = 6

class KeyboardAcceleratorPlacementMode(enum.IntEnum):
    AUTO = 0
    HIDDEN = 1

class KeyboardNavigationMode(enum.IntEnum):
    LOCAL = 0
    CYCLE = 1
    ONCE = 2

class ManipulationModes(enum.IntFlag):
    NONE = 0
    TRANSLATE_X = 0x1
    TRANSLATE_Y = 0x2
    TRANSLATE_RAILS_X = 0x4
    TRANSLATE_RAILS_Y = 0x8
    ROTATE = 0x10
    SCALE = 0x20
    TRANSLATE_INERTIA = 0x40
    ROTATE_INERTIA = 0x80
    SCALE_INERTIA = 0x100
    ALL = 0xffff
    SYSTEM = 0x10000

class StandardUICommandKind(enum.IntEnum):
    NONE = 0
    CUT = 1
    COPY = 2
    PASTE = 3
    SELECT_ALL = 4
    DELETE = 5
    SHARE = 6
    SAVE = 7
    OPEN = 8
    CLOSE = 9
    PAUSE = 10
    PLAY = 11
    STOP = 12
    FORWARD = 13
    BACKWARD = 14
    UNDO = 15
    REDO = 16

class XYFocusKeyboardNavigationMode(enum.IntEnum):
    AUTO = 0
    ENABLED = 1
    DISABLED = 2

class XYFocusNavigationStrategy(enum.IntEnum):
    AUTO = 0
    PROJECTION = 1
    NAVIGATION_DIRECTION_DISTANCE = 2
    RECTILINEAR_DISTANCE = 3

class XYFocusNavigationStrategyOverride(enum.IntEnum):
    NONE = 0
    AUTO = 1
    PROJECTION = 2
    NAVIGATION_DIRECTION_DISTANCE = 3
    RECTILINEAR_DISTANCE = 4

Self = typing.TypeVar('Self')

class AccessKeyDisplayDismissedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AccessKeyDisplayDismissedEventArgs: ...
    def __new__(cls: typing.Type[AccessKeyDisplayDismissedEventArgs]) -> AccessKeyDisplayDismissedEventArgs:...

class AccessKeyDisplayRequestedEventArgs(winrt.system.Object):
    pressed_keys: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AccessKeyDisplayRequestedEventArgs: ...
    def __new__(cls: typing.Type[AccessKeyDisplayRequestedEventArgs]) -> AccessKeyDisplayRequestedEventArgs:...

class AccessKeyInvokedEventArgs(winrt.system.Object):
    handled: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AccessKeyInvokedEventArgs: ...
    def __new__(cls: typing.Type[AccessKeyInvokedEventArgs]) -> AccessKeyInvokedEventArgs:...

class AccessKeyManager(winrt.system.Object):
    is_display_mode_enabled: typing.ClassVar[winrt.system.Boolean]
    are_key_tips_enabled: typing.ClassVar[winrt.system.Boolean]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AccessKeyManager: ...
    @staticmethod
    def exit_display_mode() -> None: ...
    @staticmethod
    def add_is_display_mode_enabled_changed(handler: winrt.windows.foundation.TypedEventHandler[winrt.system.Object, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    @staticmethod
    def remove_is_display_mode_enabled_changed(token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class CanExecuteRequestedEventArgs(winrt.system.Object):
    can_execute: winrt.system.Boolean
    parameter: typing.Optional[winrt.system.Object]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CanExecuteRequestedEventArgs: ...

class CharacterReceivedRoutedEventArgs(winrt.system.Object):
    handled: winrt.system.Boolean
    character: winrt.system.Char16
    key_status: winrt.windows.ui.core.CorePhysicalKeyStatus
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CharacterReceivedRoutedEventArgs: ...

class ContextRequestedEventArgs(winrt.system.Object):
    handled: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ContextRequestedEventArgs: ...
    def __new__(cls: typing.Type[ContextRequestedEventArgs]) -> ContextRequestedEventArgs:...
    def try_get_position(self, relative_to: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> typing.Tuple[winrt.system.Boolean, winrt.windows.foundation.Point]: ...

class DoubleTappedRoutedEventArgs(winrt.system.Object):
    handled: winrt.system.Boolean
    pointer_device_type: winrt.windows.devices.input.PointerDeviceType
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DoubleTappedRoutedEventArgs: ...
    def __new__(cls: typing.Type[DoubleTappedRoutedEventArgs]) -> DoubleTappedRoutedEventArgs:...
    def get_position(self, relative_to: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> winrt.windows.foundation.Point: ...

class ExecuteRequestedEventArgs(winrt.system.Object):
    parameter: typing.Optional[winrt.system.Object]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ExecuteRequestedEventArgs: ...

class FindNextElementOptions(winrt.system.Object):
    x_y_focus_navigation_strategy_override: XYFocusNavigationStrategyOverride
    search_root: typing.Optional[winrt.windows.ui.xaml.DependencyObject]
    hint_rect: winrt.windows.foundation.Rect
    exclusion_rect: winrt.windows.foundation.Rect
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FindNextElementOptions: ...
    def __new__(cls: typing.Type[FindNextElementOptions]) -> FindNextElementOptions:...

class FocusManager(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FocusManager: ...
    @staticmethod
    def find_first_focusable_element(search_scope: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    @staticmethod
    def find_last_focusable_element(search_scope: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    @typing.overload
    @staticmethod
    def find_next_element(focus_navigation_direction: FocusNavigationDirection, /) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    @typing.overload
    @staticmethod
    def find_next_element(focus_navigation_direction: FocusNavigationDirection, focus_navigation_options: typing.Optional[FindNextElementOptions], /) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    @typing.overload
    @staticmethod
    def find_next_focusable_element(focus_navigation_direction: FocusNavigationDirection, /) -> typing.Optional[winrt.windows.ui.xaml.UIElement]: ...
    @typing.overload
    @staticmethod
    def find_next_focusable_element(focus_navigation_direction: FocusNavigationDirection, hint_rect: winrt.windows.foundation.Rect, /) -> typing.Optional[winrt.windows.ui.xaml.UIElement]: ...
    @typing.overload
    @staticmethod
    def get_focused_element() -> typing.Optional[winrt.system.Object]: ...
    @typing.overload
    @staticmethod
    def get_focused_element(xaml_root: typing.Optional[winrt.windows.ui.xaml.XamlRoot], /) -> typing.Optional[winrt.system.Object]: ...
    @staticmethod
    def try_focus_async(element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], value: winrt.windows.ui.xaml.FocusState, /) -> winrt.windows.foundation.IAsyncOperation[FocusMovementResult]: ...
    @typing.overload
    @staticmethod
    def try_move_focus(focus_navigation_direction: FocusNavigationDirection, /) -> winrt.system.Boolean: ...
    @typing.overload
    @staticmethod
    def try_move_focus(focus_navigation_direction: FocusNavigationDirection, focus_navigation_options: typing.Optional[FindNextElementOptions], /) -> winrt.system.Boolean: ...
    @typing.overload
    @staticmethod
    def try_move_focus_async(focus_navigation_direction: FocusNavigationDirection, /) -> winrt.windows.foundation.IAsyncOperation[FocusMovementResult]: ...
    @typing.overload
    @staticmethod
    def try_move_focus_async(focus_navigation_direction: FocusNavigationDirection, focus_navigation_options: typing.Optional[FindNextElementOptions], /) -> winrt.windows.foundation.IAsyncOperation[FocusMovementResult]: ...
    @staticmethod
    def add_getting_focus(handler: winrt.windows.foundation.EventHandler[GettingFocusEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    @staticmethod
    def remove_getting_focus(token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @staticmethod
    def add_got_focus(handler: winrt.windows.foundation.EventHandler[FocusManagerGotFocusEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    @staticmethod
    def remove_got_focus(token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @staticmethod
    def add_losing_focus(handler: winrt.windows.foundation.EventHandler[LosingFocusEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    @staticmethod
    def remove_losing_focus(token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @staticmethod
    def add_lost_focus(handler: winrt.windows.foundation.EventHandler[FocusManagerLostFocusEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    @staticmethod
    def remove_lost_focus(token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class FocusManagerGotFocusEventArgs(winrt.system.Object):
    correlation_id: winrt.system.Guid
    new_focused_element: typing.Optional[winrt.windows.ui.xaml.DependencyObject]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FocusManagerGotFocusEventArgs: ...

class FocusManagerLostFocusEventArgs(winrt.system.Object):
    correlation_id: winrt.system.Guid
    old_focused_element: typing.Optional[winrt.windows.ui.xaml.DependencyObject]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FocusManagerLostFocusEventArgs: ...

class FocusMovementResult(winrt.system.Object):
    succeeded: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FocusMovementResult: ...

class GettingFocusEventArgs(winrt.system.Object):
    new_focused_element: typing.Optional[winrt.windows.ui.xaml.DependencyObject]
    handled: winrt.system.Boolean
    cancel: winrt.system.Boolean
    direction: FocusNavigationDirection
    focus_state: winrt.windows.ui.xaml.FocusState
    input_device: FocusInputDeviceKind
    old_focused_element: typing.Optional[winrt.windows.ui.xaml.DependencyObject]
    correlation_id: winrt.system.Guid
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GettingFocusEventArgs: ...
    def try_cancel(self) -> winrt.system.Boolean: ...
    def try_set_new_focused_element(self, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> winrt.system.Boolean: ...

class HoldingRoutedEventArgs(winrt.system.Object):
    handled: winrt.system.Boolean
    holding_state: winrt.windows.ui.input.HoldingState
    pointer_device_type: winrt.windows.devices.input.PointerDeviceType
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HoldingRoutedEventArgs: ...
    def __new__(cls: typing.Type[HoldingRoutedEventArgs]) -> HoldingRoutedEventArgs:...
    def get_position(self, relative_to: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> winrt.windows.foundation.Point: ...

class InertiaExpansionBehavior(winrt.system.Object):
    desired_expansion: winrt.system.Double
    desired_deceleration: winrt.system.Double
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InertiaExpansionBehavior: ...

class InertiaRotationBehavior(winrt.system.Object):
    desired_rotation: winrt.system.Double
    desired_deceleration: winrt.system.Double
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InertiaRotationBehavior: ...

class InertiaTranslationBehavior(winrt.system.Object):
    desired_displacement: winrt.system.Double
    desired_deceleration: winrt.system.Double
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InertiaTranslationBehavior: ...

class InputScope(winrt.system.Object):
    names: typing.Optional[winrt.windows.foundation.collections.IVector[InputScopeName]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InputScope: ...
    def __new__(cls: typing.Type[InputScope]) -> InputScope:...

class InputScopeName(winrt.system.Object):
    name_value: InputScopeNameValue
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InputScopeName: ...
    @typing.overload
    def __new__(cls: typing.Type[InputScopeName], name_value: InputScopeNameValue) -> InputScopeName:...
    @typing.overload
    def __new__(cls: typing.Type[InputScopeName]) -> InputScopeName:...

class KeyRoutedEventArgs(winrt.system.Object):
    handled: winrt.system.Boolean
    key: winrt.windows.system.VirtualKey
    key_status: winrt.windows.ui.core.CorePhysicalKeyStatus
    original_key: winrt.windows.system.VirtualKey
    device_id: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> KeyRoutedEventArgs: ...

class KeyboardAccelerator(winrt.system.Object):
    scope_owner: typing.Optional[winrt.windows.ui.xaml.DependencyObject]
    modifiers: winrt.windows.system.VirtualKeyModifiers
    key: winrt.windows.system.VirtualKey
    is_enabled: winrt.system.Boolean
    is_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    key_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    modifiers_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    scope_owner_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> KeyboardAccelerator: ...
    def __new__(cls: typing.Type[KeyboardAccelerator]) -> KeyboardAccelerator:...
    def add_invoked(self, handler: winrt.windows.foundation.TypedEventHandler[KeyboardAccelerator, KeyboardAcceleratorInvokedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_invoked(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class KeyboardAcceleratorInvokedEventArgs(winrt.system.Object):
    handled: winrt.system.Boolean
    element: typing.Optional[winrt.windows.ui.xaml.DependencyObject]
    keyboard_accelerator: typing.Optional[KeyboardAccelerator]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> KeyboardAcceleratorInvokedEventArgs: ...

class LosingFocusEventArgs(winrt.system.Object):
    new_focused_element: typing.Optional[winrt.windows.ui.xaml.DependencyObject]
    handled: winrt.system.Boolean
    cancel: winrt.system.Boolean
    direction: FocusNavigationDirection
    focus_state: winrt.windows.ui.xaml.FocusState
    input_device: FocusInputDeviceKind
    old_focused_element: typing.Optional[winrt.windows.ui.xaml.DependencyObject]
    correlation_id: winrt.system.Guid
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LosingFocusEventArgs: ...
    def try_cancel(self) -> winrt.system.Boolean: ...
    def try_set_new_focused_element(self, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> winrt.system.Boolean: ...

class ManipulationCompletedRoutedEventArgs(winrt.system.Object):
    handled: winrt.system.Boolean
    container: typing.Optional[winrt.windows.ui.xaml.UIElement]
    cumulative: winrt.windows.ui.input.ManipulationDelta
    is_inertial: winrt.system.Boolean
    pointer_device_type: winrt.windows.devices.input.PointerDeviceType
    position: winrt.windows.foundation.Point
    velocities: winrt.windows.ui.input.ManipulationVelocities
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ManipulationCompletedRoutedEventArgs: ...
    def __new__(cls: typing.Type[ManipulationCompletedRoutedEventArgs]) -> ManipulationCompletedRoutedEventArgs:...

class ManipulationDeltaRoutedEventArgs(winrt.system.Object):
    handled: winrt.system.Boolean
    container: typing.Optional[winrt.windows.ui.xaml.UIElement]
    cumulative: winrt.windows.ui.input.ManipulationDelta
    delta: winrt.windows.ui.input.ManipulationDelta
    is_inertial: winrt.system.Boolean
    pointer_device_type: winrt.windows.devices.input.PointerDeviceType
    position: winrt.windows.foundation.Point
    velocities: winrt.windows.ui.input.ManipulationVelocities
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ManipulationDeltaRoutedEventArgs: ...
    def __new__(cls: typing.Type[ManipulationDeltaRoutedEventArgs]) -> ManipulationDeltaRoutedEventArgs:...
    def complete(self) -> None: ...

class ManipulationInertiaStartingRoutedEventArgs(winrt.system.Object):
    translation_behavior: typing.Optional[InertiaTranslationBehavior]
    rotation_behavior: typing.Optional[InertiaRotationBehavior]
    handled: winrt.system.Boolean
    expansion_behavior: typing.Optional[InertiaExpansionBehavior]
    container: typing.Optional[winrt.windows.ui.xaml.UIElement]
    cumulative: winrt.windows.ui.input.ManipulationDelta
    delta: winrt.windows.ui.input.ManipulationDelta
    pointer_device_type: winrt.windows.devices.input.PointerDeviceType
    velocities: winrt.windows.ui.input.ManipulationVelocities
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ManipulationInertiaStartingRoutedEventArgs: ...
    def __new__(cls: typing.Type[ManipulationInertiaStartingRoutedEventArgs]) -> ManipulationInertiaStartingRoutedEventArgs:...

class ManipulationPivot(winrt.system.Object):
    radius: winrt.system.Double
    center: winrt.windows.foundation.Point
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ManipulationPivot: ...
    @typing.overload
    def __new__(cls: typing.Type[ManipulationPivot], center: winrt.windows.foundation.Point, radius: winrt.system.Double) -> ManipulationPivot:...
    @typing.overload
    def __new__(cls: typing.Type[ManipulationPivot]) -> ManipulationPivot:...

class ManipulationStartedRoutedEventArgs(winrt.system.Object):
    handled: winrt.system.Boolean
    container: typing.Optional[winrt.windows.ui.xaml.UIElement]
    cumulative: winrt.windows.ui.input.ManipulationDelta
    pointer_device_type: winrt.windows.devices.input.PointerDeviceType
    position: winrt.windows.foundation.Point
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ManipulationStartedRoutedEventArgs: ...
    def __new__(cls: typing.Type[ManipulationStartedRoutedEventArgs]) -> ManipulationStartedRoutedEventArgs:...
    def complete(self) -> None: ...

class ManipulationStartingRoutedEventArgs(winrt.system.Object):
    pivot: typing.Optional[ManipulationPivot]
    mode: ManipulationModes
    handled: winrt.system.Boolean
    container: typing.Optional[winrt.windows.ui.xaml.UIElement]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ManipulationStartingRoutedEventArgs: ...
    def __new__(cls: typing.Type[ManipulationStartingRoutedEventArgs]) -> ManipulationStartingRoutedEventArgs:...

class NoFocusCandidateFoundEventArgs(winrt.system.Object):
    handled: winrt.system.Boolean
    direction: FocusNavigationDirection
    input_device: FocusInputDeviceKind
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NoFocusCandidateFoundEventArgs: ...

class Pointer(winrt.system.Object):
    is_in_contact: winrt.system.Boolean
    is_in_range: winrt.system.Boolean
    pointer_device_type: winrt.windows.devices.input.PointerDeviceType
    pointer_id: winrt.system.UInt32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Pointer: ...

class PointerRoutedEventArgs(winrt.system.Object):
    handled: winrt.system.Boolean
    key_modifiers: winrt.windows.system.VirtualKeyModifiers
    pointer: typing.Optional[Pointer]
    is_generated: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PointerRoutedEventArgs: ...
    def get_current_point(self, relative_to: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> typing.Optional[winrt.windows.ui.input.PointerPoint]: ...
    def get_intermediate_points(self, relative_to: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.ui.input.PointerPoint]]: ...

class ProcessKeyboardAcceleratorEventArgs(winrt.system.Object):
    handled: winrt.system.Boolean
    key: winrt.windows.system.VirtualKey
    modifiers: winrt.windows.system.VirtualKeyModifiers
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProcessKeyboardAcceleratorEventArgs: ...

class RightTappedRoutedEventArgs(winrt.system.Object):
    handled: winrt.system.Boolean
    pointer_device_type: winrt.windows.devices.input.PointerDeviceType
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RightTappedRoutedEventArgs: ...
    def __new__(cls: typing.Type[RightTappedRoutedEventArgs]) -> RightTappedRoutedEventArgs:...
    def get_position(self, relative_to: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> winrt.windows.foundation.Point: ...

class StandardUICommand(winrt.system.Object):
    kind: StandardUICommandKind
    kind_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StandardUICommand: ...
    @typing.overload
    def __new__(cls: typing.Type[StandardUICommand]) -> StandardUICommand:...
    @typing.overload
    def __new__(cls: typing.Type[StandardUICommand], kind: StandardUICommandKind) -> StandardUICommand:...

class TappedRoutedEventArgs(winrt.system.Object):
    handled: winrt.system.Boolean
    pointer_device_type: winrt.windows.devices.input.PointerDeviceType
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TappedRoutedEventArgs: ...
    def __new__(cls: typing.Type[TappedRoutedEventArgs]) -> TappedRoutedEventArgs:...
    def get_position(self, relative_to: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> winrt.windows.foundation.Point: ...

class XamlUICommand(winrt.system.Object):
    label: str
    icon_source: typing.Optional[winrt.windows.ui.xaml.controls.IconSource]
    description: str
    command: typing.Optional[ICommand]
    access_key: str
    keyboard_accelerators: typing.Optional[winrt.windows.foundation.collections.IVector[KeyboardAccelerator]]
    access_key_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    command_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    description_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    icon_source_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    keyboard_accelerators_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    label_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> XamlUICommand: ...
    def __new__(cls: typing.Type[XamlUICommand]) -> XamlUICommand:...
    def can_execute(self, parameter: typing.Optional[winrt.system.Object], /) -> winrt.system.Boolean: ...
    def execute(self, parameter: typing.Optional[winrt.system.Object], /) -> None: ...
    def notify_can_execute_changed(self) -> None: ...
    def add_can_execute_requested(self, handler: winrt.windows.foundation.TypedEventHandler[XamlUICommand, CanExecuteRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_can_execute_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_execute_requested(self, handler: winrt.windows.foundation.TypedEventHandler[XamlUICommand, ExecuteRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_execute_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_can_execute_changed(self, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_can_execute_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class ICommand(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ICommand: ...
    def can_execute(self, parameter: typing.Optional[winrt.system.Object], /) -> winrt.system.Boolean: ...
    def execute(self, parameter: typing.Optional[winrt.system.Object], /) -> None: ...
    def add_can_execute_changed(self, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_can_execute_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

DoubleTappedEventHandler = typing.Callable[[typing.Optional[winrt.system.Object], typing.Optional[DoubleTappedRoutedEventArgs]], None]

HoldingEventHandler = typing.Callable[[typing.Optional[winrt.system.Object], typing.Optional[HoldingRoutedEventArgs]], None]

KeyEventHandler = typing.Callable[[typing.Optional[winrt.system.Object], typing.Optional[KeyRoutedEventArgs]], None]

ManipulationCompletedEventHandler = typing.Callable[[typing.Optional[winrt.system.Object], typing.Optional[ManipulationCompletedRoutedEventArgs]], None]

ManipulationDeltaEventHandler = typing.Callable[[typing.Optional[winrt.system.Object], typing.Optional[ManipulationDeltaRoutedEventArgs]], None]

ManipulationInertiaStartingEventHandler = typing.Callable[[typing.Optional[winrt.system.Object], typing.Optional[ManipulationInertiaStartingRoutedEventArgs]], None]

ManipulationStartedEventHandler = typing.Callable[[typing.Optional[winrt.system.Object], typing.Optional[ManipulationStartedRoutedEventArgs]], None]

ManipulationStartingEventHandler = typing.Callable[[typing.Optional[winrt.system.Object], typing.Optional[ManipulationStartingRoutedEventArgs]], None]

PointerEventHandler = typing.Callable[[typing.Optional[winrt.system.Object], typing.Optional[PointerRoutedEventArgs]], None]

RightTappedEventHandler = typing.Callable[[typing.Optional[winrt.system.Object], typing.Optional[RightTappedRoutedEventArgs]], None]

TappedEventHandler = typing.Callable[[typing.Optional[winrt.system.Object], typing.Optional[TappedRoutedEventArgs]], None]

