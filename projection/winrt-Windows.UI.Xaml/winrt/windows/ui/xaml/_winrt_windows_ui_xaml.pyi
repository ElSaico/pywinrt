# WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

import datetime
import sys
import types
import typing
import uuid

import winrt.system
import winrt.windows.applicationmodel.activation
import winrt.windows.applicationmodel.core
import winrt.windows.applicationmodel.datatransfer
import winrt.windows.applicationmodel.datatransfer.dragdrop
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.foundation.numerics
import winrt.windows.graphics.imaging
import winrt.windows.ui
import winrt.windows.ui.composition
import winrt.windows.ui.core
import winrt.windows.ui.input
import winrt.windows.ui.xaml.automation.peers
import winrt.windows.ui.xaml.controls
import winrt.windows.ui.xaml.controls.primitives
import winrt.windows.ui.xaml.data
import winrt.windows.ui.xaml.input
import winrt.windows.ui.xaml.interop
import winrt.windows.ui.xaml.media
import winrt.windows.ui.xaml.media.animation
import winrt.windows.ui.xaml.media.imaging
import winrt.windows.ui.xaml.media.media3d

from . import ApplicationHighContrastAdjustment, ApplicationRequiresPointerMode, ApplicationTheme, AutomationTextAttributesEnum, DurationType, ElementHighContrastAdjustment, ElementSoundKind, ElementSoundMode, ElementSoundPlayerState, ElementSpatialAudioMode, ElementTheme, FlowDirection, FocusState, FocusVisualKind, FontCapitals, FontEastAsianLanguage, FontEastAsianWidths, FontFraction, FontNumeralAlignment, FontNumeralStyle, FontVariants, GridUnitType, HorizontalAlignment, LineStackingStrategy, OpticalMarginAlignment, TextAlignment, TextLineBounds, TextReadingOrder, TextTrimming, TextWrapping, Vector3TransitionComponents, VerticalAlignment, Visibility
from . import ApplicationInitializationCallback, BindingFailedEventHandler, CreateDefaultValueCallback, DependencyPropertyChangedCallback, DependencyPropertyChangedEventHandler, DragEventHandler, EnteredBackgroundEventHandler, ExceptionRoutedEventHandler, LeavingBackgroundEventHandler, PropertyChangedCallback, RoutedEventHandler, SizeChangedEventHandler, SuspendingEventHandler, UnhandledExceptionEventHandler, VisualStateChangedEventHandler, WindowActivatedEventHandler, WindowClosedEventHandler, WindowSizeChangedEventHandler, WindowVisibilityChangedEventHandler

Self = typing.TypeVar('Self')

class CornerRadius:
    top_left: winrt.system.Double
    top_right: winrt.system.Double
    bottom_right: winrt.system.Double
    bottom_left: winrt.system.Double
    def __new__(cls: typing.Type[CornerRadius], top_left: winrt.system.Double, top_right: winrt.system.Double, bottom_right: winrt.system.Double, bottom_left: winrt.system.Double) -> CornerRadius: ...

class Duration:
    time_span: datetime.timedelta
    type: DurationType
    def __new__(cls: typing.Type[Duration], time_span: datetime.timedelta, type: DurationType) -> Duration: ...

class GridLength:
    value: winrt.system.Double
    grid_unit_type: GridUnitType
    def __new__(cls: typing.Type[GridLength], value: winrt.system.Double, grid_unit_type: GridUnitType) -> GridLength: ...

class Thickness:
    left: winrt.system.Double
    top: winrt.system.Double
    right: winrt.system.Double
    bottom: winrt.system.Double
    def __new__(cls: typing.Type[Thickness], left: winrt.system.Double, top: winrt.system.Double, right: winrt.system.Double, bottom: winrt.system.Double) -> Thickness: ...

class AdaptiveTrigger(winrt.system.Object):
    min_window_width: winrt.system.Double
    min_window_height: winrt.system.Double
    min_window_height_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    min_window_width_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AdaptiveTrigger: ...
    def __new__(cls: typing.Type[AdaptiveTrigger]) -> AdaptiveTrigger:...

class Application(winrt.system.Object):
    resources: typing.Optional[ResourceDictionary]
    requested_theme: ApplicationTheme
    debug_settings: typing.Optional[DebugSettings]
    requires_pointer_mode: ApplicationRequiresPointerMode
    focus_visual_kind: FocusVisualKind
    high_contrast_adjustment: ApplicationHighContrastAdjustment
    current: typing.ClassVar[typing.Optional[Application]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Application: ...
    def __new__(cls: typing.Type[Application]) -> Application:...
    def exit(self) -> None: ...
    @typing.overload
    @staticmethod
    def load_component(component: typing.Optional[winrt.system.Object], resource_locator: typing.Optional[winrt.windows.foundation.Uri], /) -> None: ...
    @typing.overload
    @staticmethod
    def load_component(component: typing.Optional[winrt.system.Object], resource_locator: typing.Optional[winrt.windows.foundation.Uri], component_resource_location: winrt.windows.ui.xaml.controls.primitives.ComponentResourceLocation, /) -> None: ...
    def on_activated(self, args: typing.Optional[winrt.windows.applicationmodel.activation.IActivatedEventArgs], /) -> None: ...
    def on_background_activated(self, args: typing.Optional[winrt.windows.applicationmodel.activation.BackgroundActivatedEventArgs], /) -> None: ...
    def on_cached_file_updater_activated(self, args: typing.Optional[winrt.windows.applicationmodel.activation.CachedFileUpdaterActivatedEventArgs], /) -> None: ...
    def on_file_activated(self, args: typing.Optional[winrt.windows.applicationmodel.activation.FileActivatedEventArgs], /) -> None: ...
    def on_file_open_picker_activated(self, args: typing.Optional[winrt.windows.applicationmodel.activation.FileOpenPickerActivatedEventArgs], /) -> None: ...
    def on_file_save_picker_activated(self, args: typing.Optional[winrt.windows.applicationmodel.activation.FileSavePickerActivatedEventArgs], /) -> None: ...
    def on_launched(self, args: typing.Optional[winrt.windows.applicationmodel.activation.LaunchActivatedEventArgs], /) -> None: ...
    def on_search_activated(self, args: typing.Optional[winrt.windows.applicationmodel.activation.SearchActivatedEventArgs], /) -> None: ...
    def on_share_target_activated(self, args: typing.Optional[winrt.windows.applicationmodel.activation.ShareTargetActivatedEventArgs], /) -> None: ...
    def on_window_created(self, args: typing.Optional[WindowCreatedEventArgs], /) -> None: ...
    @staticmethod
    def start(callback: typing.Optional[ApplicationInitializationCallback], /) -> None: ...
    def add_resuming(self, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_resuming(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_suspending(self, handler: typing.Optional[SuspendingEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_suspending(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_unhandled_exception(self, handler: typing.Optional[UnhandledExceptionEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_unhandled_exception(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_entered_background(self, handler: typing.Optional[EnteredBackgroundEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_entered_background(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_leaving_background(self, handler: typing.Optional[LeavingBackgroundEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_leaving_background(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class ApplicationInitializationCallbackParams(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ApplicationInitializationCallbackParams: ...

class BindingFailedEventArgs(winrt.system.Object):
    message: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BindingFailedEventArgs: ...

class BringIntoViewOptions(winrt.system.Object):
    target_rect: typing.Optional[typing.Optional[winrt.windows.foundation.Rect]]
    animation_desired: winrt.system.Boolean
    vertical_offset: winrt.system.Double
    vertical_alignment_ratio: winrt.system.Double
    horizontal_offset: winrt.system.Double
    horizontal_alignment_ratio: winrt.system.Double
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BringIntoViewOptions: ...
    def __new__(cls: typing.Type[BringIntoViewOptions]) -> BringIntoViewOptions:...

class BringIntoViewRequestedEventArgs(winrt.system.Object):
    vertical_offset: winrt.system.Double
    target_rect: winrt.windows.foundation.Rect
    target_element: typing.Optional[UIElement]
    horizontal_offset: winrt.system.Double
    handled: winrt.system.Boolean
    animation_desired: winrt.system.Boolean
    horizontal_alignment_ratio: winrt.system.Double
    vertical_alignment_ratio: winrt.system.Double
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BringIntoViewRequestedEventArgs: ...

class BrushTransition(winrt.system.Object):
    duration: datetime.timedelta
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BrushTransition: ...
    def __new__(cls: typing.Type[BrushTransition]) -> BrushTransition:...

class ColorPaletteResources(winrt.system.Object):
    list_medium: typing.Optional[typing.Optional[winrt.windows.ui.Color]]
    list_low: typing.Optional[typing.Optional[winrt.windows.ui.Color]]
    error_text: typing.Optional[typing.Optional[winrt.windows.ui.Color]]
    chrome_white: typing.Optional[typing.Optional[winrt.windows.ui.Color]]
    chrome_medium_low: typing.Optional[typing.Optional[winrt.windows.ui.Color]]
    chrome_medium: typing.Optional[typing.Optional[winrt.windows.ui.Color]]
    chrome_low: typing.Optional[typing.Optional[winrt.windows.ui.Color]]
    chrome_high: typing.Optional[typing.Optional[winrt.windows.ui.Color]]
    chrome_gray: typing.Optional[typing.Optional[winrt.windows.ui.Color]]
    chrome_disabled_low: typing.Optional[typing.Optional[winrt.windows.ui.Color]]
    chrome_disabled_high: typing.Optional[typing.Optional[winrt.windows.ui.Color]]
    chrome_black_medium_low: typing.Optional[typing.Optional[winrt.windows.ui.Color]]
    chrome_black_medium: typing.Optional[typing.Optional[winrt.windows.ui.Color]]
    chrome_black_low: typing.Optional[typing.Optional[winrt.windows.ui.Color]]
    chrome_black_high: typing.Optional[typing.Optional[winrt.windows.ui.Color]]
    chrome_alt_low: typing.Optional[typing.Optional[winrt.windows.ui.Color]]
    base_medium_low: typing.Optional[typing.Optional[winrt.windows.ui.Color]]
    base_medium_high: typing.Optional[typing.Optional[winrt.windows.ui.Color]]
    base_medium: typing.Optional[typing.Optional[winrt.windows.ui.Color]]
    base_low: typing.Optional[typing.Optional[winrt.windows.ui.Color]]
    base_high: typing.Optional[typing.Optional[winrt.windows.ui.Color]]
    alt_medium_low: typing.Optional[typing.Optional[winrt.windows.ui.Color]]
    alt_medium_high: typing.Optional[typing.Optional[winrt.windows.ui.Color]]
    alt_medium: typing.Optional[typing.Optional[winrt.windows.ui.Color]]
    alt_low: typing.Optional[typing.Optional[winrt.windows.ui.Color]]
    alt_high: typing.Optional[typing.Optional[winrt.windows.ui.Color]]
    accent: typing.Optional[typing.Optional[winrt.windows.ui.Color]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ColorPaletteResources: ...
    def __new__(cls: typing.Type[ColorPaletteResources]) -> ColorPaletteResources:...

class CornerRadiusHelper(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CornerRadiusHelper: ...
    @staticmethod
    def from_radii(top_left: winrt.system.Double, top_right: winrt.system.Double, bottom_right: winrt.system.Double, bottom_left: winrt.system.Double, /) -> CornerRadius: ...
    @staticmethod
    def from_uniform_radius(uniform_radius: winrt.system.Double, /) -> CornerRadius: ...

class DataContextChangedEventArgs(winrt.system.Object):
    handled: winrt.system.Boolean
    new_value: typing.Optional[winrt.system.Object]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DataContextChangedEventArgs: ...

class DataTemplate(winrt.system.Object):
    extension_instance_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DataTemplate: ...
    def __new__(cls: typing.Type[DataTemplate]) -> DataTemplate:...
    def get_element(self, args: typing.Optional[ElementFactoryGetArgs], /) -> typing.Optional[UIElement]: ...
    @staticmethod
    def get_extension_instance(element: typing.Optional[FrameworkElement], /) -> typing.Optional[IDataTemplateExtension]: ...
    def load_content(self) -> typing.Optional[DependencyObject]: ...
    def recycle_element(self, args: typing.Optional[ElementFactoryRecycleArgs], /) -> None: ...
    @staticmethod
    def set_extension_instance(element: typing.Optional[FrameworkElement], value: typing.Optional[IDataTemplateExtension], /) -> None: ...

class DataTemplateKey(winrt.system.Object):
    data_type: typing.Optional[winrt.system.Object]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DataTemplateKey: ...
    @typing.overload
    def __new__(cls: typing.Type[DataTemplateKey]) -> DataTemplateKey:...
    @typing.overload
    def __new__(cls: typing.Type[DataTemplateKey], data_type: typing.Optional[winrt.system.Object]) -> DataTemplateKey:...

class DebugSettings(winrt.system.Object):
    is_overdraw_heat_map_enabled: winrt.system.Boolean
    is_binding_tracing_enabled: winrt.system.Boolean
    enable_frame_rate_counter: winrt.system.Boolean
    enable_redraw_regions: winrt.system.Boolean
    is_text_performance_visualization_enabled: winrt.system.Boolean
    fail_fast_on_errors: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DebugSettings: ...
    def add_binding_failed(self, handler: typing.Optional[BindingFailedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_binding_failed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class DependencyObject(winrt.system.Object):
    dispatcher: typing.Optional[winrt.windows.ui.core.CoreDispatcher]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DependencyObject: ...
    def clear_value(self, dp: typing.Optional[DependencyProperty], /) -> None: ...
    def get_animation_base_value(self, dp: typing.Optional[DependencyProperty], /) -> typing.Optional[winrt.system.Object]: ...
    def get_value(self, dp: typing.Optional[DependencyProperty], /) -> typing.Optional[winrt.system.Object]: ...
    def read_local_value(self, dp: typing.Optional[DependencyProperty], /) -> typing.Optional[winrt.system.Object]: ...
    def register_property_changed_callback(self, dp: typing.Optional[DependencyProperty], callback: typing.Optional[DependencyPropertyChangedCallback], /) -> winrt.system.Int64: ...
    def set_value(self, dp: typing.Optional[DependencyProperty], value: typing.Optional[winrt.system.Object], /) -> None: ...
    def unregister_property_changed_callback(self, dp: typing.Optional[DependencyProperty], token: winrt.system.Int64, /) -> None: ...

class DependencyObjectCollection(winrt.system.Object, typing.MutableSequence[DependencyObject]):
    size: winrt.system.UInt32
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> DependencyObject: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[DependencyObject]: ...
    def insert(self, index: int, value: DependencyObject) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: DependencyObject) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[DependencyObject]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DependencyObjectCollection: ...
    def __new__(cls: typing.Type[DependencyObjectCollection]) -> DependencyObjectCollection:...
    def append(self, value: typing.Optional[DependencyObject], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[DependencyObject]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[DependencyObject]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[DependencyObject], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[DependencyObject]]: ...
    def index_of(self, value: typing.Optional[DependencyObject], /) -> typing.Tuple[winrt.system.Boolean, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[DependencyObject], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[DependencyObject], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[DependencyObject], /) -> None: ...
    def add_vector_changed(self, vhnd: winrt.windows.foundation.collections.VectorChangedEventHandler[DependencyObject], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_vector_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class DependencyProperty(winrt.system.Object):
    unset_value: typing.ClassVar[typing.Optional[winrt.system.Object]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DependencyProperty: ...
    def get_metadata(self, for_type: winrt.windows.ui.xaml.interop.TypeName, /) -> typing.Optional[PropertyMetadata]: ...
    @staticmethod
    def register(name: str, property_type: winrt.windows.ui.xaml.interop.TypeName, owner_type: winrt.windows.ui.xaml.interop.TypeName, type_metadata: typing.Optional[PropertyMetadata], /) -> typing.Optional[DependencyProperty]: ...
    @staticmethod
    def register_attached(name: str, property_type: winrt.windows.ui.xaml.interop.TypeName, owner_type: winrt.windows.ui.xaml.interop.TypeName, default_metadata: typing.Optional[PropertyMetadata], /) -> typing.Optional[DependencyProperty]: ...

class DependencyPropertyChangedEventArgs(winrt.system.Object):
    new_value: typing.Optional[winrt.system.Object]
    old_value: typing.Optional[winrt.system.Object]
    property: typing.Optional[DependencyProperty]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DependencyPropertyChangedEventArgs: ...

class DispatcherTimer(winrt.system.Object):
    interval: datetime.timedelta
    is_enabled: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DispatcherTimer: ...
    def __new__(cls: typing.Type[DispatcherTimer]) -> DispatcherTimer:...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def add_tick(self, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_tick(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class DragEventArgs(winrt.system.Object):
    handled: winrt.system.Boolean
    data: typing.Optional[winrt.windows.applicationmodel.datatransfer.DataPackage]
    accepted_operation: winrt.windows.applicationmodel.datatransfer.DataPackageOperation
    data_view: typing.Optional[winrt.windows.applicationmodel.datatransfer.DataPackageView]
    drag_u_i_override: typing.Optional[DragUIOverride]
    modifiers: winrt.windows.applicationmodel.datatransfer.dragdrop.DragDropModifiers
    allowed_operations: winrt.windows.applicationmodel.datatransfer.DataPackageOperation
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DragEventArgs: ...
    def get_deferral(self) -> typing.Optional[DragOperationDeferral]: ...
    def get_position(self, relative_to: typing.Optional[UIElement], /) -> winrt.windows.foundation.Point: ...

class DragOperationDeferral(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DragOperationDeferral: ...
    def complete(self) -> None: ...

class DragStartingEventArgs(winrt.system.Object):
    cancel: winrt.system.Boolean
    data: typing.Optional[winrt.windows.applicationmodel.datatransfer.DataPackage]
    drag_u_i: typing.Optional[DragUI]
    allowed_operations: winrt.windows.applicationmodel.datatransfer.DataPackageOperation
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DragStartingEventArgs: ...
    def get_deferral(self) -> typing.Optional[DragOperationDeferral]: ...
    def get_position(self, relative_to: typing.Optional[UIElement], /) -> winrt.windows.foundation.Point: ...

class DragUI(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DragUI: ...
    @typing.overload
    def set_content_from_bitmap_image(self, bitmap_image: typing.Optional[winrt.windows.ui.xaml.media.imaging.BitmapImage], /) -> None: ...
    @typing.overload
    def set_content_from_bitmap_image(self, bitmap_image: typing.Optional[winrt.windows.ui.xaml.media.imaging.BitmapImage], anchor_point: winrt.windows.foundation.Point, /) -> None: ...
    def set_content_from_data_package(self) -> None: ...
    @typing.overload
    def set_content_from_software_bitmap(self, software_bitmap: typing.Optional[winrt.windows.graphics.imaging.SoftwareBitmap], /) -> None: ...
    @typing.overload
    def set_content_from_software_bitmap(self, software_bitmap: typing.Optional[winrt.windows.graphics.imaging.SoftwareBitmap], anchor_point: winrt.windows.foundation.Point, /) -> None: ...

class DragUIOverride(winrt.system.Object):
    is_glyph_visible: winrt.system.Boolean
    is_content_visible: winrt.system.Boolean
    is_caption_visible: winrt.system.Boolean
    caption: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DragUIOverride: ...
    def clear(self) -> None: ...
    @typing.overload
    def set_content_from_bitmap_image(self, bitmap_image: typing.Optional[winrt.windows.ui.xaml.media.imaging.BitmapImage], /) -> None: ...
    @typing.overload
    def set_content_from_bitmap_image(self, bitmap_image: typing.Optional[winrt.windows.ui.xaml.media.imaging.BitmapImage], anchor_point: winrt.windows.foundation.Point, /) -> None: ...
    @typing.overload
    def set_content_from_software_bitmap(self, software_bitmap: typing.Optional[winrt.windows.graphics.imaging.SoftwareBitmap], /) -> None: ...
    @typing.overload
    def set_content_from_software_bitmap(self, software_bitmap: typing.Optional[winrt.windows.graphics.imaging.SoftwareBitmap], anchor_point: winrt.windows.foundation.Point, /) -> None: ...

class DropCompletedEventArgs(winrt.system.Object):
    drop_result: winrt.windows.applicationmodel.datatransfer.DataPackageOperation
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DropCompletedEventArgs: ...

class DurationHelper(winrt.system.Object):
    automatic: typing.ClassVar[Duration]
    forever: typing.ClassVar[Duration]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DurationHelper: ...
    @staticmethod
    def add(target: Duration, duration: Duration, /) -> Duration: ...
    @staticmethod
    def compare(duration1: Duration, duration2: Duration, /) -> winrt.system.Int32: ...
    @staticmethod
    def equals(target: Duration, value: Duration, /) -> winrt.system.Boolean: ...
    @staticmethod
    def from_time_span(time_span: datetime.timedelta, /) -> Duration: ...
    @staticmethod
    def get_has_time_span(target: Duration, /) -> winrt.system.Boolean: ...
    @staticmethod
    def subtract(target: Duration, duration: Duration, /) -> Duration: ...

class EffectiveViewportChangedEventArgs(winrt.system.Object):
    bring_into_view_distance_x: winrt.system.Double
    bring_into_view_distance_y: winrt.system.Double
    effective_viewport: winrt.windows.foundation.Rect
    max_viewport: winrt.windows.foundation.Rect
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EffectiveViewportChangedEventArgs: ...

class ElementFactoryGetArgs(winrt.system.Object):
    parent: typing.Optional[UIElement]
    data: typing.Optional[winrt.system.Object]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ElementFactoryGetArgs: ...
    def __new__(cls: typing.Type[ElementFactoryGetArgs]) -> ElementFactoryGetArgs:...

class ElementFactoryRecycleArgs(winrt.system.Object):
    parent: typing.Optional[UIElement]
    element: typing.Optional[UIElement]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ElementFactoryRecycleArgs: ...
    def __new__(cls: typing.Type[ElementFactoryRecycleArgs]) -> ElementFactoryRecycleArgs:...

class ElementSoundPlayer(winrt.system.Object):
    volume: typing.ClassVar[winrt.system.Double]
    state: typing.ClassVar[ElementSoundPlayerState]
    spatial_audio_mode: typing.ClassVar[ElementSpatialAudioMode]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ElementSoundPlayer: ...
    @staticmethod
    def play(sound: ElementSoundKind, /) -> None: ...

class EventTrigger(winrt.system.Object):
    routed_event: typing.Optional[RoutedEvent]
    actions: typing.Optional[TriggerActionCollection]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EventTrigger: ...
    def __new__(cls: typing.Type[EventTrigger]) -> EventTrigger:...

class ExceptionRoutedEventArgs(winrt.system.Object):
    error_message: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ExceptionRoutedEventArgs: ...

class FrameworkElement(winrt.system.Object):
    width: winrt.system.Double
    vertical_alignment: VerticalAlignment
    tag: typing.Optional[winrt.system.Object]
    style: typing.Optional[Style]
    resources: typing.Optional[ResourceDictionary]
    name: str
    min_width: winrt.system.Double
    min_height: winrt.system.Double
    max_width: winrt.system.Double
    max_height: winrt.system.Double
    margin: Thickness
    language: str
    horizontal_alignment: HorizontalAlignment
    height: winrt.system.Double
    flow_direction: FlowDirection
    data_context: typing.Optional[winrt.system.Object]
    actual_height: winrt.system.Double
    actual_width: winrt.system.Double
    base_uri: typing.Optional[winrt.windows.foundation.Uri]
    parent: typing.Optional[DependencyObject]
    triggers: typing.Optional[TriggerCollection]
    requested_theme: ElementTheme
    focus_visual_secondary_thickness: Thickness
    focus_visual_secondary_brush: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    focus_visual_primary_thickness: Thickness
    focus_visual_primary_brush: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    focus_visual_margin: Thickness
    allow_focus_when_disabled: winrt.system.Boolean
    allow_focus_on_interaction: winrt.system.Boolean
    actual_theme: ElementTheme
    is_loaded: winrt.system.Boolean
    actual_height_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    actual_width_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    data_context_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    flow_direction_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    height_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    horizontal_alignment_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    language_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    margin_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    max_height_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    max_width_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    min_height_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    min_width_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    name_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    style_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    tag_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    vertical_alignment_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    width_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    requested_theme_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    allow_focus_on_interaction_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    allow_focus_when_disabled_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    focus_visual_margin_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    focus_visual_primary_brush_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    focus_visual_primary_thickness_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    focus_visual_secondary_brush_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    focus_visual_secondary_thickness_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    actual_theme_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FrameworkElement: ...
    def arrange_override(self, final_size: winrt.windows.foundation.Size, /) -> winrt.windows.foundation.Size: ...
    @staticmethod
    def defer_tree(element: typing.Optional[DependencyObject], /) -> None: ...
    def find_name(self, name: str, /) -> typing.Optional[winrt.system.Object]: ...
    def get_binding_expression(self, dp: typing.Optional[DependencyProperty], /) -> typing.Optional[winrt.windows.ui.xaml.data.BindingExpression]: ...
    def go_to_element_state_core(self, state_name: str, use_transitions: winrt.system.Boolean, /) -> winrt.system.Boolean: ...
    def invalidate_viewport(self) -> None: ...
    def measure_override(self, available_size: winrt.windows.foundation.Size, /) -> winrt.windows.foundation.Size: ...
    def on_apply_template(self) -> None: ...
    def set_binding(self, dp: typing.Optional[DependencyProperty], binding: typing.Optional[winrt.windows.ui.xaml.data.BindingBase], /) -> None: ...
    def add_layout_updated(self, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_layout_updated(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_loaded(self, handler: typing.Optional[RoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_loaded(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_size_changed(self, handler: typing.Optional[SizeChangedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_size_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_unloaded(self, handler: typing.Optional[RoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_unloaded(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_data_context_changed(self, handler: winrt.windows.foundation.TypedEventHandler[FrameworkElement, DataContextChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_data_context_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_loading(self, handler: winrt.windows.foundation.TypedEventHandler[FrameworkElement, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_loading(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_actual_theme_changed(self, handler: winrt.windows.foundation.TypedEventHandler[FrameworkElement, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_actual_theme_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_effective_viewport_changed(self, handler: winrt.windows.foundation.TypedEventHandler[FrameworkElement, EffectiveViewportChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_effective_viewport_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class FrameworkTemplate(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FrameworkTemplate: ...

class FrameworkView(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FrameworkView: ...
    def __new__(cls: typing.Type[FrameworkView]) -> FrameworkView:...
    def initialize(self, application_view: typing.Optional[winrt.windows.applicationmodel.core.CoreApplicationView], /) -> None: ...
    def load(self, entry_point: str, /) -> None: ...
    def run(self) -> None: ...
    def set_window(self, window: typing.Optional[winrt.windows.ui.core.CoreWindow], /) -> None: ...
    def uninitialize(self) -> None: ...

class FrameworkViewSource(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FrameworkViewSource: ...
    def __new__(cls: typing.Type[FrameworkViewSource]) -> FrameworkViewSource:...
    def create_view(self) -> typing.Optional[winrt.windows.applicationmodel.core.IFrameworkView]: ...

class GridLengthHelper(winrt.system.Object):
    auto: typing.ClassVar[GridLength]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GridLengthHelper: ...
    @staticmethod
    def equals(target: GridLength, value: GridLength, /) -> winrt.system.Boolean: ...
    @staticmethod
    def from_pixels(pixels: winrt.system.Double, /) -> GridLength: ...
    @staticmethod
    def from_value_and_type(value: winrt.system.Double, type: GridUnitType, /) -> GridLength: ...
    @staticmethod
    def get_is_absolute(target: GridLength, /) -> winrt.system.Boolean: ...
    @staticmethod
    def get_is_auto(target: GridLength, /) -> winrt.system.Boolean: ...
    @staticmethod
    def get_is_star(target: GridLength, /) -> winrt.system.Boolean: ...

class MediaFailedRoutedEventArgs(winrt.system.Object):
    error_trace: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaFailedRoutedEventArgs: ...

class PointHelper(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PointHelper: ...
    @staticmethod
    def from_coordinates(x: winrt.system.Single, y: winrt.system.Single, /) -> winrt.windows.foundation.Point: ...

class PropertyMetadata(winrt.system.Object):
    create_default_value_callback: typing.Optional[CreateDefaultValueCallback]
    default_value: typing.Optional[winrt.system.Object]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PropertyMetadata: ...
    @typing.overload
    def __new__(cls: typing.Type[PropertyMetadata], default_value: typing.Optional[winrt.system.Object]) -> PropertyMetadata:...
    @typing.overload
    def __new__(cls: typing.Type[PropertyMetadata], default_value: typing.Optional[winrt.system.Object], property_changed_callback: typing.Optional[PropertyChangedCallback]) -> PropertyMetadata:...
    @typing.overload
    @staticmethod
    def create(default_value: typing.Optional[winrt.system.Object], /) -> typing.Optional[PropertyMetadata]: ...
    @typing.overload
    @staticmethod
    def create(default_value: typing.Optional[winrt.system.Object], property_changed_callback: typing.Optional[PropertyChangedCallback], /) -> typing.Optional[PropertyMetadata]: ...

class PropertyPath(winrt.system.Object):
    path: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PropertyPath: ...
    def __new__(cls: typing.Type[PropertyPath], path: str) -> PropertyPath:...

class RectHelper(winrt.system.Object):
    empty: typing.ClassVar[winrt.windows.foundation.Rect]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RectHelper: ...
    @staticmethod
    def contains(target: winrt.windows.foundation.Rect, point: winrt.windows.foundation.Point, /) -> winrt.system.Boolean: ...
    @staticmethod
    def equals(target: winrt.windows.foundation.Rect, value: winrt.windows.foundation.Rect, /) -> winrt.system.Boolean: ...
    @staticmethod
    def from_coordinates_and_dimensions(x: winrt.system.Single, y: winrt.system.Single, width: winrt.system.Single, height: winrt.system.Single, /) -> winrt.windows.foundation.Rect: ...
    @staticmethod
    def from_location_and_size(location: winrt.windows.foundation.Point, size: winrt.windows.foundation.Size, /) -> winrt.windows.foundation.Rect: ...
    @staticmethod
    def from_points(point1: winrt.windows.foundation.Point, point2: winrt.windows.foundation.Point, /) -> winrt.windows.foundation.Rect: ...
    @staticmethod
    def get_bottom(target: winrt.windows.foundation.Rect, /) -> winrt.system.Single: ...
    @staticmethod
    def get_is_empty(target: winrt.windows.foundation.Rect, /) -> winrt.system.Boolean: ...
    @staticmethod
    def get_left(target: winrt.windows.foundation.Rect, /) -> winrt.system.Single: ...
    @staticmethod
    def get_right(target: winrt.windows.foundation.Rect, /) -> winrt.system.Single: ...
    @staticmethod
    def get_top(target: winrt.windows.foundation.Rect, /) -> winrt.system.Single: ...
    @staticmethod
    def intersect(target: winrt.windows.foundation.Rect, rect: winrt.windows.foundation.Rect, /) -> winrt.windows.foundation.Rect: ...
    @staticmethod
    def union(target: winrt.windows.foundation.Rect, point: winrt.windows.foundation.Point, /) -> winrt.windows.foundation.Rect: ...

class ResourceDictionary(winrt.system.Object, typing.MutableMapping[winrt.system.Object, winrt.system.Object]):
    size: winrt.system.UInt32
    source: typing.Optional[winrt.windows.foundation.Uri]
    merged_dictionaries: typing.Optional[winrt.windows.foundation.collections.IVector[ResourceDictionary]]
    theme_dictionaries: typing.Optional[winrt.windows.foundation.collections.IMap[winrt.system.Object, winrt.system.Object]]
    def __len__(self) -> int: ...
    def __iter__(self) -> typing.Iterator[winrt.system.Object]: ...
    def __contains__(self, key: object) -> bool:...
    def __setitem__(self, key: winrt.system.Object, value: winrt.system.Object) -> None: ...
    def __getitem__(self, key: winrt.system.Object) -> winrt.system.Object: ...
    def __delitem__(self, key: winrt.system.Object) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ResourceDictionary: ...
    def __new__(cls: typing.Type[ResourceDictionary]) -> ResourceDictionary:...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[winrt.windows.foundation.collections.IKeyValuePair[winrt.system.Object, winrt.system.Object]]]: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IMapView[winrt.system.Object, winrt.system.Object]]: ...
    def has_key(self, key: typing.Optional[winrt.system.Object], /) -> winrt.system.Boolean: ...
    def insert(self, key: typing.Optional[winrt.system.Object], value: typing.Optional[winrt.system.Object], /) -> winrt.system.Boolean: ...
    def lookup(self, key: typing.Optional[winrt.system.Object], /) -> typing.Optional[winrt.system.Object]: ...
    def remove(self, key: typing.Optional[winrt.system.Object], /) -> None: ...

class RoutedEvent(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RoutedEvent: ...

class RoutedEventArgs(winrt.system.Object):
    original_source: typing.Optional[winrt.system.Object]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RoutedEventArgs: ...
    def __new__(cls: typing.Type[RoutedEventArgs]) -> RoutedEventArgs:...

class ScalarTransition(winrt.system.Object):
    duration: datetime.timedelta
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ScalarTransition: ...
    def __new__(cls: typing.Type[ScalarTransition]) -> ScalarTransition:...

class Setter(winrt.system.Object):
    value: typing.Optional[winrt.system.Object]
    property: typing.Optional[DependencyProperty]
    target: typing.Optional[TargetPropertyPath]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Setter: ...
    @typing.overload
    def __new__(cls: typing.Type[Setter], target_property: typing.Optional[DependencyProperty], value: typing.Optional[winrt.system.Object]) -> Setter:...
    @typing.overload
    def __new__(cls: typing.Type[Setter]) -> Setter:...

class SetterBase(winrt.system.Object):
    is_sealed: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SetterBase: ...

class SetterBaseCollection(winrt.system.Object, typing.MutableSequence[SetterBase]):
    size: winrt.system.UInt32
    is_sealed: winrt.system.Boolean
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> SetterBase: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[SetterBase]: ...
    def insert(self, index: int, value: SetterBase) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: SetterBase) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[SetterBase]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SetterBaseCollection: ...
    def __new__(cls: typing.Type[SetterBaseCollection]) -> SetterBaseCollection:...
    def append(self, value: typing.Optional[SetterBase], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[SetterBase]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[SetterBase]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[SetterBase], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[SetterBase]]: ...
    def index_of(self, value: typing.Optional[SetterBase], /) -> typing.Tuple[winrt.system.Boolean, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[SetterBase], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[SetterBase], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[SetterBase], /) -> None: ...

class SizeChangedEventArgs(winrt.system.Object):
    new_size: winrt.windows.foundation.Size
    previous_size: winrt.windows.foundation.Size
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SizeChangedEventArgs: ...

class SizeHelper(winrt.system.Object):
    empty: typing.ClassVar[winrt.windows.foundation.Size]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SizeHelper: ...
    @staticmethod
    def equals(target: winrt.windows.foundation.Size, value: winrt.windows.foundation.Size, /) -> winrt.system.Boolean: ...
    @staticmethod
    def from_dimensions(width: winrt.system.Single, height: winrt.system.Single, /) -> winrt.windows.foundation.Size: ...
    @staticmethod
    def get_is_empty(target: winrt.windows.foundation.Size, /) -> winrt.system.Boolean: ...

class StateTrigger(winrt.system.Object):
    is_active: winrt.system.Boolean
    is_active_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StateTrigger: ...
    def __new__(cls: typing.Type[StateTrigger]) -> StateTrigger:...

class StateTriggerBase(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StateTriggerBase: ...
    def set_active(self, is_active: winrt.system.Boolean, /) -> None: ...

class Style(winrt.system.Object):
    target_type: winrt.windows.ui.xaml.interop.TypeName
    based_on: typing.Optional[Style]
    is_sealed: winrt.system.Boolean
    setters: typing.Optional[SetterBaseCollection]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Style: ...
    @typing.overload
    def __new__(cls: typing.Type[Style], target_type: winrt.windows.ui.xaml.interop.TypeName) -> Style:...
    @typing.overload
    def __new__(cls: typing.Type[Style]) -> Style:...
    def seal(self) -> None: ...

class TargetPropertyPath(winrt.system.Object):
    target: typing.Optional[winrt.system.Object]
    path: typing.Optional[PropertyPath]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TargetPropertyPath: ...
    @typing.overload
    def __new__(cls: typing.Type[TargetPropertyPath], target_property: typing.Optional[DependencyProperty]) -> TargetPropertyPath:...
    @typing.overload
    def __new__(cls: typing.Type[TargetPropertyPath]) -> TargetPropertyPath:...

class ThicknessHelper(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ThicknessHelper: ...
    @staticmethod
    def from_lengths(left: winrt.system.Double, top: winrt.system.Double, right: winrt.system.Double, bottom: winrt.system.Double, /) -> Thickness: ...
    @staticmethod
    def from_uniform_length(uniform_length: winrt.system.Double, /) -> Thickness: ...

class TriggerAction(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TriggerAction: ...

class TriggerActionCollection(winrt.system.Object, typing.MutableSequence[TriggerAction]):
    size: winrt.system.UInt32
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> TriggerAction: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[TriggerAction]: ...
    def insert(self, index: int, value: TriggerAction) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: TriggerAction) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[TriggerAction]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TriggerActionCollection: ...
    def __new__(cls: typing.Type[TriggerActionCollection]) -> TriggerActionCollection:...
    def append(self, value: typing.Optional[TriggerAction], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[TriggerAction]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[TriggerAction]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[TriggerAction], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[TriggerAction]]: ...
    def index_of(self, value: typing.Optional[TriggerAction], /) -> typing.Tuple[winrt.system.Boolean, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[TriggerAction], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[TriggerAction], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[TriggerAction], /) -> None: ...

class TriggerBase(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TriggerBase: ...

class TriggerCollection(winrt.system.Object, typing.MutableSequence[TriggerBase]):
    size: winrt.system.UInt32
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> TriggerBase: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[TriggerBase]: ...
    def insert(self, index: int, value: TriggerBase) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: TriggerBase) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[TriggerBase]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TriggerCollection: ...
    def append(self, value: typing.Optional[TriggerBase], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[TriggerBase]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[TriggerBase]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[TriggerBase], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[TriggerBase]]: ...
    def index_of(self, value: typing.Optional[TriggerBase], /) -> typing.Tuple[winrt.system.Boolean, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[TriggerBase], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[TriggerBase], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[TriggerBase], /) -> None: ...

class UIElement(winrt.system.Object):
    transitions: typing.Optional[winrt.windows.ui.xaml.media.animation.TransitionCollection]
    projection: typing.Optional[winrt.windows.ui.xaml.media.Projection]
    render_transform_origin: winrt.windows.foundation.Point
    opacity: winrt.system.Double
    manipulation_mode: winrt.windows.ui.xaml.input.ManipulationModes
    is_tap_enabled: winrt.system.Boolean
    is_right_tap_enabled: winrt.system.Boolean
    is_holding_enabled: winrt.system.Boolean
    is_hit_test_visible: winrt.system.Boolean
    is_double_tap_enabled: winrt.system.Boolean
    allow_drop: winrt.system.Boolean
    clip: typing.Optional[winrt.windows.ui.xaml.media.RectangleGeometry]
    cache_mode: typing.Optional[winrt.windows.ui.xaml.media.CacheMode]
    use_layout_rounding: winrt.system.Boolean
    render_transform: typing.Optional[winrt.windows.ui.xaml.media.Transform]
    visibility: Visibility
    desired_size: winrt.windows.foundation.Size
    pointer_captures: typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.ui.xaml.input.Pointer]]
    render_size: winrt.windows.foundation.Size
    xaml_root: typing.Optional[XamlRoot]
    shadow: typing.Optional[winrt.windows.ui.xaml.media.Shadow]
    actual_offset: winrt.windows.foundation.numerics.Vector3
    actual_size: winrt.windows.foundation.numerics.Vector2
    u_i_context: typing.Optional[winrt.windows.ui.UIContext]
    composite_mode: winrt.windows.ui.xaml.media.ElementCompositeMode
    transform3_d: typing.Optional[winrt.windows.ui.xaml.media.media3d.Transform3D]
    can_drag: winrt.system.Boolean
    is_access_key_scope: winrt.system.Boolean
    exit_display_mode_on_access_key_invoked: winrt.system.Boolean
    context_flyout: typing.Optional[winrt.windows.ui.xaml.controls.primitives.FlyoutBase]
    access_key_scope_owner: typing.Optional[DependencyObject]
    access_key: str
    key_tip_horizontal_offset: winrt.system.Double
    high_contrast_adjustment: ElementHighContrastAdjustment
    x_y_focus_right_navigation_strategy: winrt.windows.ui.xaml.input.XYFocusNavigationStrategy
    x_y_focus_keyboard_navigation: winrt.windows.ui.xaml.input.XYFocusKeyboardNavigationMode
    x_y_focus_down_navigation_strategy: winrt.windows.ui.xaml.input.XYFocusNavigationStrategy
    tab_focus_navigation: winrt.windows.ui.xaml.input.KeyboardNavigationMode
    key_tip_vertical_offset: winrt.system.Double
    x_y_focus_up_navigation_strategy: winrt.windows.ui.xaml.input.XYFocusNavigationStrategy
    key_tip_placement_mode: winrt.windows.ui.xaml.input.KeyTipPlacementMode
    x_y_focus_left_navigation_strategy: winrt.windows.ui.xaml.input.XYFocusNavigationStrategy
    lights: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.ui.xaml.media.XamlLight]]
    keyboard_accelerators: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.ui.xaml.input.KeyboardAccelerator]]
    keyboard_accelerator_placement_target: typing.Optional[DependencyObject]
    keyboard_accelerator_placement_mode: winrt.windows.ui.xaml.input.KeyboardAcceleratorPlacementMode
    key_tip_target: typing.Optional[DependencyObject]
    translation_transition: typing.Optional[Vector3Transition]
    opacity_transition: typing.Optional[ScalarTransition]
    transform_matrix: winrt.windows.foundation.numerics.Matrix4x4
    scale_transition: typing.Optional[Vector3Transition]
    scale: winrt.windows.foundation.numerics.Vector3
    rotation_transition: typing.Optional[ScalarTransition]
    rotation_axis: winrt.windows.foundation.numerics.Vector3
    rotation: winrt.system.Single
    translation: winrt.windows.foundation.numerics.Vector3
    center_point: winrt.windows.foundation.numerics.Vector3
    can_be_scroll_anchor: winrt.system.Boolean
    holding_event: typing.ClassVar[typing.Optional[RoutedEvent]]
    is_double_tap_enabled_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    is_hit_test_visible_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    is_holding_enabled_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    is_right_tap_enabled_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    key_down_event: typing.ClassVar[typing.Optional[RoutedEvent]]
    key_up_event: typing.ClassVar[typing.Optional[RoutedEvent]]
    manipulation_completed_event: typing.ClassVar[typing.Optional[RoutedEvent]]
    manipulation_delta_event: typing.ClassVar[typing.Optional[RoutedEvent]]
    is_tap_enabled_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    manipulation_inertia_starting_event: typing.ClassVar[typing.Optional[RoutedEvent]]
    manipulation_mode_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    manipulation_started_event: typing.ClassVar[typing.Optional[RoutedEvent]]
    manipulation_starting_event: typing.ClassVar[typing.Optional[RoutedEvent]]
    opacity_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    pointer_canceled_event: typing.ClassVar[typing.Optional[RoutedEvent]]
    pointer_capture_lost_event: typing.ClassVar[typing.Optional[RoutedEvent]]
    pointer_captures_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    pointer_entered_event: typing.ClassVar[typing.Optional[RoutedEvent]]
    pointer_exited_event: typing.ClassVar[typing.Optional[RoutedEvent]]
    pointer_moved_event: typing.ClassVar[typing.Optional[RoutedEvent]]
    pointer_pressed_event: typing.ClassVar[typing.Optional[RoutedEvent]]
    pointer_wheel_changed_event: typing.ClassVar[typing.Optional[RoutedEvent]]
    projection_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    render_transform_origin_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    render_transform_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    right_tapped_event: typing.ClassVar[typing.Optional[RoutedEvent]]
    drag_enter_event: typing.ClassVar[typing.Optional[RoutedEvent]]
    tapped_event: typing.ClassVar[typing.Optional[RoutedEvent]]
    transitions_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    use_layout_rounding_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    visibility_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    allow_drop_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    cache_mode_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    clip_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    double_tapped_event: typing.ClassVar[typing.Optional[RoutedEvent]]
    pointer_released_event: typing.ClassVar[typing.Optional[RoutedEvent]]
    drag_leave_event: typing.ClassVar[typing.Optional[RoutedEvent]]
    drag_over_event: typing.ClassVar[typing.Optional[RoutedEvent]]
    drop_event: typing.ClassVar[typing.Optional[RoutedEvent]]
    shadow_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    composite_mode_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    can_drag_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    transform3_d_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    access_key_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    access_key_scope_owner_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    context_flyout_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    is_access_key_scope_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    exit_display_mode_on_access_key_invoked_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    high_contrast_adjustment_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    key_tip_horizontal_offset_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    key_tip_placement_mode_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    key_tip_vertical_offset_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    lights_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    x_y_focus_down_navigation_strategy_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    x_y_focus_keyboard_navigation_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    x_y_focus_left_navigation_strategy_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    x_y_focus_right_navigation_strategy_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    x_y_focus_up_navigation_strategy_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    tab_focus_navigation_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    getting_focus_event: typing.ClassVar[typing.Optional[RoutedEvent]]
    losing_focus_event: typing.ClassVar[typing.Optional[RoutedEvent]]
    no_focus_candidate_found_event: typing.ClassVar[typing.Optional[RoutedEvent]]
    character_received_event: typing.ClassVar[typing.Optional[RoutedEvent]]
    preview_key_down_event: typing.ClassVar[typing.Optional[RoutedEvent]]
    preview_key_up_event: typing.ClassVar[typing.Optional[RoutedEvent]]
    bring_into_view_requested_event: typing.ClassVar[typing.Optional[RoutedEvent]]
    context_requested_event: typing.ClassVar[typing.Optional[RoutedEvent]]
    key_tip_target_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    keyboard_accelerator_placement_mode_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    keyboard_accelerator_placement_target_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    can_be_scroll_anchor_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UIElement: ...
    def add_handler(self, routed_event: typing.Optional[RoutedEvent], handler: typing.Optional[winrt.system.Object], handled_events_too: winrt.system.Boolean, /) -> None: ...
    def arrange(self, final_rect: winrt.windows.foundation.Rect, /) -> None: ...
    def cancel_direct_manipulations(self) -> winrt.system.Boolean: ...
    def capture_pointer(self, value: typing.Optional[winrt.windows.ui.xaml.input.Pointer], /) -> winrt.system.Boolean: ...
    def find_sub_elements_for_touch_targeting(self, point: winrt.windows.foundation.Point, bounding_rect: winrt.windows.foundation.Rect, /) -> typing.Optional[winrt.windows.foundation.collections.IIterable[winrt.windows.foundation.collections.IIterable[winrt.windows.foundation.Point]]]: ...
    def get_children_in_tab_focus_order(self) -> typing.Optional[winrt.windows.foundation.collections.IIterable[DependencyObject]]: ...
    def invalidate_arrange(self) -> None: ...
    def invalidate_measure(self) -> None: ...
    def measure(self, available_size: winrt.windows.foundation.Size, /) -> None: ...
    def on_bring_into_view_requested(self, e: typing.Optional[BringIntoViewRequestedEventArgs], /) -> None: ...
    def on_create_automation_peer(self) -> typing.Optional[winrt.windows.ui.xaml.automation.peers.AutomationPeer]: ...
    def on_disconnect_visual_children(self) -> None: ...
    def on_keyboard_accelerator_invoked(self, args: typing.Optional[winrt.windows.ui.xaml.input.KeyboardAcceleratorInvokedEventArgs], /) -> None: ...
    def on_process_keyboard_accelerators(self, args: typing.Optional[winrt.windows.ui.xaml.input.ProcessKeyboardAcceleratorEventArgs], /) -> None: ...
    def populate_property_info(self, property_name: str, property_info: typing.Optional[winrt.windows.ui.composition.AnimationPropertyInfo], /) -> None: ...
    def populate_property_info_override(self, property_name: str, animation_property_info: typing.Optional[winrt.windows.ui.composition.AnimationPropertyInfo], /) -> None: ...
    @staticmethod
    def register_as_scroll_port(element: typing.Optional[UIElement], /) -> None: ...
    def release_pointer_capture(self, value: typing.Optional[winrt.windows.ui.xaml.input.Pointer], /) -> None: ...
    def release_pointer_captures(self) -> None: ...
    def remove_handler(self, routed_event: typing.Optional[RoutedEvent], handler: typing.Optional[winrt.system.Object], /) -> None: ...
    def start_animation(self, animation: typing.Optional[winrt.windows.ui.composition.ICompositionAnimationBase], /) -> None: ...
    @typing.overload
    def start_bring_into_view(self) -> None: ...
    @typing.overload
    def start_bring_into_view(self, options: typing.Optional[BringIntoViewOptions], /) -> None: ...
    def start_drag_async(self, pointer_point: typing.Optional[winrt.windows.ui.input.PointerPoint], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.applicationmodel.datatransfer.DataPackageOperation]: ...
    def stop_animation(self, animation: typing.Optional[winrt.windows.ui.composition.ICompositionAnimationBase], /) -> None: ...
    def transform_to_visual(self, visual: typing.Optional[UIElement], /) -> typing.Optional[winrt.windows.ui.xaml.media.GeneralTransform]: ...
    def try_invoke_keyboard_accelerator(self, args: typing.Optional[winrt.windows.ui.xaml.input.ProcessKeyboardAcceleratorEventArgs], /) -> None: ...
    @staticmethod
    def try_start_direct_manipulation(value: typing.Optional[winrt.windows.ui.xaml.input.Pointer], /) -> winrt.system.Boolean: ...
    def update_layout(self) -> None: ...
    def add_double_tapped(self, handler: typing.Optional[winrt.windows.ui.xaml.input.DoubleTappedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_double_tapped(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_drag_enter(self, handler: typing.Optional[DragEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_drag_enter(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_drag_leave(self, handler: typing.Optional[DragEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_drag_leave(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_drag_over(self, handler: typing.Optional[DragEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_drag_over(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_drop(self, handler: typing.Optional[DragEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_drop(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_got_focus(self, handler: typing.Optional[RoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_got_focus(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_holding(self, handler: typing.Optional[winrt.windows.ui.xaml.input.HoldingEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_holding(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_key_down(self, handler: typing.Optional[winrt.windows.ui.xaml.input.KeyEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_key_down(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_key_up(self, handler: typing.Optional[winrt.windows.ui.xaml.input.KeyEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_key_up(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_lost_focus(self, handler: typing.Optional[RoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_lost_focus(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_manipulation_completed(self, handler: typing.Optional[winrt.windows.ui.xaml.input.ManipulationCompletedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_manipulation_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_manipulation_delta(self, handler: typing.Optional[winrt.windows.ui.xaml.input.ManipulationDeltaEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_manipulation_delta(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_manipulation_inertia_starting(self, handler: typing.Optional[winrt.windows.ui.xaml.input.ManipulationInertiaStartingEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_manipulation_inertia_starting(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_manipulation_started(self, handler: typing.Optional[winrt.windows.ui.xaml.input.ManipulationStartedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_manipulation_started(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_manipulation_starting(self, handler: typing.Optional[winrt.windows.ui.xaml.input.ManipulationStartingEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_manipulation_starting(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_pointer_canceled(self, handler: typing.Optional[winrt.windows.ui.xaml.input.PointerEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_pointer_canceled(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_pointer_capture_lost(self, handler: typing.Optional[winrt.windows.ui.xaml.input.PointerEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_pointer_capture_lost(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_pointer_entered(self, handler: typing.Optional[winrt.windows.ui.xaml.input.PointerEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_pointer_entered(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_pointer_exited(self, handler: typing.Optional[winrt.windows.ui.xaml.input.PointerEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_pointer_exited(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_pointer_moved(self, handler: typing.Optional[winrt.windows.ui.xaml.input.PointerEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_pointer_moved(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_pointer_pressed(self, handler: typing.Optional[winrt.windows.ui.xaml.input.PointerEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_pointer_pressed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_pointer_released(self, handler: typing.Optional[winrt.windows.ui.xaml.input.PointerEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_pointer_released(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_pointer_wheel_changed(self, handler: typing.Optional[winrt.windows.ui.xaml.input.PointerEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_pointer_wheel_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_right_tapped(self, handler: typing.Optional[winrt.windows.ui.xaml.input.RightTappedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_right_tapped(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_tapped(self, handler: typing.Optional[winrt.windows.ui.xaml.input.TappedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_tapped(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_drag_starting(self, handler: winrt.windows.foundation.TypedEventHandler[UIElement, DragStartingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_drag_starting(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_drop_completed(self, handler: winrt.windows.foundation.TypedEventHandler[UIElement, DropCompletedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_drop_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_access_key_display_dismissed(self, handler: winrt.windows.foundation.TypedEventHandler[UIElement, winrt.windows.ui.xaml.input.AccessKeyDisplayDismissedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_access_key_display_dismissed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_access_key_display_requested(self, handler: winrt.windows.foundation.TypedEventHandler[UIElement, winrt.windows.ui.xaml.input.AccessKeyDisplayRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_access_key_display_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_access_key_invoked(self, handler: winrt.windows.foundation.TypedEventHandler[UIElement, winrt.windows.ui.xaml.input.AccessKeyInvokedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_access_key_invoked(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_context_canceled(self, handler: winrt.windows.foundation.TypedEventHandler[UIElement, RoutedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_context_canceled(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_context_requested(self, handler: winrt.windows.foundation.TypedEventHandler[UIElement, winrt.windows.ui.xaml.input.ContextRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_context_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_getting_focus(self, handler: winrt.windows.foundation.TypedEventHandler[UIElement, winrt.windows.ui.xaml.input.GettingFocusEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_getting_focus(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_losing_focus(self, handler: winrt.windows.foundation.TypedEventHandler[UIElement, winrt.windows.ui.xaml.input.LosingFocusEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_losing_focus(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_no_focus_candidate_found(self, handler: winrt.windows.foundation.TypedEventHandler[UIElement, winrt.windows.ui.xaml.input.NoFocusCandidateFoundEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_no_focus_candidate_found(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_character_received(self, handler: winrt.windows.foundation.TypedEventHandler[UIElement, winrt.windows.ui.xaml.input.CharacterReceivedRoutedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_character_received(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_preview_key_down(self, handler: typing.Optional[winrt.windows.ui.xaml.input.KeyEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_preview_key_down(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_preview_key_up(self, handler: typing.Optional[winrt.windows.ui.xaml.input.KeyEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_preview_key_up(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_process_keyboard_accelerators(self, handler: winrt.windows.foundation.TypedEventHandler[UIElement, winrt.windows.ui.xaml.input.ProcessKeyboardAcceleratorEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_process_keyboard_accelerators(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_bring_into_view_requested(self, handler: winrt.windows.foundation.TypedEventHandler[UIElement, BringIntoViewRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_bring_into_view_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class UIElementWeakCollection(winrt.system.Object, typing.MutableSequence[UIElement]):
    size: winrt.system.UInt32
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> UIElement: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[UIElement]: ...
    def insert(self, index: int, value: UIElement) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: UIElement) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[UIElement]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UIElementWeakCollection: ...
    def __new__(cls: typing.Type[UIElementWeakCollection]) -> UIElementWeakCollection:...
    def append(self, value: typing.Optional[UIElement], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[UIElement]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[UIElement]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[UIElement], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[UIElement]]: ...
    def index_of(self, value: typing.Optional[UIElement], /) -> typing.Tuple[winrt.system.Boolean, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[UIElement], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[UIElement], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[UIElement], /) -> None: ...

class UnhandledExceptionEventArgs(winrt.system.Object):
    handled: winrt.system.Boolean
    exception: winrt.windows.foundation.HResult
    message: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UnhandledExceptionEventArgs: ...

class Vector3Transition(winrt.system.Object):
    duration: datetime.timedelta
    components: Vector3TransitionComponents
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Vector3Transition: ...
    def __new__(cls: typing.Type[Vector3Transition]) -> Vector3Transition:...

class VisualState(winrt.system.Object):
    storyboard: typing.Optional[winrt.windows.ui.xaml.media.animation.Storyboard]
    name: str
    setters: typing.Optional[SetterBaseCollection]
    state_triggers: typing.Optional[winrt.windows.foundation.collections.IVector[StateTriggerBase]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VisualState: ...
    def __new__(cls: typing.Type[VisualState]) -> VisualState:...

class VisualStateChangedEventArgs(winrt.system.Object):
    old_state: typing.Optional[VisualState]
    new_state: typing.Optional[VisualState]
    control: typing.Optional[winrt.windows.ui.xaml.controls.Control]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VisualStateChangedEventArgs: ...
    def __new__(cls: typing.Type[VisualStateChangedEventArgs]) -> VisualStateChangedEventArgs:...

class VisualStateGroup(winrt.system.Object):
    current_state: typing.Optional[VisualState]
    name: str
    states: typing.Optional[winrt.windows.foundation.collections.IVector[VisualState]]
    transitions: typing.Optional[winrt.windows.foundation.collections.IVector[VisualTransition]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VisualStateGroup: ...
    def __new__(cls: typing.Type[VisualStateGroup]) -> VisualStateGroup:...
    def add_current_state_changed(self, handler: typing.Optional[VisualStateChangedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_current_state_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_current_state_changing(self, handler: typing.Optional[VisualStateChangedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_current_state_changing(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class VisualStateManager(winrt.system.Object):
    custom_visual_state_manager_property: typing.ClassVar[typing.Optional[DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VisualStateManager: ...
    def __new__(cls: typing.Type[VisualStateManager]) -> VisualStateManager:...
    @staticmethod
    def get_custom_visual_state_manager(obj: typing.Optional[FrameworkElement], /) -> typing.Optional[VisualStateManager]: ...
    @staticmethod
    def get_visual_state_groups(obj: typing.Optional[FrameworkElement], /) -> typing.Optional[winrt.windows.foundation.collections.IVector[VisualStateGroup]]: ...
    @staticmethod
    def go_to_state(control: typing.Optional[winrt.windows.ui.xaml.controls.Control], state_name: str, use_transitions: winrt.system.Boolean, /) -> winrt.system.Boolean: ...
    def go_to_state_core(self, control: typing.Optional[winrt.windows.ui.xaml.controls.Control], template_root: typing.Optional[FrameworkElement], state_name: str, group: typing.Optional[VisualStateGroup], state: typing.Optional[VisualState], use_transitions: winrt.system.Boolean, /) -> winrt.system.Boolean: ...
    def raise_current_state_changed(self, state_group: typing.Optional[VisualStateGroup], old_state: typing.Optional[VisualState], new_state: typing.Optional[VisualState], control: typing.Optional[winrt.windows.ui.xaml.controls.Control], /) -> None: ...
    def raise_current_state_changing(self, state_group: typing.Optional[VisualStateGroup], old_state: typing.Optional[VisualState], new_state: typing.Optional[VisualState], control: typing.Optional[winrt.windows.ui.xaml.controls.Control], /) -> None: ...
    @staticmethod
    def set_custom_visual_state_manager(obj: typing.Optional[FrameworkElement], value: typing.Optional[VisualStateManager], /) -> None: ...

class VisualTransition(winrt.system.Object):
    to: str
    storyboard: typing.Optional[winrt.windows.ui.xaml.media.animation.Storyboard]
    generated_easing_function: typing.Optional[winrt.windows.ui.xaml.media.animation.EasingFunctionBase]
    generated_duration: Duration
    from_: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VisualTransition: ...
    def __new__(cls: typing.Type[VisualTransition]) -> VisualTransition:...

class Window(winrt.system.Object):
    content: typing.Optional[UIElement]
    bounds: winrt.windows.foundation.Rect
    core_window: typing.Optional[winrt.windows.ui.core.CoreWindow]
    dispatcher: typing.Optional[winrt.windows.ui.core.CoreDispatcher]
    visible: winrt.system.Boolean
    compositor: typing.Optional[winrt.windows.ui.composition.Compositor]
    u_i_context: typing.Optional[winrt.windows.ui.UIContext]
    current: typing.ClassVar[typing.Optional[Window]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Window: ...
    def activate(self) -> None: ...
    def close(self) -> None: ...
    def set_title_bar(self, value: typing.Optional[UIElement], /) -> None: ...
    def add_activated(self, handler: typing.Optional[WindowActivatedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_activated(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_closed(self, handler: typing.Optional[WindowClosedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_closed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_size_changed(self, handler: typing.Optional[WindowSizeChangedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_size_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_visibility_changed(self, handler: typing.Optional[WindowVisibilityChangedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_visibility_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class WindowCreatedEventArgs(winrt.system.Object):
    window: typing.Optional[Window]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WindowCreatedEventArgs: ...

class XamlRoot(winrt.system.Object):
    content: typing.Optional[UIElement]
    is_host_visible: winrt.system.Boolean
    rasterization_scale: winrt.system.Double
    size: winrt.windows.foundation.Size
    u_i_context: typing.Optional[winrt.windows.ui.UIContext]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> XamlRoot: ...
    def add_changed(self, handler: winrt.windows.foundation.TypedEventHandler[XamlRoot, XamlRootChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class XamlRootChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> XamlRootChangedEventArgs: ...

class IDataTemplateExtension(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IDataTemplateExtension: ...
    def process_binding(self, phase: winrt.system.UInt32, /) -> winrt.system.Boolean: ...
    def process_bindings(self, arg: typing.Optional[winrt.windows.ui.xaml.controls.ContainerContentChangingEventArgs], /) -> winrt.system.Int32: ...
    def reset_template(self) -> None: ...

class IElementFactory(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IElementFactory: ...
    def get_element(self, args: typing.Optional[ElementFactoryGetArgs], /) -> typing.Optional[UIElement]: ...
    def recycle_element(self, args: typing.Optional[ElementFactoryRecycleArgs], /) -> None: ...

