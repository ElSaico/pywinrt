// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "pybase.h"
#include "py.Windows.UI.Xaml.h"


namespace py::cpp::Windows::UI::Xaml
{
    struct module_state
    {
        PyObject* type_ApplicationHighContrastAdjustment;
        PyObject* type_ApplicationRequiresPointerMode;
        PyObject* type_ApplicationTheme;
        PyObject* type_AutomationTextAttributesEnum;
        PyObject* type_DurationType;
        PyObject* type_ElementHighContrastAdjustment;
        PyObject* type_ElementSoundKind;
        PyObject* type_ElementSoundMode;
        PyObject* type_ElementSoundPlayerState;
        PyObject* type_ElementSpatialAudioMode;
        PyObject* type_ElementTheme;
        PyObject* type_FlowDirection;
        PyObject* type_FocusState;
        PyObject* type_FocusVisualKind;
        PyObject* type_FontCapitals;
        PyObject* type_FontEastAsianLanguage;
        PyObject* type_FontEastAsianWidths;
        PyObject* type_FontFraction;
        PyObject* type_FontNumeralAlignment;
        PyObject* type_FontNumeralStyle;
        PyObject* type_FontVariants;
        PyObject* type_GridUnitType;
        PyObject* type_HorizontalAlignment;
        PyObject* type_LineStackingStrategy;
        PyObject* type_OpticalMarginAlignment;
        PyObject* type_TextAlignment;
        PyObject* type_TextLineBounds;
        PyObject* type_TextReadingOrder;
        PyObject* type_TextTrimming;
        PyObject* type_TextWrapping;
        PyObject* type_Vector3TransitionComponents;
        PyObject* type_VerticalAlignment;
        PyObject* type_Visibility;
        PyTypeObject* type_AdaptiveTrigger;
        PyTypeObject* type_Application;
        PyTypeObject* type_ApplicationInitializationCallbackParams;
        PyTypeObject* type_BindingFailedEventArgs;
        PyTypeObject* type_BringIntoViewOptions;
        PyTypeObject* type_BringIntoViewRequestedEventArgs;
        PyTypeObject* type_BrushTransition;
        PyTypeObject* type_ColorPaletteResources;
        PyTypeObject* type_CornerRadiusHelper;
        PyTypeObject* type_DataContextChangedEventArgs;
        PyTypeObject* type_DataTemplate;
        PyTypeObject* type_DataTemplateKey;
        PyTypeObject* type_DebugSettings;
        PyTypeObject* type_DependencyObject;
        PyTypeObject* type_DependencyObjectCollection;
        PyTypeObject* type_DependencyProperty;
        PyTypeObject* type_DependencyPropertyChangedEventArgs;
        PyTypeObject* type_DispatcherTimer;
        PyTypeObject* type_DragEventArgs;
        PyTypeObject* type_DragOperationDeferral;
        PyTypeObject* type_DragStartingEventArgs;
        PyTypeObject* type_DragUI;
        PyTypeObject* type_DragUIOverride;
        PyTypeObject* type_DropCompletedEventArgs;
        PyTypeObject* type_DurationHelper;
        PyTypeObject* type_EffectiveViewportChangedEventArgs;
        PyTypeObject* type_ElementFactoryGetArgs;
        PyTypeObject* type_ElementFactoryRecycleArgs;
        PyTypeObject* type_ElementSoundPlayer;
        PyTypeObject* type_EventTrigger;
        PyTypeObject* type_ExceptionRoutedEventArgs;
        PyTypeObject* type_FrameworkElement;
        PyTypeObject* type_FrameworkTemplate;
        PyTypeObject* type_FrameworkView;
        PyTypeObject* type_FrameworkViewSource;
        PyTypeObject* type_GridLengthHelper;
        PyTypeObject* type_MediaFailedRoutedEventArgs;
        PyTypeObject* type_PointHelper;
        PyTypeObject* type_PropertyMetadata;
        PyTypeObject* type_PropertyPath;
        PyTypeObject* type_RectHelper;
        PyTypeObject* type_ResourceDictionary;
        PyTypeObject* type_RoutedEvent;
        PyTypeObject* type_RoutedEventArgs;
        PyTypeObject* type_ScalarTransition;
        PyTypeObject* type_Setter;
        PyTypeObject* type_SetterBase;
        PyTypeObject* type_SetterBaseCollection;
        PyTypeObject* type_SizeChangedEventArgs;
        PyTypeObject* type_SizeHelper;
        PyTypeObject* type_StateTrigger;
        PyTypeObject* type_StateTriggerBase;
        PyTypeObject* type_Style;
        PyTypeObject* type_TargetPropertyPath;
        PyTypeObject* type_ThicknessHelper;
        PyTypeObject* type_TriggerAction;
        PyTypeObject* type_TriggerActionCollection;
        PyTypeObject* type_TriggerBase;
        PyTypeObject* type_TriggerCollection;
        PyTypeObject* type_UIElement;
        PyTypeObject* type_UIElementWeakCollection;
        PyTypeObject* type_UnhandledExceptionEventArgs;
        PyTypeObject* type_Vector3Transition;
        PyTypeObject* type_VisualState;
        PyTypeObject* type_VisualStateChangedEventArgs;
        PyTypeObject* type_VisualStateGroup;
        PyTypeObject* type_VisualStateManager;
        PyTypeObject* type_VisualTransition;
        PyTypeObject* type_Window;
        PyTypeObject* type_WindowCreatedEventArgs;
        PyTypeObject* type_XamlRoot;
        PyTypeObject* type_XamlRootChangedEventArgs;
        PyTypeObject* type_IDataTemplateExtension;
        PyTypeObject* type_IElementFactory;
        PyTypeObject* type_CornerRadius;
        PyTypeObject* type_Duration;
        PyTypeObject* type_GridLength;
        PyTypeObject* type_Thickness;
    };

    static PyObject* register_ApplicationHighContrastAdjustment(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_ApplicationHighContrastAdjustment)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ApplicationHighContrastAdjustment = type;
        Py_INCREF(state->type_ApplicationHighContrastAdjustment);


        Py_RETURN_NONE;
    }

    static PyObject* register_ApplicationRequiresPointerMode(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_ApplicationRequiresPointerMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ApplicationRequiresPointerMode = type;
        Py_INCREF(state->type_ApplicationRequiresPointerMode);


        Py_RETURN_NONE;
    }

    static PyObject* register_ApplicationTheme(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_ApplicationTheme)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ApplicationTheme = type;
        Py_INCREF(state->type_ApplicationTheme);


        Py_RETURN_NONE;
    }

    static PyObject* register_AutomationTextAttributesEnum(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_AutomationTextAttributesEnum)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AutomationTextAttributesEnum = type;
        Py_INCREF(state->type_AutomationTextAttributesEnum);


        Py_RETURN_NONE;
    }

    static PyObject* register_DurationType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_DurationType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_DurationType = type;
        Py_INCREF(state->type_DurationType);


        Py_RETURN_NONE;
    }

    static PyObject* register_ElementHighContrastAdjustment(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_ElementHighContrastAdjustment)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ElementHighContrastAdjustment = type;
        Py_INCREF(state->type_ElementHighContrastAdjustment);


        Py_RETURN_NONE;
    }

    static PyObject* register_ElementSoundKind(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_ElementSoundKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ElementSoundKind = type;
        Py_INCREF(state->type_ElementSoundKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_ElementSoundMode(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_ElementSoundMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ElementSoundMode = type;
        Py_INCREF(state->type_ElementSoundMode);


        Py_RETURN_NONE;
    }

    static PyObject* register_ElementSoundPlayerState(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_ElementSoundPlayerState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ElementSoundPlayerState = type;
        Py_INCREF(state->type_ElementSoundPlayerState);


        Py_RETURN_NONE;
    }

    static PyObject* register_ElementSpatialAudioMode(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_ElementSpatialAudioMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ElementSpatialAudioMode = type;
        Py_INCREF(state->type_ElementSpatialAudioMode);


        Py_RETURN_NONE;
    }

    static PyObject* register_ElementTheme(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_ElementTheme)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ElementTheme = type;
        Py_INCREF(state->type_ElementTheme);


        Py_RETURN_NONE;
    }

    static PyObject* register_FlowDirection(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_FlowDirection)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_FlowDirection = type;
        Py_INCREF(state->type_FlowDirection);


        Py_RETURN_NONE;
    }

    static PyObject* register_FocusState(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_FocusState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_FocusState = type;
        Py_INCREF(state->type_FocusState);


        Py_RETURN_NONE;
    }

    static PyObject* register_FocusVisualKind(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_FocusVisualKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_FocusVisualKind = type;
        Py_INCREF(state->type_FocusVisualKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_FontCapitals(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_FontCapitals)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_FontCapitals = type;
        Py_INCREF(state->type_FontCapitals);


        Py_RETURN_NONE;
    }

    static PyObject* register_FontEastAsianLanguage(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_FontEastAsianLanguage)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_FontEastAsianLanguage = type;
        Py_INCREF(state->type_FontEastAsianLanguage);


        Py_RETURN_NONE;
    }

    static PyObject* register_FontEastAsianWidths(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_FontEastAsianWidths)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_FontEastAsianWidths = type;
        Py_INCREF(state->type_FontEastAsianWidths);


        Py_RETURN_NONE;
    }

    static PyObject* register_FontFraction(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_FontFraction)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_FontFraction = type;
        Py_INCREF(state->type_FontFraction);


        Py_RETURN_NONE;
    }

    static PyObject* register_FontNumeralAlignment(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_FontNumeralAlignment)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_FontNumeralAlignment = type;
        Py_INCREF(state->type_FontNumeralAlignment);


        Py_RETURN_NONE;
    }

    static PyObject* register_FontNumeralStyle(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_FontNumeralStyle)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_FontNumeralStyle = type;
        Py_INCREF(state->type_FontNumeralStyle);


        Py_RETURN_NONE;
    }

    static PyObject* register_FontVariants(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_FontVariants)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_FontVariants = type;
        Py_INCREF(state->type_FontVariants);


        Py_RETURN_NONE;
    }

    static PyObject* register_GridUnitType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_GridUnitType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_GridUnitType = type;
        Py_INCREF(state->type_GridUnitType);


        Py_RETURN_NONE;
    }

    static PyObject* register_HorizontalAlignment(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_HorizontalAlignment)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_HorizontalAlignment = type;
        Py_INCREF(state->type_HorizontalAlignment);


        Py_RETURN_NONE;
    }

    static PyObject* register_LineStackingStrategy(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_LineStackingStrategy)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_LineStackingStrategy = type;
        Py_INCREF(state->type_LineStackingStrategy);


        Py_RETURN_NONE;
    }

    static PyObject* register_OpticalMarginAlignment(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_OpticalMarginAlignment)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_OpticalMarginAlignment = type;
        Py_INCREF(state->type_OpticalMarginAlignment);


        Py_RETURN_NONE;
    }

    static PyObject* register_TextAlignment(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_TextAlignment)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_TextAlignment = type;
        Py_INCREF(state->type_TextAlignment);


        Py_RETURN_NONE;
    }

    static PyObject* register_TextLineBounds(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_TextLineBounds)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_TextLineBounds = type;
        Py_INCREF(state->type_TextLineBounds);


        Py_RETURN_NONE;
    }

    static PyObject* register_TextReadingOrder(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_TextReadingOrder)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_TextReadingOrder = type;
        Py_INCREF(state->type_TextReadingOrder);


        Py_RETURN_NONE;
    }

    static PyObject* register_TextTrimming(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_TextTrimming)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_TextTrimming = type;
        Py_INCREF(state->type_TextTrimming);


        Py_RETURN_NONE;
    }

    static PyObject* register_TextWrapping(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_TextWrapping)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_TextWrapping = type;
        Py_INCREF(state->type_TextWrapping);


        Py_RETURN_NONE;
    }

    static PyObject* register_Vector3TransitionComponents(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_Vector3TransitionComponents)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_Vector3TransitionComponents = type;
        Py_INCREF(state->type_Vector3TransitionComponents);


        Py_RETURN_NONE;
    }

    static PyObject* register_VerticalAlignment(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_VerticalAlignment)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_VerticalAlignment = type;
        Py_INCREF(state->type_VerticalAlignment);


        Py_RETURN_NONE;
    }

    static PyObject* register_Visibility(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_Visibility)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_Visibility = type;
        Py_INCREF(state->type_Visibility);


        Py_RETURN_NONE;
    }

    // ----- AdaptiveTrigger class --------------------
    static constexpr const char* const type_name_AdaptiveTrigger = "AdaptiveTrigger";

    static PyObject* _new_AdaptiveTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::AdaptiveTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AdaptiveTrigger(py::wrapper::Windows::UI::Xaml::AdaptiveTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AdaptiveTrigger_get_MinWindowWidth(py::wrapper::Windows::UI::Xaml::AdaptiveTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.AdaptiveTrigger", L"MinWindowWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinWindowWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AdaptiveTrigger_put_MinWindowWidth(py::wrapper::Windows::UI::Xaml::AdaptiveTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.AdaptiveTrigger", L"MinWindowWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.MinWindowWidth(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AdaptiveTrigger_get_MinWindowHeight(py::wrapper::Windows::UI::Xaml::AdaptiveTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.AdaptiveTrigger", L"MinWindowHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinWindowHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AdaptiveTrigger_put_MinWindowHeight(py::wrapper::Windows::UI::Xaml::AdaptiveTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.AdaptiveTrigger", L"MinWindowHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.MinWindowHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AdaptiveTrigger_get_MinWindowHeightProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.AdaptiveTrigger", L"MinWindowHeightProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::AdaptiveTrigger::MinWindowHeightProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveTrigger_get_MinWindowWidthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.AdaptiveTrigger", L"MinWindowWidthProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::AdaptiveTrigger::MinWindowWidthProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AdaptiveTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::AdaptiveTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AdaptiveTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::AdaptiveTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdaptiveTrigger[] = {
        { "_assign_array_", _assign_array_AdaptiveTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AdaptiveTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AdaptiveTrigger[] = {
        { "min_window_width", reinterpret_cast<getter>(AdaptiveTrigger_get_MinWindowWidth), reinterpret_cast<setter>(AdaptiveTrigger_put_MinWindowWidth), nullptr, nullptr },
        { "min_window_height", reinterpret_cast<getter>(AdaptiveTrigger_get_MinWindowHeight), reinterpret_cast<setter>(AdaptiveTrigger_put_MinWindowHeight), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AdaptiveTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AdaptiveTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AdaptiveTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AdaptiveTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AdaptiveTrigger) },
        { },
    };

    static PyType_Spec type_spec_AdaptiveTrigger =
    {
        "_winrt_Windows_UI_Xaml.AdaptiveTrigger",
        sizeof(py::wrapper::Windows::UI::Xaml::AdaptiveTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdaptiveTrigger
    };

    static PyGetSetDef getset_AdaptiveTrigger_Meta[] = {
        { "min_window_height_property", reinterpret_cast<getter>(AdaptiveTrigger_get_MinWindowHeightProperty), nullptr, nullptr, nullptr },
        { "min_window_width_property", reinterpret_cast<getter>(AdaptiveTrigger_get_MinWindowWidthProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_AdaptiveTrigger_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AdaptiveTrigger_Meta) },
        { }
    };

    static PyType_Spec type_spec_AdaptiveTrigger_Meta =
    {
        "_winrt_Windows_UI_Xaml.AdaptiveTrigger_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AdaptiveTrigger_Meta
    };

    // ----- Application class --------------------
    static constexpr const char* const type_name_Application = "Application";

    static PyObject* _new_Application(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Application instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Application(py::wrapper::Windows::UI::Xaml::Application* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Application_Exit(py::wrapper::Windows::UI::Xaml::Application* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Application", L"Exit", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Exit();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Application_LoadComponent(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Application", L"LoadComponent", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);

                winrt::Windows::UI::Xaml::Application::LoadComponent(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Application", L"LoadComponent", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::ComponentResourceLocation>(args, 2);

                winrt::Windows::UI::Xaml::Application::LoadComponent(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Application_OnActivated(py::wrapper::Windows::UI::Xaml::Application* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Application", L"OnActivated", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Activation::IActivatedEventArgs>(args, 0);

                self->obj.OnActivated(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Application_OnBackgroundActivated(py::wrapper::Windows::UI::Xaml::Application* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Application", L"OnBackgroundActivated", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Activation::BackgroundActivatedEventArgs>(args, 0);

                self->obj.OnBackgroundActivated(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Application_OnCachedFileUpdaterActivated(py::wrapper::Windows::UI::Xaml::Application* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Application", L"OnCachedFileUpdaterActivated", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Activation::CachedFileUpdaterActivatedEventArgs>(args, 0);

                self->obj.OnCachedFileUpdaterActivated(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Application_OnFileActivated(py::wrapper::Windows::UI::Xaml::Application* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Application", L"OnFileActivated", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Activation::FileActivatedEventArgs>(args, 0);

                self->obj.OnFileActivated(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Application_OnFileOpenPickerActivated(py::wrapper::Windows::UI::Xaml::Application* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Application", L"OnFileOpenPickerActivated", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Activation::FileOpenPickerActivatedEventArgs>(args, 0);

                self->obj.OnFileOpenPickerActivated(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Application_OnFileSavePickerActivated(py::wrapper::Windows::UI::Xaml::Application* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Application", L"OnFileSavePickerActivated", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Activation::FileSavePickerActivatedEventArgs>(args, 0);

                self->obj.OnFileSavePickerActivated(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Application_OnLaunched(py::wrapper::Windows::UI::Xaml::Application* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Application", L"OnLaunched", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Activation::LaunchActivatedEventArgs>(args, 0);

                self->obj.OnLaunched(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Application_OnSearchActivated(py::wrapper::Windows::UI::Xaml::Application* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Application", L"OnSearchActivated", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Activation::SearchActivatedEventArgs>(args, 0);

                self->obj.OnSearchActivated(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Application_OnShareTargetActivated(py::wrapper::Windows::UI::Xaml::Application* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Application", L"OnShareTargetActivated", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Activation::ShareTargetActivatedEventArgs>(args, 0);

                self->obj.OnShareTargetActivated(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Application_OnWindowCreated(py::wrapper::Windows::UI::Xaml::Application* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Application", L"OnWindowCreated", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::WindowCreatedEventArgs>(args, 0);

                self->obj.OnWindowCreated(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Application_Start(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Application", L"Start", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::ApplicationInitializationCallback>(args, 0);

                winrt::Windows::UI::Xaml::Application::Start(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Application_get_Resources(py::wrapper::Windows::UI::Xaml::Application* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Application", L"Resources"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Resources());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Application_put_Resources(py::wrapper::Windows::UI::Xaml::Application* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Application", L"Resources"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::ResourceDictionary>(arg);

            self->obj.Resources(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Application_get_RequestedTheme(py::wrapper::Windows::UI::Xaml::Application* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Application", L"RequestedTheme"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RequestedTheme());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Application_put_RequestedTheme(py::wrapper::Windows::UI::Xaml::Application* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Application", L"RequestedTheme"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::ApplicationTheme>(arg);

            self->obj.RequestedTheme(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Application_get_DebugSettings(py::wrapper::Windows::UI::Xaml::Application* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Application", L"DebugSettings"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DebugSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Application_get_RequiresPointerMode(py::wrapper::Windows::UI::Xaml::Application* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Application", L"RequiresPointerMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RequiresPointerMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Application_put_RequiresPointerMode(py::wrapper::Windows::UI::Xaml::Application* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Application", L"RequiresPointerMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::ApplicationRequiresPointerMode>(arg);

            self->obj.RequiresPointerMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Application_get_FocusVisualKind(py::wrapper::Windows::UI::Xaml::Application* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Application", L"FocusVisualKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FocusVisualKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Application_put_FocusVisualKind(py::wrapper::Windows::UI::Xaml::Application* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Application", L"FocusVisualKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::FocusVisualKind>(arg);

            self->obj.FocusVisualKind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Application_get_HighContrastAdjustment(py::wrapper::Windows::UI::Xaml::Application* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Application", L"HighContrastAdjustment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HighContrastAdjustment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Application_put_HighContrastAdjustment(py::wrapper::Windows::UI::Xaml::Application* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Application", L"HighContrastAdjustment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::ApplicationHighContrastAdjustment>(arg);

            self->obj.HighContrastAdjustment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Application_get_Current(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Application", L"Current"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Application::Current());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Application_add_Resuming(py::wrapper::Windows::UI::Xaml::Application* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Application", L"Resuming"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Resuming(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Application_remove_Resuming(py::wrapper::Windows::UI::Xaml::Application* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Application", L"Resuming"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Resuming(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Application_add_Suspending(py::wrapper::Windows::UI::Xaml::Application* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Application", L"Suspending"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::SuspendingEventHandler>(arg);

            return py::convert(self->obj.Suspending(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Application_remove_Suspending(py::wrapper::Windows::UI::Xaml::Application* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Application", L"Suspending"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Suspending(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Application_add_UnhandledException(py::wrapper::Windows::UI::Xaml::Application* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Application", L"UnhandledException"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UnhandledExceptionEventHandler>(arg);

            return py::convert(self->obj.UnhandledException(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Application_remove_UnhandledException(py::wrapper::Windows::UI::Xaml::Application* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Application", L"UnhandledException"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UnhandledException(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Application_add_EnteredBackground(py::wrapper::Windows::UI::Xaml::Application* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Application", L"EnteredBackground"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::EnteredBackgroundEventHandler>(arg);

            return py::convert(self->obj.EnteredBackground(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Application_remove_EnteredBackground(py::wrapper::Windows::UI::Xaml::Application* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Application", L"EnteredBackground"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EnteredBackground(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Application_add_LeavingBackground(py::wrapper::Windows::UI::Xaml::Application* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Application", L"LeavingBackground"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::LeavingBackgroundEventHandler>(arg);

            return py::convert(self->obj.LeavingBackground(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Application_remove_LeavingBackground(py::wrapper::Windows::UI::Xaml::Application* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Application", L"LeavingBackground"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LeavingBackground(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Application(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Application>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Application(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Application>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Application[] = {
        { "exit", reinterpret_cast<PyCFunction>(Application_Exit), METH_VARARGS, nullptr },
        { "load_component", reinterpret_cast<PyCFunction>(Application_LoadComponent), METH_VARARGS | METH_STATIC, nullptr },
        { "on_activated", reinterpret_cast<PyCFunction>(Application_OnActivated), METH_VARARGS, nullptr },
        { "on_background_activated", reinterpret_cast<PyCFunction>(Application_OnBackgroundActivated), METH_VARARGS, nullptr },
        { "on_cached_file_updater_activated", reinterpret_cast<PyCFunction>(Application_OnCachedFileUpdaterActivated), METH_VARARGS, nullptr },
        { "on_file_activated", reinterpret_cast<PyCFunction>(Application_OnFileActivated), METH_VARARGS, nullptr },
        { "on_file_open_picker_activated", reinterpret_cast<PyCFunction>(Application_OnFileOpenPickerActivated), METH_VARARGS, nullptr },
        { "on_file_save_picker_activated", reinterpret_cast<PyCFunction>(Application_OnFileSavePickerActivated), METH_VARARGS, nullptr },
        { "on_launched", reinterpret_cast<PyCFunction>(Application_OnLaunched), METH_VARARGS, nullptr },
        { "on_search_activated", reinterpret_cast<PyCFunction>(Application_OnSearchActivated), METH_VARARGS, nullptr },
        { "on_share_target_activated", reinterpret_cast<PyCFunction>(Application_OnShareTargetActivated), METH_VARARGS, nullptr },
        { "on_window_created", reinterpret_cast<PyCFunction>(Application_OnWindowCreated), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(Application_Start), METH_VARARGS | METH_STATIC, nullptr },
        { "add_resuming", reinterpret_cast<PyCFunction>(Application_add_Resuming), METH_O, nullptr },
        { "remove_resuming", reinterpret_cast<PyCFunction>(Application_remove_Resuming), METH_O, nullptr },
        { "add_suspending", reinterpret_cast<PyCFunction>(Application_add_Suspending), METH_O, nullptr },
        { "remove_suspending", reinterpret_cast<PyCFunction>(Application_remove_Suspending), METH_O, nullptr },
        { "add_unhandled_exception", reinterpret_cast<PyCFunction>(Application_add_UnhandledException), METH_O, nullptr },
        { "remove_unhandled_exception", reinterpret_cast<PyCFunction>(Application_remove_UnhandledException), METH_O, nullptr },
        { "add_entered_background", reinterpret_cast<PyCFunction>(Application_add_EnteredBackground), METH_O, nullptr },
        { "remove_entered_background", reinterpret_cast<PyCFunction>(Application_remove_EnteredBackground), METH_O, nullptr },
        { "add_leaving_background", reinterpret_cast<PyCFunction>(Application_add_LeavingBackground), METH_O, nullptr },
        { "remove_leaving_background", reinterpret_cast<PyCFunction>(Application_remove_LeavingBackground), METH_O, nullptr },
        { "_assign_array_", _assign_array_Application, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Application), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Application[] = {
        { "resources", reinterpret_cast<getter>(Application_get_Resources), reinterpret_cast<setter>(Application_put_Resources), nullptr, nullptr },
        { "requested_theme", reinterpret_cast<getter>(Application_get_RequestedTheme), reinterpret_cast<setter>(Application_put_RequestedTheme), nullptr, nullptr },
        { "debug_settings", reinterpret_cast<getter>(Application_get_DebugSettings), nullptr, nullptr, nullptr },
        { "requires_pointer_mode", reinterpret_cast<getter>(Application_get_RequiresPointerMode), reinterpret_cast<setter>(Application_put_RequiresPointerMode), nullptr, nullptr },
        { "focus_visual_kind", reinterpret_cast<getter>(Application_get_FocusVisualKind), reinterpret_cast<setter>(Application_put_FocusVisualKind), nullptr, nullptr },
        { "high_contrast_adjustment", reinterpret_cast<getter>(Application_get_HighContrastAdjustment), reinterpret_cast<setter>(Application_put_HighContrastAdjustment), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Application[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Application) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Application) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Application) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Application) },
        { },
    };

    static PyType_Spec type_spec_Application =
    {
        "_winrt_Windows_UI_Xaml.Application",
        sizeof(py::wrapper::Windows::UI::Xaml::Application),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Application
    };

    static PyGetSetDef getset_Application_Meta[] = {
        { "current", reinterpret_cast<getter>(Application_get_Current), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_Application_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Application_Meta) },
        { }
    };

    static PyType_Spec type_spec_Application_Meta =
    {
        "_winrt_Windows_UI_Xaml.Application_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Application_Meta
    };

    // ----- ApplicationInitializationCallbackParams class --------------------
    static constexpr const char* const type_name_ApplicationInitializationCallbackParams = "ApplicationInitializationCallbackParams";

    static PyObject* _new_ApplicationInitializationCallbackParams(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ApplicationInitializationCallbackParams);
        return nullptr;
    }

    static void _dealloc_ApplicationInitializationCallbackParams(py::wrapper::Windows::UI::Xaml::ApplicationInitializationCallbackParams* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ApplicationInitializationCallbackParams(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::ApplicationInitializationCallbackParams>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ApplicationInitializationCallbackParams(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::ApplicationInitializationCallbackParams>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ApplicationInitializationCallbackParams[] = {
        { "_assign_array_", _assign_array_ApplicationInitializationCallbackParams, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ApplicationInitializationCallbackParams), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ApplicationInitializationCallbackParams[] = {
        { }
    };

    static PyType_Slot _type_slots_ApplicationInitializationCallbackParams[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ApplicationInitializationCallbackParams) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ApplicationInitializationCallbackParams) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ApplicationInitializationCallbackParams) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ApplicationInitializationCallbackParams) },
        { },
    };

    static PyType_Spec type_spec_ApplicationInitializationCallbackParams =
    {
        "_winrt_Windows_UI_Xaml.ApplicationInitializationCallbackParams",
        sizeof(py::wrapper::Windows::UI::Xaml::ApplicationInitializationCallbackParams),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ApplicationInitializationCallbackParams
    };

    // ----- BindingFailedEventArgs class --------------------
    static constexpr const char* const type_name_BindingFailedEventArgs = "BindingFailedEventArgs";

    static PyObject* _new_BindingFailedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BindingFailedEventArgs);
        return nullptr;
    }

    static void _dealloc_BindingFailedEventArgs(py::wrapper::Windows::UI::Xaml::BindingFailedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BindingFailedEventArgs_get_Message(py::wrapper::Windows::UI::Xaml::BindingFailedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.BindingFailedEventArgs", L"Message"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Message());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BindingFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::BindingFailedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BindingFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::BindingFailedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BindingFailedEventArgs[] = {
        { "_assign_array_", _assign_array_BindingFailedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BindingFailedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BindingFailedEventArgs[] = {
        { "message", reinterpret_cast<getter>(BindingFailedEventArgs_get_Message), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BindingFailedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BindingFailedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BindingFailedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BindingFailedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BindingFailedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_BindingFailedEventArgs =
    {
        "_winrt_Windows_UI_Xaml.BindingFailedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::BindingFailedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BindingFailedEventArgs
    };

    // ----- BringIntoViewOptions class --------------------
    static constexpr const char* const type_name_BringIntoViewOptions = "BringIntoViewOptions";

    static PyObject* _new_BringIntoViewOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::BringIntoViewOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BringIntoViewOptions(py::wrapper::Windows::UI::Xaml::BringIntoViewOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BringIntoViewOptions_get_TargetRect(py::wrapper::Windows::UI::Xaml::BringIntoViewOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.BringIntoViewOptions", L"TargetRect"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TargetRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BringIntoViewOptions_put_TargetRect(py::wrapper::Windows::UI::Xaml::BringIntoViewOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.BringIntoViewOptions", L"TargetRect"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::Rect>>(arg);

            self->obj.TargetRect(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BringIntoViewOptions_get_AnimationDesired(py::wrapper::Windows::UI::Xaml::BringIntoViewOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.BringIntoViewOptions", L"AnimationDesired"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AnimationDesired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BringIntoViewOptions_put_AnimationDesired(py::wrapper::Windows::UI::Xaml::BringIntoViewOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.BringIntoViewOptions", L"AnimationDesired"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AnimationDesired(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BringIntoViewOptions_get_VerticalOffset(py::wrapper::Windows::UI::Xaml::BringIntoViewOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.BringIntoViewOptions", L"VerticalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VerticalOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BringIntoViewOptions_put_VerticalOffset(py::wrapper::Windows::UI::Xaml::BringIntoViewOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.BringIntoViewOptions", L"VerticalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.VerticalOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BringIntoViewOptions_get_VerticalAlignmentRatio(py::wrapper::Windows::UI::Xaml::BringIntoViewOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.BringIntoViewOptions", L"VerticalAlignmentRatio"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VerticalAlignmentRatio());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BringIntoViewOptions_put_VerticalAlignmentRatio(py::wrapper::Windows::UI::Xaml::BringIntoViewOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.BringIntoViewOptions", L"VerticalAlignmentRatio"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.VerticalAlignmentRatio(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BringIntoViewOptions_get_HorizontalOffset(py::wrapper::Windows::UI::Xaml::BringIntoViewOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.BringIntoViewOptions", L"HorizontalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HorizontalOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BringIntoViewOptions_put_HorizontalOffset(py::wrapper::Windows::UI::Xaml::BringIntoViewOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.BringIntoViewOptions", L"HorizontalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.HorizontalOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BringIntoViewOptions_get_HorizontalAlignmentRatio(py::wrapper::Windows::UI::Xaml::BringIntoViewOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.BringIntoViewOptions", L"HorizontalAlignmentRatio"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HorizontalAlignmentRatio());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BringIntoViewOptions_put_HorizontalAlignmentRatio(py::wrapper::Windows::UI::Xaml::BringIntoViewOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.BringIntoViewOptions", L"HorizontalAlignmentRatio"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.HorizontalAlignmentRatio(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_BringIntoViewOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::BringIntoViewOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BringIntoViewOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::BringIntoViewOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BringIntoViewOptions[] = {
        { "_assign_array_", _assign_array_BringIntoViewOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BringIntoViewOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BringIntoViewOptions[] = {
        { "target_rect", reinterpret_cast<getter>(BringIntoViewOptions_get_TargetRect), reinterpret_cast<setter>(BringIntoViewOptions_put_TargetRect), nullptr, nullptr },
        { "animation_desired", reinterpret_cast<getter>(BringIntoViewOptions_get_AnimationDesired), reinterpret_cast<setter>(BringIntoViewOptions_put_AnimationDesired), nullptr, nullptr },
        { "vertical_offset", reinterpret_cast<getter>(BringIntoViewOptions_get_VerticalOffset), reinterpret_cast<setter>(BringIntoViewOptions_put_VerticalOffset), nullptr, nullptr },
        { "vertical_alignment_ratio", reinterpret_cast<getter>(BringIntoViewOptions_get_VerticalAlignmentRatio), reinterpret_cast<setter>(BringIntoViewOptions_put_VerticalAlignmentRatio), nullptr, nullptr },
        { "horizontal_offset", reinterpret_cast<getter>(BringIntoViewOptions_get_HorizontalOffset), reinterpret_cast<setter>(BringIntoViewOptions_put_HorizontalOffset), nullptr, nullptr },
        { "horizontal_alignment_ratio", reinterpret_cast<getter>(BringIntoViewOptions_get_HorizontalAlignmentRatio), reinterpret_cast<setter>(BringIntoViewOptions_put_HorizontalAlignmentRatio), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BringIntoViewOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BringIntoViewOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BringIntoViewOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BringIntoViewOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BringIntoViewOptions) },
        { },
    };

    static PyType_Spec type_spec_BringIntoViewOptions =
    {
        "_winrt_Windows_UI_Xaml.BringIntoViewOptions",
        sizeof(py::wrapper::Windows::UI::Xaml::BringIntoViewOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BringIntoViewOptions
    };

    // ----- BringIntoViewRequestedEventArgs class --------------------
    static constexpr const char* const type_name_BringIntoViewRequestedEventArgs = "BringIntoViewRequestedEventArgs";

    static PyObject* _new_BringIntoViewRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BringIntoViewRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_BringIntoViewRequestedEventArgs(py::wrapper::Windows::UI::Xaml::BringIntoViewRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BringIntoViewRequestedEventArgs_get_VerticalOffset(py::wrapper::Windows::UI::Xaml::BringIntoViewRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.BringIntoViewRequestedEventArgs", L"VerticalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VerticalOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BringIntoViewRequestedEventArgs_put_VerticalOffset(py::wrapper::Windows::UI::Xaml::BringIntoViewRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.BringIntoViewRequestedEventArgs", L"VerticalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.VerticalOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BringIntoViewRequestedEventArgs_get_TargetRect(py::wrapper::Windows::UI::Xaml::BringIntoViewRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.BringIntoViewRequestedEventArgs", L"TargetRect"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TargetRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BringIntoViewRequestedEventArgs_put_TargetRect(py::wrapper::Windows::UI::Xaml::BringIntoViewRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.BringIntoViewRequestedEventArgs", L"TargetRect"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(arg);

            self->obj.TargetRect(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BringIntoViewRequestedEventArgs_get_TargetElement(py::wrapper::Windows::UI::Xaml::BringIntoViewRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.BringIntoViewRequestedEventArgs", L"TargetElement"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TargetElement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BringIntoViewRequestedEventArgs_put_TargetElement(py::wrapper::Windows::UI::Xaml::BringIntoViewRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.BringIntoViewRequestedEventArgs", L"TargetElement"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(arg);

            self->obj.TargetElement(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BringIntoViewRequestedEventArgs_get_HorizontalOffset(py::wrapper::Windows::UI::Xaml::BringIntoViewRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.BringIntoViewRequestedEventArgs", L"HorizontalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HorizontalOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BringIntoViewRequestedEventArgs_put_HorizontalOffset(py::wrapper::Windows::UI::Xaml::BringIntoViewRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.BringIntoViewRequestedEventArgs", L"HorizontalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.HorizontalOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BringIntoViewRequestedEventArgs_get_Handled(py::wrapper::Windows::UI::Xaml::BringIntoViewRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.BringIntoViewRequestedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BringIntoViewRequestedEventArgs_put_Handled(py::wrapper::Windows::UI::Xaml::BringIntoViewRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.BringIntoViewRequestedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BringIntoViewRequestedEventArgs_get_AnimationDesired(py::wrapper::Windows::UI::Xaml::BringIntoViewRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.BringIntoViewRequestedEventArgs", L"AnimationDesired"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AnimationDesired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BringIntoViewRequestedEventArgs_put_AnimationDesired(py::wrapper::Windows::UI::Xaml::BringIntoViewRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.BringIntoViewRequestedEventArgs", L"AnimationDesired"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AnimationDesired(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BringIntoViewRequestedEventArgs_get_HorizontalAlignmentRatio(py::wrapper::Windows::UI::Xaml::BringIntoViewRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.BringIntoViewRequestedEventArgs", L"HorizontalAlignmentRatio"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HorizontalAlignmentRatio());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BringIntoViewRequestedEventArgs_get_VerticalAlignmentRatio(py::wrapper::Windows::UI::Xaml::BringIntoViewRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.BringIntoViewRequestedEventArgs", L"VerticalAlignmentRatio"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VerticalAlignmentRatio());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BringIntoViewRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::BringIntoViewRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BringIntoViewRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::BringIntoViewRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BringIntoViewRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_BringIntoViewRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BringIntoViewRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BringIntoViewRequestedEventArgs[] = {
        { "vertical_offset", reinterpret_cast<getter>(BringIntoViewRequestedEventArgs_get_VerticalOffset), reinterpret_cast<setter>(BringIntoViewRequestedEventArgs_put_VerticalOffset), nullptr, nullptr },
        { "target_rect", reinterpret_cast<getter>(BringIntoViewRequestedEventArgs_get_TargetRect), reinterpret_cast<setter>(BringIntoViewRequestedEventArgs_put_TargetRect), nullptr, nullptr },
        { "target_element", reinterpret_cast<getter>(BringIntoViewRequestedEventArgs_get_TargetElement), reinterpret_cast<setter>(BringIntoViewRequestedEventArgs_put_TargetElement), nullptr, nullptr },
        { "horizontal_offset", reinterpret_cast<getter>(BringIntoViewRequestedEventArgs_get_HorizontalOffset), reinterpret_cast<setter>(BringIntoViewRequestedEventArgs_put_HorizontalOffset), nullptr, nullptr },
        { "handled", reinterpret_cast<getter>(BringIntoViewRequestedEventArgs_get_Handled), reinterpret_cast<setter>(BringIntoViewRequestedEventArgs_put_Handled), nullptr, nullptr },
        { "animation_desired", reinterpret_cast<getter>(BringIntoViewRequestedEventArgs_get_AnimationDesired), reinterpret_cast<setter>(BringIntoViewRequestedEventArgs_put_AnimationDesired), nullptr, nullptr },
        { "horizontal_alignment_ratio", reinterpret_cast<getter>(BringIntoViewRequestedEventArgs_get_HorizontalAlignmentRatio), nullptr, nullptr, nullptr },
        { "vertical_alignment_ratio", reinterpret_cast<getter>(BringIntoViewRequestedEventArgs_get_VerticalAlignmentRatio), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BringIntoViewRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BringIntoViewRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BringIntoViewRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BringIntoViewRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BringIntoViewRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_BringIntoViewRequestedEventArgs =
    {
        "_winrt_Windows_UI_Xaml.BringIntoViewRequestedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::BringIntoViewRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BringIntoViewRequestedEventArgs
    };

    // ----- BrushTransition class --------------------
    static constexpr const char* const type_name_BrushTransition = "BrushTransition";

    static PyObject* _new_BrushTransition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::BrushTransition instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BrushTransition(py::wrapper::Windows::UI::Xaml::BrushTransition* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BrushTransition_get_Duration(py::wrapper::Windows::UI::Xaml::BrushTransition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.BrushTransition", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BrushTransition_put_Duration(py::wrapper::Windows::UI::Xaml::BrushTransition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.BrushTransition", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_BrushTransition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::BrushTransition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BrushTransition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::BrushTransition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BrushTransition[] = {
        { "_assign_array_", _assign_array_BrushTransition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BrushTransition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BrushTransition[] = {
        { "duration", reinterpret_cast<getter>(BrushTransition_get_Duration), reinterpret_cast<setter>(BrushTransition_put_Duration), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BrushTransition[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BrushTransition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BrushTransition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BrushTransition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BrushTransition) },
        { },
    };

    static PyType_Spec type_spec_BrushTransition =
    {
        "_winrt_Windows_UI_Xaml.BrushTransition",
        sizeof(py::wrapper::Windows::UI::Xaml::BrushTransition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BrushTransition
    };

    // ----- ColorPaletteResources class --------------------
    static constexpr const char* const type_name_ColorPaletteResources = "ColorPaletteResources";

    static PyObject* _new_ColorPaletteResources(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::ColorPaletteResources instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ColorPaletteResources(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ColorPaletteResources_get_ListMedium(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"ListMedium"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ListMedium());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPaletteResources_put_ListMedium(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"ListMedium"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.ListMedium(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorPaletteResources_get_ListLow(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"ListLow"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ListLow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPaletteResources_put_ListLow(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"ListLow"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.ListLow(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorPaletteResources_get_ErrorText(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"ErrorText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPaletteResources_put_ErrorText(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"ErrorText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.ErrorText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorPaletteResources_get_ChromeWhite(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"ChromeWhite"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ChromeWhite());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPaletteResources_put_ChromeWhite(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"ChromeWhite"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.ChromeWhite(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorPaletteResources_get_ChromeMediumLow(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"ChromeMediumLow"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ChromeMediumLow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPaletteResources_put_ChromeMediumLow(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"ChromeMediumLow"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.ChromeMediumLow(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorPaletteResources_get_ChromeMedium(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"ChromeMedium"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ChromeMedium());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPaletteResources_put_ChromeMedium(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"ChromeMedium"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.ChromeMedium(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorPaletteResources_get_ChromeLow(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"ChromeLow"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ChromeLow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPaletteResources_put_ChromeLow(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"ChromeLow"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.ChromeLow(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorPaletteResources_get_ChromeHigh(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"ChromeHigh"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ChromeHigh());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPaletteResources_put_ChromeHigh(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"ChromeHigh"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.ChromeHigh(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorPaletteResources_get_ChromeGray(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"ChromeGray"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ChromeGray());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPaletteResources_put_ChromeGray(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"ChromeGray"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.ChromeGray(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorPaletteResources_get_ChromeDisabledLow(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"ChromeDisabledLow"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ChromeDisabledLow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPaletteResources_put_ChromeDisabledLow(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"ChromeDisabledLow"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.ChromeDisabledLow(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorPaletteResources_get_ChromeDisabledHigh(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"ChromeDisabledHigh"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ChromeDisabledHigh());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPaletteResources_put_ChromeDisabledHigh(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"ChromeDisabledHigh"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.ChromeDisabledHigh(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorPaletteResources_get_ChromeBlackMediumLow(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"ChromeBlackMediumLow"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ChromeBlackMediumLow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPaletteResources_put_ChromeBlackMediumLow(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"ChromeBlackMediumLow"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.ChromeBlackMediumLow(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorPaletteResources_get_ChromeBlackMedium(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"ChromeBlackMedium"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ChromeBlackMedium());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPaletteResources_put_ChromeBlackMedium(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"ChromeBlackMedium"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.ChromeBlackMedium(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorPaletteResources_get_ChromeBlackLow(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"ChromeBlackLow"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ChromeBlackLow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPaletteResources_put_ChromeBlackLow(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"ChromeBlackLow"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.ChromeBlackLow(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorPaletteResources_get_ChromeBlackHigh(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"ChromeBlackHigh"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ChromeBlackHigh());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPaletteResources_put_ChromeBlackHigh(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"ChromeBlackHigh"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.ChromeBlackHigh(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorPaletteResources_get_ChromeAltLow(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"ChromeAltLow"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ChromeAltLow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPaletteResources_put_ChromeAltLow(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"ChromeAltLow"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.ChromeAltLow(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorPaletteResources_get_BaseMediumLow(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"BaseMediumLow"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BaseMediumLow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPaletteResources_put_BaseMediumLow(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"BaseMediumLow"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.BaseMediumLow(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorPaletteResources_get_BaseMediumHigh(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"BaseMediumHigh"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BaseMediumHigh());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPaletteResources_put_BaseMediumHigh(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"BaseMediumHigh"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.BaseMediumHigh(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorPaletteResources_get_BaseMedium(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"BaseMedium"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BaseMedium());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPaletteResources_put_BaseMedium(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"BaseMedium"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.BaseMedium(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorPaletteResources_get_BaseLow(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"BaseLow"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BaseLow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPaletteResources_put_BaseLow(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"BaseLow"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.BaseLow(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorPaletteResources_get_BaseHigh(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"BaseHigh"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BaseHigh());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPaletteResources_put_BaseHigh(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"BaseHigh"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.BaseHigh(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorPaletteResources_get_AltMediumLow(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"AltMediumLow"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AltMediumLow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPaletteResources_put_AltMediumLow(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"AltMediumLow"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.AltMediumLow(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorPaletteResources_get_AltMediumHigh(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"AltMediumHigh"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AltMediumHigh());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPaletteResources_put_AltMediumHigh(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"AltMediumHigh"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.AltMediumHigh(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorPaletteResources_get_AltMedium(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"AltMedium"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AltMedium());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPaletteResources_put_AltMedium(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"AltMedium"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.AltMedium(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorPaletteResources_get_AltLow(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"AltLow"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AltLow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPaletteResources_put_AltLow(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"AltLow"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.AltLow(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorPaletteResources_get_AltHigh(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"AltHigh"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AltHigh());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPaletteResources_put_AltHigh(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"AltHigh"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.AltHigh(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorPaletteResources_get_Accent(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"Accent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Accent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorPaletteResources_put_Accent(py::wrapper::Windows::UI::Xaml::ColorPaletteResources* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ColorPaletteResources", L"Accent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.Accent(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ColorPaletteResources(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::ColorPaletteResources>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ColorPaletteResources(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::ColorPaletteResources>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ColorPaletteResources[] = {
        { "_assign_array_", _assign_array_ColorPaletteResources, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ColorPaletteResources), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ColorPaletteResources[] = {
        { "list_medium", reinterpret_cast<getter>(ColorPaletteResources_get_ListMedium), reinterpret_cast<setter>(ColorPaletteResources_put_ListMedium), nullptr, nullptr },
        { "list_low", reinterpret_cast<getter>(ColorPaletteResources_get_ListLow), reinterpret_cast<setter>(ColorPaletteResources_put_ListLow), nullptr, nullptr },
        { "error_text", reinterpret_cast<getter>(ColorPaletteResources_get_ErrorText), reinterpret_cast<setter>(ColorPaletteResources_put_ErrorText), nullptr, nullptr },
        { "chrome_white", reinterpret_cast<getter>(ColorPaletteResources_get_ChromeWhite), reinterpret_cast<setter>(ColorPaletteResources_put_ChromeWhite), nullptr, nullptr },
        { "chrome_medium_low", reinterpret_cast<getter>(ColorPaletteResources_get_ChromeMediumLow), reinterpret_cast<setter>(ColorPaletteResources_put_ChromeMediumLow), nullptr, nullptr },
        { "chrome_medium", reinterpret_cast<getter>(ColorPaletteResources_get_ChromeMedium), reinterpret_cast<setter>(ColorPaletteResources_put_ChromeMedium), nullptr, nullptr },
        { "chrome_low", reinterpret_cast<getter>(ColorPaletteResources_get_ChromeLow), reinterpret_cast<setter>(ColorPaletteResources_put_ChromeLow), nullptr, nullptr },
        { "chrome_high", reinterpret_cast<getter>(ColorPaletteResources_get_ChromeHigh), reinterpret_cast<setter>(ColorPaletteResources_put_ChromeHigh), nullptr, nullptr },
        { "chrome_gray", reinterpret_cast<getter>(ColorPaletteResources_get_ChromeGray), reinterpret_cast<setter>(ColorPaletteResources_put_ChromeGray), nullptr, nullptr },
        { "chrome_disabled_low", reinterpret_cast<getter>(ColorPaletteResources_get_ChromeDisabledLow), reinterpret_cast<setter>(ColorPaletteResources_put_ChromeDisabledLow), nullptr, nullptr },
        { "chrome_disabled_high", reinterpret_cast<getter>(ColorPaletteResources_get_ChromeDisabledHigh), reinterpret_cast<setter>(ColorPaletteResources_put_ChromeDisabledHigh), nullptr, nullptr },
        { "chrome_black_medium_low", reinterpret_cast<getter>(ColorPaletteResources_get_ChromeBlackMediumLow), reinterpret_cast<setter>(ColorPaletteResources_put_ChromeBlackMediumLow), nullptr, nullptr },
        { "chrome_black_medium", reinterpret_cast<getter>(ColorPaletteResources_get_ChromeBlackMedium), reinterpret_cast<setter>(ColorPaletteResources_put_ChromeBlackMedium), nullptr, nullptr },
        { "chrome_black_low", reinterpret_cast<getter>(ColorPaletteResources_get_ChromeBlackLow), reinterpret_cast<setter>(ColorPaletteResources_put_ChromeBlackLow), nullptr, nullptr },
        { "chrome_black_high", reinterpret_cast<getter>(ColorPaletteResources_get_ChromeBlackHigh), reinterpret_cast<setter>(ColorPaletteResources_put_ChromeBlackHigh), nullptr, nullptr },
        { "chrome_alt_low", reinterpret_cast<getter>(ColorPaletteResources_get_ChromeAltLow), reinterpret_cast<setter>(ColorPaletteResources_put_ChromeAltLow), nullptr, nullptr },
        { "base_medium_low", reinterpret_cast<getter>(ColorPaletteResources_get_BaseMediumLow), reinterpret_cast<setter>(ColorPaletteResources_put_BaseMediumLow), nullptr, nullptr },
        { "base_medium_high", reinterpret_cast<getter>(ColorPaletteResources_get_BaseMediumHigh), reinterpret_cast<setter>(ColorPaletteResources_put_BaseMediumHigh), nullptr, nullptr },
        { "base_medium", reinterpret_cast<getter>(ColorPaletteResources_get_BaseMedium), reinterpret_cast<setter>(ColorPaletteResources_put_BaseMedium), nullptr, nullptr },
        { "base_low", reinterpret_cast<getter>(ColorPaletteResources_get_BaseLow), reinterpret_cast<setter>(ColorPaletteResources_put_BaseLow), nullptr, nullptr },
        { "base_high", reinterpret_cast<getter>(ColorPaletteResources_get_BaseHigh), reinterpret_cast<setter>(ColorPaletteResources_put_BaseHigh), nullptr, nullptr },
        { "alt_medium_low", reinterpret_cast<getter>(ColorPaletteResources_get_AltMediumLow), reinterpret_cast<setter>(ColorPaletteResources_put_AltMediumLow), nullptr, nullptr },
        { "alt_medium_high", reinterpret_cast<getter>(ColorPaletteResources_get_AltMediumHigh), reinterpret_cast<setter>(ColorPaletteResources_put_AltMediumHigh), nullptr, nullptr },
        { "alt_medium", reinterpret_cast<getter>(ColorPaletteResources_get_AltMedium), reinterpret_cast<setter>(ColorPaletteResources_put_AltMedium), nullptr, nullptr },
        { "alt_low", reinterpret_cast<getter>(ColorPaletteResources_get_AltLow), reinterpret_cast<setter>(ColorPaletteResources_put_AltLow), nullptr, nullptr },
        { "alt_high", reinterpret_cast<getter>(ColorPaletteResources_get_AltHigh), reinterpret_cast<setter>(ColorPaletteResources_put_AltHigh), nullptr, nullptr },
        { "accent", reinterpret_cast<getter>(ColorPaletteResources_get_Accent), reinterpret_cast<setter>(ColorPaletteResources_put_Accent), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ColorPaletteResources[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ColorPaletteResources) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ColorPaletteResources) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ColorPaletteResources) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ColorPaletteResources) },
        { },
    };

    static PyType_Spec type_spec_ColorPaletteResources =
    {
        "_winrt_Windows_UI_Xaml.ColorPaletteResources",
        sizeof(py::wrapper::Windows::UI::Xaml::ColorPaletteResources),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ColorPaletteResources
    };

    // ----- CornerRadiusHelper class --------------------
    static constexpr const char* const type_name_CornerRadiusHelper = "CornerRadiusHelper";

    static PyObject* _new_CornerRadiusHelper(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CornerRadiusHelper);
        return nullptr;
    }

    static void _dealloc_CornerRadiusHelper(py::wrapper::Windows::UI::Xaml::CornerRadiusHelper* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CornerRadiusHelper_FromRadii(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.CornerRadiusHelper", L"FromRadii", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<double>(args, 2);
                auto param3 = py::convert_to<double>(args, 3);

                return py::convert(winrt::Windows::UI::Xaml::CornerRadiusHelper::FromRadii(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CornerRadiusHelper_FromUniformRadius(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.CornerRadiusHelper", L"FromUniformRadius", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::CornerRadiusHelper::FromUniformRadius(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_CornerRadiusHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::CornerRadiusHelper>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CornerRadiusHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::CornerRadiusHelper>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CornerRadiusHelper[] = {
        { "from_radii", reinterpret_cast<PyCFunction>(CornerRadiusHelper_FromRadii), METH_VARARGS | METH_STATIC, nullptr },
        { "from_uniform_radius", reinterpret_cast<PyCFunction>(CornerRadiusHelper_FromUniformRadius), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_CornerRadiusHelper, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CornerRadiusHelper), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CornerRadiusHelper[] = {
        { }
    };

    static PyType_Slot _type_slots_CornerRadiusHelper[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CornerRadiusHelper) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CornerRadiusHelper) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CornerRadiusHelper) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CornerRadiusHelper) },
        { },
    };

    static PyType_Spec type_spec_CornerRadiusHelper =
    {
        "_winrt_Windows_UI_Xaml.CornerRadiusHelper",
        sizeof(py::wrapper::Windows::UI::Xaml::CornerRadiusHelper),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CornerRadiusHelper
    };

    // ----- DataContextChangedEventArgs class --------------------
    static constexpr const char* const type_name_DataContextChangedEventArgs = "DataContextChangedEventArgs";

    static PyObject* _new_DataContextChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DataContextChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_DataContextChangedEventArgs(py::wrapper::Windows::UI::Xaml::DataContextChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DataContextChangedEventArgs_get_Handled(py::wrapper::Windows::UI::Xaml::DataContextChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DataContextChangedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataContextChangedEventArgs_put_Handled(py::wrapper::Windows::UI::Xaml::DataContextChangedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DataContextChangedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataContextChangedEventArgs_get_NewValue(py::wrapper::Windows::UI::Xaml::DataContextChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DataContextChangedEventArgs", L"NewValue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NewValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DataContextChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::DataContextChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DataContextChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::DataContextChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DataContextChangedEventArgs[] = {
        { "_assign_array_", _assign_array_DataContextChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DataContextChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DataContextChangedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(DataContextChangedEventArgs_get_Handled), reinterpret_cast<setter>(DataContextChangedEventArgs_put_Handled), nullptr, nullptr },
        { "new_value", reinterpret_cast<getter>(DataContextChangedEventArgs_get_NewValue), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DataContextChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DataContextChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DataContextChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DataContextChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DataContextChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_DataContextChangedEventArgs =
    {
        "_winrt_Windows_UI_Xaml.DataContextChangedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::DataContextChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DataContextChangedEventArgs
    };

    // ----- DataTemplate class --------------------
    static constexpr const char* const type_name_DataTemplate = "DataTemplate";

    static PyObject* _new_DataTemplate(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::DataTemplate instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DataTemplate(py::wrapper::Windows::UI::Xaml::DataTemplate* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DataTemplate_GetElement(py::wrapper::Windows::UI::Xaml::DataTemplate* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DataTemplate", L"GetElement", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::ElementFactoryGetArgs>(args, 0);

                return py::convert(self->obj.GetElement(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataTemplate_GetExtensionInstance(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DataTemplate", L"GetExtensionInstance", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::FrameworkElement>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::DataTemplate::GetExtensionInstance(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataTemplate_LoadContent(py::wrapper::Windows::UI::Xaml::DataTemplate* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DataTemplate", L"LoadContent", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.LoadContent());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataTemplate_RecycleElement(py::wrapper::Windows::UI::Xaml::DataTemplate* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DataTemplate", L"RecycleElement", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::ElementFactoryRecycleArgs>(args, 0);

                self->obj.RecycleElement(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataTemplate_SetExtensionInstance(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DataTemplate", L"SetExtensionInstance", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::FrameworkElement>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::IDataTemplateExtension>(args, 1);

                winrt::Windows::UI::Xaml::DataTemplate::SetExtensionInstance(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataTemplate_get_ExtensionInstanceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DataTemplate", L"ExtensionInstanceProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::DataTemplate::ExtensionInstanceProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DataTemplate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::DataTemplate>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DataTemplate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::DataTemplate>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DataTemplate[] = {
        { "get_element", reinterpret_cast<PyCFunction>(DataTemplate_GetElement), METH_VARARGS, nullptr },
        { "get_extension_instance", reinterpret_cast<PyCFunction>(DataTemplate_GetExtensionInstance), METH_VARARGS | METH_STATIC, nullptr },
        { "load_content", reinterpret_cast<PyCFunction>(DataTemplate_LoadContent), METH_VARARGS, nullptr },
        { "recycle_element", reinterpret_cast<PyCFunction>(DataTemplate_RecycleElement), METH_VARARGS, nullptr },
        { "set_extension_instance", reinterpret_cast<PyCFunction>(DataTemplate_SetExtensionInstance), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_DataTemplate, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DataTemplate), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DataTemplate[] = {
        { }
    };

    static PyType_Slot _type_slots_DataTemplate[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DataTemplate) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DataTemplate) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DataTemplate) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DataTemplate) },
        { },
    };

    static PyType_Spec type_spec_DataTemplate =
    {
        "_winrt_Windows_UI_Xaml.DataTemplate",
        sizeof(py::wrapper::Windows::UI::Xaml::DataTemplate),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DataTemplate
    };

    static PyGetSetDef getset_DataTemplate_Meta[] = {
        { "extension_instance_property", reinterpret_cast<getter>(DataTemplate_get_ExtensionInstanceProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_DataTemplate_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DataTemplate_Meta) },
        { }
    };

    static PyType_Spec type_spec_DataTemplate_Meta =
    {
        "_winrt_Windows_UI_Xaml.DataTemplate_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_DataTemplate_Meta
    };

    // ----- DataTemplateKey class --------------------
    static constexpr const char* const type_name_DataTemplateKey = "DataTemplateKey";

    static PyObject* _new_DataTemplateKey(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::DataTemplateKey instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                winrt::Windows::UI::Xaml::DataTemplateKey instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DataTemplateKey(py::wrapper::Windows::UI::Xaml::DataTemplateKey* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DataTemplateKey_get_DataType(py::wrapper::Windows::UI::Xaml::DataTemplateKey* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DataTemplateKey", L"DataType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DataType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataTemplateKey_put_DataType(py::wrapper::Windows::UI::Xaml::DataTemplateKey* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DataTemplateKey", L"DataType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.DataType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_DataTemplateKey(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::DataTemplateKey>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DataTemplateKey(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::DataTemplateKey>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DataTemplateKey[] = {
        { "_assign_array_", _assign_array_DataTemplateKey, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DataTemplateKey), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DataTemplateKey[] = {
        { "data_type", reinterpret_cast<getter>(DataTemplateKey_get_DataType), reinterpret_cast<setter>(DataTemplateKey_put_DataType), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DataTemplateKey[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DataTemplateKey) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DataTemplateKey) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DataTemplateKey) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DataTemplateKey) },
        { },
    };

    static PyType_Spec type_spec_DataTemplateKey =
    {
        "_winrt_Windows_UI_Xaml.DataTemplateKey",
        sizeof(py::wrapper::Windows::UI::Xaml::DataTemplateKey),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DataTemplateKey
    };

    // ----- DebugSettings class --------------------
    static constexpr const char* const type_name_DebugSettings = "DebugSettings";

    static PyObject* _new_DebugSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DebugSettings);
        return nullptr;
    }

    static void _dealloc_DebugSettings(py::wrapper::Windows::UI::Xaml::DebugSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DebugSettings_get_IsOverdrawHeatMapEnabled(py::wrapper::Windows::UI::Xaml::DebugSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DebugSettings", L"IsOverdrawHeatMapEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsOverdrawHeatMapEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DebugSettings_put_IsOverdrawHeatMapEnabled(py::wrapper::Windows::UI::Xaml::DebugSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DebugSettings", L"IsOverdrawHeatMapEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsOverdrawHeatMapEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DebugSettings_get_IsBindingTracingEnabled(py::wrapper::Windows::UI::Xaml::DebugSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DebugSettings", L"IsBindingTracingEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsBindingTracingEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DebugSettings_put_IsBindingTracingEnabled(py::wrapper::Windows::UI::Xaml::DebugSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DebugSettings", L"IsBindingTracingEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsBindingTracingEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DebugSettings_get_EnableFrameRateCounter(py::wrapper::Windows::UI::Xaml::DebugSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DebugSettings", L"EnableFrameRateCounter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EnableFrameRateCounter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DebugSettings_put_EnableFrameRateCounter(py::wrapper::Windows::UI::Xaml::DebugSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DebugSettings", L"EnableFrameRateCounter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.EnableFrameRateCounter(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DebugSettings_get_EnableRedrawRegions(py::wrapper::Windows::UI::Xaml::DebugSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DebugSettings", L"EnableRedrawRegions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EnableRedrawRegions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DebugSettings_put_EnableRedrawRegions(py::wrapper::Windows::UI::Xaml::DebugSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DebugSettings", L"EnableRedrawRegions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.EnableRedrawRegions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DebugSettings_get_IsTextPerformanceVisualizationEnabled(py::wrapper::Windows::UI::Xaml::DebugSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DebugSettings", L"IsTextPerformanceVisualizationEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsTextPerformanceVisualizationEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DebugSettings_put_IsTextPerformanceVisualizationEnabled(py::wrapper::Windows::UI::Xaml::DebugSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DebugSettings", L"IsTextPerformanceVisualizationEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsTextPerformanceVisualizationEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DebugSettings_get_FailFastOnErrors(py::wrapper::Windows::UI::Xaml::DebugSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DebugSettings", L"FailFastOnErrors"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FailFastOnErrors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DebugSettings_put_FailFastOnErrors(py::wrapper::Windows::UI::Xaml::DebugSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DebugSettings", L"FailFastOnErrors"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.FailFastOnErrors(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DebugSettings_add_BindingFailed(py::wrapper::Windows::UI::Xaml::DebugSettings* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.DebugSettings", L"BindingFailed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::BindingFailedEventHandler>(arg);

            return py::convert(self->obj.BindingFailed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DebugSettings_remove_BindingFailed(py::wrapper::Windows::UI::Xaml::DebugSettings* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.DebugSettings", L"BindingFailed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BindingFailed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DebugSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::DebugSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DebugSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::DebugSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DebugSettings[] = {
        { "add_binding_failed", reinterpret_cast<PyCFunction>(DebugSettings_add_BindingFailed), METH_O, nullptr },
        { "remove_binding_failed", reinterpret_cast<PyCFunction>(DebugSettings_remove_BindingFailed), METH_O, nullptr },
        { "_assign_array_", _assign_array_DebugSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DebugSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DebugSettings[] = {
        { "is_overdraw_heat_map_enabled", reinterpret_cast<getter>(DebugSettings_get_IsOverdrawHeatMapEnabled), reinterpret_cast<setter>(DebugSettings_put_IsOverdrawHeatMapEnabled), nullptr, nullptr },
        { "is_binding_tracing_enabled", reinterpret_cast<getter>(DebugSettings_get_IsBindingTracingEnabled), reinterpret_cast<setter>(DebugSettings_put_IsBindingTracingEnabled), nullptr, nullptr },
        { "enable_frame_rate_counter", reinterpret_cast<getter>(DebugSettings_get_EnableFrameRateCounter), reinterpret_cast<setter>(DebugSettings_put_EnableFrameRateCounter), nullptr, nullptr },
        { "enable_redraw_regions", reinterpret_cast<getter>(DebugSettings_get_EnableRedrawRegions), reinterpret_cast<setter>(DebugSettings_put_EnableRedrawRegions), nullptr, nullptr },
        { "is_text_performance_visualization_enabled", reinterpret_cast<getter>(DebugSettings_get_IsTextPerformanceVisualizationEnabled), reinterpret_cast<setter>(DebugSettings_put_IsTextPerformanceVisualizationEnabled), nullptr, nullptr },
        { "fail_fast_on_errors", reinterpret_cast<getter>(DebugSettings_get_FailFastOnErrors), reinterpret_cast<setter>(DebugSettings_put_FailFastOnErrors), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DebugSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DebugSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DebugSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DebugSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DebugSettings) },
        { },
    };

    static PyType_Spec type_spec_DebugSettings =
    {
        "_winrt_Windows_UI_Xaml.DebugSettings",
        sizeof(py::wrapper::Windows::UI::Xaml::DebugSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DebugSettings
    };

    // ----- DependencyObject class --------------------
    static constexpr const char* const type_name_DependencyObject = "DependencyObject";

    static PyObject* _new_DependencyObject(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DependencyObject);
        return nullptr;
    }

    static void _dealloc_DependencyObject(py::wrapper::Windows::UI::Xaml::DependencyObject* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DependencyObject_ClearValue(py::wrapper::Windows::UI::Xaml::DependencyObject* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ClearValue", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                self->obj.ClearValue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DependencyObject_GetAnimationBaseValue(py::wrapper::Windows::UI::Xaml::DependencyObject* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetAnimationBaseValue", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetAnimationBaseValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DependencyObject_GetValue(py::wrapper::Windows::UI::Xaml::DependencyObject* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetValue", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DependencyObject_ReadLocalValue(py::wrapper::Windows::UI::Xaml::DependencyObject* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ReadLocalValue", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.ReadLocalValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DependencyObject_RegisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::DependencyObject* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"RegisterPropertyChangedCallback", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::DependencyPropertyChangedCallback>(args, 1);

                return py::convert(self->obj.RegisterPropertyChangedCallback(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DependencyObject_SetValue(py::wrapper::Windows::UI::Xaml::DependencyObject* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"SetValue", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.SetValue(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DependencyObject_UnregisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::DependencyObject* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"UnregisterPropertyChangedCallback", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<int64_t>(args, 1);

                self->obj.UnregisterPropertyChangedCallback(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DependencyObject_get_Dispatcher(py::wrapper::Windows::UI::Xaml::DependencyObject* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DependencyObject", L"Dispatcher"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Dispatcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DependencyObject(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::DependencyObject>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DependencyObject(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::DependencyObject>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DependencyObject[] = {
        { "clear_value", reinterpret_cast<PyCFunction>(DependencyObject_ClearValue), METH_VARARGS, nullptr },
        { "get_animation_base_value", reinterpret_cast<PyCFunction>(DependencyObject_GetAnimationBaseValue), METH_VARARGS, nullptr },
        { "get_value", reinterpret_cast<PyCFunction>(DependencyObject_GetValue), METH_VARARGS, nullptr },
        { "read_local_value", reinterpret_cast<PyCFunction>(DependencyObject_ReadLocalValue), METH_VARARGS, nullptr },
        { "register_property_changed_callback", reinterpret_cast<PyCFunction>(DependencyObject_RegisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "set_value", reinterpret_cast<PyCFunction>(DependencyObject_SetValue), METH_VARARGS, nullptr },
        { "unregister_property_changed_callback", reinterpret_cast<PyCFunction>(DependencyObject_UnregisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DependencyObject, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DependencyObject), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DependencyObject[] = {
        { "dispatcher", reinterpret_cast<getter>(DependencyObject_get_Dispatcher), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DependencyObject[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DependencyObject) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DependencyObject) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DependencyObject) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DependencyObject) },
        { },
    };

    static PyType_Spec type_spec_DependencyObject =
    {
        "_winrt_Windows_UI_Xaml.DependencyObject",
        sizeof(py::wrapper::Windows::UI::Xaml::DependencyObject),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DependencyObject
    };

    // ----- DependencyObjectCollection class --------------------
    static constexpr const char* const type_name_DependencyObjectCollection = "DependencyObjectCollection";

    static PyObject* _new_DependencyObjectCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::DependencyObjectCollection instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DependencyObjectCollection(py::wrapper::Windows::UI::Xaml::DependencyObjectCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DependencyObjectCollection_Append(py::wrapper::Windows::UI::Xaml::DependencyObjectCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObjectCollection", L"Append", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DependencyObjectCollection_Clear(py::wrapper::Windows::UI::Xaml::DependencyObjectCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObjectCollection", L"Clear", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DependencyObjectCollection_First(py::wrapper::Windows::UI::Xaml::DependencyObjectCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObjectCollection", L"First", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DependencyObjectCollection_GetAt(py::wrapper::Windows::UI::Xaml::DependencyObjectCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObjectCollection", L"GetAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DependencyObjectCollection_GetMany(py::wrapper::Windows::UI::Xaml::DependencyObjectCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObjectCollection", L"GetMany", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::DependencyObject, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DependencyObjectCollection_GetView(py::wrapper::Windows::UI::Xaml::DependencyObjectCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObjectCollection", L"GetView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DependencyObjectCollection_IndexOf(py::wrapper::Windows::UI::Xaml::DependencyObjectCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObjectCollection", L"IndexOf", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DependencyObjectCollection_InsertAt(py::wrapper::Windows::UI::Xaml::DependencyObjectCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObjectCollection", L"InsertAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DependencyObjectCollection_RemoveAt(py::wrapper::Windows::UI::Xaml::DependencyObjectCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObjectCollection", L"RemoveAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DependencyObjectCollection_RemoveAtEnd(py::wrapper::Windows::UI::Xaml::DependencyObjectCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObjectCollection", L"RemoveAtEnd", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DependencyObjectCollection_ReplaceAll(py::wrapper::Windows::UI::Xaml::DependencyObjectCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObjectCollection", L"ReplaceAll", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::DependencyObject, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DependencyObjectCollection_SetAt(py::wrapper::Windows::UI::Xaml::DependencyObjectCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObjectCollection", L"SetAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DependencyObjectCollection_get_Size(py::wrapper::Windows::UI::Xaml::DependencyObjectCollection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DependencyObjectCollection", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DependencyObjectCollection_add_VectorChanged(py::wrapper::Windows::UI::Xaml::DependencyObjectCollection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.DependencyObjectCollection", L"VectorChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::VectorChangedEventHandler<winrt::Windows::UI::Xaml::DependencyObject>>(arg);

            return py::convert(self->obj.VectorChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DependencyObjectCollection_remove_VectorChanged(py::wrapper::Windows::UI::Xaml::DependencyObjectCollection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.DependencyObjectCollection", L"VectorChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VectorChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DependencyObjectCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::DependencyObjectCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DependencyObjectCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::DependencyObjectCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_DependencyObjectCollection(py::wrapper::Windows::UI::Xaml::DependencyObjectCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_DependencyObjectCollection(py::wrapper::Windows::UI::Xaml::DependencyObjectCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_DependencyObjectCollection(py::wrapper::Windows::UI::Xaml::DependencyObjectCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_DependencyObjectCollection(py::wrapper::Windows::UI::Xaml::DependencyObjectCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_DependencyObjectCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(
                    PyExc_TypeError,
                    "indicies must be integers, not '%s'",
                    Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(
                    slice, self->obj.Size(), &start, &stop, &step, &length)
                < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(
                    PyExc_NotImplementedError,
                    "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::UI::Xaml::DependencyObject> items(length, empty_instance<winrt::Windows::UI::Xaml::DependencyObject>::get());

            auto count = self->obj.GetMany(start, items);

            if (count != length)
            {
                PyErr_Format(
                    PyExc_RuntimeError,
                    "returned count %d did not match requested length %zd",
                    count,
                    length);
                return nullptr;
            }

            return convert(items);}
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_DependencyObjectCollection(py::wrapper::Windows::UI::Xaml::DependencyObjectCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (value == nullptr) { self->obj.RemoveAt(static_cast<uint32_t>(i)); }
            else { self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_DependencyObjectCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(DependencyObjectCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(DependencyObjectCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(DependencyObjectCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(DependencyObjectCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(DependencyObjectCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(DependencyObjectCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(DependencyObjectCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(DependencyObjectCollection_InsertAt), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(DependencyObjectCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(DependencyObjectCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(DependencyObjectCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(DependencyObjectCollection_SetAt), METH_VARARGS, nullptr },
        { "add_vector_changed", reinterpret_cast<PyCFunction>(DependencyObjectCollection_add_VectorChanged), METH_O, nullptr },
        { "remove_vector_changed", reinterpret_cast<PyCFunction>(DependencyObjectCollection_remove_VectorChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_DependencyObjectCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DependencyObjectCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DependencyObjectCollection[] = {
        { "size", reinterpret_cast<getter>(DependencyObjectCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DependencyObjectCollection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DependencyObjectCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DependencyObjectCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DependencyObjectCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DependencyObjectCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_DependencyObjectCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_DependencyObjectCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_DependencyObjectCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_DependencyObjectCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_DependencyObjectCollection) },
        { },
    };

    static PyType_Spec type_spec_DependencyObjectCollection =
    {
        "_winrt_Windows_UI_Xaml.DependencyObjectCollection",
        sizeof(py::wrapper::Windows::UI::Xaml::DependencyObjectCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DependencyObjectCollection
    };

    // ----- DependencyProperty class --------------------
    static constexpr const char* const type_name_DependencyProperty = "DependencyProperty";

    static PyObject* _new_DependencyProperty(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DependencyProperty);
        return nullptr;
    }

    static void _dealloc_DependencyProperty(py::wrapper::Windows::UI::Xaml::DependencyProperty* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DependencyProperty_GetMetadata(py::wrapper::Windows::UI::Xaml::DependencyProperty* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyProperty", L"GetMetadata", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Interop::TypeName>(args, 0);

                return py::convert(self->obj.GetMetadata(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DependencyProperty_Register(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyProperty", L"Register", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Interop::TypeName>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Xaml::Interop::TypeName>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::UI::Xaml::PropertyMetadata>(args, 3);

                return py::convert(winrt::Windows::UI::Xaml::DependencyProperty::Register(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DependencyProperty_RegisterAttached(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyProperty", L"RegisterAttached", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Interop::TypeName>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Xaml::Interop::TypeName>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::UI::Xaml::PropertyMetadata>(args, 3);

                return py::convert(winrt::Windows::UI::Xaml::DependencyProperty::RegisterAttached(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DependencyProperty_get_UnsetValue(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DependencyProperty", L"UnsetValue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::DependencyProperty::UnsetValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DependencyProperty(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::DependencyProperty>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DependencyProperty(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::DependencyProperty>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DependencyProperty[] = {
        { "get_metadata", reinterpret_cast<PyCFunction>(DependencyProperty_GetMetadata), METH_VARARGS, nullptr },
        { "register", reinterpret_cast<PyCFunction>(DependencyProperty_Register), METH_VARARGS | METH_STATIC, nullptr },
        { "register_attached", reinterpret_cast<PyCFunction>(DependencyProperty_RegisterAttached), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_DependencyProperty, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DependencyProperty), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DependencyProperty[] = {
        { }
    };

    static PyType_Slot _type_slots_DependencyProperty[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DependencyProperty) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DependencyProperty) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DependencyProperty) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DependencyProperty) },
        { },
    };

    static PyType_Spec type_spec_DependencyProperty =
    {
        "_winrt_Windows_UI_Xaml.DependencyProperty",
        sizeof(py::wrapper::Windows::UI::Xaml::DependencyProperty),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DependencyProperty
    };

    static PyGetSetDef getset_DependencyProperty_Meta[] = {
        { "unset_value", reinterpret_cast<getter>(DependencyProperty_get_UnsetValue), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_DependencyProperty_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DependencyProperty_Meta) },
        { }
    };

    static PyType_Spec type_spec_DependencyProperty_Meta =
    {
        "_winrt_Windows_UI_Xaml.DependencyProperty_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_DependencyProperty_Meta
    };

    // ----- DependencyPropertyChangedEventArgs class --------------------
    static constexpr const char* const type_name_DependencyPropertyChangedEventArgs = "DependencyPropertyChangedEventArgs";

    static PyObject* _new_DependencyPropertyChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DependencyPropertyChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_DependencyPropertyChangedEventArgs(py::wrapper::Windows::UI::Xaml::DependencyPropertyChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DependencyPropertyChangedEventArgs_get_NewValue(py::wrapper::Windows::UI::Xaml::DependencyPropertyChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DependencyPropertyChangedEventArgs", L"NewValue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NewValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DependencyPropertyChangedEventArgs_get_OldValue(py::wrapper::Windows::UI::Xaml::DependencyPropertyChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DependencyPropertyChangedEventArgs", L"OldValue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OldValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DependencyPropertyChangedEventArgs_get_Property(py::wrapper::Windows::UI::Xaml::DependencyPropertyChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DependencyPropertyChangedEventArgs", L"Property"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Property());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DependencyPropertyChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::DependencyPropertyChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DependencyPropertyChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::DependencyPropertyChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DependencyPropertyChangedEventArgs[] = {
        { "_assign_array_", _assign_array_DependencyPropertyChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DependencyPropertyChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DependencyPropertyChangedEventArgs[] = {
        { "new_value", reinterpret_cast<getter>(DependencyPropertyChangedEventArgs_get_NewValue), nullptr, nullptr, nullptr },
        { "old_value", reinterpret_cast<getter>(DependencyPropertyChangedEventArgs_get_OldValue), nullptr, nullptr, nullptr },
        { "property", reinterpret_cast<getter>(DependencyPropertyChangedEventArgs_get_Property), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DependencyPropertyChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DependencyPropertyChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DependencyPropertyChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DependencyPropertyChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DependencyPropertyChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_DependencyPropertyChangedEventArgs =
    {
        "_winrt_Windows_UI_Xaml.DependencyPropertyChangedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::DependencyPropertyChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DependencyPropertyChangedEventArgs
    };

    // ----- DispatcherTimer class --------------------
    static constexpr const char* const type_name_DispatcherTimer = "DispatcherTimer";

    static PyObject* _new_DispatcherTimer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::DispatcherTimer instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DispatcherTimer(py::wrapper::Windows::UI::Xaml::DispatcherTimer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DispatcherTimer_Start(py::wrapper::Windows::UI::Xaml::DispatcherTimer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DispatcherTimer", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DispatcherTimer_Stop(py::wrapper::Windows::UI::Xaml::DispatcherTimer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DispatcherTimer", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DispatcherTimer_get_Interval(py::wrapper::Windows::UI::Xaml::DispatcherTimer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DispatcherTimer", L"Interval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Interval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DispatcherTimer_put_Interval(py::wrapper::Windows::UI::Xaml::DispatcherTimer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DispatcherTimer", L"Interval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Interval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DispatcherTimer_get_IsEnabled(py::wrapper::Windows::UI::Xaml::DispatcherTimer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DispatcherTimer", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DispatcherTimer_add_Tick(py::wrapper::Windows::UI::Xaml::DispatcherTimer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.DispatcherTimer", L"Tick"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Tick(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DispatcherTimer_remove_Tick(py::wrapper::Windows::UI::Xaml::DispatcherTimer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.DispatcherTimer", L"Tick"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Tick(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DispatcherTimer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::DispatcherTimer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DispatcherTimer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::DispatcherTimer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DispatcherTimer[] = {
        { "start", reinterpret_cast<PyCFunction>(DispatcherTimer_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(DispatcherTimer_Stop), METH_VARARGS, nullptr },
        { "add_tick", reinterpret_cast<PyCFunction>(DispatcherTimer_add_Tick), METH_O, nullptr },
        { "remove_tick", reinterpret_cast<PyCFunction>(DispatcherTimer_remove_Tick), METH_O, nullptr },
        { "_assign_array_", _assign_array_DispatcherTimer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DispatcherTimer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DispatcherTimer[] = {
        { "interval", reinterpret_cast<getter>(DispatcherTimer_get_Interval), reinterpret_cast<setter>(DispatcherTimer_put_Interval), nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(DispatcherTimer_get_IsEnabled), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DispatcherTimer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DispatcherTimer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DispatcherTimer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DispatcherTimer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DispatcherTimer) },
        { },
    };

    static PyType_Spec type_spec_DispatcherTimer =
    {
        "_winrt_Windows_UI_Xaml.DispatcherTimer",
        sizeof(py::wrapper::Windows::UI::Xaml::DispatcherTimer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DispatcherTimer
    };

    // ----- DragEventArgs class --------------------
    static constexpr const char* const type_name_DragEventArgs = "DragEventArgs";

    static PyObject* _new_DragEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DragEventArgs);
        return nullptr;
    }

    static void _dealloc_DragEventArgs(py::wrapper::Windows::UI::Xaml::DragEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DragEventArgs_GetDeferral(py::wrapper::Windows::UI::Xaml::DragEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DragEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DragEventArgs_GetPosition(py::wrapper::Windows::UI::Xaml::DragEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DragEventArgs", L"GetPosition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 0);

                return py::convert(self->obj.GetPosition(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DragEventArgs_get_Handled(py::wrapper::Windows::UI::Xaml::DragEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DragEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DragEventArgs_put_Handled(py::wrapper::Windows::UI::Xaml::DragEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DragEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DragEventArgs_get_Data(py::wrapper::Windows::UI::Xaml::DragEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DragEventArgs", L"Data"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Data());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DragEventArgs_put_Data(py::wrapper::Windows::UI::Xaml::DragEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DragEventArgs", L"Data"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::DataTransfer::DataPackage>(arg);

            self->obj.Data(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DragEventArgs_get_AcceptedOperation(py::wrapper::Windows::UI::Xaml::DragEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DragEventArgs", L"AcceptedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AcceptedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DragEventArgs_put_AcceptedOperation(py::wrapper::Windows::UI::Xaml::DragEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DragEventArgs", L"AcceptedOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::DataTransfer::DataPackageOperation>(arg);

            self->obj.AcceptedOperation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DragEventArgs_get_DataView(py::wrapper::Windows::UI::Xaml::DragEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DragEventArgs", L"DataView"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DataView());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DragEventArgs_get_DragUIOverride(py::wrapper::Windows::UI::Xaml::DragEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DragEventArgs", L"DragUIOverride"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DragUIOverride());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DragEventArgs_get_Modifiers(py::wrapper::Windows::UI::Xaml::DragEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DragEventArgs", L"Modifiers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Modifiers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DragEventArgs_get_AllowedOperations(py::wrapper::Windows::UI::Xaml::DragEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DragEventArgs", L"AllowedOperations"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AllowedOperations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DragEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::DragEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DragEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::DragEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DragEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(DragEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "get_position", reinterpret_cast<PyCFunction>(DragEventArgs_GetPosition), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DragEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DragEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DragEventArgs[] = {
        { "handled", reinterpret_cast<getter>(DragEventArgs_get_Handled), reinterpret_cast<setter>(DragEventArgs_put_Handled), nullptr, nullptr },
        { "data", reinterpret_cast<getter>(DragEventArgs_get_Data), reinterpret_cast<setter>(DragEventArgs_put_Data), nullptr, nullptr },
        { "accepted_operation", reinterpret_cast<getter>(DragEventArgs_get_AcceptedOperation), reinterpret_cast<setter>(DragEventArgs_put_AcceptedOperation), nullptr, nullptr },
        { "data_view", reinterpret_cast<getter>(DragEventArgs_get_DataView), nullptr, nullptr, nullptr },
        { "drag_u_i_override", reinterpret_cast<getter>(DragEventArgs_get_DragUIOverride), nullptr, nullptr, nullptr },
        { "modifiers", reinterpret_cast<getter>(DragEventArgs_get_Modifiers), nullptr, nullptr, nullptr },
        { "allowed_operations", reinterpret_cast<getter>(DragEventArgs_get_AllowedOperations), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DragEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DragEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DragEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DragEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DragEventArgs) },
        { },
    };

    static PyType_Spec type_spec_DragEventArgs =
    {
        "_winrt_Windows_UI_Xaml.DragEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::DragEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DragEventArgs
    };

    // ----- DragOperationDeferral class --------------------
    static constexpr const char* const type_name_DragOperationDeferral = "DragOperationDeferral";

    static PyObject* _new_DragOperationDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DragOperationDeferral);
        return nullptr;
    }

    static void _dealloc_DragOperationDeferral(py::wrapper::Windows::UI::Xaml::DragOperationDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DragOperationDeferral_Complete(py::wrapper::Windows::UI::Xaml::DragOperationDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DragOperationDeferral", L"Complete", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_DragOperationDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::DragOperationDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DragOperationDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::DragOperationDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DragOperationDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(DragOperationDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DragOperationDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DragOperationDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DragOperationDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_DragOperationDeferral[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DragOperationDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DragOperationDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DragOperationDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DragOperationDeferral) },
        { },
    };

    static PyType_Spec type_spec_DragOperationDeferral =
    {
        "_winrt_Windows_UI_Xaml.DragOperationDeferral",
        sizeof(py::wrapper::Windows::UI::Xaml::DragOperationDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DragOperationDeferral
    };

    // ----- DragStartingEventArgs class --------------------
    static constexpr const char* const type_name_DragStartingEventArgs = "DragStartingEventArgs";

    static PyObject* _new_DragStartingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DragStartingEventArgs);
        return nullptr;
    }

    static void _dealloc_DragStartingEventArgs(py::wrapper::Windows::UI::Xaml::DragStartingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DragStartingEventArgs_GetDeferral(py::wrapper::Windows::UI::Xaml::DragStartingEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DragStartingEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DragStartingEventArgs_GetPosition(py::wrapper::Windows::UI::Xaml::DragStartingEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DragStartingEventArgs", L"GetPosition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 0);

                return py::convert(self->obj.GetPosition(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DragStartingEventArgs_get_Cancel(py::wrapper::Windows::UI::Xaml::DragStartingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DragStartingEventArgs", L"Cancel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Cancel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DragStartingEventArgs_put_Cancel(py::wrapper::Windows::UI::Xaml::DragStartingEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DragStartingEventArgs", L"Cancel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Cancel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DragStartingEventArgs_get_Data(py::wrapper::Windows::UI::Xaml::DragStartingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DragStartingEventArgs", L"Data"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Data());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DragStartingEventArgs_get_DragUI(py::wrapper::Windows::UI::Xaml::DragStartingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DragStartingEventArgs", L"DragUI"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DragUI());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DragStartingEventArgs_get_AllowedOperations(py::wrapper::Windows::UI::Xaml::DragStartingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DragStartingEventArgs", L"AllowedOperations"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AllowedOperations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DragStartingEventArgs_put_AllowedOperations(py::wrapper::Windows::UI::Xaml::DragStartingEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DragStartingEventArgs", L"AllowedOperations"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::DataTransfer::DataPackageOperation>(arg);

            self->obj.AllowedOperations(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_DragStartingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::DragStartingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DragStartingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::DragStartingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DragStartingEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(DragStartingEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "get_position", reinterpret_cast<PyCFunction>(DragStartingEventArgs_GetPosition), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DragStartingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DragStartingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DragStartingEventArgs[] = {
        { "cancel", reinterpret_cast<getter>(DragStartingEventArgs_get_Cancel), reinterpret_cast<setter>(DragStartingEventArgs_put_Cancel), nullptr, nullptr },
        { "data", reinterpret_cast<getter>(DragStartingEventArgs_get_Data), nullptr, nullptr, nullptr },
        { "drag_u_i", reinterpret_cast<getter>(DragStartingEventArgs_get_DragUI), nullptr, nullptr, nullptr },
        { "allowed_operations", reinterpret_cast<getter>(DragStartingEventArgs_get_AllowedOperations), reinterpret_cast<setter>(DragStartingEventArgs_put_AllowedOperations), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DragStartingEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DragStartingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DragStartingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DragStartingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DragStartingEventArgs) },
        { },
    };

    static PyType_Spec type_spec_DragStartingEventArgs =
    {
        "_winrt_Windows_UI_Xaml.DragStartingEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::DragStartingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DragStartingEventArgs
    };

    // ----- DragUI class --------------------
    static constexpr const char* const type_name_DragUI = "DragUI";

    static PyObject* _new_DragUI(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DragUI);
        return nullptr;
    }

    static void _dealloc_DragUI(py::wrapper::Windows::UI::Xaml::DragUI* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DragUI_SetContentFromBitmapImage(py::wrapper::Windows::UI::Xaml::DragUI* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DragUI", L"SetContentFromBitmapImage", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Imaging::BitmapImage>(args, 0);

                self->obj.SetContentFromBitmapImage(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DragUI", L"SetContentFromBitmapImage", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Imaging::BitmapImage>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Point>(args, 1);

                self->obj.SetContentFromBitmapImage(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DragUI_SetContentFromDataPackage(py::wrapper::Windows::UI::Xaml::DragUI* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DragUI", L"SetContentFromDataPackage", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.SetContentFromDataPackage();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DragUI_SetContentFromSoftwareBitmap(py::wrapper::Windows::UI::Xaml::DragUI* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DragUI", L"SetContentFromSoftwareBitmap", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(args, 0);

                self->obj.SetContentFromSoftwareBitmap(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DragUI", L"SetContentFromSoftwareBitmap", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Point>(args, 1);

                self->obj.SetContentFromSoftwareBitmap(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_DragUI(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::DragUI>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DragUI(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::DragUI>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DragUI[] = {
        { "set_content_from_bitmap_image", reinterpret_cast<PyCFunction>(DragUI_SetContentFromBitmapImage), METH_VARARGS, nullptr },
        { "set_content_from_data_package", reinterpret_cast<PyCFunction>(DragUI_SetContentFromDataPackage), METH_VARARGS, nullptr },
        { "set_content_from_software_bitmap", reinterpret_cast<PyCFunction>(DragUI_SetContentFromSoftwareBitmap), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DragUI, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DragUI), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DragUI[] = {
        { }
    };

    static PyType_Slot _type_slots_DragUI[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DragUI) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DragUI) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DragUI) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DragUI) },
        { },
    };

    static PyType_Spec type_spec_DragUI =
    {
        "_winrt_Windows_UI_Xaml.DragUI",
        sizeof(py::wrapper::Windows::UI::Xaml::DragUI),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DragUI
    };

    // ----- DragUIOverride class --------------------
    static constexpr const char* const type_name_DragUIOverride = "DragUIOverride";

    static PyObject* _new_DragUIOverride(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DragUIOverride);
        return nullptr;
    }

    static void _dealloc_DragUIOverride(py::wrapper::Windows::UI::Xaml::DragUIOverride* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DragUIOverride_Clear(py::wrapper::Windows::UI::Xaml::DragUIOverride* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DragUIOverride", L"Clear", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DragUIOverride_SetContentFromBitmapImage(py::wrapper::Windows::UI::Xaml::DragUIOverride* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DragUIOverride", L"SetContentFromBitmapImage", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Imaging::BitmapImage>(args, 0);

                self->obj.SetContentFromBitmapImage(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DragUIOverride", L"SetContentFromBitmapImage", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Imaging::BitmapImage>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Point>(args, 1);

                self->obj.SetContentFromBitmapImage(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DragUIOverride_SetContentFromSoftwareBitmap(py::wrapper::Windows::UI::Xaml::DragUIOverride* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DragUIOverride", L"SetContentFromSoftwareBitmap", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(args, 0);

                self->obj.SetContentFromSoftwareBitmap(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DragUIOverride", L"SetContentFromSoftwareBitmap", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Point>(args, 1);

                self->obj.SetContentFromSoftwareBitmap(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DragUIOverride_get_IsGlyphVisible(py::wrapper::Windows::UI::Xaml::DragUIOverride* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DragUIOverride", L"IsGlyphVisible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsGlyphVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DragUIOverride_put_IsGlyphVisible(py::wrapper::Windows::UI::Xaml::DragUIOverride* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DragUIOverride", L"IsGlyphVisible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsGlyphVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DragUIOverride_get_IsContentVisible(py::wrapper::Windows::UI::Xaml::DragUIOverride* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DragUIOverride", L"IsContentVisible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsContentVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DragUIOverride_put_IsContentVisible(py::wrapper::Windows::UI::Xaml::DragUIOverride* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DragUIOverride", L"IsContentVisible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsContentVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DragUIOverride_get_IsCaptionVisible(py::wrapper::Windows::UI::Xaml::DragUIOverride* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DragUIOverride", L"IsCaptionVisible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCaptionVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DragUIOverride_put_IsCaptionVisible(py::wrapper::Windows::UI::Xaml::DragUIOverride* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DragUIOverride", L"IsCaptionVisible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCaptionVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DragUIOverride_get_Caption(py::wrapper::Windows::UI::Xaml::DragUIOverride* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DragUIOverride", L"Caption"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Caption());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DragUIOverride_put_Caption(py::wrapper::Windows::UI::Xaml::DragUIOverride* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DragUIOverride", L"Caption"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Caption(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_DragUIOverride(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::DragUIOverride>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DragUIOverride(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::DragUIOverride>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DragUIOverride[] = {
        { "clear", reinterpret_cast<PyCFunction>(DragUIOverride_Clear), METH_VARARGS, nullptr },
        { "set_content_from_bitmap_image", reinterpret_cast<PyCFunction>(DragUIOverride_SetContentFromBitmapImage), METH_VARARGS, nullptr },
        { "set_content_from_software_bitmap", reinterpret_cast<PyCFunction>(DragUIOverride_SetContentFromSoftwareBitmap), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DragUIOverride, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DragUIOverride), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DragUIOverride[] = {
        { "is_glyph_visible", reinterpret_cast<getter>(DragUIOverride_get_IsGlyphVisible), reinterpret_cast<setter>(DragUIOverride_put_IsGlyphVisible), nullptr, nullptr },
        { "is_content_visible", reinterpret_cast<getter>(DragUIOverride_get_IsContentVisible), reinterpret_cast<setter>(DragUIOverride_put_IsContentVisible), nullptr, nullptr },
        { "is_caption_visible", reinterpret_cast<getter>(DragUIOverride_get_IsCaptionVisible), reinterpret_cast<setter>(DragUIOverride_put_IsCaptionVisible), nullptr, nullptr },
        { "caption", reinterpret_cast<getter>(DragUIOverride_get_Caption), reinterpret_cast<setter>(DragUIOverride_put_Caption), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DragUIOverride[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DragUIOverride) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DragUIOverride) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DragUIOverride) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DragUIOverride) },
        { },
    };

    static PyType_Spec type_spec_DragUIOverride =
    {
        "_winrt_Windows_UI_Xaml.DragUIOverride",
        sizeof(py::wrapper::Windows::UI::Xaml::DragUIOverride),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DragUIOverride
    };

    // ----- DropCompletedEventArgs class --------------------
    static constexpr const char* const type_name_DropCompletedEventArgs = "DropCompletedEventArgs";

    static PyObject* _new_DropCompletedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DropCompletedEventArgs);
        return nullptr;
    }

    static void _dealloc_DropCompletedEventArgs(py::wrapper::Windows::UI::Xaml::DropCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DropCompletedEventArgs_get_DropResult(py::wrapper::Windows::UI::Xaml::DropCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DropCompletedEventArgs", L"DropResult"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DropResult());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DropCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::DropCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DropCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::DropCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DropCompletedEventArgs[] = {
        { "_assign_array_", _assign_array_DropCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DropCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DropCompletedEventArgs[] = {
        { "drop_result", reinterpret_cast<getter>(DropCompletedEventArgs_get_DropResult), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DropCompletedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DropCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DropCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DropCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DropCompletedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_DropCompletedEventArgs =
    {
        "_winrt_Windows_UI_Xaml.DropCompletedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::DropCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DropCompletedEventArgs
    };

    // ----- DurationHelper class --------------------
    static constexpr const char* const type_name_DurationHelper = "DurationHelper";

    static PyObject* _new_DurationHelper(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DurationHelper);
        return nullptr;
    }

    static void _dealloc_DurationHelper(py::wrapper::Windows::UI::Xaml::DurationHelper* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DurationHelper_Add(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DurationHelper", L"Add", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Duration>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Duration>(args, 1);

                return py::convert(winrt::Windows::UI::Xaml::DurationHelper::Add(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DurationHelper_Compare(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DurationHelper", L"Compare", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Duration>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Duration>(args, 1);

                return py::convert(winrt::Windows::UI::Xaml::DurationHelper::Compare(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DurationHelper_Equals(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DurationHelper", L"Equals", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Duration>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Duration>(args, 1);

                return py::convert(winrt::Windows::UI::Xaml::DurationHelper::Equals(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DurationHelper_FromTimeSpan(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DurationHelper", L"FromTimeSpan", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::DurationHelper::FromTimeSpan(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DurationHelper_GetHasTimeSpan(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DurationHelper", L"GetHasTimeSpan", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Duration>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::DurationHelper::GetHasTimeSpan(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DurationHelper_Subtract(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DurationHelper", L"Subtract", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Duration>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Duration>(args, 1);

                return py::convert(winrt::Windows::UI::Xaml::DurationHelper::Subtract(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DurationHelper_get_Automatic(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DurationHelper", L"Automatic"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::DurationHelper::Automatic());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DurationHelper_get_Forever(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DurationHelper", L"Forever"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::DurationHelper::Forever());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DurationHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::DurationHelper>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DurationHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::DurationHelper>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DurationHelper[] = {
        { "add", reinterpret_cast<PyCFunction>(DurationHelper_Add), METH_VARARGS | METH_STATIC, nullptr },
        { "compare", reinterpret_cast<PyCFunction>(DurationHelper_Compare), METH_VARARGS | METH_STATIC, nullptr },
        { "equals", reinterpret_cast<PyCFunction>(DurationHelper_Equals), METH_VARARGS | METH_STATIC, nullptr },
        { "from_time_span", reinterpret_cast<PyCFunction>(DurationHelper_FromTimeSpan), METH_VARARGS | METH_STATIC, nullptr },
        { "get_has_time_span", reinterpret_cast<PyCFunction>(DurationHelper_GetHasTimeSpan), METH_VARARGS | METH_STATIC, nullptr },
        { "subtract", reinterpret_cast<PyCFunction>(DurationHelper_Subtract), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_DurationHelper, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DurationHelper), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DurationHelper[] = {
        { }
    };

    static PyType_Slot _type_slots_DurationHelper[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DurationHelper) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DurationHelper) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DurationHelper) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DurationHelper) },
        { },
    };

    static PyType_Spec type_spec_DurationHelper =
    {
        "_winrt_Windows_UI_Xaml.DurationHelper",
        sizeof(py::wrapper::Windows::UI::Xaml::DurationHelper),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DurationHelper
    };

    static PyGetSetDef getset_DurationHelper_Meta[] = {
        { "automatic", reinterpret_cast<getter>(DurationHelper_get_Automatic), nullptr, nullptr, nullptr },
        { "forever", reinterpret_cast<getter>(DurationHelper_get_Forever), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_DurationHelper_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DurationHelper_Meta) },
        { }
    };

    static PyType_Spec type_spec_DurationHelper_Meta =
    {
        "_winrt_Windows_UI_Xaml.DurationHelper_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_DurationHelper_Meta
    };

    // ----- EffectiveViewportChangedEventArgs class --------------------
    static constexpr const char* const type_name_EffectiveViewportChangedEventArgs = "EffectiveViewportChangedEventArgs";

    static PyObject* _new_EffectiveViewportChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_EffectiveViewportChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_EffectiveViewportChangedEventArgs(py::wrapper::Windows::UI::Xaml::EffectiveViewportChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EffectiveViewportChangedEventArgs_get_BringIntoViewDistanceX(py::wrapper::Windows::UI::Xaml::EffectiveViewportChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.EffectiveViewportChangedEventArgs", L"BringIntoViewDistanceX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BringIntoViewDistanceX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EffectiveViewportChangedEventArgs_get_BringIntoViewDistanceY(py::wrapper::Windows::UI::Xaml::EffectiveViewportChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.EffectiveViewportChangedEventArgs", L"BringIntoViewDistanceY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BringIntoViewDistanceY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EffectiveViewportChangedEventArgs_get_EffectiveViewport(py::wrapper::Windows::UI::Xaml::EffectiveViewportChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.EffectiveViewportChangedEventArgs", L"EffectiveViewport"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EffectiveViewport());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EffectiveViewportChangedEventArgs_get_MaxViewport(py::wrapper::Windows::UI::Xaml::EffectiveViewportChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.EffectiveViewportChangedEventArgs", L"MaxViewport"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxViewport());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EffectiveViewportChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::EffectiveViewportChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EffectiveViewportChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::EffectiveViewportChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EffectiveViewportChangedEventArgs[] = {
        { "_assign_array_", _assign_array_EffectiveViewportChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EffectiveViewportChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EffectiveViewportChangedEventArgs[] = {
        { "bring_into_view_distance_x", reinterpret_cast<getter>(EffectiveViewportChangedEventArgs_get_BringIntoViewDistanceX), nullptr, nullptr, nullptr },
        { "bring_into_view_distance_y", reinterpret_cast<getter>(EffectiveViewportChangedEventArgs_get_BringIntoViewDistanceY), nullptr, nullptr, nullptr },
        { "effective_viewport", reinterpret_cast<getter>(EffectiveViewportChangedEventArgs_get_EffectiveViewport), nullptr, nullptr, nullptr },
        { "max_viewport", reinterpret_cast<getter>(EffectiveViewportChangedEventArgs_get_MaxViewport), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EffectiveViewportChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EffectiveViewportChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EffectiveViewportChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EffectiveViewportChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EffectiveViewportChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_EffectiveViewportChangedEventArgs =
    {
        "_winrt_Windows_UI_Xaml.EffectiveViewportChangedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::EffectiveViewportChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EffectiveViewportChangedEventArgs
    };

    // ----- ElementFactoryGetArgs class --------------------
    static constexpr const char* const type_name_ElementFactoryGetArgs = "ElementFactoryGetArgs";

    static PyObject* _new_ElementFactoryGetArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::ElementFactoryGetArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ElementFactoryGetArgs(py::wrapper::Windows::UI::Xaml::ElementFactoryGetArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ElementFactoryGetArgs_get_Parent(py::wrapper::Windows::UI::Xaml::ElementFactoryGetArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ElementFactoryGetArgs", L"Parent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Parent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ElementFactoryGetArgs_put_Parent(py::wrapper::Windows::UI::Xaml::ElementFactoryGetArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ElementFactoryGetArgs", L"Parent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(arg);

            self->obj.Parent(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ElementFactoryGetArgs_get_Data(py::wrapper::Windows::UI::Xaml::ElementFactoryGetArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ElementFactoryGetArgs", L"Data"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Data());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ElementFactoryGetArgs_put_Data(py::wrapper::Windows::UI::Xaml::ElementFactoryGetArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ElementFactoryGetArgs", L"Data"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.Data(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ElementFactoryGetArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::ElementFactoryGetArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ElementFactoryGetArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::ElementFactoryGetArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ElementFactoryGetArgs[] = {
        { "_assign_array_", _assign_array_ElementFactoryGetArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ElementFactoryGetArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ElementFactoryGetArgs[] = {
        { "parent", reinterpret_cast<getter>(ElementFactoryGetArgs_get_Parent), reinterpret_cast<setter>(ElementFactoryGetArgs_put_Parent), nullptr, nullptr },
        { "data", reinterpret_cast<getter>(ElementFactoryGetArgs_get_Data), reinterpret_cast<setter>(ElementFactoryGetArgs_put_Data), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ElementFactoryGetArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ElementFactoryGetArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ElementFactoryGetArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ElementFactoryGetArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ElementFactoryGetArgs) },
        { },
    };

    static PyType_Spec type_spec_ElementFactoryGetArgs =
    {
        "_winrt_Windows_UI_Xaml.ElementFactoryGetArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::ElementFactoryGetArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ElementFactoryGetArgs
    };

    // ----- ElementFactoryRecycleArgs class --------------------
    static constexpr const char* const type_name_ElementFactoryRecycleArgs = "ElementFactoryRecycleArgs";

    static PyObject* _new_ElementFactoryRecycleArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::ElementFactoryRecycleArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ElementFactoryRecycleArgs(py::wrapper::Windows::UI::Xaml::ElementFactoryRecycleArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ElementFactoryRecycleArgs_get_Parent(py::wrapper::Windows::UI::Xaml::ElementFactoryRecycleArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ElementFactoryRecycleArgs", L"Parent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Parent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ElementFactoryRecycleArgs_put_Parent(py::wrapper::Windows::UI::Xaml::ElementFactoryRecycleArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ElementFactoryRecycleArgs", L"Parent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(arg);

            self->obj.Parent(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ElementFactoryRecycleArgs_get_Element(py::wrapper::Windows::UI::Xaml::ElementFactoryRecycleArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ElementFactoryRecycleArgs", L"Element"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Element());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ElementFactoryRecycleArgs_put_Element(py::wrapper::Windows::UI::Xaml::ElementFactoryRecycleArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ElementFactoryRecycleArgs", L"Element"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(arg);

            self->obj.Element(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ElementFactoryRecycleArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::ElementFactoryRecycleArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ElementFactoryRecycleArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::ElementFactoryRecycleArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ElementFactoryRecycleArgs[] = {
        { "_assign_array_", _assign_array_ElementFactoryRecycleArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ElementFactoryRecycleArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ElementFactoryRecycleArgs[] = {
        { "parent", reinterpret_cast<getter>(ElementFactoryRecycleArgs_get_Parent), reinterpret_cast<setter>(ElementFactoryRecycleArgs_put_Parent), nullptr, nullptr },
        { "element", reinterpret_cast<getter>(ElementFactoryRecycleArgs_get_Element), reinterpret_cast<setter>(ElementFactoryRecycleArgs_put_Element), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ElementFactoryRecycleArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ElementFactoryRecycleArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ElementFactoryRecycleArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ElementFactoryRecycleArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ElementFactoryRecycleArgs) },
        { },
    };

    static PyType_Spec type_spec_ElementFactoryRecycleArgs =
    {
        "_winrt_Windows_UI_Xaml.ElementFactoryRecycleArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::ElementFactoryRecycleArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ElementFactoryRecycleArgs
    };

    // ----- ElementSoundPlayer class --------------------
    static constexpr const char* const type_name_ElementSoundPlayer = "ElementSoundPlayer";

    static PyObject* _new_ElementSoundPlayer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ElementSoundPlayer);
        return nullptr;
    }

    static void _dealloc_ElementSoundPlayer(py::wrapper::Windows::UI::Xaml::ElementSoundPlayer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ElementSoundPlayer_Play(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.ElementSoundPlayer", L"Play", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::ElementSoundKind>(args, 0);

                winrt::Windows::UI::Xaml::ElementSoundPlayer::Play(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ElementSoundPlayer_get_Volume(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ElementSoundPlayer", L"Volume"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::ElementSoundPlayer::Volume());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ElementSoundPlayer_put_Volume(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ElementSoundPlayer", L"Volume"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            winrt::Windows::UI::Xaml::ElementSoundPlayer::Volume(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ElementSoundPlayer_get_State(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ElementSoundPlayer", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::ElementSoundPlayer::State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ElementSoundPlayer_put_State(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ElementSoundPlayer", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::ElementSoundPlayerState>(arg);

            winrt::Windows::UI::Xaml::ElementSoundPlayer::State(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ElementSoundPlayer_get_SpatialAudioMode(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ElementSoundPlayer", L"SpatialAudioMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::ElementSoundPlayer::SpatialAudioMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ElementSoundPlayer_put_SpatialAudioMode(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ElementSoundPlayer", L"SpatialAudioMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::ElementSpatialAudioMode>(arg);

            winrt::Windows::UI::Xaml::ElementSoundPlayer::SpatialAudioMode(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ElementSoundPlayer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::ElementSoundPlayer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ElementSoundPlayer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::ElementSoundPlayer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ElementSoundPlayer[] = {
        { "play", reinterpret_cast<PyCFunction>(ElementSoundPlayer_Play), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_ElementSoundPlayer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ElementSoundPlayer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ElementSoundPlayer[] = {
        { }
    };

    static PyType_Slot _type_slots_ElementSoundPlayer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ElementSoundPlayer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ElementSoundPlayer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ElementSoundPlayer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ElementSoundPlayer) },
        { },
    };

    static PyType_Spec type_spec_ElementSoundPlayer =
    {
        "_winrt_Windows_UI_Xaml.ElementSoundPlayer",
        sizeof(py::wrapper::Windows::UI::Xaml::ElementSoundPlayer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ElementSoundPlayer
    };

    static PyGetSetDef getset_ElementSoundPlayer_Meta[] = {
        { "volume", reinterpret_cast<getter>(ElementSoundPlayer_get_Volume), reinterpret_cast<setter>(ElementSoundPlayer_put_Volume), nullptr, nullptr },
        { "state", reinterpret_cast<getter>(ElementSoundPlayer_get_State), reinterpret_cast<setter>(ElementSoundPlayer_put_State), nullptr, nullptr },
        { "spatial_audio_mode", reinterpret_cast<getter>(ElementSoundPlayer_get_SpatialAudioMode), reinterpret_cast<setter>(ElementSoundPlayer_put_SpatialAudioMode), nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_ElementSoundPlayer_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ElementSoundPlayer_Meta) },
        { }
    };

    static PyType_Spec type_spec_ElementSoundPlayer_Meta =
    {
        "_winrt_Windows_UI_Xaml.ElementSoundPlayer_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ElementSoundPlayer_Meta
    };

    // ----- EventTrigger class --------------------
    static constexpr const char* const type_name_EventTrigger = "EventTrigger";

    static PyObject* _new_EventTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::EventTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EventTrigger(py::wrapper::Windows::UI::Xaml::EventTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EventTrigger_get_RoutedEvent(py::wrapper::Windows::UI::Xaml::EventTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.EventTrigger", L"RoutedEvent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RoutedEvent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EventTrigger_put_RoutedEvent(py::wrapper::Windows::UI::Xaml::EventTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.EventTrigger", L"RoutedEvent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::RoutedEvent>(arg);

            self->obj.RoutedEvent(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EventTrigger_get_Actions(py::wrapper::Windows::UI::Xaml::EventTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.EventTrigger", L"Actions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Actions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EventTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::EventTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EventTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::EventTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EventTrigger[] = {
        { "_assign_array_", _assign_array_EventTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EventTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EventTrigger[] = {
        { "routed_event", reinterpret_cast<getter>(EventTrigger_get_RoutedEvent), reinterpret_cast<setter>(EventTrigger_put_RoutedEvent), nullptr, nullptr },
        { "actions", reinterpret_cast<getter>(EventTrigger_get_Actions), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EventTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EventTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EventTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EventTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EventTrigger) },
        { },
    };

    static PyType_Spec type_spec_EventTrigger =
    {
        "_winrt_Windows_UI_Xaml.EventTrigger",
        sizeof(py::wrapper::Windows::UI::Xaml::EventTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EventTrigger
    };

    // ----- ExceptionRoutedEventArgs class --------------------
    static constexpr const char* const type_name_ExceptionRoutedEventArgs = "ExceptionRoutedEventArgs";

    static PyObject* _new_ExceptionRoutedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ExceptionRoutedEventArgs);
        return nullptr;
    }

    static void _dealloc_ExceptionRoutedEventArgs(py::wrapper::Windows::UI::Xaml::ExceptionRoutedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ExceptionRoutedEventArgs_get_ErrorMessage(py::wrapper::Windows::UI::Xaml::ExceptionRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ExceptionRoutedEventArgs", L"ErrorMessage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ExceptionRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::ExceptionRoutedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ExceptionRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::ExceptionRoutedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ExceptionRoutedEventArgs[] = {
        { "_assign_array_", _assign_array_ExceptionRoutedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ExceptionRoutedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ExceptionRoutedEventArgs[] = {
        { "error_message", reinterpret_cast<getter>(ExceptionRoutedEventArgs_get_ErrorMessage), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ExceptionRoutedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ExceptionRoutedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ExceptionRoutedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ExceptionRoutedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ExceptionRoutedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ExceptionRoutedEventArgs =
    {
        "_winrt_Windows_UI_Xaml.ExceptionRoutedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::ExceptionRoutedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ExceptionRoutedEventArgs
    };

    // ----- FrameworkElement class --------------------
    static constexpr const char* const type_name_FrameworkElement = "FrameworkElement";

    static PyObject* _new_FrameworkElement(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_FrameworkElement);
        return nullptr;
    }

    static void _dealloc_FrameworkElement(py::wrapper::Windows::UI::Xaml::FrameworkElement* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FrameworkElement_ArrangeOverride(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.FrameworkElement", L"ArrangeOverride", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(args, 0);

                return py::convert(self->obj.ArrangeOverride(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_DeferTree(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.FrameworkElement", L"DeferTree", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(args, 0);

                winrt::Windows::UI::Xaml::FrameworkElement::DeferTree(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_FindName(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.FrameworkElement", L"FindName", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindName(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_GetBindingExpression(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.FrameworkElement", L"GetBindingExpression", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetBindingExpression(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_GoToElementStateCore(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.FrameworkElement", L"GoToElementStateCore", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(self->obj.GoToElementStateCore(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_InvalidateViewport(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.FrameworkElement", L"InvalidateViewport", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.InvalidateViewport();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_MeasureOverride(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.FrameworkElement", L"MeasureOverride", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(args, 0);

                return py::convert(self->obj.MeasureOverride(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_OnApplyTemplate(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.FrameworkElement", L"OnApplyTemplate", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.OnApplyTemplate();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_SetBinding(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.FrameworkElement", L"SetBinding", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Data::BindingBase>(args, 1);

                self->obj.SetBinding(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_get_Width(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"Width"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Width());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameworkElement_put_Width(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"Width"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Width(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FrameworkElement_get_VerticalAlignment(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"VerticalAlignment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VerticalAlignment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameworkElement_put_VerticalAlignment(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"VerticalAlignment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::VerticalAlignment>(arg);

            self->obj.VerticalAlignment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FrameworkElement_get_Tag(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"Tag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Tag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameworkElement_put_Tag(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"Tag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.Tag(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FrameworkElement_get_Style(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"Style"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Style());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameworkElement_put_Style(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"Style"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Style>(arg);

            self->obj.Style(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FrameworkElement_get_Resources(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"Resources"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Resources());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameworkElement_put_Resources(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"Resources"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::ResourceDictionary>(arg);

            self->obj.Resources(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FrameworkElement_get_Name(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameworkElement_put_Name(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FrameworkElement_get_MinWidth(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"MinWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameworkElement_put_MinWidth(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"MinWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.MinWidth(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FrameworkElement_get_MinHeight(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"MinHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameworkElement_put_MinHeight(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"MinHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.MinHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FrameworkElement_get_MaxWidth(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"MaxWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameworkElement_put_MaxWidth(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"MaxWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.MaxWidth(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FrameworkElement_get_MaxHeight(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"MaxHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameworkElement_put_MaxHeight(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"MaxHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.MaxHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FrameworkElement_get_Margin(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"Margin"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Margin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameworkElement_put_Margin(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"Margin"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Thickness>(arg);

            self->obj.Margin(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FrameworkElement_get_Language(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"Language"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameworkElement_put_Language(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"Language"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Language(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FrameworkElement_get_HorizontalAlignment(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"HorizontalAlignment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HorizontalAlignment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameworkElement_put_HorizontalAlignment(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"HorizontalAlignment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::HorizontalAlignment>(arg);

            self->obj.HorizontalAlignment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FrameworkElement_get_Height(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"Height"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameworkElement_put_Height(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"Height"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Height(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FrameworkElement_get_FlowDirection(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"FlowDirection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FlowDirection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameworkElement_put_FlowDirection(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"FlowDirection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::FlowDirection>(arg);

            self->obj.FlowDirection(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FrameworkElement_get_DataContext(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"DataContext"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DataContext());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameworkElement_put_DataContext(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"DataContext"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.DataContext(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FrameworkElement_get_ActualHeight(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"ActualHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActualHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_get_ActualWidth(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"ActualWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActualWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_get_BaseUri(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"BaseUri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BaseUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_get_Parent(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"Parent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Parent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_get_Triggers(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"Triggers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Triggers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_get_RequestedTheme(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"RequestedTheme"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RequestedTheme());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameworkElement_put_RequestedTheme(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"RequestedTheme"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::ElementTheme>(arg);

            self->obj.RequestedTheme(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FrameworkElement_get_FocusVisualSecondaryThickness(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"FocusVisualSecondaryThickness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FocusVisualSecondaryThickness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameworkElement_put_FocusVisualSecondaryThickness(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"FocusVisualSecondaryThickness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Thickness>(arg);

            self->obj.FocusVisualSecondaryThickness(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FrameworkElement_get_FocusVisualSecondaryBrush(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"FocusVisualSecondaryBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FocusVisualSecondaryBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameworkElement_put_FocusVisualSecondaryBrush(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"FocusVisualSecondaryBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.FocusVisualSecondaryBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FrameworkElement_get_FocusVisualPrimaryThickness(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"FocusVisualPrimaryThickness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FocusVisualPrimaryThickness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameworkElement_put_FocusVisualPrimaryThickness(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"FocusVisualPrimaryThickness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Thickness>(arg);

            self->obj.FocusVisualPrimaryThickness(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FrameworkElement_get_FocusVisualPrimaryBrush(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"FocusVisualPrimaryBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FocusVisualPrimaryBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameworkElement_put_FocusVisualPrimaryBrush(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"FocusVisualPrimaryBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.FocusVisualPrimaryBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FrameworkElement_get_FocusVisualMargin(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"FocusVisualMargin"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FocusVisualMargin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameworkElement_put_FocusVisualMargin(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"FocusVisualMargin"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Thickness>(arg);

            self->obj.FocusVisualMargin(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FrameworkElement_get_AllowFocusWhenDisabled(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"AllowFocusWhenDisabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AllowFocusWhenDisabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameworkElement_put_AllowFocusWhenDisabled(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"AllowFocusWhenDisabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowFocusWhenDisabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FrameworkElement_get_AllowFocusOnInteraction(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"AllowFocusOnInteraction"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AllowFocusOnInteraction());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameworkElement_put_AllowFocusOnInteraction(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"AllowFocusOnInteraction"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowFocusOnInteraction(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FrameworkElement_get_ActualTheme(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"ActualTheme"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActualTheme());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_get_IsLoaded(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"IsLoaded"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsLoaded());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_get_ActualHeightProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"ActualHeightProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::FrameworkElement::ActualHeightProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_get_ActualWidthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"ActualWidthProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::FrameworkElement::ActualWidthProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_get_DataContextProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"DataContextProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::FrameworkElement::DataContextProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_get_FlowDirectionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"FlowDirectionProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::FrameworkElement::FlowDirectionProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_get_HeightProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"HeightProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::FrameworkElement::HeightProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_get_HorizontalAlignmentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"HorizontalAlignmentProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::FrameworkElement::HorizontalAlignmentProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_get_LanguageProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"LanguageProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::FrameworkElement::LanguageProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_get_MarginProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"MarginProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::FrameworkElement::MarginProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_get_MaxHeightProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"MaxHeightProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::FrameworkElement::MaxHeightProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_get_MaxWidthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"MaxWidthProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::FrameworkElement::MaxWidthProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_get_MinHeightProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"MinHeightProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::FrameworkElement::MinHeightProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_get_MinWidthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"MinWidthProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::FrameworkElement::MinWidthProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_get_NameProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"NameProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::FrameworkElement::NameProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_get_StyleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"StyleProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::FrameworkElement::StyleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_get_TagProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"TagProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::FrameworkElement::TagProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_get_VerticalAlignmentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"VerticalAlignmentProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::FrameworkElement::VerticalAlignmentProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_get_WidthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"WidthProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::FrameworkElement::WidthProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_get_RequestedThemeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"RequestedThemeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::FrameworkElement::RequestedThemeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_get_AllowFocusOnInteractionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"AllowFocusOnInteractionProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::FrameworkElement::AllowFocusOnInteractionProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_get_AllowFocusWhenDisabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"AllowFocusWhenDisabledProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::FrameworkElement::AllowFocusWhenDisabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_get_FocusVisualMarginProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"FocusVisualMarginProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::FrameworkElement::FocusVisualMarginProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_get_FocusVisualPrimaryBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"FocusVisualPrimaryBrushProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::FrameworkElement::FocusVisualPrimaryBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_get_FocusVisualPrimaryThicknessProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"FocusVisualPrimaryThicknessProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::FrameworkElement::FocusVisualPrimaryThicknessProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_get_FocusVisualSecondaryBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"FocusVisualSecondaryBrushProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::FrameworkElement::FocusVisualSecondaryBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_get_FocusVisualSecondaryThicknessProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"FocusVisualSecondaryThicknessProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::FrameworkElement::FocusVisualSecondaryThicknessProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_get_ActualThemeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"ActualThemeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::FrameworkElement::ActualThemeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_add_LayoutUpdated(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.FrameworkElement", L"LayoutUpdated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.LayoutUpdated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_remove_LayoutUpdated(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.FrameworkElement", L"LayoutUpdated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LayoutUpdated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_add_Loaded(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.FrameworkElement", L"Loaded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::RoutedEventHandler>(arg);

            return py::convert(self->obj.Loaded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_remove_Loaded(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.FrameworkElement", L"Loaded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Loaded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_add_SizeChanged(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.FrameworkElement", L"SizeChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::SizeChangedEventHandler>(arg);

            return py::convert(self->obj.SizeChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_remove_SizeChanged(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.FrameworkElement", L"SizeChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SizeChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_add_Unloaded(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.FrameworkElement", L"Unloaded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::RoutedEventHandler>(arg);

            return py::convert(self->obj.Unloaded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_remove_Unloaded(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.FrameworkElement", L"Unloaded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Unloaded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_add_DataContextChanged(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.FrameworkElement", L"DataContextChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::FrameworkElement, winrt::Windows::UI::Xaml::DataContextChangedEventArgs>>(arg);

            return py::convert(self->obj.DataContextChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_remove_DataContextChanged(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.FrameworkElement", L"DataContextChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DataContextChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_add_Loading(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.FrameworkElement", L"Loading"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::FrameworkElement, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Loading(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_remove_Loading(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.FrameworkElement", L"Loading"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Loading(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_add_ActualThemeChanged(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.FrameworkElement", L"ActualThemeChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::FrameworkElement, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ActualThemeChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_remove_ActualThemeChanged(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.FrameworkElement", L"ActualThemeChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ActualThemeChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_add_EffectiveViewportChanged(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.FrameworkElement", L"EffectiveViewportChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::FrameworkElement, winrt::Windows::UI::Xaml::EffectiveViewportChangedEventArgs>>(arg);

            return py::convert(self->obj.EffectiveViewportChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameworkElement_remove_EffectiveViewportChanged(py::wrapper::Windows::UI::Xaml::FrameworkElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.FrameworkElement", L"EffectiveViewportChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EffectiveViewportChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FrameworkElement(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::FrameworkElement>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FrameworkElement(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::FrameworkElement>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameworkElement[] = {
        { "arrange_override", reinterpret_cast<PyCFunction>(FrameworkElement_ArrangeOverride), METH_VARARGS, nullptr },
        { "defer_tree", reinterpret_cast<PyCFunction>(FrameworkElement_DeferTree), METH_VARARGS | METH_STATIC, nullptr },
        { "find_name", reinterpret_cast<PyCFunction>(FrameworkElement_FindName), METH_VARARGS, nullptr },
        { "get_binding_expression", reinterpret_cast<PyCFunction>(FrameworkElement_GetBindingExpression), METH_VARARGS, nullptr },
        { "go_to_element_state_core", reinterpret_cast<PyCFunction>(FrameworkElement_GoToElementStateCore), METH_VARARGS, nullptr },
        { "invalidate_viewport", reinterpret_cast<PyCFunction>(FrameworkElement_InvalidateViewport), METH_VARARGS, nullptr },
        { "measure_override", reinterpret_cast<PyCFunction>(FrameworkElement_MeasureOverride), METH_VARARGS, nullptr },
        { "on_apply_template", reinterpret_cast<PyCFunction>(FrameworkElement_OnApplyTemplate), METH_VARARGS, nullptr },
        { "set_binding", reinterpret_cast<PyCFunction>(FrameworkElement_SetBinding), METH_VARARGS, nullptr },
        { "add_layout_updated", reinterpret_cast<PyCFunction>(FrameworkElement_add_LayoutUpdated), METH_O, nullptr },
        { "remove_layout_updated", reinterpret_cast<PyCFunction>(FrameworkElement_remove_LayoutUpdated), METH_O, nullptr },
        { "add_loaded", reinterpret_cast<PyCFunction>(FrameworkElement_add_Loaded), METH_O, nullptr },
        { "remove_loaded", reinterpret_cast<PyCFunction>(FrameworkElement_remove_Loaded), METH_O, nullptr },
        { "add_size_changed", reinterpret_cast<PyCFunction>(FrameworkElement_add_SizeChanged), METH_O, nullptr },
        { "remove_size_changed", reinterpret_cast<PyCFunction>(FrameworkElement_remove_SizeChanged), METH_O, nullptr },
        { "add_unloaded", reinterpret_cast<PyCFunction>(FrameworkElement_add_Unloaded), METH_O, nullptr },
        { "remove_unloaded", reinterpret_cast<PyCFunction>(FrameworkElement_remove_Unloaded), METH_O, nullptr },
        { "add_data_context_changed", reinterpret_cast<PyCFunction>(FrameworkElement_add_DataContextChanged), METH_O, nullptr },
        { "remove_data_context_changed", reinterpret_cast<PyCFunction>(FrameworkElement_remove_DataContextChanged), METH_O, nullptr },
        { "add_loading", reinterpret_cast<PyCFunction>(FrameworkElement_add_Loading), METH_O, nullptr },
        { "remove_loading", reinterpret_cast<PyCFunction>(FrameworkElement_remove_Loading), METH_O, nullptr },
        { "add_actual_theme_changed", reinterpret_cast<PyCFunction>(FrameworkElement_add_ActualThemeChanged), METH_O, nullptr },
        { "remove_actual_theme_changed", reinterpret_cast<PyCFunction>(FrameworkElement_remove_ActualThemeChanged), METH_O, nullptr },
        { "add_effective_viewport_changed", reinterpret_cast<PyCFunction>(FrameworkElement_add_EffectiveViewportChanged), METH_O, nullptr },
        { "remove_effective_viewport_changed", reinterpret_cast<PyCFunction>(FrameworkElement_remove_EffectiveViewportChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_FrameworkElement, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FrameworkElement), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FrameworkElement[] = {
        { "width", reinterpret_cast<getter>(FrameworkElement_get_Width), reinterpret_cast<setter>(FrameworkElement_put_Width), nullptr, nullptr },
        { "vertical_alignment", reinterpret_cast<getter>(FrameworkElement_get_VerticalAlignment), reinterpret_cast<setter>(FrameworkElement_put_VerticalAlignment), nullptr, nullptr },
        { "tag", reinterpret_cast<getter>(FrameworkElement_get_Tag), reinterpret_cast<setter>(FrameworkElement_put_Tag), nullptr, nullptr },
        { "style", reinterpret_cast<getter>(FrameworkElement_get_Style), reinterpret_cast<setter>(FrameworkElement_put_Style), nullptr, nullptr },
        { "resources", reinterpret_cast<getter>(FrameworkElement_get_Resources), reinterpret_cast<setter>(FrameworkElement_put_Resources), nullptr, nullptr },
        { "name", reinterpret_cast<getter>(FrameworkElement_get_Name), reinterpret_cast<setter>(FrameworkElement_put_Name), nullptr, nullptr },
        { "min_width", reinterpret_cast<getter>(FrameworkElement_get_MinWidth), reinterpret_cast<setter>(FrameworkElement_put_MinWidth), nullptr, nullptr },
        { "min_height", reinterpret_cast<getter>(FrameworkElement_get_MinHeight), reinterpret_cast<setter>(FrameworkElement_put_MinHeight), nullptr, nullptr },
        { "max_width", reinterpret_cast<getter>(FrameworkElement_get_MaxWidth), reinterpret_cast<setter>(FrameworkElement_put_MaxWidth), nullptr, nullptr },
        { "max_height", reinterpret_cast<getter>(FrameworkElement_get_MaxHeight), reinterpret_cast<setter>(FrameworkElement_put_MaxHeight), nullptr, nullptr },
        { "margin", reinterpret_cast<getter>(FrameworkElement_get_Margin), reinterpret_cast<setter>(FrameworkElement_put_Margin), nullptr, nullptr },
        { "language", reinterpret_cast<getter>(FrameworkElement_get_Language), reinterpret_cast<setter>(FrameworkElement_put_Language), nullptr, nullptr },
        { "horizontal_alignment", reinterpret_cast<getter>(FrameworkElement_get_HorizontalAlignment), reinterpret_cast<setter>(FrameworkElement_put_HorizontalAlignment), nullptr, nullptr },
        { "height", reinterpret_cast<getter>(FrameworkElement_get_Height), reinterpret_cast<setter>(FrameworkElement_put_Height), nullptr, nullptr },
        { "flow_direction", reinterpret_cast<getter>(FrameworkElement_get_FlowDirection), reinterpret_cast<setter>(FrameworkElement_put_FlowDirection), nullptr, nullptr },
        { "data_context", reinterpret_cast<getter>(FrameworkElement_get_DataContext), reinterpret_cast<setter>(FrameworkElement_put_DataContext), nullptr, nullptr },
        { "actual_height", reinterpret_cast<getter>(FrameworkElement_get_ActualHeight), nullptr, nullptr, nullptr },
        { "actual_width", reinterpret_cast<getter>(FrameworkElement_get_ActualWidth), nullptr, nullptr, nullptr },
        { "base_uri", reinterpret_cast<getter>(FrameworkElement_get_BaseUri), nullptr, nullptr, nullptr },
        { "parent", reinterpret_cast<getter>(FrameworkElement_get_Parent), nullptr, nullptr, nullptr },
        { "triggers", reinterpret_cast<getter>(FrameworkElement_get_Triggers), nullptr, nullptr, nullptr },
        { "requested_theme", reinterpret_cast<getter>(FrameworkElement_get_RequestedTheme), reinterpret_cast<setter>(FrameworkElement_put_RequestedTheme), nullptr, nullptr },
        { "focus_visual_secondary_thickness", reinterpret_cast<getter>(FrameworkElement_get_FocusVisualSecondaryThickness), reinterpret_cast<setter>(FrameworkElement_put_FocusVisualSecondaryThickness), nullptr, nullptr },
        { "focus_visual_secondary_brush", reinterpret_cast<getter>(FrameworkElement_get_FocusVisualSecondaryBrush), reinterpret_cast<setter>(FrameworkElement_put_FocusVisualSecondaryBrush), nullptr, nullptr },
        { "focus_visual_primary_thickness", reinterpret_cast<getter>(FrameworkElement_get_FocusVisualPrimaryThickness), reinterpret_cast<setter>(FrameworkElement_put_FocusVisualPrimaryThickness), nullptr, nullptr },
        { "focus_visual_primary_brush", reinterpret_cast<getter>(FrameworkElement_get_FocusVisualPrimaryBrush), reinterpret_cast<setter>(FrameworkElement_put_FocusVisualPrimaryBrush), nullptr, nullptr },
        { "focus_visual_margin", reinterpret_cast<getter>(FrameworkElement_get_FocusVisualMargin), reinterpret_cast<setter>(FrameworkElement_put_FocusVisualMargin), nullptr, nullptr },
        { "allow_focus_when_disabled", reinterpret_cast<getter>(FrameworkElement_get_AllowFocusWhenDisabled), reinterpret_cast<setter>(FrameworkElement_put_AllowFocusWhenDisabled), nullptr, nullptr },
        { "allow_focus_on_interaction", reinterpret_cast<getter>(FrameworkElement_get_AllowFocusOnInteraction), reinterpret_cast<setter>(FrameworkElement_put_AllowFocusOnInteraction), nullptr, nullptr },
        { "actual_theme", reinterpret_cast<getter>(FrameworkElement_get_ActualTheme), nullptr, nullptr, nullptr },
        { "is_loaded", reinterpret_cast<getter>(FrameworkElement_get_IsLoaded), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FrameworkElement[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FrameworkElement) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FrameworkElement) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FrameworkElement) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FrameworkElement) },
        { },
    };

    static PyType_Spec type_spec_FrameworkElement =
    {
        "_winrt_Windows_UI_Xaml.FrameworkElement",
        sizeof(py::wrapper::Windows::UI::Xaml::FrameworkElement),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameworkElement
    };

    static PyGetSetDef getset_FrameworkElement_Meta[] = {
        { "actual_height_property", reinterpret_cast<getter>(FrameworkElement_get_ActualHeightProperty), nullptr, nullptr, nullptr },
        { "actual_width_property", reinterpret_cast<getter>(FrameworkElement_get_ActualWidthProperty), nullptr, nullptr, nullptr },
        { "data_context_property", reinterpret_cast<getter>(FrameworkElement_get_DataContextProperty), nullptr, nullptr, nullptr },
        { "flow_direction_property", reinterpret_cast<getter>(FrameworkElement_get_FlowDirectionProperty), nullptr, nullptr, nullptr },
        { "height_property", reinterpret_cast<getter>(FrameworkElement_get_HeightProperty), nullptr, nullptr, nullptr },
        { "horizontal_alignment_property", reinterpret_cast<getter>(FrameworkElement_get_HorizontalAlignmentProperty), nullptr, nullptr, nullptr },
        { "language_property", reinterpret_cast<getter>(FrameworkElement_get_LanguageProperty), nullptr, nullptr, nullptr },
        { "margin_property", reinterpret_cast<getter>(FrameworkElement_get_MarginProperty), nullptr, nullptr, nullptr },
        { "max_height_property", reinterpret_cast<getter>(FrameworkElement_get_MaxHeightProperty), nullptr, nullptr, nullptr },
        { "max_width_property", reinterpret_cast<getter>(FrameworkElement_get_MaxWidthProperty), nullptr, nullptr, nullptr },
        { "min_height_property", reinterpret_cast<getter>(FrameworkElement_get_MinHeightProperty), nullptr, nullptr, nullptr },
        { "min_width_property", reinterpret_cast<getter>(FrameworkElement_get_MinWidthProperty), nullptr, nullptr, nullptr },
        { "name_property", reinterpret_cast<getter>(FrameworkElement_get_NameProperty), nullptr, nullptr, nullptr },
        { "style_property", reinterpret_cast<getter>(FrameworkElement_get_StyleProperty), nullptr, nullptr, nullptr },
        { "tag_property", reinterpret_cast<getter>(FrameworkElement_get_TagProperty), nullptr, nullptr, nullptr },
        { "vertical_alignment_property", reinterpret_cast<getter>(FrameworkElement_get_VerticalAlignmentProperty), nullptr, nullptr, nullptr },
        { "width_property", reinterpret_cast<getter>(FrameworkElement_get_WidthProperty), nullptr, nullptr, nullptr },
        { "requested_theme_property", reinterpret_cast<getter>(FrameworkElement_get_RequestedThemeProperty), nullptr, nullptr, nullptr },
        { "allow_focus_on_interaction_property", reinterpret_cast<getter>(FrameworkElement_get_AllowFocusOnInteractionProperty), nullptr, nullptr, nullptr },
        { "allow_focus_when_disabled_property", reinterpret_cast<getter>(FrameworkElement_get_AllowFocusWhenDisabledProperty), nullptr, nullptr, nullptr },
        { "focus_visual_margin_property", reinterpret_cast<getter>(FrameworkElement_get_FocusVisualMarginProperty), nullptr, nullptr, nullptr },
        { "focus_visual_primary_brush_property", reinterpret_cast<getter>(FrameworkElement_get_FocusVisualPrimaryBrushProperty), nullptr, nullptr, nullptr },
        { "focus_visual_primary_thickness_property", reinterpret_cast<getter>(FrameworkElement_get_FocusVisualPrimaryThicknessProperty), nullptr, nullptr, nullptr },
        { "focus_visual_secondary_brush_property", reinterpret_cast<getter>(FrameworkElement_get_FocusVisualSecondaryBrushProperty), nullptr, nullptr, nullptr },
        { "focus_visual_secondary_thickness_property", reinterpret_cast<getter>(FrameworkElement_get_FocusVisualSecondaryThicknessProperty), nullptr, nullptr, nullptr },
        { "actual_theme_property", reinterpret_cast<getter>(FrameworkElement_get_ActualThemeProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_FrameworkElement_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_FrameworkElement_Meta) },
        { }
    };

    static PyType_Spec type_spec_FrameworkElement_Meta =
    {
        "_winrt_Windows_UI_Xaml.FrameworkElement_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_FrameworkElement_Meta
    };

    // ----- FrameworkTemplate class --------------------
    static constexpr const char* const type_name_FrameworkTemplate = "FrameworkTemplate";

    static PyObject* _new_FrameworkTemplate(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_FrameworkTemplate);
        return nullptr;
    }

    static void _dealloc_FrameworkTemplate(py::wrapper::Windows::UI::Xaml::FrameworkTemplate* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_FrameworkTemplate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::FrameworkTemplate>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FrameworkTemplate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::FrameworkTemplate>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameworkTemplate[] = {
        { "_assign_array_", _assign_array_FrameworkTemplate, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FrameworkTemplate), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FrameworkTemplate[] = {
        { }
    };

    static PyType_Slot _type_slots_FrameworkTemplate[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FrameworkTemplate) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FrameworkTemplate) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FrameworkTemplate) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FrameworkTemplate) },
        { },
    };

    static PyType_Spec type_spec_FrameworkTemplate =
    {
        "_winrt_Windows_UI_Xaml.FrameworkTemplate",
        sizeof(py::wrapper::Windows::UI::Xaml::FrameworkTemplate),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameworkTemplate
    };

    // ----- FrameworkView class --------------------
    static constexpr const char* const type_name_FrameworkView = "FrameworkView";

    static PyObject* _new_FrameworkView(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::FrameworkView instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FrameworkView(py::wrapper::Windows::UI::Xaml::FrameworkView* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FrameworkView_Initialize(py::wrapper::Windows::UI::Xaml::FrameworkView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.FrameworkView", L"Initialize", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Core::CoreApplicationView>(args, 0);

                self->obj.Initialize(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FrameworkView_Load(py::wrapper::Windows::UI::Xaml::FrameworkView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.FrameworkView", L"Load", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Load(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FrameworkView_Run(py::wrapper::Windows::UI::Xaml::FrameworkView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.FrameworkView", L"Run", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Run();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FrameworkView_SetWindow(py::wrapper::Windows::UI::Xaml::FrameworkView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.FrameworkView", L"SetWindow", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Core::CoreWindow>(args, 0);

                self->obj.SetWindow(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FrameworkView_Uninitialize(py::wrapper::Windows::UI::Xaml::FrameworkView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.FrameworkView", L"Uninitialize", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Uninitialize();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_FrameworkView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::FrameworkView>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FrameworkView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::FrameworkView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameworkView[] = {
        { "initialize", reinterpret_cast<PyCFunction>(FrameworkView_Initialize), METH_VARARGS, nullptr },
        { "load", reinterpret_cast<PyCFunction>(FrameworkView_Load), METH_VARARGS, nullptr },
        { "run", reinterpret_cast<PyCFunction>(FrameworkView_Run), METH_VARARGS, nullptr },
        { "set_window", reinterpret_cast<PyCFunction>(FrameworkView_SetWindow), METH_VARARGS, nullptr },
        { "uninitialize", reinterpret_cast<PyCFunction>(FrameworkView_Uninitialize), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_FrameworkView, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FrameworkView), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FrameworkView[] = {
        { }
    };

    static PyType_Slot _type_slots_FrameworkView[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FrameworkView) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FrameworkView) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FrameworkView) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FrameworkView) },
        { },
    };

    static PyType_Spec type_spec_FrameworkView =
    {
        "_winrt_Windows_UI_Xaml.FrameworkView",
        sizeof(py::wrapper::Windows::UI::Xaml::FrameworkView),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameworkView
    };

    // ----- FrameworkViewSource class --------------------
    static constexpr const char* const type_name_FrameworkViewSource = "FrameworkViewSource";

    static PyObject* _new_FrameworkViewSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::FrameworkViewSource instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FrameworkViewSource(py::wrapper::Windows::UI::Xaml::FrameworkViewSource* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FrameworkViewSource_CreateView(py::wrapper::Windows::UI::Xaml::FrameworkViewSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.FrameworkViewSource", L"CreateView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_FrameworkViewSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::FrameworkViewSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FrameworkViewSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::FrameworkViewSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameworkViewSource[] = {
        { "create_view", reinterpret_cast<PyCFunction>(FrameworkViewSource_CreateView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_FrameworkViewSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FrameworkViewSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FrameworkViewSource[] = {
        { }
    };

    static PyType_Slot _type_slots_FrameworkViewSource[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FrameworkViewSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FrameworkViewSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FrameworkViewSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FrameworkViewSource) },
        { },
    };

    static PyType_Spec type_spec_FrameworkViewSource =
    {
        "_winrt_Windows_UI_Xaml.FrameworkViewSource",
        sizeof(py::wrapper::Windows::UI::Xaml::FrameworkViewSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameworkViewSource
    };

    // ----- GridLengthHelper class --------------------
    static constexpr const char* const type_name_GridLengthHelper = "GridLengthHelper";

    static PyObject* _new_GridLengthHelper(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_GridLengthHelper);
        return nullptr;
    }

    static void _dealloc_GridLengthHelper(py::wrapper::Windows::UI::Xaml::GridLengthHelper* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GridLengthHelper_Equals(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.GridLengthHelper", L"Equals", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::GridLength>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::GridLength>(args, 1);

                return py::convert(winrt::Windows::UI::Xaml::GridLengthHelper::Equals(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GridLengthHelper_FromPixels(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.GridLengthHelper", L"FromPixels", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::GridLengthHelper::FromPixels(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GridLengthHelper_FromValueAndType(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.GridLengthHelper", L"FromValueAndType", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::GridUnitType>(args, 1);

                return py::convert(winrt::Windows::UI::Xaml::GridLengthHelper::FromValueAndType(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GridLengthHelper_GetIsAbsolute(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.GridLengthHelper", L"GetIsAbsolute", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::GridLength>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::GridLengthHelper::GetIsAbsolute(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GridLengthHelper_GetIsAuto(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.GridLengthHelper", L"GetIsAuto", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::GridLength>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::GridLengthHelper::GetIsAuto(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GridLengthHelper_GetIsStar(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.GridLengthHelper", L"GetIsStar", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::GridLength>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::GridLengthHelper::GetIsStar(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GridLengthHelper_get_Auto(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.GridLengthHelper", L"Auto"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::GridLengthHelper::Auto());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GridLengthHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::GridLengthHelper>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GridLengthHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::GridLengthHelper>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GridLengthHelper[] = {
        { "equals", reinterpret_cast<PyCFunction>(GridLengthHelper_Equals), METH_VARARGS | METH_STATIC, nullptr },
        { "from_pixels", reinterpret_cast<PyCFunction>(GridLengthHelper_FromPixels), METH_VARARGS | METH_STATIC, nullptr },
        { "from_value_and_type", reinterpret_cast<PyCFunction>(GridLengthHelper_FromValueAndType), METH_VARARGS | METH_STATIC, nullptr },
        { "get_is_absolute", reinterpret_cast<PyCFunction>(GridLengthHelper_GetIsAbsolute), METH_VARARGS | METH_STATIC, nullptr },
        { "get_is_auto", reinterpret_cast<PyCFunction>(GridLengthHelper_GetIsAuto), METH_VARARGS | METH_STATIC, nullptr },
        { "get_is_star", reinterpret_cast<PyCFunction>(GridLengthHelper_GetIsStar), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_GridLengthHelper, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GridLengthHelper), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GridLengthHelper[] = {
        { }
    };

    static PyType_Slot _type_slots_GridLengthHelper[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GridLengthHelper) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GridLengthHelper) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GridLengthHelper) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GridLengthHelper) },
        { },
    };

    static PyType_Spec type_spec_GridLengthHelper =
    {
        "_winrt_Windows_UI_Xaml.GridLengthHelper",
        sizeof(py::wrapper::Windows::UI::Xaml::GridLengthHelper),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GridLengthHelper
    };

    static PyGetSetDef getset_GridLengthHelper_Meta[] = {
        { "auto", reinterpret_cast<getter>(GridLengthHelper_get_Auto), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_GridLengthHelper_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GridLengthHelper_Meta) },
        { }
    };

    static PyType_Spec type_spec_GridLengthHelper_Meta =
    {
        "_winrt_Windows_UI_Xaml.GridLengthHelper_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_GridLengthHelper_Meta
    };

    // ----- MediaFailedRoutedEventArgs class --------------------
    static constexpr const char* const type_name_MediaFailedRoutedEventArgs = "MediaFailedRoutedEventArgs";

    static PyObject* _new_MediaFailedRoutedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaFailedRoutedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaFailedRoutedEventArgs(py::wrapper::Windows::UI::Xaml::MediaFailedRoutedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaFailedRoutedEventArgs_get_ErrorTrace(py::wrapper::Windows::UI::Xaml::MediaFailedRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.MediaFailedRoutedEventArgs", L"ErrorTrace"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorTrace());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaFailedRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::MediaFailedRoutedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaFailedRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::MediaFailedRoutedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaFailedRoutedEventArgs[] = {
        { "_assign_array_", _assign_array_MediaFailedRoutedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaFailedRoutedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaFailedRoutedEventArgs[] = {
        { "error_trace", reinterpret_cast<getter>(MediaFailedRoutedEventArgs_get_ErrorTrace), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaFailedRoutedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaFailedRoutedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaFailedRoutedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaFailedRoutedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaFailedRoutedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MediaFailedRoutedEventArgs =
    {
        "_winrt_Windows_UI_Xaml.MediaFailedRoutedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::MediaFailedRoutedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaFailedRoutedEventArgs
    };

    // ----- PointHelper class --------------------
    static constexpr const char* const type_name_PointHelper = "PointHelper";

    static PyObject* _new_PointHelper(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PointHelper);
        return nullptr;
    }

    static void _dealloc_PointHelper(py::wrapper::Windows::UI::Xaml::PointHelper* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PointHelper_FromCoordinates(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.PointHelper", L"FromCoordinates", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<float>(args, 1);

                return py::convert(winrt::Windows::UI::Xaml::PointHelper::FromCoordinates(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_PointHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::PointHelper>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PointHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::PointHelper>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PointHelper[] = {
        { "from_coordinates", reinterpret_cast<PyCFunction>(PointHelper_FromCoordinates), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_PointHelper, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PointHelper), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PointHelper[] = {
        { }
    };

    static PyType_Slot _type_slots_PointHelper[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PointHelper) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PointHelper) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PointHelper) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PointHelper) },
        { },
    };

    static PyType_Spec type_spec_PointHelper =
    {
        "_winrt_Windows_UI_Xaml.PointHelper",
        sizeof(py::wrapper::Windows::UI::Xaml::PointHelper),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PointHelper
    };

    // ----- PropertyMetadata class --------------------
    static constexpr const char* const type_name_PropertyMetadata = "PropertyMetadata";

    static PyObject* _new_PropertyMetadata(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                winrt::Windows::UI::Xaml::PropertyMetadata instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::PropertyChangedCallback>(args, 1);

                winrt::Windows::UI::Xaml::PropertyMetadata instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PropertyMetadata(py::wrapper::Windows::UI::Xaml::PropertyMetadata* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PropertyMetadata_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.PropertyMetadata", L"Create", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::PropertyMetadata::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.PropertyMetadata", L"Create", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::PropertyChangedCallback>(args, 1);

                return py::convert(winrt::Windows::UI::Xaml::PropertyMetadata::Create(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyMetadata_get_CreateDefaultValueCallback(py::wrapper::Windows::UI::Xaml::PropertyMetadata* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.PropertyMetadata", L"CreateDefaultValueCallback"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CreateDefaultValueCallback());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PropertyMetadata_get_DefaultValue(py::wrapper::Windows::UI::Xaml::PropertyMetadata* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.PropertyMetadata", L"DefaultValue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PropertyMetadata(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::PropertyMetadata>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PropertyMetadata(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::PropertyMetadata>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PropertyMetadata[] = {
        { "create", reinterpret_cast<PyCFunction>(PropertyMetadata_Create), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_PropertyMetadata, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PropertyMetadata), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PropertyMetadata[] = {
        { "create_default_value_callback", reinterpret_cast<getter>(PropertyMetadata_get_CreateDefaultValueCallback), nullptr, nullptr, nullptr },
        { "default_value", reinterpret_cast<getter>(PropertyMetadata_get_DefaultValue), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PropertyMetadata[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PropertyMetadata) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PropertyMetadata) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PropertyMetadata) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PropertyMetadata) },
        { },
    };

    static PyType_Spec type_spec_PropertyMetadata =
    {
        "_winrt_Windows_UI_Xaml.PropertyMetadata",
        sizeof(py::wrapper::Windows::UI::Xaml::PropertyMetadata),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PropertyMetadata
    };

    // ----- PropertyPath class --------------------
    static constexpr const char* const type_name_PropertyPath = "PropertyPath";

    static PyObject* _new_PropertyPath(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::UI::Xaml::PropertyPath instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PropertyPath(py::wrapper::Windows::UI::Xaml::PropertyPath* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PropertyPath_get_Path(py::wrapper::Windows::UI::Xaml::PropertyPath* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.PropertyPath", L"Path"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Path());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PropertyPath(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::PropertyPath>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PropertyPath(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::PropertyPath>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PropertyPath[] = {
        { "_assign_array_", _assign_array_PropertyPath, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PropertyPath), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PropertyPath[] = {
        { "path", reinterpret_cast<getter>(PropertyPath_get_Path), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PropertyPath[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PropertyPath) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PropertyPath) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PropertyPath) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PropertyPath) },
        { },
    };

    static PyType_Spec type_spec_PropertyPath =
    {
        "_winrt_Windows_UI_Xaml.PropertyPath",
        sizeof(py::wrapper::Windows::UI::Xaml::PropertyPath),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PropertyPath
    };

    // ----- RectHelper class --------------------
    static constexpr const char* const type_name_RectHelper = "RectHelper";

    static PyObject* _new_RectHelper(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_RectHelper);
        return nullptr;
    }

    static void _dealloc_RectHelper(py::wrapper::Windows::UI::Xaml::RectHelper* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RectHelper_Contains(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.RectHelper", L"Contains", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Point>(args, 1);

                return py::convert(winrt::Windows::UI::Xaml::RectHelper::Contains(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RectHelper_Equals(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.RectHelper", L"Equals", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);

                return py::convert(winrt::Windows::UI::Xaml::RectHelper::Equals(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RectHelper_FromCoordinatesAndDimensions(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.RectHelper", L"FromCoordinatesAndDimensions", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<float>(args, 1);
                auto param2 = py::convert_to<float>(args, 2);
                auto param3 = py::convert_to<float>(args, 3);

                return py::convert(winrt::Windows::UI::Xaml::RectHelper::FromCoordinatesAndDimensions(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RectHelper_FromLocationAndSize(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.RectHelper", L"FromLocationAndSize", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Size>(args, 1);

                return py::convert(winrt::Windows::UI::Xaml::RectHelper::FromLocationAndSize(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RectHelper_FromPoints(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.RectHelper", L"FromPoints", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Point>(args, 1);

                return py::convert(winrt::Windows::UI::Xaml::RectHelper::FromPoints(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RectHelper_GetBottom(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.RectHelper", L"GetBottom", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::RectHelper::GetBottom(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RectHelper_GetIsEmpty(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.RectHelper", L"GetIsEmpty", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::RectHelper::GetIsEmpty(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RectHelper_GetLeft(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.RectHelper", L"GetLeft", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::RectHelper::GetLeft(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RectHelper_GetRight(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.RectHelper", L"GetRight", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::RectHelper::GetRight(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RectHelper_GetTop(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.RectHelper", L"GetTop", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::RectHelper::GetTop(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RectHelper_Intersect(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.RectHelper", L"Intersect", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);

                return py::convert(winrt::Windows::UI::Xaml::RectHelper::Intersect(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RectHelper_Union(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.RectHelper", L"Union", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Point>(args, 1);

                return py::convert(winrt::Windows::UI::Xaml::RectHelper::Union(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RectHelper_get_Empty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.RectHelper", L"Empty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::RectHelper::Empty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RectHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::RectHelper>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RectHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::RectHelper>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RectHelper[] = {
        { "contains", reinterpret_cast<PyCFunction>(RectHelper_Contains), METH_VARARGS | METH_STATIC, nullptr },
        { "equals", reinterpret_cast<PyCFunction>(RectHelper_Equals), METH_VARARGS | METH_STATIC, nullptr },
        { "from_coordinates_and_dimensions", reinterpret_cast<PyCFunction>(RectHelper_FromCoordinatesAndDimensions), METH_VARARGS | METH_STATIC, nullptr },
        { "from_location_and_size", reinterpret_cast<PyCFunction>(RectHelper_FromLocationAndSize), METH_VARARGS | METH_STATIC, nullptr },
        { "from_points", reinterpret_cast<PyCFunction>(RectHelper_FromPoints), METH_VARARGS | METH_STATIC, nullptr },
        { "get_bottom", reinterpret_cast<PyCFunction>(RectHelper_GetBottom), METH_VARARGS | METH_STATIC, nullptr },
        { "get_is_empty", reinterpret_cast<PyCFunction>(RectHelper_GetIsEmpty), METH_VARARGS | METH_STATIC, nullptr },
        { "get_left", reinterpret_cast<PyCFunction>(RectHelper_GetLeft), METH_VARARGS | METH_STATIC, nullptr },
        { "get_right", reinterpret_cast<PyCFunction>(RectHelper_GetRight), METH_VARARGS | METH_STATIC, nullptr },
        { "get_top", reinterpret_cast<PyCFunction>(RectHelper_GetTop), METH_VARARGS | METH_STATIC, nullptr },
        { "intersect", reinterpret_cast<PyCFunction>(RectHelper_Intersect), METH_VARARGS | METH_STATIC, nullptr },
        { "union", reinterpret_cast<PyCFunction>(RectHelper_Union), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_RectHelper, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RectHelper), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RectHelper[] = {
        { }
    };

    static PyType_Slot _type_slots_RectHelper[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RectHelper) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RectHelper) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RectHelper) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RectHelper) },
        { },
    };

    static PyType_Spec type_spec_RectHelper =
    {
        "_winrt_Windows_UI_Xaml.RectHelper",
        sizeof(py::wrapper::Windows::UI::Xaml::RectHelper),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RectHelper
    };

    static PyGetSetDef getset_RectHelper_Meta[] = {
        { "empty", reinterpret_cast<getter>(RectHelper_get_Empty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_RectHelper_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RectHelper_Meta) },
        { }
    };

    static PyType_Spec type_spec_RectHelper_Meta =
    {
        "_winrt_Windows_UI_Xaml.RectHelper_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RectHelper_Meta
    };

    // ----- ResourceDictionary class --------------------
    static constexpr const char* const type_name_ResourceDictionary = "ResourceDictionary";

    static PyObject* _new_ResourceDictionary(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::ResourceDictionary instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ResourceDictionary(py::wrapper::Windows::UI::Xaml::ResourceDictionary* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ResourceDictionary_Clear(py::wrapper::Windows::UI::Xaml::ResourceDictionary* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.ResourceDictionary", L"Clear", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ResourceDictionary_First(py::wrapper::Windows::UI::Xaml::ResourceDictionary* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.ResourceDictionary", L"First", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ResourceDictionary_GetView(py::wrapper::Windows::UI::Xaml::ResourceDictionary* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.ResourceDictionary", L"GetView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ResourceDictionary_HasKey(py::wrapper::Windows::UI::Xaml::ResourceDictionary* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.ResourceDictionary", L"HasKey", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert(self->obj.HasKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ResourceDictionary_Insert(py::wrapper::Windows::UI::Xaml::ResourceDictionary* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.ResourceDictionary", L"Insert", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(self->obj.Insert(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ResourceDictionary_Lookup(py::wrapper::Windows::UI::Xaml::ResourceDictionary* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.ResourceDictionary", L"Lookup", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert(self->obj.Lookup(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ResourceDictionary_Remove(py::wrapper::Windows::UI::Xaml::ResourceDictionary* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.ResourceDictionary", L"Remove", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                self->obj.Remove(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ResourceDictionary_get_Size(py::wrapper::Windows::UI::Xaml::ResourceDictionary* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ResourceDictionary", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ResourceDictionary_get_Source(py::wrapper::Windows::UI::Xaml::ResourceDictionary* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ResourceDictionary", L"Source"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ResourceDictionary_put_Source(py::wrapper::Windows::UI::Xaml::ResourceDictionary* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ResourceDictionary", L"Source"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Source(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ResourceDictionary_get_MergedDictionaries(py::wrapper::Windows::UI::Xaml::ResourceDictionary* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ResourceDictionary", L"MergedDictionaries"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MergedDictionaries());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ResourceDictionary_get_ThemeDictionaries(py::wrapper::Windows::UI::Xaml::ResourceDictionary* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ResourceDictionary", L"ThemeDictionaries"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ThemeDictionaries());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ResourceDictionary(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::ResourceDictionary>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ResourceDictionary(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::ResourceDictionary>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_ResourceDictionary(py::wrapper::Windows::UI::Xaml::ResourceDictionary* self) noexcept
    {
        try
        {
            py::pyobj_handle iter{py::convert(self->obj.First())};
            return py::wrap_mapping_iter(iter.get());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_contains_ResourceDictionary(py::wrapper::Windows::UI::Xaml::ResourceDictionary* self, PyObject* key) noexcept
    {
        try
        {
            return static_cast<int>(self->obj.HasKey(py::convert_to<winrt::Windows::Foundation::IInspectable>(key)));
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static Py_ssize_t _map_length_ResourceDictionary(py::wrapper::Windows::UI::Xaml::ResourceDictionary* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _map_subscript_ResourceDictionary(py::wrapper::Windows::UI::Xaml::ResourceDictionary* self, PyObject* key) noexcept
    {
        try
        {
            auto value = self->obj.TryLookup(py::convert_to<winrt::Windows::Foundation::IInspectable>(key));

            if (!value) {
                PyErr_SetObject(PyExc_KeyError, key);
                return nullptr;
            }

            return py::convert(value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_assign_ResourceDictionary(py::wrapper::Windows::UI::Xaml::ResourceDictionary* self, PyObject* key, PyObject* value) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::Windows::Foundation::IInspectable>(key);

            if (value == nullptr) {
                if (!self->obj.TryRemove(_key)) {
                    PyErr_SetObject(PyExc_KeyError, key);
                    return -1;
                }

                return 0;
            }

            self->obj.Insert(_key, py::convert_to<winrt::Windows::Foundation::IInspectable>(value));

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_ResourceDictionary[] = {
        { "clear", reinterpret_cast<PyCFunction>(ResourceDictionary_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(ResourceDictionary_First), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(ResourceDictionary_GetView), METH_VARARGS, nullptr },
        { "has_key", reinterpret_cast<PyCFunction>(ResourceDictionary_HasKey), METH_VARARGS, nullptr },
        { "insert", reinterpret_cast<PyCFunction>(ResourceDictionary_Insert), METH_VARARGS, nullptr },
        { "lookup", reinterpret_cast<PyCFunction>(ResourceDictionary_Lookup), METH_VARARGS, nullptr },
        { "remove", reinterpret_cast<PyCFunction>(ResourceDictionary_Remove), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ResourceDictionary, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ResourceDictionary), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ResourceDictionary[] = {
        { "size", reinterpret_cast<getter>(ResourceDictionary_get_Size), nullptr, nullptr, nullptr },
        { "source", reinterpret_cast<getter>(ResourceDictionary_get_Source), reinterpret_cast<setter>(ResourceDictionary_put_Source), nullptr, nullptr },
        { "merged_dictionaries", reinterpret_cast<getter>(ResourceDictionary_get_MergedDictionaries), nullptr, nullptr, nullptr },
        { "theme_dictionaries", reinterpret_cast<getter>(ResourceDictionary_get_ThemeDictionaries), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ResourceDictionary[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ResourceDictionary) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ResourceDictionary) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ResourceDictionary) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ResourceDictionary) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_ResourceDictionary) },
        { Py_sq_contains, reinterpret_cast<void*>(_map_contains_ResourceDictionary) },
        { Py_mp_length, reinterpret_cast<void*>(_map_length_ResourceDictionary) },
        { Py_mp_subscript, reinterpret_cast<void*>(_map_subscript_ResourceDictionary) },
        { Py_mp_ass_subscript, reinterpret_cast<void*>(_map_assign_ResourceDictionary) },
        { },
    };

    static PyType_Spec type_spec_ResourceDictionary =
    {
        "_winrt_Windows_UI_Xaml.ResourceDictionary",
        sizeof(py::wrapper::Windows::UI::Xaml::ResourceDictionary),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ResourceDictionary
    };

    // ----- RoutedEvent class --------------------
    static constexpr const char* const type_name_RoutedEvent = "RoutedEvent";

    static PyObject* _new_RoutedEvent(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_RoutedEvent);
        return nullptr;
    }

    static void _dealloc_RoutedEvent(py::wrapper::Windows::UI::Xaml::RoutedEvent* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_RoutedEvent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::RoutedEvent>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RoutedEvent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::RoutedEvent>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RoutedEvent[] = {
        { "_assign_array_", _assign_array_RoutedEvent, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RoutedEvent), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RoutedEvent[] = {
        { }
    };

    static PyType_Slot _type_slots_RoutedEvent[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RoutedEvent) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RoutedEvent) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RoutedEvent) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RoutedEvent) },
        { },
    };

    static PyType_Spec type_spec_RoutedEvent =
    {
        "_winrt_Windows_UI_Xaml.RoutedEvent",
        sizeof(py::wrapper::Windows::UI::Xaml::RoutedEvent),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RoutedEvent
    };

    // ----- RoutedEventArgs class --------------------
    static constexpr const char* const type_name_RoutedEventArgs = "RoutedEventArgs";

    static PyObject* _new_RoutedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::RoutedEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RoutedEventArgs(py::wrapper::Windows::UI::Xaml::RoutedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RoutedEventArgs_get_OriginalSource(py::wrapper::Windows::UI::Xaml::RoutedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.RoutedEventArgs", L"OriginalSource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OriginalSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::RoutedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::RoutedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RoutedEventArgs[] = {
        { "_assign_array_", _assign_array_RoutedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RoutedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RoutedEventArgs[] = {
        { "original_source", reinterpret_cast<getter>(RoutedEventArgs_get_OriginalSource), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RoutedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RoutedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RoutedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RoutedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RoutedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_RoutedEventArgs =
    {
        "_winrt_Windows_UI_Xaml.RoutedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::RoutedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RoutedEventArgs
    };

    // ----- ScalarTransition class --------------------
    static constexpr const char* const type_name_ScalarTransition = "ScalarTransition";

    static PyObject* _new_ScalarTransition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::ScalarTransition instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ScalarTransition(py::wrapper::Windows::UI::Xaml::ScalarTransition* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ScalarTransition_get_Duration(py::wrapper::Windows::UI::Xaml::ScalarTransition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ScalarTransition", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScalarTransition_put_Duration(py::wrapper::Windows::UI::Xaml::ScalarTransition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.ScalarTransition", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ScalarTransition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::ScalarTransition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ScalarTransition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::ScalarTransition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ScalarTransition[] = {
        { "_assign_array_", _assign_array_ScalarTransition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ScalarTransition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ScalarTransition[] = {
        { "duration", reinterpret_cast<getter>(ScalarTransition_get_Duration), reinterpret_cast<setter>(ScalarTransition_put_Duration), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ScalarTransition[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ScalarTransition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ScalarTransition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ScalarTransition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ScalarTransition) },
        { },
    };

    static PyType_Spec type_spec_ScalarTransition =
    {
        "_winrt_Windows_UI_Xaml.ScalarTransition",
        sizeof(py::wrapper::Windows::UI::Xaml::ScalarTransition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ScalarTransition
    };

    // ----- Setter class --------------------
    static constexpr const char* const type_name_Setter = "Setter";

    static PyObject* _new_Setter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                winrt::Windows::UI::Xaml::Setter instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Setter instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Setter(py::wrapper::Windows::UI::Xaml::Setter* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Setter_get_Value(py::wrapper::Windows::UI::Xaml::Setter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Setter", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Setter_put_Value(py::wrapper::Windows::UI::Xaml::Setter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Setter", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Setter_get_Property(py::wrapper::Windows::UI::Xaml::Setter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Setter", L"Property"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Property());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Setter_put_Property(py::wrapper::Windows::UI::Xaml::Setter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Setter", L"Property"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(arg);

            self->obj.Property(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Setter_get_Target(py::wrapper::Windows::UI::Xaml::Setter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Setter", L"Target"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Target());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Setter_put_Target(py::wrapper::Windows::UI::Xaml::Setter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Setter", L"Target"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::TargetPropertyPath>(arg);

            self->obj.Target(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_Setter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Setter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Setter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Setter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Setter[] = {
        { "_assign_array_", _assign_array_Setter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Setter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Setter[] = {
        { "value", reinterpret_cast<getter>(Setter_get_Value), reinterpret_cast<setter>(Setter_put_Value), nullptr, nullptr },
        { "property", reinterpret_cast<getter>(Setter_get_Property), reinterpret_cast<setter>(Setter_put_Property), nullptr, nullptr },
        { "target", reinterpret_cast<getter>(Setter_get_Target), reinterpret_cast<setter>(Setter_put_Target), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Setter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Setter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Setter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Setter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Setter) },
        { },
    };

    static PyType_Spec type_spec_Setter =
    {
        "_winrt_Windows_UI_Xaml.Setter",
        sizeof(py::wrapper::Windows::UI::Xaml::Setter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Setter
    };

    // ----- SetterBase class --------------------
    static constexpr const char* const type_name_SetterBase = "SetterBase";

    static PyObject* _new_SetterBase(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SetterBase);
        return nullptr;
    }

    static void _dealloc_SetterBase(py::wrapper::Windows::UI::Xaml::SetterBase* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SetterBase_get_IsSealed(py::wrapper::Windows::UI::Xaml::SetterBase* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.SetterBase", L"IsSealed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSealed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SetterBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::SetterBase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SetterBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::SetterBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SetterBase[] = {
        { "_assign_array_", _assign_array_SetterBase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SetterBase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SetterBase[] = {
        { "is_sealed", reinterpret_cast<getter>(SetterBase_get_IsSealed), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SetterBase[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SetterBase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SetterBase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SetterBase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SetterBase) },
        { },
    };

    static PyType_Spec type_spec_SetterBase =
    {
        "_winrt_Windows_UI_Xaml.SetterBase",
        sizeof(py::wrapper::Windows::UI::Xaml::SetterBase),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SetterBase
    };

    // ----- SetterBaseCollection class --------------------
    static constexpr const char* const type_name_SetterBaseCollection = "SetterBaseCollection";

    static PyObject* _new_SetterBaseCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::SetterBaseCollection instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SetterBaseCollection(py::wrapper::Windows::UI::Xaml::SetterBaseCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SetterBaseCollection_Append(py::wrapper::Windows::UI::Xaml::SetterBaseCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.SetterBaseCollection", L"Append", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::SetterBase>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SetterBaseCollection_Clear(py::wrapper::Windows::UI::Xaml::SetterBaseCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.SetterBaseCollection", L"Clear", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SetterBaseCollection_First(py::wrapper::Windows::UI::Xaml::SetterBaseCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.SetterBaseCollection", L"First", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SetterBaseCollection_GetAt(py::wrapper::Windows::UI::Xaml::SetterBaseCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.SetterBaseCollection", L"GetAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SetterBaseCollection_GetMany(py::wrapper::Windows::UI::Xaml::SetterBaseCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.SetterBaseCollection", L"GetMany", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::SetterBase, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SetterBaseCollection_GetView(py::wrapper::Windows::UI::Xaml::SetterBaseCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.SetterBaseCollection", L"GetView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SetterBaseCollection_IndexOf(py::wrapper::Windows::UI::Xaml::SetterBaseCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.SetterBaseCollection", L"IndexOf", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::SetterBase>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SetterBaseCollection_InsertAt(py::wrapper::Windows::UI::Xaml::SetterBaseCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.SetterBaseCollection", L"InsertAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::SetterBase>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SetterBaseCollection_RemoveAt(py::wrapper::Windows::UI::Xaml::SetterBaseCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.SetterBaseCollection", L"RemoveAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SetterBaseCollection_RemoveAtEnd(py::wrapper::Windows::UI::Xaml::SetterBaseCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.SetterBaseCollection", L"RemoveAtEnd", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SetterBaseCollection_ReplaceAll(py::wrapper::Windows::UI::Xaml::SetterBaseCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.SetterBaseCollection", L"ReplaceAll", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::SetterBase, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SetterBaseCollection_SetAt(py::wrapper::Windows::UI::Xaml::SetterBaseCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.SetterBaseCollection", L"SetAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::SetterBase>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SetterBaseCollection_get_Size(py::wrapper::Windows::UI::Xaml::SetterBaseCollection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.SetterBaseCollection", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SetterBaseCollection_get_IsSealed(py::wrapper::Windows::UI::Xaml::SetterBaseCollection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.SetterBaseCollection", L"IsSealed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSealed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SetterBaseCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::SetterBaseCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SetterBaseCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::SetterBaseCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_SetterBaseCollection(py::wrapper::Windows::UI::Xaml::SetterBaseCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_SetterBaseCollection(py::wrapper::Windows::UI::Xaml::SetterBaseCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_SetterBaseCollection(py::wrapper::Windows::UI::Xaml::SetterBaseCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_SetterBaseCollection(py::wrapper::Windows::UI::Xaml::SetterBaseCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_SetterBaseCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(
                    PyExc_TypeError,
                    "indicies must be integers, not '%s'",
                    Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(
                    slice, self->obj.Size(), &start, &stop, &step, &length)
                < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(
                    PyExc_NotImplementedError,
                    "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::UI::Xaml::SetterBase> items(length, empty_instance<winrt::Windows::UI::Xaml::SetterBase>::get());

            auto count = self->obj.GetMany(start, items);

            if (count != length)
            {
                PyErr_Format(
                    PyExc_RuntimeError,
                    "returned count %d did not match requested length %zd",
                    count,
                    length);
                return nullptr;
            }

            return convert(items);}
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_SetterBaseCollection(py::wrapper::Windows::UI::Xaml::SetterBaseCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (value == nullptr) { self->obj.RemoveAt(static_cast<uint32_t>(i)); }
            else { self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::UI::Xaml::SetterBase>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_SetterBaseCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(SetterBaseCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(SetterBaseCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(SetterBaseCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(SetterBaseCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(SetterBaseCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(SetterBaseCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(SetterBaseCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(SetterBaseCollection_InsertAt), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(SetterBaseCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(SetterBaseCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(SetterBaseCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(SetterBaseCollection_SetAt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SetterBaseCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SetterBaseCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SetterBaseCollection[] = {
        { "size", reinterpret_cast<getter>(SetterBaseCollection_get_Size), nullptr, nullptr, nullptr },
        { "is_sealed", reinterpret_cast<getter>(SetterBaseCollection_get_IsSealed), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SetterBaseCollection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SetterBaseCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SetterBaseCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SetterBaseCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SetterBaseCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_SetterBaseCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_SetterBaseCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_SetterBaseCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_SetterBaseCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_SetterBaseCollection) },
        { },
    };

    static PyType_Spec type_spec_SetterBaseCollection =
    {
        "_winrt_Windows_UI_Xaml.SetterBaseCollection",
        sizeof(py::wrapper::Windows::UI::Xaml::SetterBaseCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SetterBaseCollection
    };

    // ----- SizeChangedEventArgs class --------------------
    static constexpr const char* const type_name_SizeChangedEventArgs = "SizeChangedEventArgs";

    static PyObject* _new_SizeChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SizeChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_SizeChangedEventArgs(py::wrapper::Windows::UI::Xaml::SizeChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SizeChangedEventArgs_get_NewSize(py::wrapper::Windows::UI::Xaml::SizeChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.SizeChangedEventArgs", L"NewSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NewSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SizeChangedEventArgs_get_PreviousSize(py::wrapper::Windows::UI::Xaml::SizeChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.SizeChangedEventArgs", L"PreviousSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreviousSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SizeChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::SizeChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SizeChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::SizeChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SizeChangedEventArgs[] = {
        { "_assign_array_", _assign_array_SizeChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SizeChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SizeChangedEventArgs[] = {
        { "new_size", reinterpret_cast<getter>(SizeChangedEventArgs_get_NewSize), nullptr, nullptr, nullptr },
        { "previous_size", reinterpret_cast<getter>(SizeChangedEventArgs_get_PreviousSize), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SizeChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SizeChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SizeChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SizeChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SizeChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_SizeChangedEventArgs =
    {
        "_winrt_Windows_UI_Xaml.SizeChangedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::SizeChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SizeChangedEventArgs
    };

    // ----- SizeHelper class --------------------
    static constexpr const char* const type_name_SizeHelper = "SizeHelper";

    static PyObject* _new_SizeHelper(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SizeHelper);
        return nullptr;
    }

    static void _dealloc_SizeHelper(py::wrapper::Windows::UI::Xaml::SizeHelper* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SizeHelper_Equals(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.SizeHelper", L"Equals", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Size>(args, 1);

                return py::convert(winrt::Windows::UI::Xaml::SizeHelper::Equals(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SizeHelper_FromDimensions(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.SizeHelper", L"FromDimensions", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<float>(args, 1);

                return py::convert(winrt::Windows::UI::Xaml::SizeHelper::FromDimensions(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SizeHelper_GetIsEmpty(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.SizeHelper", L"GetIsEmpty", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::SizeHelper::GetIsEmpty(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SizeHelper_get_Empty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.SizeHelper", L"Empty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::SizeHelper::Empty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SizeHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::SizeHelper>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SizeHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::SizeHelper>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SizeHelper[] = {
        { "equals", reinterpret_cast<PyCFunction>(SizeHelper_Equals), METH_VARARGS | METH_STATIC, nullptr },
        { "from_dimensions", reinterpret_cast<PyCFunction>(SizeHelper_FromDimensions), METH_VARARGS | METH_STATIC, nullptr },
        { "get_is_empty", reinterpret_cast<PyCFunction>(SizeHelper_GetIsEmpty), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_SizeHelper, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SizeHelper), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SizeHelper[] = {
        { }
    };

    static PyType_Slot _type_slots_SizeHelper[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SizeHelper) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SizeHelper) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SizeHelper) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SizeHelper) },
        { },
    };

    static PyType_Spec type_spec_SizeHelper =
    {
        "_winrt_Windows_UI_Xaml.SizeHelper",
        sizeof(py::wrapper::Windows::UI::Xaml::SizeHelper),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SizeHelper
    };

    static PyGetSetDef getset_SizeHelper_Meta[] = {
        { "empty", reinterpret_cast<getter>(SizeHelper_get_Empty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_SizeHelper_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SizeHelper_Meta) },
        { }
    };

    static PyType_Spec type_spec_SizeHelper_Meta =
    {
        "_winrt_Windows_UI_Xaml.SizeHelper_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SizeHelper_Meta
    };

    // ----- StateTrigger class --------------------
    static constexpr const char* const type_name_StateTrigger = "StateTrigger";

    static PyObject* _new_StateTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::StateTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StateTrigger(py::wrapper::Windows::UI::Xaml::StateTrigger* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StateTrigger_get_IsActive(py::wrapper::Windows::UI::Xaml::StateTrigger* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.StateTrigger", L"IsActive"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsActive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StateTrigger_put_IsActive(py::wrapper::Windows::UI::Xaml::StateTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.StateTrigger", L"IsActive"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsActive(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StateTrigger_get_IsActiveProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.StateTrigger", L"IsActiveProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::StateTrigger::IsActiveProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StateTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::StateTrigger>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StateTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::StateTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StateTrigger[] = {
        { "_assign_array_", _assign_array_StateTrigger, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StateTrigger), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StateTrigger[] = {
        { "is_active", reinterpret_cast<getter>(StateTrigger_get_IsActive), reinterpret_cast<setter>(StateTrigger_put_IsActive), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StateTrigger[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StateTrigger) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StateTrigger) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StateTrigger) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StateTrigger) },
        { },
    };

    static PyType_Spec type_spec_StateTrigger =
    {
        "_winrt_Windows_UI_Xaml.StateTrigger",
        sizeof(py::wrapper::Windows::UI::Xaml::StateTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StateTrigger
    };

    static PyGetSetDef getset_StateTrigger_Meta[] = {
        { "is_active_property", reinterpret_cast<getter>(StateTrigger_get_IsActiveProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_StateTrigger_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_StateTrigger_Meta) },
        { }
    };

    static PyType_Spec type_spec_StateTrigger_Meta =
    {
        "_winrt_Windows_UI_Xaml.StateTrigger_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_StateTrigger_Meta
    };

    // ----- StateTriggerBase class --------------------
    static constexpr const char* const type_name_StateTriggerBase = "StateTriggerBase";

    static PyObject* _new_StateTriggerBase(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_StateTriggerBase);
        return nullptr;
    }

    static void _dealloc_StateTriggerBase(py::wrapper::Windows::UI::Xaml::StateTriggerBase* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StateTriggerBase_SetActive(py::wrapper::Windows::UI::Xaml::StateTriggerBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.StateTriggerBase", L"SetActive", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.SetActive(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_StateTriggerBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::StateTriggerBase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StateTriggerBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::StateTriggerBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StateTriggerBase[] = {
        { "set_active", reinterpret_cast<PyCFunction>(StateTriggerBase_SetActive), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_StateTriggerBase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StateTriggerBase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StateTriggerBase[] = {
        { }
    };

    static PyType_Slot _type_slots_StateTriggerBase[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StateTriggerBase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StateTriggerBase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StateTriggerBase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StateTriggerBase) },
        { },
    };

    static PyType_Spec type_spec_StateTriggerBase =
    {
        "_winrt_Windows_UI_Xaml.StateTriggerBase",
        sizeof(py::wrapper::Windows::UI::Xaml::StateTriggerBase),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StateTriggerBase
    };

    // ----- Style class --------------------
    static constexpr const char* const type_name_Style = "Style";

    static PyObject* _new_Style(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Interop::TypeName>(args, 0);

                winrt::Windows::UI::Xaml::Style instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Style instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Style(py::wrapper::Windows::UI::Xaml::Style* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Style_Seal(py::wrapper::Windows::UI::Xaml::Style* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Style", L"Seal", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Seal();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Style_get_TargetType(py::wrapper::Windows::UI::Xaml::Style* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Style", L"TargetType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TargetType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Style_put_TargetType(py::wrapper::Windows::UI::Xaml::Style* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Style", L"TargetType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Interop::TypeName>(arg);

            self->obj.TargetType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Style_get_BasedOn(py::wrapper::Windows::UI::Xaml::Style* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Style", L"BasedOn"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BasedOn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Style_put_BasedOn(py::wrapper::Windows::UI::Xaml::Style* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Style", L"BasedOn"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Style>(arg);

            self->obj.BasedOn(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Style_get_IsSealed(py::wrapper::Windows::UI::Xaml::Style* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Style", L"IsSealed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSealed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Style_get_Setters(py::wrapper::Windows::UI::Xaml::Style* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Style", L"Setters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Setters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Style(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Style>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Style(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Style>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Style[] = {
        { "seal", reinterpret_cast<PyCFunction>(Style_Seal), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_Style, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Style), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Style[] = {
        { "target_type", reinterpret_cast<getter>(Style_get_TargetType), reinterpret_cast<setter>(Style_put_TargetType), nullptr, nullptr },
        { "based_on", reinterpret_cast<getter>(Style_get_BasedOn), reinterpret_cast<setter>(Style_put_BasedOn), nullptr, nullptr },
        { "is_sealed", reinterpret_cast<getter>(Style_get_IsSealed), nullptr, nullptr, nullptr },
        { "setters", reinterpret_cast<getter>(Style_get_Setters), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Style[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Style) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Style) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Style) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Style) },
        { },
    };

    static PyType_Spec type_spec_Style =
    {
        "_winrt_Windows_UI_Xaml.Style",
        sizeof(py::wrapper::Windows::UI::Xaml::Style),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Style
    };

    // ----- TargetPropertyPath class --------------------
    static constexpr const char* const type_name_TargetPropertyPath = "TargetPropertyPath";

    static PyObject* _new_TargetPropertyPath(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                winrt::Windows::UI::Xaml::TargetPropertyPath instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::TargetPropertyPath instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TargetPropertyPath(py::wrapper::Windows::UI::Xaml::TargetPropertyPath* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TargetPropertyPath_get_Target(py::wrapper::Windows::UI::Xaml::TargetPropertyPath* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.TargetPropertyPath", L"Target"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Target());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TargetPropertyPath_put_Target(py::wrapper::Windows::UI::Xaml::TargetPropertyPath* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.TargetPropertyPath", L"Target"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.Target(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TargetPropertyPath_get_Path(py::wrapper::Windows::UI::Xaml::TargetPropertyPath* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.TargetPropertyPath", L"Path"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Path());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TargetPropertyPath_put_Path(py::wrapper::Windows::UI::Xaml::TargetPropertyPath* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.TargetPropertyPath", L"Path"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::PropertyPath>(arg);

            self->obj.Path(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_TargetPropertyPath(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::TargetPropertyPath>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TargetPropertyPath(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::TargetPropertyPath>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TargetPropertyPath[] = {
        { "_assign_array_", _assign_array_TargetPropertyPath, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TargetPropertyPath), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TargetPropertyPath[] = {
        { "target", reinterpret_cast<getter>(TargetPropertyPath_get_Target), reinterpret_cast<setter>(TargetPropertyPath_put_Target), nullptr, nullptr },
        { "path", reinterpret_cast<getter>(TargetPropertyPath_get_Path), reinterpret_cast<setter>(TargetPropertyPath_put_Path), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TargetPropertyPath[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TargetPropertyPath) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TargetPropertyPath) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TargetPropertyPath) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TargetPropertyPath) },
        { },
    };

    static PyType_Spec type_spec_TargetPropertyPath =
    {
        "_winrt_Windows_UI_Xaml.TargetPropertyPath",
        sizeof(py::wrapper::Windows::UI::Xaml::TargetPropertyPath),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TargetPropertyPath
    };

    // ----- ThicknessHelper class --------------------
    static constexpr const char* const type_name_ThicknessHelper = "ThicknessHelper";

    static PyObject* _new_ThicknessHelper(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ThicknessHelper);
        return nullptr;
    }

    static void _dealloc_ThicknessHelper(py::wrapper::Windows::UI::Xaml::ThicknessHelper* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ThicknessHelper_FromLengths(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.ThicknessHelper", L"FromLengths", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<double>(args, 2);
                auto param3 = py::convert_to<double>(args, 3);

                return py::convert(winrt::Windows::UI::Xaml::ThicknessHelper::FromLengths(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ThicknessHelper_FromUniformLength(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.ThicknessHelper", L"FromUniformLength", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::ThicknessHelper::FromUniformLength(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ThicknessHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::ThicknessHelper>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ThicknessHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::ThicknessHelper>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ThicknessHelper[] = {
        { "from_lengths", reinterpret_cast<PyCFunction>(ThicknessHelper_FromLengths), METH_VARARGS | METH_STATIC, nullptr },
        { "from_uniform_length", reinterpret_cast<PyCFunction>(ThicknessHelper_FromUniformLength), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_ThicknessHelper, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ThicknessHelper), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ThicknessHelper[] = {
        { }
    };

    static PyType_Slot _type_slots_ThicknessHelper[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ThicknessHelper) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ThicknessHelper) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ThicknessHelper) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ThicknessHelper) },
        { },
    };

    static PyType_Spec type_spec_ThicknessHelper =
    {
        "_winrt_Windows_UI_Xaml.ThicknessHelper",
        sizeof(py::wrapper::Windows::UI::Xaml::ThicknessHelper),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ThicknessHelper
    };

    // ----- TriggerAction class --------------------
    static constexpr const char* const type_name_TriggerAction = "TriggerAction";

    static PyObject* _new_TriggerAction(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_TriggerAction);
        return nullptr;
    }

    static void _dealloc_TriggerAction(py::wrapper::Windows::UI::Xaml::TriggerAction* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TriggerAction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::TriggerAction>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TriggerAction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::TriggerAction>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TriggerAction[] = {
        { "_assign_array_", _assign_array_TriggerAction, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TriggerAction), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TriggerAction[] = {
        { }
    };

    static PyType_Slot _type_slots_TriggerAction[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TriggerAction) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TriggerAction) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TriggerAction) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TriggerAction) },
        { },
    };

    static PyType_Spec type_spec_TriggerAction =
    {
        "_winrt_Windows_UI_Xaml.TriggerAction",
        sizeof(py::wrapper::Windows::UI::Xaml::TriggerAction),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TriggerAction
    };

    // ----- TriggerActionCollection class --------------------
    static constexpr const char* const type_name_TriggerActionCollection = "TriggerActionCollection";

    static PyObject* _new_TriggerActionCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::TriggerActionCollection instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TriggerActionCollection(py::wrapper::Windows::UI::Xaml::TriggerActionCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TriggerActionCollection_Append(py::wrapper::Windows::UI::Xaml::TriggerActionCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.TriggerActionCollection", L"Append", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::TriggerAction>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TriggerActionCollection_Clear(py::wrapper::Windows::UI::Xaml::TriggerActionCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.TriggerActionCollection", L"Clear", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TriggerActionCollection_First(py::wrapper::Windows::UI::Xaml::TriggerActionCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.TriggerActionCollection", L"First", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TriggerActionCollection_GetAt(py::wrapper::Windows::UI::Xaml::TriggerActionCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.TriggerActionCollection", L"GetAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TriggerActionCollection_GetMany(py::wrapper::Windows::UI::Xaml::TriggerActionCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.TriggerActionCollection", L"GetMany", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::TriggerAction, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TriggerActionCollection_GetView(py::wrapper::Windows::UI::Xaml::TriggerActionCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.TriggerActionCollection", L"GetView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TriggerActionCollection_IndexOf(py::wrapper::Windows::UI::Xaml::TriggerActionCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.TriggerActionCollection", L"IndexOf", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::TriggerAction>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TriggerActionCollection_InsertAt(py::wrapper::Windows::UI::Xaml::TriggerActionCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.TriggerActionCollection", L"InsertAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::TriggerAction>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TriggerActionCollection_RemoveAt(py::wrapper::Windows::UI::Xaml::TriggerActionCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.TriggerActionCollection", L"RemoveAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TriggerActionCollection_RemoveAtEnd(py::wrapper::Windows::UI::Xaml::TriggerActionCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.TriggerActionCollection", L"RemoveAtEnd", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TriggerActionCollection_ReplaceAll(py::wrapper::Windows::UI::Xaml::TriggerActionCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.TriggerActionCollection", L"ReplaceAll", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::TriggerAction, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TriggerActionCollection_SetAt(py::wrapper::Windows::UI::Xaml::TriggerActionCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.TriggerActionCollection", L"SetAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::TriggerAction>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TriggerActionCollection_get_Size(py::wrapper::Windows::UI::Xaml::TriggerActionCollection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.TriggerActionCollection", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TriggerActionCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::TriggerActionCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TriggerActionCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::TriggerActionCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_TriggerActionCollection(py::wrapper::Windows::UI::Xaml::TriggerActionCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_TriggerActionCollection(py::wrapper::Windows::UI::Xaml::TriggerActionCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_TriggerActionCollection(py::wrapper::Windows::UI::Xaml::TriggerActionCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_TriggerActionCollection(py::wrapper::Windows::UI::Xaml::TriggerActionCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_TriggerActionCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(
                    PyExc_TypeError,
                    "indicies must be integers, not '%s'",
                    Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(
                    slice, self->obj.Size(), &start, &stop, &step, &length)
                < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(
                    PyExc_NotImplementedError,
                    "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::UI::Xaml::TriggerAction> items(length, empty_instance<winrt::Windows::UI::Xaml::TriggerAction>::get());

            auto count = self->obj.GetMany(start, items);

            if (count != length)
            {
                PyErr_Format(
                    PyExc_RuntimeError,
                    "returned count %d did not match requested length %zd",
                    count,
                    length);
                return nullptr;
            }

            return convert(items);}
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_TriggerActionCollection(py::wrapper::Windows::UI::Xaml::TriggerActionCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (value == nullptr) { self->obj.RemoveAt(static_cast<uint32_t>(i)); }
            else { self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::UI::Xaml::TriggerAction>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_TriggerActionCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(TriggerActionCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(TriggerActionCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(TriggerActionCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(TriggerActionCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(TriggerActionCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(TriggerActionCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(TriggerActionCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(TriggerActionCollection_InsertAt), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(TriggerActionCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(TriggerActionCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(TriggerActionCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(TriggerActionCollection_SetAt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TriggerActionCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TriggerActionCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TriggerActionCollection[] = {
        { "size", reinterpret_cast<getter>(TriggerActionCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TriggerActionCollection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TriggerActionCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TriggerActionCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TriggerActionCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TriggerActionCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_TriggerActionCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_TriggerActionCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_TriggerActionCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_TriggerActionCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_TriggerActionCollection) },
        { },
    };

    static PyType_Spec type_spec_TriggerActionCollection =
    {
        "_winrt_Windows_UI_Xaml.TriggerActionCollection",
        sizeof(py::wrapper::Windows::UI::Xaml::TriggerActionCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TriggerActionCollection
    };

    // ----- TriggerBase class --------------------
    static constexpr const char* const type_name_TriggerBase = "TriggerBase";

    static PyObject* _new_TriggerBase(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_TriggerBase);
        return nullptr;
    }

    static void _dealloc_TriggerBase(py::wrapper::Windows::UI::Xaml::TriggerBase* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TriggerBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::TriggerBase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TriggerBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::TriggerBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TriggerBase[] = {
        { "_assign_array_", _assign_array_TriggerBase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TriggerBase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TriggerBase[] = {
        { }
    };

    static PyType_Slot _type_slots_TriggerBase[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TriggerBase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TriggerBase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TriggerBase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TriggerBase) },
        { },
    };

    static PyType_Spec type_spec_TriggerBase =
    {
        "_winrt_Windows_UI_Xaml.TriggerBase",
        sizeof(py::wrapper::Windows::UI::Xaml::TriggerBase),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TriggerBase
    };

    // ----- TriggerCollection class --------------------
    static constexpr const char* const type_name_TriggerCollection = "TriggerCollection";

    static PyObject* _new_TriggerCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_TriggerCollection);
        return nullptr;
    }

    static void _dealloc_TriggerCollection(py::wrapper::Windows::UI::Xaml::TriggerCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TriggerCollection_Append(py::wrapper::Windows::UI::Xaml::TriggerCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.TriggerCollection", L"Append", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::TriggerBase>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TriggerCollection_Clear(py::wrapper::Windows::UI::Xaml::TriggerCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.TriggerCollection", L"Clear", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TriggerCollection_First(py::wrapper::Windows::UI::Xaml::TriggerCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.TriggerCollection", L"First", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TriggerCollection_GetAt(py::wrapper::Windows::UI::Xaml::TriggerCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.TriggerCollection", L"GetAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TriggerCollection_GetMany(py::wrapper::Windows::UI::Xaml::TriggerCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.TriggerCollection", L"GetMany", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::TriggerBase, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TriggerCollection_GetView(py::wrapper::Windows::UI::Xaml::TriggerCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.TriggerCollection", L"GetView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TriggerCollection_IndexOf(py::wrapper::Windows::UI::Xaml::TriggerCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.TriggerCollection", L"IndexOf", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::TriggerBase>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TriggerCollection_InsertAt(py::wrapper::Windows::UI::Xaml::TriggerCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.TriggerCollection", L"InsertAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::TriggerBase>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TriggerCollection_RemoveAt(py::wrapper::Windows::UI::Xaml::TriggerCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.TriggerCollection", L"RemoveAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TriggerCollection_RemoveAtEnd(py::wrapper::Windows::UI::Xaml::TriggerCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.TriggerCollection", L"RemoveAtEnd", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TriggerCollection_ReplaceAll(py::wrapper::Windows::UI::Xaml::TriggerCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.TriggerCollection", L"ReplaceAll", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::TriggerBase, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TriggerCollection_SetAt(py::wrapper::Windows::UI::Xaml::TriggerCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.TriggerCollection", L"SetAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::TriggerBase>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TriggerCollection_get_Size(py::wrapper::Windows::UI::Xaml::TriggerCollection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.TriggerCollection", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TriggerCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::TriggerCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TriggerCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::TriggerCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_TriggerCollection(py::wrapper::Windows::UI::Xaml::TriggerCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_TriggerCollection(py::wrapper::Windows::UI::Xaml::TriggerCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_TriggerCollection(py::wrapper::Windows::UI::Xaml::TriggerCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_TriggerCollection(py::wrapper::Windows::UI::Xaml::TriggerCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_TriggerCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(
                    PyExc_TypeError,
                    "indicies must be integers, not '%s'",
                    Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(
                    slice, self->obj.Size(), &start, &stop, &step, &length)
                < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(
                    PyExc_NotImplementedError,
                    "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::UI::Xaml::TriggerBase> items(length, empty_instance<winrt::Windows::UI::Xaml::TriggerBase>::get());

            auto count = self->obj.GetMany(start, items);

            if (count != length)
            {
                PyErr_Format(
                    PyExc_RuntimeError,
                    "returned count %d did not match requested length %zd",
                    count,
                    length);
                return nullptr;
            }

            return convert(items);}
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_TriggerCollection(py::wrapper::Windows::UI::Xaml::TriggerCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (value == nullptr) { self->obj.RemoveAt(static_cast<uint32_t>(i)); }
            else { self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::UI::Xaml::TriggerBase>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_TriggerCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(TriggerCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(TriggerCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(TriggerCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(TriggerCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(TriggerCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(TriggerCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(TriggerCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(TriggerCollection_InsertAt), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(TriggerCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(TriggerCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(TriggerCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(TriggerCollection_SetAt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TriggerCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TriggerCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TriggerCollection[] = {
        { "size", reinterpret_cast<getter>(TriggerCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TriggerCollection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TriggerCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TriggerCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TriggerCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TriggerCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_TriggerCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_TriggerCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_TriggerCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_TriggerCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_TriggerCollection) },
        { },
    };

    static PyType_Spec type_spec_TriggerCollection =
    {
        "_winrt_Windows_UI_Xaml.TriggerCollection",
        sizeof(py::wrapper::Windows::UI::Xaml::TriggerCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TriggerCollection
    };

    // ----- UIElement class --------------------
    static constexpr const char* const type_name_UIElement = "UIElement";

    static PyObject* _new_UIElement(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_UIElement);
        return nullptr;
    }

    static void _dealloc_UIElement(py::wrapper::Windows::UI::Xaml::UIElement* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UIElement_AddHandler(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElement", L"AddHandler", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::RoutedEvent>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                self->obj.AddHandler(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UIElement_Arrange(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElement", L"Arrange", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);

                self->obj.Arrange(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UIElement_CancelDirectManipulations(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElement", L"CancelDirectManipulations", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CancelDirectManipulations());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UIElement_CapturePointer(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElement", L"CapturePointer", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::Pointer>(args, 0);

                return py::convert(self->obj.CapturePointer(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UIElement_FindSubElementsForTouchTargeting(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElement", L"FindSubElementsForTouchTargeting", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);

                return py::convert(self->obj.FindSubElementsForTouchTargeting(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UIElement_GetChildrenInTabFocusOrder(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElement", L"GetChildrenInTabFocusOrder", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetChildrenInTabFocusOrder());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UIElement_InvalidateArrange(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElement", L"InvalidateArrange", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.InvalidateArrange();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UIElement_InvalidateMeasure(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElement", L"InvalidateMeasure", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.InvalidateMeasure();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UIElement_Measure(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElement", L"Measure", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(args, 0);

                self->obj.Measure(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UIElement_OnBringIntoViewRequested(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElement", L"OnBringIntoViewRequested", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::BringIntoViewRequestedEventArgs>(args, 0);

                self->obj.OnBringIntoViewRequested(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UIElement_OnCreateAutomationPeer(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElement", L"OnCreateAutomationPeer", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.OnCreateAutomationPeer());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UIElement_OnDisconnectVisualChildren(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElement", L"OnDisconnectVisualChildren", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.OnDisconnectVisualChildren();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UIElement_OnKeyboardAcceleratorInvoked(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElement", L"OnKeyboardAcceleratorInvoked", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::KeyboardAcceleratorInvokedEventArgs>(args, 0);

                self->obj.OnKeyboardAcceleratorInvoked(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UIElement_OnProcessKeyboardAccelerators(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElement", L"OnProcessKeyboardAccelerators", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::ProcessKeyboardAcceleratorEventArgs>(args, 0);

                self->obj.OnProcessKeyboardAccelerators(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UIElement_PopulatePropertyInfo(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElement", L"PopulatePropertyInfo", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Composition::AnimationPropertyInfo>(args, 1);

                self->obj.PopulatePropertyInfo(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UIElement_PopulatePropertyInfoOverride(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElement", L"PopulatePropertyInfoOverride", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Composition::AnimationPropertyInfo>(args, 1);

                self->obj.PopulatePropertyInfoOverride(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UIElement_RegisterAsScrollPort(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElement", L"RegisterAsScrollPort", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 0);

                winrt::Windows::UI::Xaml::UIElement::RegisterAsScrollPort(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UIElement_ReleasePointerCapture(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElement", L"ReleasePointerCapture", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::Pointer>(args, 0);

                self->obj.ReleasePointerCapture(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UIElement_ReleasePointerCaptures(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElement", L"ReleasePointerCaptures", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.ReleasePointerCaptures();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UIElement_RemoveHandler(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElement", L"RemoveHandler", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::RoutedEvent>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.RemoveHandler(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UIElement_StartAnimation(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElement", L"StartAnimation", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Composition::ICompositionAnimationBase>(args, 0);

                self->obj.StartAnimation(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UIElement_StartBringIntoView(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElement", L"StartBringIntoView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.StartBringIntoView();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElement", L"StartBringIntoView", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::BringIntoViewOptions>(args, 0);

                self->obj.StartBringIntoView(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UIElement_StartDragAsync(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElement", L"StartDragAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::PointerPoint>(args, 0);

                return py::convert(self->obj.StartDragAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UIElement_StopAnimation(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElement", L"StopAnimation", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Composition::ICompositionAnimationBase>(args, 0);

                self->obj.StopAnimation(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UIElement_TransformToVisual(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElement", L"TransformToVisual", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 0);

                return py::convert(self->obj.TransformToVisual(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UIElement_TryInvokeKeyboardAccelerator(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElement", L"TryInvokeKeyboardAccelerator", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::ProcessKeyboardAcceleratorEventArgs>(args, 0);

                self->obj.TryInvokeKeyboardAccelerator(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UIElement_TryStartDirectManipulation(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElement", L"TryStartDirectManipulation", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::Pointer>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::UIElement::TryStartDirectManipulation(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UIElement_UpdateLayout(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElement", L"UpdateLayout", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.UpdateLayout();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UIElement_get_Transitions(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"Transitions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Transitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_Transitions(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"Transitions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::TransitionCollection>(arg);

            self->obj.Transitions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_Projection(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"Projection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Projection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_Projection(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"Projection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Projection>(arg);

            self->obj.Projection(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_RenderTransformOrigin(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"RenderTransformOrigin"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RenderTransformOrigin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_RenderTransformOrigin(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"RenderTransformOrigin"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.RenderTransformOrigin(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_Opacity(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"Opacity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Opacity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_Opacity(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"Opacity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Opacity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_ManipulationMode(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"ManipulationMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ManipulationMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_ManipulationMode(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"ManipulationMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::ManipulationModes>(arg);

            self->obj.ManipulationMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_IsTapEnabled(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"IsTapEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsTapEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_IsTapEnabled(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"IsTapEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsTapEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_IsRightTapEnabled(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"IsRightTapEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsRightTapEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_IsRightTapEnabled(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"IsRightTapEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsRightTapEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_IsHoldingEnabled(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"IsHoldingEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsHoldingEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_IsHoldingEnabled(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"IsHoldingEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsHoldingEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_IsHitTestVisible(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"IsHitTestVisible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsHitTestVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_IsHitTestVisible(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"IsHitTestVisible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsHitTestVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_IsDoubleTapEnabled(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"IsDoubleTapEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDoubleTapEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_IsDoubleTapEnabled(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"IsDoubleTapEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDoubleTapEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_AllowDrop(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"AllowDrop"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AllowDrop());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_AllowDrop(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"AllowDrop"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowDrop(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_Clip(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"Clip"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Clip());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_Clip(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"Clip"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::RectangleGeometry>(arg);

            self->obj.Clip(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_CacheMode(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"CacheMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CacheMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_CacheMode(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"CacheMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::CacheMode>(arg);

            self->obj.CacheMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_UseLayoutRounding(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"UseLayoutRounding"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UseLayoutRounding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_UseLayoutRounding(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"UseLayoutRounding"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.UseLayoutRounding(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_RenderTransform(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"RenderTransform"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RenderTransform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_RenderTransform(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"RenderTransform"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Transform>(arg);

            self->obj.RenderTransform(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_Visibility(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"Visibility"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Visibility());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_Visibility(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"Visibility"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Visibility>(arg);

            self->obj.Visibility(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_DesiredSize(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"DesiredSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DesiredSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_PointerCaptures(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"PointerCaptures"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PointerCaptures());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_RenderSize(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"RenderSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RenderSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_XamlRoot(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"XamlRoot"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.XamlRoot());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_XamlRoot(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"XamlRoot"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::XamlRoot>(arg);

            self->obj.XamlRoot(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_Shadow(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"Shadow"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Shadow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_Shadow(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"Shadow"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Shadow>(arg);

            self->obj.Shadow(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_ActualOffset(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"ActualOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActualOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_ActualSize(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"ActualSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActualSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_UIContext(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"UIContext"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UIContext());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_CompositeMode(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"CompositeMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CompositeMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_CompositeMode(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"CompositeMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::ElementCompositeMode>(arg);

            self->obj.CompositeMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_Transform3D(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"Transform3D"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Transform3D());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_Transform3D(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"Transform3D"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Media3D::Transform3D>(arg);

            self->obj.Transform3D(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_CanDrag(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"CanDrag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanDrag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_CanDrag(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"CanDrag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanDrag(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_IsAccessKeyScope(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"IsAccessKeyScope"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsAccessKeyScope());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_IsAccessKeyScope(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"IsAccessKeyScope"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsAccessKeyScope(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_ExitDisplayModeOnAccessKeyInvoked(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"ExitDisplayModeOnAccessKeyInvoked"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExitDisplayModeOnAccessKeyInvoked());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_ExitDisplayModeOnAccessKeyInvoked(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"ExitDisplayModeOnAccessKeyInvoked"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ExitDisplayModeOnAccessKeyInvoked(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_ContextFlyout(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"ContextFlyout"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContextFlyout());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_ContextFlyout(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"ContextFlyout"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>(arg);

            self->obj.ContextFlyout(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_AccessKeyScopeOwner(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"AccessKeyScopeOwner"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AccessKeyScopeOwner());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_AccessKeyScopeOwner(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"AccessKeyScopeOwner"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(arg);

            self->obj.AccessKeyScopeOwner(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_AccessKey(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"AccessKey"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AccessKey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_AccessKey(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"AccessKey"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.AccessKey(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_KeyTipHorizontalOffset(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"KeyTipHorizontalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyTipHorizontalOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_KeyTipHorizontalOffset(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"KeyTipHorizontalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.KeyTipHorizontalOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_HighContrastAdjustment(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"HighContrastAdjustment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HighContrastAdjustment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_HighContrastAdjustment(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"HighContrastAdjustment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::ElementHighContrastAdjustment>(arg);

            self->obj.HighContrastAdjustment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_XYFocusRightNavigationStrategy(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"XYFocusRightNavigationStrategy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.XYFocusRightNavigationStrategy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_XYFocusRightNavigationStrategy(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"XYFocusRightNavigationStrategy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::XYFocusNavigationStrategy>(arg);

            self->obj.XYFocusRightNavigationStrategy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_XYFocusKeyboardNavigation(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"XYFocusKeyboardNavigation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.XYFocusKeyboardNavigation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_XYFocusKeyboardNavigation(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"XYFocusKeyboardNavigation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::XYFocusKeyboardNavigationMode>(arg);

            self->obj.XYFocusKeyboardNavigation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_XYFocusDownNavigationStrategy(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"XYFocusDownNavigationStrategy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.XYFocusDownNavigationStrategy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_XYFocusDownNavigationStrategy(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"XYFocusDownNavigationStrategy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::XYFocusNavigationStrategy>(arg);

            self->obj.XYFocusDownNavigationStrategy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_TabFocusNavigation(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"TabFocusNavigation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TabFocusNavigation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_TabFocusNavigation(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"TabFocusNavigation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::KeyboardNavigationMode>(arg);

            self->obj.TabFocusNavigation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_KeyTipVerticalOffset(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"KeyTipVerticalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyTipVerticalOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_KeyTipVerticalOffset(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"KeyTipVerticalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.KeyTipVerticalOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_XYFocusUpNavigationStrategy(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"XYFocusUpNavigationStrategy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.XYFocusUpNavigationStrategy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_XYFocusUpNavigationStrategy(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"XYFocusUpNavigationStrategy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::XYFocusNavigationStrategy>(arg);

            self->obj.XYFocusUpNavigationStrategy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_KeyTipPlacementMode(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"KeyTipPlacementMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyTipPlacementMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_KeyTipPlacementMode(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"KeyTipPlacementMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::KeyTipPlacementMode>(arg);

            self->obj.KeyTipPlacementMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_XYFocusLeftNavigationStrategy(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"XYFocusLeftNavigationStrategy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.XYFocusLeftNavigationStrategy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_XYFocusLeftNavigationStrategy(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"XYFocusLeftNavigationStrategy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::XYFocusNavigationStrategy>(arg);

            self->obj.XYFocusLeftNavigationStrategy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_Lights(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"Lights"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Lights());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_KeyboardAccelerators(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"KeyboardAccelerators"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyboardAccelerators());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_KeyboardAcceleratorPlacementTarget(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"KeyboardAcceleratorPlacementTarget"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyboardAcceleratorPlacementTarget());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_KeyboardAcceleratorPlacementTarget(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"KeyboardAcceleratorPlacementTarget"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(arg);

            self->obj.KeyboardAcceleratorPlacementTarget(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_KeyboardAcceleratorPlacementMode(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"KeyboardAcceleratorPlacementMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyboardAcceleratorPlacementMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_KeyboardAcceleratorPlacementMode(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"KeyboardAcceleratorPlacementMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::KeyboardAcceleratorPlacementMode>(arg);

            self->obj.KeyboardAcceleratorPlacementMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_KeyTipTarget(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"KeyTipTarget"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyTipTarget());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_KeyTipTarget(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"KeyTipTarget"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(arg);

            self->obj.KeyTipTarget(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_TranslationTransition(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"TranslationTransition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TranslationTransition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_TranslationTransition(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"TranslationTransition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Vector3Transition>(arg);

            self->obj.TranslationTransition(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_OpacityTransition(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"OpacityTransition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OpacityTransition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_OpacityTransition(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"OpacityTransition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::ScalarTransition>(arg);

            self->obj.OpacityTransition(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_TransformMatrix(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"TransformMatrix"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TransformMatrix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_TransformMatrix(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"TransformMatrix"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float4x4>(arg);

            self->obj.TransformMatrix(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_ScaleTransition(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"ScaleTransition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ScaleTransition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_ScaleTransition(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"ScaleTransition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Vector3Transition>(arg);

            self->obj.ScaleTransition(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_Scale(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"Scale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Scale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_Scale(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"Scale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            self->obj.Scale(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_RotationTransition(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"RotationTransition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RotationTransition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_RotationTransition(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"RotationTransition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::ScalarTransition>(arg);

            self->obj.RotationTransition(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_RotationAxis(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"RotationAxis"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RotationAxis());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_RotationAxis(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"RotationAxis"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            self->obj.RotationAxis(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_Rotation(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"Rotation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Rotation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_Rotation(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"Rotation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.Rotation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_Translation(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"Translation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Translation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_Translation(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"Translation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            self->obj.Translation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_CenterPoint(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"CenterPoint"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CenterPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_CenterPoint(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"CenterPoint"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            self->obj.CenterPoint(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_CanBeScrollAnchor(py::wrapper::Windows::UI::Xaml::UIElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"CanBeScrollAnchor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanBeScrollAnchor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UIElement_put_CanBeScrollAnchor(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"CanBeScrollAnchor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanBeScrollAnchor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UIElement_get_HoldingEvent(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"HoldingEvent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::HoldingEvent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_IsDoubleTapEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"IsDoubleTapEnabledProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::IsDoubleTapEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_IsHitTestVisibleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"IsHitTestVisibleProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::IsHitTestVisibleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_IsHoldingEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"IsHoldingEnabledProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::IsHoldingEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_IsRightTapEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"IsRightTapEnabledProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::IsRightTapEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_KeyDownEvent(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"KeyDownEvent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::KeyDownEvent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_KeyUpEvent(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"KeyUpEvent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::KeyUpEvent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_ManipulationCompletedEvent(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"ManipulationCompletedEvent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::ManipulationCompletedEvent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_ManipulationDeltaEvent(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"ManipulationDeltaEvent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::ManipulationDeltaEvent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_IsTapEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"IsTapEnabledProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::IsTapEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_ManipulationInertiaStartingEvent(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"ManipulationInertiaStartingEvent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::ManipulationInertiaStartingEvent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_ManipulationModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"ManipulationModeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::ManipulationModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_ManipulationStartedEvent(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"ManipulationStartedEvent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::ManipulationStartedEvent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_ManipulationStartingEvent(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"ManipulationStartingEvent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::ManipulationStartingEvent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_OpacityProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"OpacityProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::OpacityProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_PointerCanceledEvent(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"PointerCanceledEvent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::PointerCanceledEvent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_PointerCaptureLostEvent(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"PointerCaptureLostEvent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::PointerCaptureLostEvent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_PointerCapturesProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"PointerCapturesProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::PointerCapturesProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_PointerEnteredEvent(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"PointerEnteredEvent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::PointerEnteredEvent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_PointerExitedEvent(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"PointerExitedEvent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::PointerExitedEvent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_PointerMovedEvent(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"PointerMovedEvent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::PointerMovedEvent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_PointerPressedEvent(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"PointerPressedEvent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::PointerPressedEvent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_PointerWheelChangedEvent(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"PointerWheelChangedEvent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::PointerWheelChangedEvent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_ProjectionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"ProjectionProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::ProjectionProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_RenderTransformOriginProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"RenderTransformOriginProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::RenderTransformOriginProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_RenderTransformProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"RenderTransformProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::RenderTransformProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_RightTappedEvent(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"RightTappedEvent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::RightTappedEvent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_DragEnterEvent(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"DragEnterEvent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::DragEnterEvent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_TappedEvent(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"TappedEvent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::TappedEvent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_TransitionsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"TransitionsProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::TransitionsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_UseLayoutRoundingProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"UseLayoutRoundingProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::UseLayoutRoundingProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_VisibilityProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"VisibilityProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::VisibilityProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_AllowDropProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"AllowDropProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::AllowDropProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_CacheModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"CacheModeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::CacheModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_ClipProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"ClipProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::ClipProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_DoubleTappedEvent(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"DoubleTappedEvent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::DoubleTappedEvent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_PointerReleasedEvent(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"PointerReleasedEvent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::PointerReleasedEvent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_DragLeaveEvent(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"DragLeaveEvent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::DragLeaveEvent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_DragOverEvent(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"DragOverEvent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::DragOverEvent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_DropEvent(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"DropEvent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::DropEvent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_ShadowProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"ShadowProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::ShadowProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_CompositeModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"CompositeModeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::CompositeModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_CanDragProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"CanDragProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::CanDragProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_Transform3DProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"Transform3DProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::Transform3DProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_AccessKeyProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"AccessKeyProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::AccessKeyProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_AccessKeyScopeOwnerProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"AccessKeyScopeOwnerProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::AccessKeyScopeOwnerProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_ContextFlyoutProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"ContextFlyoutProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::ContextFlyoutProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_IsAccessKeyScopeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"IsAccessKeyScopeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::IsAccessKeyScopeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_ExitDisplayModeOnAccessKeyInvokedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"ExitDisplayModeOnAccessKeyInvokedProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::ExitDisplayModeOnAccessKeyInvokedProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_HighContrastAdjustmentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"HighContrastAdjustmentProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::HighContrastAdjustmentProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_KeyTipHorizontalOffsetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"KeyTipHorizontalOffsetProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::KeyTipHorizontalOffsetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_KeyTipPlacementModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"KeyTipPlacementModeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::KeyTipPlacementModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_KeyTipVerticalOffsetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"KeyTipVerticalOffsetProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::KeyTipVerticalOffsetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_LightsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"LightsProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::LightsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_XYFocusDownNavigationStrategyProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"XYFocusDownNavigationStrategyProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::XYFocusDownNavigationStrategyProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_XYFocusKeyboardNavigationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"XYFocusKeyboardNavigationProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::XYFocusKeyboardNavigationProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_XYFocusLeftNavigationStrategyProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"XYFocusLeftNavigationStrategyProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::XYFocusLeftNavigationStrategyProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_XYFocusRightNavigationStrategyProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"XYFocusRightNavigationStrategyProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::XYFocusRightNavigationStrategyProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_XYFocusUpNavigationStrategyProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"XYFocusUpNavigationStrategyProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::XYFocusUpNavigationStrategyProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_TabFocusNavigationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"TabFocusNavigationProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::TabFocusNavigationProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_GettingFocusEvent(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"GettingFocusEvent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::GettingFocusEvent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_LosingFocusEvent(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"LosingFocusEvent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::LosingFocusEvent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_NoFocusCandidateFoundEvent(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"NoFocusCandidateFoundEvent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::NoFocusCandidateFoundEvent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_CharacterReceivedEvent(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"CharacterReceivedEvent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::CharacterReceivedEvent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_PreviewKeyDownEvent(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"PreviewKeyDownEvent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::PreviewKeyDownEvent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_PreviewKeyUpEvent(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"PreviewKeyUpEvent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::PreviewKeyUpEvent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_BringIntoViewRequestedEvent(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"BringIntoViewRequestedEvent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::BringIntoViewRequestedEvent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_ContextRequestedEvent(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"ContextRequestedEvent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::ContextRequestedEvent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_KeyTipTargetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"KeyTipTargetProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::KeyTipTargetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_KeyboardAcceleratorPlacementModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"KeyboardAcceleratorPlacementModeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::KeyboardAcceleratorPlacementModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_KeyboardAcceleratorPlacementTargetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"KeyboardAcceleratorPlacementTargetProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::KeyboardAcceleratorPlacementTargetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_get_CanBeScrollAnchorProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"CanBeScrollAnchorProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::UIElement::CanBeScrollAnchorProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_add_DoubleTapped(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"DoubleTapped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::DoubleTappedEventHandler>(arg);

            return py::convert(self->obj.DoubleTapped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_remove_DoubleTapped(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"DoubleTapped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DoubleTapped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_add_DragEnter(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"DragEnter"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DragEventHandler>(arg);

            return py::convert(self->obj.DragEnter(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_remove_DragEnter(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"DragEnter"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DragEnter(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_add_DragLeave(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"DragLeave"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DragEventHandler>(arg);

            return py::convert(self->obj.DragLeave(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_remove_DragLeave(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"DragLeave"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DragLeave(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_add_DragOver(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"DragOver"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DragEventHandler>(arg);

            return py::convert(self->obj.DragOver(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_remove_DragOver(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"DragOver"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DragOver(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_add_Drop(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"Drop"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DragEventHandler>(arg);

            return py::convert(self->obj.Drop(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_remove_Drop(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"Drop"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Drop(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_add_GotFocus(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"GotFocus"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::RoutedEventHandler>(arg);

            return py::convert(self->obj.GotFocus(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_remove_GotFocus(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"GotFocus"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.GotFocus(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_add_Holding(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"Holding"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::HoldingEventHandler>(arg);

            return py::convert(self->obj.Holding(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_remove_Holding(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"Holding"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Holding(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_add_KeyDown(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"KeyDown"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::KeyEventHandler>(arg);

            return py::convert(self->obj.KeyDown(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_remove_KeyDown(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"KeyDown"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.KeyDown(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_add_KeyUp(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"KeyUp"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::KeyEventHandler>(arg);

            return py::convert(self->obj.KeyUp(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_remove_KeyUp(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"KeyUp"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.KeyUp(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_add_LostFocus(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"LostFocus"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::RoutedEventHandler>(arg);

            return py::convert(self->obj.LostFocus(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_remove_LostFocus(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"LostFocus"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LostFocus(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_add_ManipulationCompleted(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"ManipulationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::ManipulationCompletedEventHandler>(arg);

            return py::convert(self->obj.ManipulationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_remove_ManipulationCompleted(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"ManipulationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ManipulationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_add_ManipulationDelta(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"ManipulationDelta"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::ManipulationDeltaEventHandler>(arg);

            return py::convert(self->obj.ManipulationDelta(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_remove_ManipulationDelta(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"ManipulationDelta"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ManipulationDelta(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_add_ManipulationInertiaStarting(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"ManipulationInertiaStarting"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::ManipulationInertiaStartingEventHandler>(arg);

            return py::convert(self->obj.ManipulationInertiaStarting(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_remove_ManipulationInertiaStarting(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"ManipulationInertiaStarting"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ManipulationInertiaStarting(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_add_ManipulationStarted(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"ManipulationStarted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::ManipulationStartedEventHandler>(arg);

            return py::convert(self->obj.ManipulationStarted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_remove_ManipulationStarted(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"ManipulationStarted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ManipulationStarted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_add_ManipulationStarting(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"ManipulationStarting"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::ManipulationStartingEventHandler>(arg);

            return py::convert(self->obj.ManipulationStarting(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_remove_ManipulationStarting(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"ManipulationStarting"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ManipulationStarting(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_add_PointerCanceled(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"PointerCanceled"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::PointerEventHandler>(arg);

            return py::convert(self->obj.PointerCanceled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_remove_PointerCanceled(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"PointerCanceled"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerCanceled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_add_PointerCaptureLost(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"PointerCaptureLost"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::PointerEventHandler>(arg);

            return py::convert(self->obj.PointerCaptureLost(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_remove_PointerCaptureLost(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"PointerCaptureLost"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerCaptureLost(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_add_PointerEntered(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"PointerEntered"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::PointerEventHandler>(arg);

            return py::convert(self->obj.PointerEntered(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_remove_PointerEntered(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"PointerEntered"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerEntered(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_add_PointerExited(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"PointerExited"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::PointerEventHandler>(arg);

            return py::convert(self->obj.PointerExited(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_remove_PointerExited(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"PointerExited"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerExited(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_add_PointerMoved(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"PointerMoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::PointerEventHandler>(arg);

            return py::convert(self->obj.PointerMoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_remove_PointerMoved(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"PointerMoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerMoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_add_PointerPressed(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"PointerPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::PointerEventHandler>(arg);

            return py::convert(self->obj.PointerPressed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_remove_PointerPressed(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"PointerPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerPressed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_add_PointerReleased(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"PointerReleased"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::PointerEventHandler>(arg);

            return py::convert(self->obj.PointerReleased(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_remove_PointerReleased(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"PointerReleased"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerReleased(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_add_PointerWheelChanged(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"PointerWheelChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::PointerEventHandler>(arg);

            return py::convert(self->obj.PointerWheelChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_remove_PointerWheelChanged(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"PointerWheelChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerWheelChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_add_RightTapped(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"RightTapped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::RightTappedEventHandler>(arg);

            return py::convert(self->obj.RightTapped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_remove_RightTapped(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"RightTapped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.RightTapped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_add_Tapped(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"Tapped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::TappedEventHandler>(arg);

            return py::convert(self->obj.Tapped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_remove_Tapped(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"Tapped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Tapped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_add_DragStarting(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"DragStarting"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::DragStartingEventArgs>>(arg);

            return py::convert(self->obj.DragStarting(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_remove_DragStarting(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"DragStarting"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DragStarting(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_add_DropCompleted(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"DropCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::DropCompletedEventArgs>>(arg);

            return py::convert(self->obj.DropCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_remove_DropCompleted(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"DropCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DropCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_add_AccessKeyDisplayDismissed(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"AccessKeyDisplayDismissed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::Input::AccessKeyDisplayDismissedEventArgs>>(arg);

            return py::convert(self->obj.AccessKeyDisplayDismissed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_remove_AccessKeyDisplayDismissed(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"AccessKeyDisplayDismissed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AccessKeyDisplayDismissed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_add_AccessKeyDisplayRequested(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"AccessKeyDisplayRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::Input::AccessKeyDisplayRequestedEventArgs>>(arg);

            return py::convert(self->obj.AccessKeyDisplayRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_remove_AccessKeyDisplayRequested(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"AccessKeyDisplayRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AccessKeyDisplayRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_add_AccessKeyInvoked(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"AccessKeyInvoked"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::Input::AccessKeyInvokedEventArgs>>(arg);

            return py::convert(self->obj.AccessKeyInvoked(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_remove_AccessKeyInvoked(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"AccessKeyInvoked"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AccessKeyInvoked(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_add_ContextCanceled(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"ContextCanceled"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::RoutedEventArgs>>(arg);

            return py::convert(self->obj.ContextCanceled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_remove_ContextCanceled(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"ContextCanceled"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ContextCanceled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_add_ContextRequested(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"ContextRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::Input::ContextRequestedEventArgs>>(arg);

            return py::convert(self->obj.ContextRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_remove_ContextRequested(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"ContextRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ContextRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_add_GettingFocus(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"GettingFocus"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::Input::GettingFocusEventArgs>>(arg);

            return py::convert(self->obj.GettingFocus(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_remove_GettingFocus(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"GettingFocus"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.GettingFocus(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_add_LosingFocus(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"LosingFocus"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::Input::LosingFocusEventArgs>>(arg);

            return py::convert(self->obj.LosingFocus(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_remove_LosingFocus(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"LosingFocus"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LosingFocus(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_add_NoFocusCandidateFound(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"NoFocusCandidateFound"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::Input::NoFocusCandidateFoundEventArgs>>(arg);

            return py::convert(self->obj.NoFocusCandidateFound(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_remove_NoFocusCandidateFound(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"NoFocusCandidateFound"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.NoFocusCandidateFound(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_add_CharacterReceived(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"CharacterReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::Input::CharacterReceivedRoutedEventArgs>>(arg);

            return py::convert(self->obj.CharacterReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_remove_CharacterReceived(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"CharacterReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CharacterReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_add_PreviewKeyDown(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"PreviewKeyDown"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::KeyEventHandler>(arg);

            return py::convert(self->obj.PreviewKeyDown(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_remove_PreviewKeyDown(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"PreviewKeyDown"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PreviewKeyDown(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_add_PreviewKeyUp(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"PreviewKeyUp"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::KeyEventHandler>(arg);

            return py::convert(self->obj.PreviewKeyUp(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_remove_PreviewKeyUp(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"PreviewKeyUp"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PreviewKeyUp(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_add_ProcessKeyboardAccelerators(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"ProcessKeyboardAccelerators"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::Input::ProcessKeyboardAcceleratorEventArgs>>(arg);

            return py::convert(self->obj.ProcessKeyboardAccelerators(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_remove_ProcessKeyboardAccelerators(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"ProcessKeyboardAccelerators"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ProcessKeyboardAccelerators(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_add_BringIntoViewRequested(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"BringIntoViewRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::BringIntoViewRequestedEventArgs>>(arg);

            return py::convert(self->obj.BringIntoViewRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UIElement_remove_BringIntoViewRequested(py::wrapper::Windows::UI::Xaml::UIElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"BringIntoViewRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BringIntoViewRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UIElement(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::UIElement>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UIElement(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::UIElement>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UIElement[] = {
        { "add_handler", reinterpret_cast<PyCFunction>(UIElement_AddHandler), METH_VARARGS, nullptr },
        { "arrange", reinterpret_cast<PyCFunction>(UIElement_Arrange), METH_VARARGS, nullptr },
        { "cancel_direct_manipulations", reinterpret_cast<PyCFunction>(UIElement_CancelDirectManipulations), METH_VARARGS, nullptr },
        { "capture_pointer", reinterpret_cast<PyCFunction>(UIElement_CapturePointer), METH_VARARGS, nullptr },
        { "find_sub_elements_for_touch_targeting", reinterpret_cast<PyCFunction>(UIElement_FindSubElementsForTouchTargeting), METH_VARARGS, nullptr },
        { "get_children_in_tab_focus_order", reinterpret_cast<PyCFunction>(UIElement_GetChildrenInTabFocusOrder), METH_VARARGS, nullptr },
        { "invalidate_arrange", reinterpret_cast<PyCFunction>(UIElement_InvalidateArrange), METH_VARARGS, nullptr },
        { "invalidate_measure", reinterpret_cast<PyCFunction>(UIElement_InvalidateMeasure), METH_VARARGS, nullptr },
        { "measure", reinterpret_cast<PyCFunction>(UIElement_Measure), METH_VARARGS, nullptr },
        { "on_bring_into_view_requested", reinterpret_cast<PyCFunction>(UIElement_OnBringIntoViewRequested), METH_VARARGS, nullptr },
        { "on_create_automation_peer", reinterpret_cast<PyCFunction>(UIElement_OnCreateAutomationPeer), METH_VARARGS, nullptr },
        { "on_disconnect_visual_children", reinterpret_cast<PyCFunction>(UIElement_OnDisconnectVisualChildren), METH_VARARGS, nullptr },
        { "on_keyboard_accelerator_invoked", reinterpret_cast<PyCFunction>(UIElement_OnKeyboardAcceleratorInvoked), METH_VARARGS, nullptr },
        { "on_process_keyboard_accelerators", reinterpret_cast<PyCFunction>(UIElement_OnProcessKeyboardAccelerators), METH_VARARGS, nullptr },
        { "populate_property_info", reinterpret_cast<PyCFunction>(UIElement_PopulatePropertyInfo), METH_VARARGS, nullptr },
        { "populate_property_info_override", reinterpret_cast<PyCFunction>(UIElement_PopulatePropertyInfoOverride), METH_VARARGS, nullptr },
        { "register_as_scroll_port", reinterpret_cast<PyCFunction>(UIElement_RegisterAsScrollPort), METH_VARARGS | METH_STATIC, nullptr },
        { "release_pointer_capture", reinterpret_cast<PyCFunction>(UIElement_ReleasePointerCapture), METH_VARARGS, nullptr },
        { "release_pointer_captures", reinterpret_cast<PyCFunction>(UIElement_ReleasePointerCaptures), METH_VARARGS, nullptr },
        { "remove_handler", reinterpret_cast<PyCFunction>(UIElement_RemoveHandler), METH_VARARGS, nullptr },
        { "start_animation", reinterpret_cast<PyCFunction>(UIElement_StartAnimation), METH_VARARGS, nullptr },
        { "start_bring_into_view", reinterpret_cast<PyCFunction>(UIElement_StartBringIntoView), METH_VARARGS, nullptr },
        { "start_drag_async", reinterpret_cast<PyCFunction>(UIElement_StartDragAsync), METH_VARARGS, nullptr },
        { "stop_animation", reinterpret_cast<PyCFunction>(UIElement_StopAnimation), METH_VARARGS, nullptr },
        { "transform_to_visual", reinterpret_cast<PyCFunction>(UIElement_TransformToVisual), METH_VARARGS, nullptr },
        { "try_invoke_keyboard_accelerator", reinterpret_cast<PyCFunction>(UIElement_TryInvokeKeyboardAccelerator), METH_VARARGS, nullptr },
        { "try_start_direct_manipulation", reinterpret_cast<PyCFunction>(UIElement_TryStartDirectManipulation), METH_VARARGS | METH_STATIC, nullptr },
        { "update_layout", reinterpret_cast<PyCFunction>(UIElement_UpdateLayout), METH_VARARGS, nullptr },
        { "add_double_tapped", reinterpret_cast<PyCFunction>(UIElement_add_DoubleTapped), METH_O, nullptr },
        { "remove_double_tapped", reinterpret_cast<PyCFunction>(UIElement_remove_DoubleTapped), METH_O, nullptr },
        { "add_drag_enter", reinterpret_cast<PyCFunction>(UIElement_add_DragEnter), METH_O, nullptr },
        { "remove_drag_enter", reinterpret_cast<PyCFunction>(UIElement_remove_DragEnter), METH_O, nullptr },
        { "add_drag_leave", reinterpret_cast<PyCFunction>(UIElement_add_DragLeave), METH_O, nullptr },
        { "remove_drag_leave", reinterpret_cast<PyCFunction>(UIElement_remove_DragLeave), METH_O, nullptr },
        { "add_drag_over", reinterpret_cast<PyCFunction>(UIElement_add_DragOver), METH_O, nullptr },
        { "remove_drag_over", reinterpret_cast<PyCFunction>(UIElement_remove_DragOver), METH_O, nullptr },
        { "add_drop", reinterpret_cast<PyCFunction>(UIElement_add_Drop), METH_O, nullptr },
        { "remove_drop", reinterpret_cast<PyCFunction>(UIElement_remove_Drop), METH_O, nullptr },
        { "add_got_focus", reinterpret_cast<PyCFunction>(UIElement_add_GotFocus), METH_O, nullptr },
        { "remove_got_focus", reinterpret_cast<PyCFunction>(UIElement_remove_GotFocus), METH_O, nullptr },
        { "add_holding", reinterpret_cast<PyCFunction>(UIElement_add_Holding), METH_O, nullptr },
        { "remove_holding", reinterpret_cast<PyCFunction>(UIElement_remove_Holding), METH_O, nullptr },
        { "add_key_down", reinterpret_cast<PyCFunction>(UIElement_add_KeyDown), METH_O, nullptr },
        { "remove_key_down", reinterpret_cast<PyCFunction>(UIElement_remove_KeyDown), METH_O, nullptr },
        { "add_key_up", reinterpret_cast<PyCFunction>(UIElement_add_KeyUp), METH_O, nullptr },
        { "remove_key_up", reinterpret_cast<PyCFunction>(UIElement_remove_KeyUp), METH_O, nullptr },
        { "add_lost_focus", reinterpret_cast<PyCFunction>(UIElement_add_LostFocus), METH_O, nullptr },
        { "remove_lost_focus", reinterpret_cast<PyCFunction>(UIElement_remove_LostFocus), METH_O, nullptr },
        { "add_manipulation_completed", reinterpret_cast<PyCFunction>(UIElement_add_ManipulationCompleted), METH_O, nullptr },
        { "remove_manipulation_completed", reinterpret_cast<PyCFunction>(UIElement_remove_ManipulationCompleted), METH_O, nullptr },
        { "add_manipulation_delta", reinterpret_cast<PyCFunction>(UIElement_add_ManipulationDelta), METH_O, nullptr },
        { "remove_manipulation_delta", reinterpret_cast<PyCFunction>(UIElement_remove_ManipulationDelta), METH_O, nullptr },
        { "add_manipulation_inertia_starting", reinterpret_cast<PyCFunction>(UIElement_add_ManipulationInertiaStarting), METH_O, nullptr },
        { "remove_manipulation_inertia_starting", reinterpret_cast<PyCFunction>(UIElement_remove_ManipulationInertiaStarting), METH_O, nullptr },
        { "add_manipulation_started", reinterpret_cast<PyCFunction>(UIElement_add_ManipulationStarted), METH_O, nullptr },
        { "remove_manipulation_started", reinterpret_cast<PyCFunction>(UIElement_remove_ManipulationStarted), METH_O, nullptr },
        { "add_manipulation_starting", reinterpret_cast<PyCFunction>(UIElement_add_ManipulationStarting), METH_O, nullptr },
        { "remove_manipulation_starting", reinterpret_cast<PyCFunction>(UIElement_remove_ManipulationStarting), METH_O, nullptr },
        { "add_pointer_canceled", reinterpret_cast<PyCFunction>(UIElement_add_PointerCanceled), METH_O, nullptr },
        { "remove_pointer_canceled", reinterpret_cast<PyCFunction>(UIElement_remove_PointerCanceled), METH_O, nullptr },
        { "add_pointer_capture_lost", reinterpret_cast<PyCFunction>(UIElement_add_PointerCaptureLost), METH_O, nullptr },
        { "remove_pointer_capture_lost", reinterpret_cast<PyCFunction>(UIElement_remove_PointerCaptureLost), METH_O, nullptr },
        { "add_pointer_entered", reinterpret_cast<PyCFunction>(UIElement_add_PointerEntered), METH_O, nullptr },
        { "remove_pointer_entered", reinterpret_cast<PyCFunction>(UIElement_remove_PointerEntered), METH_O, nullptr },
        { "add_pointer_exited", reinterpret_cast<PyCFunction>(UIElement_add_PointerExited), METH_O, nullptr },
        { "remove_pointer_exited", reinterpret_cast<PyCFunction>(UIElement_remove_PointerExited), METH_O, nullptr },
        { "add_pointer_moved", reinterpret_cast<PyCFunction>(UIElement_add_PointerMoved), METH_O, nullptr },
        { "remove_pointer_moved", reinterpret_cast<PyCFunction>(UIElement_remove_PointerMoved), METH_O, nullptr },
        { "add_pointer_pressed", reinterpret_cast<PyCFunction>(UIElement_add_PointerPressed), METH_O, nullptr },
        { "remove_pointer_pressed", reinterpret_cast<PyCFunction>(UIElement_remove_PointerPressed), METH_O, nullptr },
        { "add_pointer_released", reinterpret_cast<PyCFunction>(UIElement_add_PointerReleased), METH_O, nullptr },
        { "remove_pointer_released", reinterpret_cast<PyCFunction>(UIElement_remove_PointerReleased), METH_O, nullptr },
        { "add_pointer_wheel_changed", reinterpret_cast<PyCFunction>(UIElement_add_PointerWheelChanged), METH_O, nullptr },
        { "remove_pointer_wheel_changed", reinterpret_cast<PyCFunction>(UIElement_remove_PointerWheelChanged), METH_O, nullptr },
        { "add_right_tapped", reinterpret_cast<PyCFunction>(UIElement_add_RightTapped), METH_O, nullptr },
        { "remove_right_tapped", reinterpret_cast<PyCFunction>(UIElement_remove_RightTapped), METH_O, nullptr },
        { "add_tapped", reinterpret_cast<PyCFunction>(UIElement_add_Tapped), METH_O, nullptr },
        { "remove_tapped", reinterpret_cast<PyCFunction>(UIElement_remove_Tapped), METH_O, nullptr },
        { "add_drag_starting", reinterpret_cast<PyCFunction>(UIElement_add_DragStarting), METH_O, nullptr },
        { "remove_drag_starting", reinterpret_cast<PyCFunction>(UIElement_remove_DragStarting), METH_O, nullptr },
        { "add_drop_completed", reinterpret_cast<PyCFunction>(UIElement_add_DropCompleted), METH_O, nullptr },
        { "remove_drop_completed", reinterpret_cast<PyCFunction>(UIElement_remove_DropCompleted), METH_O, nullptr },
        { "add_access_key_display_dismissed", reinterpret_cast<PyCFunction>(UIElement_add_AccessKeyDisplayDismissed), METH_O, nullptr },
        { "remove_access_key_display_dismissed", reinterpret_cast<PyCFunction>(UIElement_remove_AccessKeyDisplayDismissed), METH_O, nullptr },
        { "add_access_key_display_requested", reinterpret_cast<PyCFunction>(UIElement_add_AccessKeyDisplayRequested), METH_O, nullptr },
        { "remove_access_key_display_requested", reinterpret_cast<PyCFunction>(UIElement_remove_AccessKeyDisplayRequested), METH_O, nullptr },
        { "add_access_key_invoked", reinterpret_cast<PyCFunction>(UIElement_add_AccessKeyInvoked), METH_O, nullptr },
        { "remove_access_key_invoked", reinterpret_cast<PyCFunction>(UIElement_remove_AccessKeyInvoked), METH_O, nullptr },
        { "add_context_canceled", reinterpret_cast<PyCFunction>(UIElement_add_ContextCanceled), METH_O, nullptr },
        { "remove_context_canceled", reinterpret_cast<PyCFunction>(UIElement_remove_ContextCanceled), METH_O, nullptr },
        { "add_context_requested", reinterpret_cast<PyCFunction>(UIElement_add_ContextRequested), METH_O, nullptr },
        { "remove_context_requested", reinterpret_cast<PyCFunction>(UIElement_remove_ContextRequested), METH_O, nullptr },
        { "add_getting_focus", reinterpret_cast<PyCFunction>(UIElement_add_GettingFocus), METH_O, nullptr },
        { "remove_getting_focus", reinterpret_cast<PyCFunction>(UIElement_remove_GettingFocus), METH_O, nullptr },
        { "add_losing_focus", reinterpret_cast<PyCFunction>(UIElement_add_LosingFocus), METH_O, nullptr },
        { "remove_losing_focus", reinterpret_cast<PyCFunction>(UIElement_remove_LosingFocus), METH_O, nullptr },
        { "add_no_focus_candidate_found", reinterpret_cast<PyCFunction>(UIElement_add_NoFocusCandidateFound), METH_O, nullptr },
        { "remove_no_focus_candidate_found", reinterpret_cast<PyCFunction>(UIElement_remove_NoFocusCandidateFound), METH_O, nullptr },
        { "add_character_received", reinterpret_cast<PyCFunction>(UIElement_add_CharacterReceived), METH_O, nullptr },
        { "remove_character_received", reinterpret_cast<PyCFunction>(UIElement_remove_CharacterReceived), METH_O, nullptr },
        { "add_preview_key_down", reinterpret_cast<PyCFunction>(UIElement_add_PreviewKeyDown), METH_O, nullptr },
        { "remove_preview_key_down", reinterpret_cast<PyCFunction>(UIElement_remove_PreviewKeyDown), METH_O, nullptr },
        { "add_preview_key_up", reinterpret_cast<PyCFunction>(UIElement_add_PreviewKeyUp), METH_O, nullptr },
        { "remove_preview_key_up", reinterpret_cast<PyCFunction>(UIElement_remove_PreviewKeyUp), METH_O, nullptr },
        { "add_process_keyboard_accelerators", reinterpret_cast<PyCFunction>(UIElement_add_ProcessKeyboardAccelerators), METH_O, nullptr },
        { "remove_process_keyboard_accelerators", reinterpret_cast<PyCFunction>(UIElement_remove_ProcessKeyboardAccelerators), METH_O, nullptr },
        { "add_bring_into_view_requested", reinterpret_cast<PyCFunction>(UIElement_add_BringIntoViewRequested), METH_O, nullptr },
        { "remove_bring_into_view_requested", reinterpret_cast<PyCFunction>(UIElement_remove_BringIntoViewRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_UIElement, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UIElement), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UIElement[] = {
        { "transitions", reinterpret_cast<getter>(UIElement_get_Transitions), reinterpret_cast<setter>(UIElement_put_Transitions), nullptr, nullptr },
        { "projection", reinterpret_cast<getter>(UIElement_get_Projection), reinterpret_cast<setter>(UIElement_put_Projection), nullptr, nullptr },
        { "render_transform_origin", reinterpret_cast<getter>(UIElement_get_RenderTransformOrigin), reinterpret_cast<setter>(UIElement_put_RenderTransformOrigin), nullptr, nullptr },
        { "opacity", reinterpret_cast<getter>(UIElement_get_Opacity), reinterpret_cast<setter>(UIElement_put_Opacity), nullptr, nullptr },
        { "manipulation_mode", reinterpret_cast<getter>(UIElement_get_ManipulationMode), reinterpret_cast<setter>(UIElement_put_ManipulationMode), nullptr, nullptr },
        { "is_tap_enabled", reinterpret_cast<getter>(UIElement_get_IsTapEnabled), reinterpret_cast<setter>(UIElement_put_IsTapEnabled), nullptr, nullptr },
        { "is_right_tap_enabled", reinterpret_cast<getter>(UIElement_get_IsRightTapEnabled), reinterpret_cast<setter>(UIElement_put_IsRightTapEnabled), nullptr, nullptr },
        { "is_holding_enabled", reinterpret_cast<getter>(UIElement_get_IsHoldingEnabled), reinterpret_cast<setter>(UIElement_put_IsHoldingEnabled), nullptr, nullptr },
        { "is_hit_test_visible", reinterpret_cast<getter>(UIElement_get_IsHitTestVisible), reinterpret_cast<setter>(UIElement_put_IsHitTestVisible), nullptr, nullptr },
        { "is_double_tap_enabled", reinterpret_cast<getter>(UIElement_get_IsDoubleTapEnabled), reinterpret_cast<setter>(UIElement_put_IsDoubleTapEnabled), nullptr, nullptr },
        { "allow_drop", reinterpret_cast<getter>(UIElement_get_AllowDrop), reinterpret_cast<setter>(UIElement_put_AllowDrop), nullptr, nullptr },
        { "clip", reinterpret_cast<getter>(UIElement_get_Clip), reinterpret_cast<setter>(UIElement_put_Clip), nullptr, nullptr },
        { "cache_mode", reinterpret_cast<getter>(UIElement_get_CacheMode), reinterpret_cast<setter>(UIElement_put_CacheMode), nullptr, nullptr },
        { "use_layout_rounding", reinterpret_cast<getter>(UIElement_get_UseLayoutRounding), reinterpret_cast<setter>(UIElement_put_UseLayoutRounding), nullptr, nullptr },
        { "render_transform", reinterpret_cast<getter>(UIElement_get_RenderTransform), reinterpret_cast<setter>(UIElement_put_RenderTransform), nullptr, nullptr },
        { "visibility", reinterpret_cast<getter>(UIElement_get_Visibility), reinterpret_cast<setter>(UIElement_put_Visibility), nullptr, nullptr },
        { "desired_size", reinterpret_cast<getter>(UIElement_get_DesiredSize), nullptr, nullptr, nullptr },
        { "pointer_captures", reinterpret_cast<getter>(UIElement_get_PointerCaptures), nullptr, nullptr, nullptr },
        { "render_size", reinterpret_cast<getter>(UIElement_get_RenderSize), nullptr, nullptr, nullptr },
        { "xaml_root", reinterpret_cast<getter>(UIElement_get_XamlRoot), reinterpret_cast<setter>(UIElement_put_XamlRoot), nullptr, nullptr },
        { "shadow", reinterpret_cast<getter>(UIElement_get_Shadow), reinterpret_cast<setter>(UIElement_put_Shadow), nullptr, nullptr },
        { "actual_offset", reinterpret_cast<getter>(UIElement_get_ActualOffset), nullptr, nullptr, nullptr },
        { "actual_size", reinterpret_cast<getter>(UIElement_get_ActualSize), nullptr, nullptr, nullptr },
        { "u_i_context", reinterpret_cast<getter>(UIElement_get_UIContext), nullptr, nullptr, nullptr },
        { "composite_mode", reinterpret_cast<getter>(UIElement_get_CompositeMode), reinterpret_cast<setter>(UIElement_put_CompositeMode), nullptr, nullptr },
        { "transform3_d", reinterpret_cast<getter>(UIElement_get_Transform3D), reinterpret_cast<setter>(UIElement_put_Transform3D), nullptr, nullptr },
        { "can_drag", reinterpret_cast<getter>(UIElement_get_CanDrag), reinterpret_cast<setter>(UIElement_put_CanDrag), nullptr, nullptr },
        { "is_access_key_scope", reinterpret_cast<getter>(UIElement_get_IsAccessKeyScope), reinterpret_cast<setter>(UIElement_put_IsAccessKeyScope), nullptr, nullptr },
        { "exit_display_mode_on_access_key_invoked", reinterpret_cast<getter>(UIElement_get_ExitDisplayModeOnAccessKeyInvoked), reinterpret_cast<setter>(UIElement_put_ExitDisplayModeOnAccessKeyInvoked), nullptr, nullptr },
        { "context_flyout", reinterpret_cast<getter>(UIElement_get_ContextFlyout), reinterpret_cast<setter>(UIElement_put_ContextFlyout), nullptr, nullptr },
        { "access_key_scope_owner", reinterpret_cast<getter>(UIElement_get_AccessKeyScopeOwner), reinterpret_cast<setter>(UIElement_put_AccessKeyScopeOwner), nullptr, nullptr },
        { "access_key", reinterpret_cast<getter>(UIElement_get_AccessKey), reinterpret_cast<setter>(UIElement_put_AccessKey), nullptr, nullptr },
        { "key_tip_horizontal_offset", reinterpret_cast<getter>(UIElement_get_KeyTipHorizontalOffset), reinterpret_cast<setter>(UIElement_put_KeyTipHorizontalOffset), nullptr, nullptr },
        { "high_contrast_adjustment", reinterpret_cast<getter>(UIElement_get_HighContrastAdjustment), reinterpret_cast<setter>(UIElement_put_HighContrastAdjustment), nullptr, nullptr },
        { "x_y_focus_right_navigation_strategy", reinterpret_cast<getter>(UIElement_get_XYFocusRightNavigationStrategy), reinterpret_cast<setter>(UIElement_put_XYFocusRightNavigationStrategy), nullptr, nullptr },
        { "x_y_focus_keyboard_navigation", reinterpret_cast<getter>(UIElement_get_XYFocusKeyboardNavigation), reinterpret_cast<setter>(UIElement_put_XYFocusKeyboardNavigation), nullptr, nullptr },
        { "x_y_focus_down_navigation_strategy", reinterpret_cast<getter>(UIElement_get_XYFocusDownNavigationStrategy), reinterpret_cast<setter>(UIElement_put_XYFocusDownNavigationStrategy), nullptr, nullptr },
        { "tab_focus_navigation", reinterpret_cast<getter>(UIElement_get_TabFocusNavigation), reinterpret_cast<setter>(UIElement_put_TabFocusNavigation), nullptr, nullptr },
        { "key_tip_vertical_offset", reinterpret_cast<getter>(UIElement_get_KeyTipVerticalOffset), reinterpret_cast<setter>(UIElement_put_KeyTipVerticalOffset), nullptr, nullptr },
        { "x_y_focus_up_navigation_strategy", reinterpret_cast<getter>(UIElement_get_XYFocusUpNavigationStrategy), reinterpret_cast<setter>(UIElement_put_XYFocusUpNavigationStrategy), nullptr, nullptr },
        { "key_tip_placement_mode", reinterpret_cast<getter>(UIElement_get_KeyTipPlacementMode), reinterpret_cast<setter>(UIElement_put_KeyTipPlacementMode), nullptr, nullptr },
        { "x_y_focus_left_navigation_strategy", reinterpret_cast<getter>(UIElement_get_XYFocusLeftNavigationStrategy), reinterpret_cast<setter>(UIElement_put_XYFocusLeftNavigationStrategy), nullptr, nullptr },
        { "lights", reinterpret_cast<getter>(UIElement_get_Lights), nullptr, nullptr, nullptr },
        { "keyboard_accelerators", reinterpret_cast<getter>(UIElement_get_KeyboardAccelerators), nullptr, nullptr, nullptr },
        { "keyboard_accelerator_placement_target", reinterpret_cast<getter>(UIElement_get_KeyboardAcceleratorPlacementTarget), reinterpret_cast<setter>(UIElement_put_KeyboardAcceleratorPlacementTarget), nullptr, nullptr },
        { "keyboard_accelerator_placement_mode", reinterpret_cast<getter>(UIElement_get_KeyboardAcceleratorPlacementMode), reinterpret_cast<setter>(UIElement_put_KeyboardAcceleratorPlacementMode), nullptr, nullptr },
        { "key_tip_target", reinterpret_cast<getter>(UIElement_get_KeyTipTarget), reinterpret_cast<setter>(UIElement_put_KeyTipTarget), nullptr, nullptr },
        { "translation_transition", reinterpret_cast<getter>(UIElement_get_TranslationTransition), reinterpret_cast<setter>(UIElement_put_TranslationTransition), nullptr, nullptr },
        { "opacity_transition", reinterpret_cast<getter>(UIElement_get_OpacityTransition), reinterpret_cast<setter>(UIElement_put_OpacityTransition), nullptr, nullptr },
        { "transform_matrix", reinterpret_cast<getter>(UIElement_get_TransformMatrix), reinterpret_cast<setter>(UIElement_put_TransformMatrix), nullptr, nullptr },
        { "scale_transition", reinterpret_cast<getter>(UIElement_get_ScaleTransition), reinterpret_cast<setter>(UIElement_put_ScaleTransition), nullptr, nullptr },
        { "scale", reinterpret_cast<getter>(UIElement_get_Scale), reinterpret_cast<setter>(UIElement_put_Scale), nullptr, nullptr },
        { "rotation_transition", reinterpret_cast<getter>(UIElement_get_RotationTransition), reinterpret_cast<setter>(UIElement_put_RotationTransition), nullptr, nullptr },
        { "rotation_axis", reinterpret_cast<getter>(UIElement_get_RotationAxis), reinterpret_cast<setter>(UIElement_put_RotationAxis), nullptr, nullptr },
        { "rotation", reinterpret_cast<getter>(UIElement_get_Rotation), reinterpret_cast<setter>(UIElement_put_Rotation), nullptr, nullptr },
        { "translation", reinterpret_cast<getter>(UIElement_get_Translation), reinterpret_cast<setter>(UIElement_put_Translation), nullptr, nullptr },
        { "center_point", reinterpret_cast<getter>(UIElement_get_CenterPoint), reinterpret_cast<setter>(UIElement_put_CenterPoint), nullptr, nullptr },
        { "can_be_scroll_anchor", reinterpret_cast<getter>(UIElement_get_CanBeScrollAnchor), reinterpret_cast<setter>(UIElement_put_CanBeScrollAnchor), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UIElement[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UIElement) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UIElement) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UIElement) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UIElement) },
        { },
    };

    static PyType_Spec type_spec_UIElement =
    {
        "_winrt_Windows_UI_Xaml.UIElement",
        sizeof(py::wrapper::Windows::UI::Xaml::UIElement),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UIElement
    };

    static PyGetSetDef getset_UIElement_Meta[] = {
        { "holding_event", reinterpret_cast<getter>(UIElement_get_HoldingEvent), nullptr, nullptr, nullptr },
        { "is_double_tap_enabled_property", reinterpret_cast<getter>(UIElement_get_IsDoubleTapEnabledProperty), nullptr, nullptr, nullptr },
        { "is_hit_test_visible_property", reinterpret_cast<getter>(UIElement_get_IsHitTestVisibleProperty), nullptr, nullptr, nullptr },
        { "is_holding_enabled_property", reinterpret_cast<getter>(UIElement_get_IsHoldingEnabledProperty), nullptr, nullptr, nullptr },
        { "is_right_tap_enabled_property", reinterpret_cast<getter>(UIElement_get_IsRightTapEnabledProperty), nullptr, nullptr, nullptr },
        { "key_down_event", reinterpret_cast<getter>(UIElement_get_KeyDownEvent), nullptr, nullptr, nullptr },
        { "key_up_event", reinterpret_cast<getter>(UIElement_get_KeyUpEvent), nullptr, nullptr, nullptr },
        { "manipulation_completed_event", reinterpret_cast<getter>(UIElement_get_ManipulationCompletedEvent), nullptr, nullptr, nullptr },
        { "manipulation_delta_event", reinterpret_cast<getter>(UIElement_get_ManipulationDeltaEvent), nullptr, nullptr, nullptr },
        { "is_tap_enabled_property", reinterpret_cast<getter>(UIElement_get_IsTapEnabledProperty), nullptr, nullptr, nullptr },
        { "manipulation_inertia_starting_event", reinterpret_cast<getter>(UIElement_get_ManipulationInertiaStartingEvent), nullptr, nullptr, nullptr },
        { "manipulation_mode_property", reinterpret_cast<getter>(UIElement_get_ManipulationModeProperty), nullptr, nullptr, nullptr },
        { "manipulation_started_event", reinterpret_cast<getter>(UIElement_get_ManipulationStartedEvent), nullptr, nullptr, nullptr },
        { "manipulation_starting_event", reinterpret_cast<getter>(UIElement_get_ManipulationStartingEvent), nullptr, nullptr, nullptr },
        { "opacity_property", reinterpret_cast<getter>(UIElement_get_OpacityProperty), nullptr, nullptr, nullptr },
        { "pointer_canceled_event", reinterpret_cast<getter>(UIElement_get_PointerCanceledEvent), nullptr, nullptr, nullptr },
        { "pointer_capture_lost_event", reinterpret_cast<getter>(UIElement_get_PointerCaptureLostEvent), nullptr, nullptr, nullptr },
        { "pointer_captures_property", reinterpret_cast<getter>(UIElement_get_PointerCapturesProperty), nullptr, nullptr, nullptr },
        { "pointer_entered_event", reinterpret_cast<getter>(UIElement_get_PointerEnteredEvent), nullptr, nullptr, nullptr },
        { "pointer_exited_event", reinterpret_cast<getter>(UIElement_get_PointerExitedEvent), nullptr, nullptr, nullptr },
        { "pointer_moved_event", reinterpret_cast<getter>(UIElement_get_PointerMovedEvent), nullptr, nullptr, nullptr },
        { "pointer_pressed_event", reinterpret_cast<getter>(UIElement_get_PointerPressedEvent), nullptr, nullptr, nullptr },
        { "pointer_wheel_changed_event", reinterpret_cast<getter>(UIElement_get_PointerWheelChangedEvent), nullptr, nullptr, nullptr },
        { "projection_property", reinterpret_cast<getter>(UIElement_get_ProjectionProperty), nullptr, nullptr, nullptr },
        { "render_transform_origin_property", reinterpret_cast<getter>(UIElement_get_RenderTransformOriginProperty), nullptr, nullptr, nullptr },
        { "render_transform_property", reinterpret_cast<getter>(UIElement_get_RenderTransformProperty), nullptr, nullptr, nullptr },
        { "right_tapped_event", reinterpret_cast<getter>(UIElement_get_RightTappedEvent), nullptr, nullptr, nullptr },
        { "drag_enter_event", reinterpret_cast<getter>(UIElement_get_DragEnterEvent), nullptr, nullptr, nullptr },
        { "tapped_event", reinterpret_cast<getter>(UIElement_get_TappedEvent), nullptr, nullptr, nullptr },
        { "transitions_property", reinterpret_cast<getter>(UIElement_get_TransitionsProperty), nullptr, nullptr, nullptr },
        { "use_layout_rounding_property", reinterpret_cast<getter>(UIElement_get_UseLayoutRoundingProperty), nullptr, nullptr, nullptr },
        { "visibility_property", reinterpret_cast<getter>(UIElement_get_VisibilityProperty), nullptr, nullptr, nullptr },
        { "allow_drop_property", reinterpret_cast<getter>(UIElement_get_AllowDropProperty), nullptr, nullptr, nullptr },
        { "cache_mode_property", reinterpret_cast<getter>(UIElement_get_CacheModeProperty), nullptr, nullptr, nullptr },
        { "clip_property", reinterpret_cast<getter>(UIElement_get_ClipProperty), nullptr, nullptr, nullptr },
        { "double_tapped_event", reinterpret_cast<getter>(UIElement_get_DoubleTappedEvent), nullptr, nullptr, nullptr },
        { "pointer_released_event", reinterpret_cast<getter>(UIElement_get_PointerReleasedEvent), nullptr, nullptr, nullptr },
        { "drag_leave_event", reinterpret_cast<getter>(UIElement_get_DragLeaveEvent), nullptr, nullptr, nullptr },
        { "drag_over_event", reinterpret_cast<getter>(UIElement_get_DragOverEvent), nullptr, nullptr, nullptr },
        { "drop_event", reinterpret_cast<getter>(UIElement_get_DropEvent), nullptr, nullptr, nullptr },
        { "shadow_property", reinterpret_cast<getter>(UIElement_get_ShadowProperty), nullptr, nullptr, nullptr },
        { "composite_mode_property", reinterpret_cast<getter>(UIElement_get_CompositeModeProperty), nullptr, nullptr, nullptr },
        { "can_drag_property", reinterpret_cast<getter>(UIElement_get_CanDragProperty), nullptr, nullptr, nullptr },
        { "transform3_d_property", reinterpret_cast<getter>(UIElement_get_Transform3DProperty), nullptr, nullptr, nullptr },
        { "access_key_property", reinterpret_cast<getter>(UIElement_get_AccessKeyProperty), nullptr, nullptr, nullptr },
        { "access_key_scope_owner_property", reinterpret_cast<getter>(UIElement_get_AccessKeyScopeOwnerProperty), nullptr, nullptr, nullptr },
        { "context_flyout_property", reinterpret_cast<getter>(UIElement_get_ContextFlyoutProperty), nullptr, nullptr, nullptr },
        { "is_access_key_scope_property", reinterpret_cast<getter>(UIElement_get_IsAccessKeyScopeProperty), nullptr, nullptr, nullptr },
        { "exit_display_mode_on_access_key_invoked_property", reinterpret_cast<getter>(UIElement_get_ExitDisplayModeOnAccessKeyInvokedProperty), nullptr, nullptr, nullptr },
        { "high_contrast_adjustment_property", reinterpret_cast<getter>(UIElement_get_HighContrastAdjustmentProperty), nullptr, nullptr, nullptr },
        { "key_tip_horizontal_offset_property", reinterpret_cast<getter>(UIElement_get_KeyTipHorizontalOffsetProperty), nullptr, nullptr, nullptr },
        { "key_tip_placement_mode_property", reinterpret_cast<getter>(UIElement_get_KeyTipPlacementModeProperty), nullptr, nullptr, nullptr },
        { "key_tip_vertical_offset_property", reinterpret_cast<getter>(UIElement_get_KeyTipVerticalOffsetProperty), nullptr, nullptr, nullptr },
        { "lights_property", reinterpret_cast<getter>(UIElement_get_LightsProperty), nullptr, nullptr, nullptr },
        { "x_y_focus_down_navigation_strategy_property", reinterpret_cast<getter>(UIElement_get_XYFocusDownNavigationStrategyProperty), nullptr, nullptr, nullptr },
        { "x_y_focus_keyboard_navigation_property", reinterpret_cast<getter>(UIElement_get_XYFocusKeyboardNavigationProperty), nullptr, nullptr, nullptr },
        { "x_y_focus_left_navigation_strategy_property", reinterpret_cast<getter>(UIElement_get_XYFocusLeftNavigationStrategyProperty), nullptr, nullptr, nullptr },
        { "x_y_focus_right_navigation_strategy_property", reinterpret_cast<getter>(UIElement_get_XYFocusRightNavigationStrategyProperty), nullptr, nullptr, nullptr },
        { "x_y_focus_up_navigation_strategy_property", reinterpret_cast<getter>(UIElement_get_XYFocusUpNavigationStrategyProperty), nullptr, nullptr, nullptr },
        { "tab_focus_navigation_property", reinterpret_cast<getter>(UIElement_get_TabFocusNavigationProperty), nullptr, nullptr, nullptr },
        { "getting_focus_event", reinterpret_cast<getter>(UIElement_get_GettingFocusEvent), nullptr, nullptr, nullptr },
        { "losing_focus_event", reinterpret_cast<getter>(UIElement_get_LosingFocusEvent), nullptr, nullptr, nullptr },
        { "no_focus_candidate_found_event", reinterpret_cast<getter>(UIElement_get_NoFocusCandidateFoundEvent), nullptr, nullptr, nullptr },
        { "character_received_event", reinterpret_cast<getter>(UIElement_get_CharacterReceivedEvent), nullptr, nullptr, nullptr },
        { "preview_key_down_event", reinterpret_cast<getter>(UIElement_get_PreviewKeyDownEvent), nullptr, nullptr, nullptr },
        { "preview_key_up_event", reinterpret_cast<getter>(UIElement_get_PreviewKeyUpEvent), nullptr, nullptr, nullptr },
        { "bring_into_view_requested_event", reinterpret_cast<getter>(UIElement_get_BringIntoViewRequestedEvent), nullptr, nullptr, nullptr },
        { "context_requested_event", reinterpret_cast<getter>(UIElement_get_ContextRequestedEvent), nullptr, nullptr, nullptr },
        { "key_tip_target_property", reinterpret_cast<getter>(UIElement_get_KeyTipTargetProperty), nullptr, nullptr, nullptr },
        { "keyboard_accelerator_placement_mode_property", reinterpret_cast<getter>(UIElement_get_KeyboardAcceleratorPlacementModeProperty), nullptr, nullptr, nullptr },
        { "keyboard_accelerator_placement_target_property", reinterpret_cast<getter>(UIElement_get_KeyboardAcceleratorPlacementTargetProperty), nullptr, nullptr, nullptr },
        { "can_be_scroll_anchor_property", reinterpret_cast<getter>(UIElement_get_CanBeScrollAnchorProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_UIElement_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_UIElement_Meta) },
        { }
    };

    static PyType_Spec type_spec_UIElement_Meta =
    {
        "_winrt_Windows_UI_Xaml.UIElement_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_UIElement_Meta
    };

    // ----- UIElementWeakCollection class --------------------
    static constexpr const char* const type_name_UIElementWeakCollection = "UIElementWeakCollection";

    static PyObject* _new_UIElementWeakCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::UIElementWeakCollection instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_UIElementWeakCollection(py::wrapper::Windows::UI::Xaml::UIElementWeakCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UIElementWeakCollection_Append(py::wrapper::Windows::UI::Xaml::UIElementWeakCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElementWeakCollection", L"Append", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UIElementWeakCollection_Clear(py::wrapper::Windows::UI::Xaml::UIElementWeakCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElementWeakCollection", L"Clear", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UIElementWeakCollection_First(py::wrapper::Windows::UI::Xaml::UIElementWeakCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElementWeakCollection", L"First", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UIElementWeakCollection_GetAt(py::wrapper::Windows::UI::Xaml::UIElementWeakCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElementWeakCollection", L"GetAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UIElementWeakCollection_GetMany(py::wrapper::Windows::UI::Xaml::UIElementWeakCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElementWeakCollection", L"GetMany", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::UIElement, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UIElementWeakCollection_GetView(py::wrapper::Windows::UI::Xaml::UIElementWeakCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElementWeakCollection", L"GetView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UIElementWeakCollection_IndexOf(py::wrapper::Windows::UI::Xaml::UIElementWeakCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElementWeakCollection", L"IndexOf", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UIElementWeakCollection_InsertAt(py::wrapper::Windows::UI::Xaml::UIElementWeakCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElementWeakCollection", L"InsertAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UIElementWeakCollection_RemoveAt(py::wrapper::Windows::UI::Xaml::UIElementWeakCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElementWeakCollection", L"RemoveAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UIElementWeakCollection_RemoveAtEnd(py::wrapper::Windows::UI::Xaml::UIElementWeakCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElementWeakCollection", L"RemoveAtEnd", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UIElementWeakCollection_ReplaceAll(py::wrapper::Windows::UI::Xaml::UIElementWeakCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElementWeakCollection", L"ReplaceAll", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::UIElement, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UIElementWeakCollection_SetAt(py::wrapper::Windows::UI::Xaml::UIElementWeakCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElementWeakCollection", L"SetAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UIElementWeakCollection_get_Size(py::wrapper::Windows::UI::Xaml::UIElementWeakCollection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElementWeakCollection", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UIElementWeakCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::UIElementWeakCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UIElementWeakCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::UIElementWeakCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_UIElementWeakCollection(py::wrapper::Windows::UI::Xaml::UIElementWeakCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_UIElementWeakCollection(py::wrapper::Windows::UI::Xaml::UIElementWeakCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_UIElementWeakCollection(py::wrapper::Windows::UI::Xaml::UIElementWeakCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_UIElementWeakCollection(py::wrapper::Windows::UI::Xaml::UIElementWeakCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_UIElementWeakCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(
                    PyExc_TypeError,
                    "indicies must be integers, not '%s'",
                    Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(
                    slice, self->obj.Size(), &start, &stop, &step, &length)
                < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(
                    PyExc_NotImplementedError,
                    "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::UI::Xaml::UIElement> items(length, empty_instance<winrt::Windows::UI::Xaml::UIElement>::get());

            auto count = self->obj.GetMany(start, items);

            if (count != length)
            {
                PyErr_Format(
                    PyExc_RuntimeError,
                    "returned count %d did not match requested length %zd",
                    count,
                    length);
                return nullptr;
            }

            return convert(items);}
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_UIElementWeakCollection(py::wrapper::Windows::UI::Xaml::UIElementWeakCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (value == nullptr) { self->obj.RemoveAt(static_cast<uint32_t>(i)); }
            else { self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::UI::Xaml::UIElement>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_UIElementWeakCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(UIElementWeakCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(UIElementWeakCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(UIElementWeakCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(UIElementWeakCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(UIElementWeakCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(UIElementWeakCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(UIElementWeakCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(UIElementWeakCollection_InsertAt), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(UIElementWeakCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(UIElementWeakCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(UIElementWeakCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(UIElementWeakCollection_SetAt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_UIElementWeakCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UIElementWeakCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UIElementWeakCollection[] = {
        { "size", reinterpret_cast<getter>(UIElementWeakCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UIElementWeakCollection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UIElementWeakCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UIElementWeakCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UIElementWeakCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UIElementWeakCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_UIElementWeakCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_UIElementWeakCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_UIElementWeakCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_UIElementWeakCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_UIElementWeakCollection) },
        { },
    };

    static PyType_Spec type_spec_UIElementWeakCollection =
    {
        "_winrt_Windows_UI_Xaml.UIElementWeakCollection",
        sizeof(py::wrapper::Windows::UI::Xaml::UIElementWeakCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UIElementWeakCollection
    };

    // ----- UnhandledExceptionEventArgs class --------------------
    static constexpr const char* const type_name_UnhandledExceptionEventArgs = "UnhandledExceptionEventArgs";

    static PyObject* _new_UnhandledExceptionEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_UnhandledExceptionEventArgs);
        return nullptr;
    }

    static void _dealloc_UnhandledExceptionEventArgs(py::wrapper::Windows::UI::Xaml::UnhandledExceptionEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UnhandledExceptionEventArgs_get_Handled(py::wrapper::Windows::UI::Xaml::UnhandledExceptionEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UnhandledExceptionEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UnhandledExceptionEventArgs_put_Handled(py::wrapper::Windows::UI::Xaml::UnhandledExceptionEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UnhandledExceptionEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UnhandledExceptionEventArgs_get_Exception(py::wrapper::Windows::UI::Xaml::UnhandledExceptionEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UnhandledExceptionEventArgs", L"Exception"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Exception());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UnhandledExceptionEventArgs_get_Message(py::wrapper::Windows::UI::Xaml::UnhandledExceptionEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UnhandledExceptionEventArgs", L"Message"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Message());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UnhandledExceptionEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::UnhandledExceptionEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UnhandledExceptionEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::UnhandledExceptionEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UnhandledExceptionEventArgs[] = {
        { "_assign_array_", _assign_array_UnhandledExceptionEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UnhandledExceptionEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UnhandledExceptionEventArgs[] = {
        { "handled", reinterpret_cast<getter>(UnhandledExceptionEventArgs_get_Handled), reinterpret_cast<setter>(UnhandledExceptionEventArgs_put_Handled), nullptr, nullptr },
        { "exception", reinterpret_cast<getter>(UnhandledExceptionEventArgs_get_Exception), nullptr, nullptr, nullptr },
        { "message", reinterpret_cast<getter>(UnhandledExceptionEventArgs_get_Message), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UnhandledExceptionEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UnhandledExceptionEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UnhandledExceptionEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UnhandledExceptionEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UnhandledExceptionEventArgs) },
        { },
    };

    static PyType_Spec type_spec_UnhandledExceptionEventArgs =
    {
        "_winrt_Windows_UI_Xaml.UnhandledExceptionEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::UnhandledExceptionEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UnhandledExceptionEventArgs
    };

    // ----- Vector3Transition class --------------------
    static constexpr const char* const type_name_Vector3Transition = "Vector3Transition";

    static PyObject* _new_Vector3Transition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Vector3Transition instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Vector3Transition(py::wrapper::Windows::UI::Xaml::Vector3Transition* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Vector3Transition_get_Duration(py::wrapper::Windows::UI::Xaml::Vector3Transition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Vector3Transition", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Vector3Transition_put_Duration(py::wrapper::Windows::UI::Xaml::Vector3Transition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Vector3Transition", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Vector3Transition_get_Components(py::wrapper::Windows::UI::Xaml::Vector3Transition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Vector3Transition", L"Components"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Components());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Vector3Transition_put_Components(py::wrapper::Windows::UI::Xaml::Vector3Transition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Vector3Transition", L"Components"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Vector3TransitionComponents>(arg);

            self->obj.Components(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_Vector3Transition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Vector3Transition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Vector3Transition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Vector3Transition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Vector3Transition[] = {
        { "_assign_array_", _assign_array_Vector3Transition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Vector3Transition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Vector3Transition[] = {
        { "duration", reinterpret_cast<getter>(Vector3Transition_get_Duration), reinterpret_cast<setter>(Vector3Transition_put_Duration), nullptr, nullptr },
        { "components", reinterpret_cast<getter>(Vector3Transition_get_Components), reinterpret_cast<setter>(Vector3Transition_put_Components), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Vector3Transition[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Vector3Transition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Vector3Transition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Vector3Transition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Vector3Transition) },
        { },
    };

    static PyType_Spec type_spec_Vector3Transition =
    {
        "_winrt_Windows_UI_Xaml.Vector3Transition",
        sizeof(py::wrapper::Windows::UI::Xaml::Vector3Transition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Vector3Transition
    };

    // ----- VisualState class --------------------
    static constexpr const char* const type_name_VisualState = "VisualState";

    static PyObject* _new_VisualState(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::VisualState instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VisualState(py::wrapper::Windows::UI::Xaml::VisualState* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VisualState_get_Storyboard(py::wrapper::Windows::UI::Xaml::VisualState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.VisualState", L"Storyboard"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Storyboard());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VisualState_put_Storyboard(py::wrapper::Windows::UI::Xaml::VisualState* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.VisualState", L"Storyboard"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::Storyboard>(arg);

            self->obj.Storyboard(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VisualState_get_Name(py::wrapper::Windows::UI::Xaml::VisualState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.VisualState", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VisualState_get_Setters(py::wrapper::Windows::UI::Xaml::VisualState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.VisualState", L"Setters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Setters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VisualState_get_StateTriggers(py::wrapper::Windows::UI::Xaml::VisualState* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.VisualState", L"StateTriggers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StateTriggers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VisualState(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::VisualState>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VisualState(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::VisualState>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VisualState[] = {
        { "_assign_array_", _assign_array_VisualState, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VisualState), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VisualState[] = {
        { "storyboard", reinterpret_cast<getter>(VisualState_get_Storyboard), reinterpret_cast<setter>(VisualState_put_Storyboard), nullptr, nullptr },
        { "name", reinterpret_cast<getter>(VisualState_get_Name), nullptr, nullptr, nullptr },
        { "setters", reinterpret_cast<getter>(VisualState_get_Setters), nullptr, nullptr, nullptr },
        { "state_triggers", reinterpret_cast<getter>(VisualState_get_StateTriggers), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VisualState[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VisualState) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VisualState) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VisualState) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VisualState) },
        { },
    };

    static PyType_Spec type_spec_VisualState =
    {
        "_winrt_Windows_UI_Xaml.VisualState",
        sizeof(py::wrapper::Windows::UI::Xaml::VisualState),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VisualState
    };

    // ----- VisualStateChangedEventArgs class --------------------
    static constexpr const char* const type_name_VisualStateChangedEventArgs = "VisualStateChangedEventArgs";

    static PyObject* _new_VisualStateChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::VisualStateChangedEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VisualStateChangedEventArgs(py::wrapper::Windows::UI::Xaml::VisualStateChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VisualStateChangedEventArgs_get_OldState(py::wrapper::Windows::UI::Xaml::VisualStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.VisualStateChangedEventArgs", L"OldState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OldState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VisualStateChangedEventArgs_put_OldState(py::wrapper::Windows::UI::Xaml::VisualStateChangedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.VisualStateChangedEventArgs", L"OldState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::VisualState>(arg);

            self->obj.OldState(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VisualStateChangedEventArgs_get_NewState(py::wrapper::Windows::UI::Xaml::VisualStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.VisualStateChangedEventArgs", L"NewState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NewState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VisualStateChangedEventArgs_put_NewState(py::wrapper::Windows::UI::Xaml::VisualStateChangedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.VisualStateChangedEventArgs", L"NewState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::VisualState>(arg);

            self->obj.NewState(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VisualStateChangedEventArgs_get_Control(py::wrapper::Windows::UI::Xaml::VisualStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.VisualStateChangedEventArgs", L"Control"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Control());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VisualStateChangedEventArgs_put_Control(py::wrapper::Windows::UI::Xaml::VisualStateChangedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.VisualStateChangedEventArgs", L"Control"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Control>(arg);

            self->obj.Control(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_VisualStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::VisualStateChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VisualStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::VisualStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VisualStateChangedEventArgs[] = {
        { "_assign_array_", _assign_array_VisualStateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VisualStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VisualStateChangedEventArgs[] = {
        { "old_state", reinterpret_cast<getter>(VisualStateChangedEventArgs_get_OldState), reinterpret_cast<setter>(VisualStateChangedEventArgs_put_OldState), nullptr, nullptr },
        { "new_state", reinterpret_cast<getter>(VisualStateChangedEventArgs_get_NewState), reinterpret_cast<setter>(VisualStateChangedEventArgs_put_NewState), nullptr, nullptr },
        { "control", reinterpret_cast<getter>(VisualStateChangedEventArgs_get_Control), reinterpret_cast<setter>(VisualStateChangedEventArgs_put_Control), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VisualStateChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VisualStateChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VisualStateChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VisualStateChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VisualStateChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_VisualStateChangedEventArgs =
    {
        "_winrt_Windows_UI_Xaml.VisualStateChangedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::VisualStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VisualStateChangedEventArgs
    };

    // ----- VisualStateGroup class --------------------
    static constexpr const char* const type_name_VisualStateGroup = "VisualStateGroup";

    static PyObject* _new_VisualStateGroup(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::VisualStateGroup instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VisualStateGroup(py::wrapper::Windows::UI::Xaml::VisualStateGroup* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VisualStateGroup_get_CurrentState(py::wrapper::Windows::UI::Xaml::VisualStateGroup* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.VisualStateGroup", L"CurrentState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrentState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VisualStateGroup_get_Name(py::wrapper::Windows::UI::Xaml::VisualStateGroup* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.VisualStateGroup", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VisualStateGroup_get_States(py::wrapper::Windows::UI::Xaml::VisualStateGroup* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.VisualStateGroup", L"States"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.States());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VisualStateGroup_get_Transitions(py::wrapper::Windows::UI::Xaml::VisualStateGroup* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.VisualStateGroup", L"Transitions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Transitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VisualStateGroup_add_CurrentStateChanged(py::wrapper::Windows::UI::Xaml::VisualStateGroup* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.VisualStateGroup", L"CurrentStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::VisualStateChangedEventHandler>(arg);

            return py::convert(self->obj.CurrentStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VisualStateGroup_remove_CurrentStateChanged(py::wrapper::Windows::UI::Xaml::VisualStateGroup* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.VisualStateGroup", L"CurrentStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CurrentStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VisualStateGroup_add_CurrentStateChanging(py::wrapper::Windows::UI::Xaml::VisualStateGroup* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.VisualStateGroup", L"CurrentStateChanging"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::VisualStateChangedEventHandler>(arg);

            return py::convert(self->obj.CurrentStateChanging(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VisualStateGroup_remove_CurrentStateChanging(py::wrapper::Windows::UI::Xaml::VisualStateGroup* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.VisualStateGroup", L"CurrentStateChanging"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CurrentStateChanging(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VisualStateGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::VisualStateGroup>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VisualStateGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::VisualStateGroup>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VisualStateGroup[] = {
        { "add_current_state_changed", reinterpret_cast<PyCFunction>(VisualStateGroup_add_CurrentStateChanged), METH_O, nullptr },
        { "remove_current_state_changed", reinterpret_cast<PyCFunction>(VisualStateGroup_remove_CurrentStateChanged), METH_O, nullptr },
        { "add_current_state_changing", reinterpret_cast<PyCFunction>(VisualStateGroup_add_CurrentStateChanging), METH_O, nullptr },
        { "remove_current_state_changing", reinterpret_cast<PyCFunction>(VisualStateGroup_remove_CurrentStateChanging), METH_O, nullptr },
        { "_assign_array_", _assign_array_VisualStateGroup, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VisualStateGroup), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VisualStateGroup[] = {
        { "current_state", reinterpret_cast<getter>(VisualStateGroup_get_CurrentState), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(VisualStateGroup_get_Name), nullptr, nullptr, nullptr },
        { "states", reinterpret_cast<getter>(VisualStateGroup_get_States), nullptr, nullptr, nullptr },
        { "transitions", reinterpret_cast<getter>(VisualStateGroup_get_Transitions), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VisualStateGroup[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VisualStateGroup) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VisualStateGroup) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VisualStateGroup) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VisualStateGroup) },
        { },
    };

    static PyType_Spec type_spec_VisualStateGroup =
    {
        "_winrt_Windows_UI_Xaml.VisualStateGroup",
        sizeof(py::wrapper::Windows::UI::Xaml::VisualStateGroup),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VisualStateGroup
    };

    // ----- VisualStateManager class --------------------
    static constexpr const char* const type_name_VisualStateManager = "VisualStateManager";

    static PyObject* _new_VisualStateManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::VisualStateManager instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VisualStateManager(py::wrapper::Windows::UI::Xaml::VisualStateManager* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VisualStateManager_GetCustomVisualStateManager(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.VisualStateManager", L"GetCustomVisualStateManager", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::FrameworkElement>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::VisualStateManager::GetCustomVisualStateManager(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualStateManager_GetVisualStateGroups(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.VisualStateManager", L"GetVisualStateGroups", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::FrameworkElement>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::VisualStateManager::GetVisualStateGroups(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualStateManager_GoToState(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.VisualStateManager", L"GoToState", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Control>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                return py::convert(winrt::Windows::UI::Xaml::VisualStateManager::GoToState(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualStateManager_GoToStateCore(py::wrapper::Windows::UI::Xaml::VisualStateManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.VisualStateManager", L"GoToStateCore", 6))
            {
                py::set_arg_count_version_error(6);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Control>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::FrameworkElement>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::UI::Xaml::VisualStateGroup>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::UI::Xaml::VisualState>(args, 4);
                auto param5 = py::convert_to<bool>(args, 5);

                return py::convert(self->obj.GoToStateCore(param0, param1, param2, param3, param4, param5));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualStateManager_RaiseCurrentStateChanged(py::wrapper::Windows::UI::Xaml::VisualStateManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.VisualStateManager", L"RaiseCurrentStateChanged", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::VisualStateGroup>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::VisualState>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Xaml::VisualState>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Control>(args, 3);

                self->obj.RaiseCurrentStateChanged(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualStateManager_RaiseCurrentStateChanging(py::wrapper::Windows::UI::Xaml::VisualStateManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.VisualStateManager", L"RaiseCurrentStateChanging", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::VisualStateGroup>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::VisualState>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Xaml::VisualState>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Control>(args, 3);

                self->obj.RaiseCurrentStateChanging(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualStateManager_SetCustomVisualStateManager(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.VisualStateManager", L"SetCustomVisualStateManager", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::FrameworkElement>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::VisualStateManager>(args, 1);

                winrt::Windows::UI::Xaml::VisualStateManager::SetCustomVisualStateManager(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualStateManager_get_CustomVisualStateManagerProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.VisualStateManager", L"CustomVisualStateManagerProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::VisualStateManager::CustomVisualStateManagerProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VisualStateManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::VisualStateManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VisualStateManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::VisualStateManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VisualStateManager[] = {
        { "get_custom_visual_state_manager", reinterpret_cast<PyCFunction>(VisualStateManager_GetCustomVisualStateManager), METH_VARARGS | METH_STATIC, nullptr },
        { "get_visual_state_groups", reinterpret_cast<PyCFunction>(VisualStateManager_GetVisualStateGroups), METH_VARARGS | METH_STATIC, nullptr },
        { "go_to_state", reinterpret_cast<PyCFunction>(VisualStateManager_GoToState), METH_VARARGS | METH_STATIC, nullptr },
        { "go_to_state_core", reinterpret_cast<PyCFunction>(VisualStateManager_GoToStateCore), METH_VARARGS, nullptr },
        { "raise_current_state_changed", reinterpret_cast<PyCFunction>(VisualStateManager_RaiseCurrentStateChanged), METH_VARARGS, nullptr },
        { "raise_current_state_changing", reinterpret_cast<PyCFunction>(VisualStateManager_RaiseCurrentStateChanging), METH_VARARGS, nullptr },
        { "set_custom_visual_state_manager", reinterpret_cast<PyCFunction>(VisualStateManager_SetCustomVisualStateManager), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_VisualStateManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VisualStateManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VisualStateManager[] = {
        { }
    };

    static PyType_Slot _type_slots_VisualStateManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VisualStateManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VisualStateManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VisualStateManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VisualStateManager) },
        { },
    };

    static PyType_Spec type_spec_VisualStateManager =
    {
        "_winrt_Windows_UI_Xaml.VisualStateManager",
        sizeof(py::wrapper::Windows::UI::Xaml::VisualStateManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VisualStateManager
    };

    static PyGetSetDef getset_VisualStateManager_Meta[] = {
        { "custom_visual_state_manager_property", reinterpret_cast<getter>(VisualStateManager_get_CustomVisualStateManagerProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_VisualStateManager_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_VisualStateManager_Meta) },
        { }
    };

    static PyType_Spec type_spec_VisualStateManager_Meta =
    {
        "_winrt_Windows_UI_Xaml.VisualStateManager_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_VisualStateManager_Meta
    };

    // ----- VisualTransition class --------------------
    static constexpr const char* const type_name_VisualTransition = "VisualTransition";

    static PyObject* _new_VisualTransition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::VisualTransition instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VisualTransition(py::wrapper::Windows::UI::Xaml::VisualTransition* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VisualTransition_get_To(py::wrapper::Windows::UI::Xaml::VisualTransition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.VisualTransition", L"To"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.To());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VisualTransition_put_To(py::wrapper::Windows::UI::Xaml::VisualTransition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.VisualTransition", L"To"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.To(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VisualTransition_get_Storyboard(py::wrapper::Windows::UI::Xaml::VisualTransition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.VisualTransition", L"Storyboard"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Storyboard());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VisualTransition_put_Storyboard(py::wrapper::Windows::UI::Xaml::VisualTransition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.VisualTransition", L"Storyboard"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::Storyboard>(arg);

            self->obj.Storyboard(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VisualTransition_get_GeneratedEasingFunction(py::wrapper::Windows::UI::Xaml::VisualTransition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.VisualTransition", L"GeneratedEasingFunction"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.GeneratedEasingFunction());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VisualTransition_put_GeneratedEasingFunction(py::wrapper::Windows::UI::Xaml::VisualTransition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.VisualTransition", L"GeneratedEasingFunction"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::EasingFunctionBase>(arg);

            self->obj.GeneratedEasingFunction(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VisualTransition_get_GeneratedDuration(py::wrapper::Windows::UI::Xaml::VisualTransition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.VisualTransition", L"GeneratedDuration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.GeneratedDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VisualTransition_put_GeneratedDuration(py::wrapper::Windows::UI::Xaml::VisualTransition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.VisualTransition", L"GeneratedDuration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Duration>(arg);

            self->obj.GeneratedDuration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VisualTransition_get_From(py::wrapper::Windows::UI::Xaml::VisualTransition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.VisualTransition", L"From"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.From());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VisualTransition_put_From(py::wrapper::Windows::UI::Xaml::VisualTransition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.VisualTransition", L"From"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.From(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_VisualTransition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::VisualTransition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VisualTransition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::VisualTransition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VisualTransition[] = {
        { "_assign_array_", _assign_array_VisualTransition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VisualTransition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VisualTransition[] = {
        { "to", reinterpret_cast<getter>(VisualTransition_get_To), reinterpret_cast<setter>(VisualTransition_put_To), nullptr, nullptr },
        { "storyboard", reinterpret_cast<getter>(VisualTransition_get_Storyboard), reinterpret_cast<setter>(VisualTransition_put_Storyboard), nullptr, nullptr },
        { "generated_easing_function", reinterpret_cast<getter>(VisualTransition_get_GeneratedEasingFunction), reinterpret_cast<setter>(VisualTransition_put_GeneratedEasingFunction), nullptr, nullptr },
        { "generated_duration", reinterpret_cast<getter>(VisualTransition_get_GeneratedDuration), reinterpret_cast<setter>(VisualTransition_put_GeneratedDuration), nullptr, nullptr },
        { "from_", reinterpret_cast<getter>(VisualTransition_get_From), reinterpret_cast<setter>(VisualTransition_put_From), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VisualTransition[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VisualTransition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VisualTransition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VisualTransition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VisualTransition) },
        { },
    };

    static PyType_Spec type_spec_VisualTransition =
    {
        "_winrt_Windows_UI_Xaml.VisualTransition",
        sizeof(py::wrapper::Windows::UI::Xaml::VisualTransition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VisualTransition
    };

    // ----- Window class --------------------
    static constexpr const char* const type_name_Window = "Window";

    static PyObject* _new_Window(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_Window);
        return nullptr;
    }

    static void _dealloc_Window(py::wrapper::Windows::UI::Xaml::Window* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Window_Activate(py::wrapper::Windows::UI::Xaml::Window* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Window", L"Activate", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Activate();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Window_Close(py::wrapper::Windows::UI::Xaml::Window* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Window", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Window_SetTitleBar(py::wrapper::Windows::UI::Xaml::Window* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Window", L"SetTitleBar", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 0);

                self->obj.SetTitleBar(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Window_get_Content(py::wrapper::Windows::UI::Xaml::Window* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Window", L"Content"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Content());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Window_put_Content(py::wrapper::Windows::UI::Xaml::Window* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Window", L"Content"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(arg);

            self->obj.Content(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Window_get_Bounds(py::wrapper::Windows::UI::Xaml::Window* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Window", L"Bounds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Bounds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Window_get_CoreWindow(py::wrapper::Windows::UI::Xaml::Window* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Window", L"CoreWindow"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CoreWindow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Window_get_Dispatcher(py::wrapper::Windows::UI::Xaml::Window* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Window", L"Dispatcher"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Dispatcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Window_get_Visible(py::wrapper::Windows::UI::Xaml::Window* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Window", L"Visible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Visible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Window_get_Compositor(py::wrapper::Windows::UI::Xaml::Window* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Window", L"Compositor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Compositor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Window_get_UIContext(py::wrapper::Windows::UI::Xaml::Window* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Window", L"UIContext"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UIContext());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Window_get_Current(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Window", L"Current"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Window::Current());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Window_add_Activated(py::wrapper::Windows::UI::Xaml::Window* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Window", L"Activated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::WindowActivatedEventHandler>(arg);

            return py::convert(self->obj.Activated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Window_remove_Activated(py::wrapper::Windows::UI::Xaml::Window* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Window", L"Activated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Activated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Window_add_Closed(py::wrapper::Windows::UI::Xaml::Window* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Window", L"Closed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::WindowClosedEventHandler>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Window_remove_Closed(py::wrapper::Windows::UI::Xaml::Window* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Window", L"Closed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Window_add_SizeChanged(py::wrapper::Windows::UI::Xaml::Window* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Window", L"SizeChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::WindowSizeChangedEventHandler>(arg);

            return py::convert(self->obj.SizeChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Window_remove_SizeChanged(py::wrapper::Windows::UI::Xaml::Window* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Window", L"SizeChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SizeChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Window_add_VisibilityChanged(py::wrapper::Windows::UI::Xaml::Window* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Window", L"VisibilityChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::WindowVisibilityChangedEventHandler>(arg);

            return py::convert(self->obj.VisibilityChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Window_remove_VisibilityChanged(py::wrapper::Windows::UI::Xaml::Window* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Window", L"VisibilityChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VisibilityChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Window(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Window>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Window(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Window>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Window[] = {
        { "activate", reinterpret_cast<PyCFunction>(Window_Activate), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(Window_Close), METH_VARARGS, nullptr },
        { "set_title_bar", reinterpret_cast<PyCFunction>(Window_SetTitleBar), METH_VARARGS, nullptr },
        { "add_activated", reinterpret_cast<PyCFunction>(Window_add_Activated), METH_O, nullptr },
        { "remove_activated", reinterpret_cast<PyCFunction>(Window_remove_Activated), METH_O, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(Window_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(Window_remove_Closed), METH_O, nullptr },
        { "add_size_changed", reinterpret_cast<PyCFunction>(Window_add_SizeChanged), METH_O, nullptr },
        { "remove_size_changed", reinterpret_cast<PyCFunction>(Window_remove_SizeChanged), METH_O, nullptr },
        { "add_visibility_changed", reinterpret_cast<PyCFunction>(Window_add_VisibilityChanged), METH_O, nullptr },
        { "remove_visibility_changed", reinterpret_cast<PyCFunction>(Window_remove_VisibilityChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_Window, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Window), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Window[] = {
        { "content", reinterpret_cast<getter>(Window_get_Content), reinterpret_cast<setter>(Window_put_Content), nullptr, nullptr },
        { "bounds", reinterpret_cast<getter>(Window_get_Bounds), nullptr, nullptr, nullptr },
        { "core_window", reinterpret_cast<getter>(Window_get_CoreWindow), nullptr, nullptr, nullptr },
        { "dispatcher", reinterpret_cast<getter>(Window_get_Dispatcher), nullptr, nullptr, nullptr },
        { "visible", reinterpret_cast<getter>(Window_get_Visible), nullptr, nullptr, nullptr },
        { "compositor", reinterpret_cast<getter>(Window_get_Compositor), nullptr, nullptr, nullptr },
        { "u_i_context", reinterpret_cast<getter>(Window_get_UIContext), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Window[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Window) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Window) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Window) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Window) },
        { },
    };

    static PyType_Spec type_spec_Window =
    {
        "_winrt_Windows_UI_Xaml.Window",
        sizeof(py::wrapper::Windows::UI::Xaml::Window),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Window
    };

    static PyGetSetDef getset_Window_Meta[] = {
        { "current", reinterpret_cast<getter>(Window_get_Current), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_Window_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Window_Meta) },
        { }
    };

    static PyType_Spec type_spec_Window_Meta =
    {
        "_winrt_Windows_UI_Xaml.Window_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Window_Meta
    };

    // ----- WindowCreatedEventArgs class --------------------
    static constexpr const char* const type_name_WindowCreatedEventArgs = "WindowCreatedEventArgs";

    static PyObject* _new_WindowCreatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WindowCreatedEventArgs);
        return nullptr;
    }

    static void _dealloc_WindowCreatedEventArgs(py::wrapper::Windows::UI::Xaml::WindowCreatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WindowCreatedEventArgs_get_Window(py::wrapper::Windows::UI::Xaml::WindowCreatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.WindowCreatedEventArgs", L"Window"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Window());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WindowCreatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::WindowCreatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WindowCreatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::WindowCreatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowCreatedEventArgs[] = {
        { "_assign_array_", _assign_array_WindowCreatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WindowCreatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WindowCreatedEventArgs[] = {
        { "window", reinterpret_cast<getter>(WindowCreatedEventArgs_get_Window), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WindowCreatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowCreatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WindowCreatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowCreatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowCreatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_WindowCreatedEventArgs =
    {
        "_winrt_Windows_UI_Xaml.WindowCreatedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::WindowCreatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowCreatedEventArgs
    };

    // ----- XamlRoot class --------------------
    static constexpr const char* const type_name_XamlRoot = "XamlRoot";

    static PyObject* _new_XamlRoot(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_XamlRoot);
        return nullptr;
    }

    static void _dealloc_XamlRoot(py::wrapper::Windows::UI::Xaml::XamlRoot* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* XamlRoot_get_Content(py::wrapper::Windows::UI::Xaml::XamlRoot* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.XamlRoot", L"Content"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Content());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XamlRoot_get_IsHostVisible(py::wrapper::Windows::UI::Xaml::XamlRoot* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.XamlRoot", L"IsHostVisible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsHostVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XamlRoot_get_RasterizationScale(py::wrapper::Windows::UI::Xaml::XamlRoot* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.XamlRoot", L"RasterizationScale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RasterizationScale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XamlRoot_get_Size(py::wrapper::Windows::UI::Xaml::XamlRoot* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.XamlRoot", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XamlRoot_get_UIContext(py::wrapper::Windows::UI::Xaml::XamlRoot* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.XamlRoot", L"UIContext"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UIContext());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XamlRoot_add_Changed(py::wrapper::Windows::UI::Xaml::XamlRoot* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.XamlRoot", L"Changed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::XamlRoot, winrt::Windows::UI::Xaml::XamlRootChangedEventArgs>>(arg);

            return py::convert(self->obj.Changed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XamlRoot_remove_Changed(py::wrapper::Windows::UI::Xaml::XamlRoot* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.XamlRoot", L"Changed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Changed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_XamlRoot(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::XamlRoot>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_XamlRoot(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::XamlRoot>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_XamlRoot[] = {
        { "add_changed", reinterpret_cast<PyCFunction>(XamlRoot_add_Changed), METH_O, nullptr },
        { "remove_changed", reinterpret_cast<PyCFunction>(XamlRoot_remove_Changed), METH_O, nullptr },
        { "_assign_array_", _assign_array_XamlRoot, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_XamlRoot), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_XamlRoot[] = {
        { "content", reinterpret_cast<getter>(XamlRoot_get_Content), nullptr, nullptr, nullptr },
        { "is_host_visible", reinterpret_cast<getter>(XamlRoot_get_IsHostVisible), nullptr, nullptr, nullptr },
        { "rasterization_scale", reinterpret_cast<getter>(XamlRoot_get_RasterizationScale), nullptr, nullptr, nullptr },
        { "size", reinterpret_cast<getter>(XamlRoot_get_Size), nullptr, nullptr, nullptr },
        { "u_i_context", reinterpret_cast<getter>(XamlRoot_get_UIContext), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_XamlRoot[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_XamlRoot) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_XamlRoot) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_XamlRoot) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_XamlRoot) },
        { },
    };

    static PyType_Spec type_spec_XamlRoot =
    {
        "_winrt_Windows_UI_Xaml.XamlRoot",
        sizeof(py::wrapper::Windows::UI::Xaml::XamlRoot),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_XamlRoot
    };

    // ----- XamlRootChangedEventArgs class --------------------
    static constexpr const char* const type_name_XamlRootChangedEventArgs = "XamlRootChangedEventArgs";

    static PyObject* _new_XamlRootChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_XamlRootChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_XamlRootChangedEventArgs(py::wrapper::Windows::UI::Xaml::XamlRootChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_XamlRootChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::XamlRootChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_XamlRootChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::XamlRootChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_XamlRootChangedEventArgs[] = {
        { "_assign_array_", _assign_array_XamlRootChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_XamlRootChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_XamlRootChangedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_XamlRootChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_XamlRootChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_XamlRootChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_XamlRootChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_XamlRootChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_XamlRootChangedEventArgs =
    {
        "_winrt_Windows_UI_Xaml.XamlRootChangedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::XamlRootChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_XamlRootChangedEventArgs
    };

    // ----- IDataTemplateExtension interface --------------------
    static constexpr const char* const type_name_IDataTemplateExtension = "IDataTemplateExtension";

    static PyObject* _new_IDataTemplateExtension(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IDataTemplateExtension);
        return nullptr;
    }

    static void _dealloc_IDataTemplateExtension(py::wrapper::Windows::UI::Xaml::IDataTemplateExtension* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IDataTemplateExtension_ProcessBinding(py::wrapper::Windows::UI::Xaml::IDataTemplateExtension* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.IDataTemplateExtension", L"ProcessBinding", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.ProcessBinding(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataTemplateExtension_ProcessBindings(py::wrapper::Windows::UI::Xaml::IDataTemplateExtension* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.IDataTemplateExtension", L"ProcessBindings", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ContainerContentChangingEventArgs>(args, 0);

                return py::convert(self->obj.ProcessBindings(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataTemplateExtension_ResetTemplate(py::wrapper::Windows::UI::Xaml::IDataTemplateExtension* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.IDataTemplateExtension", L"ResetTemplate", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.ResetTemplate();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IDataTemplateExtension(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::IDataTemplateExtension>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IDataTemplateExtension(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::IDataTemplateExtension>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IDataTemplateExtension[] = {
        { "process_binding", reinterpret_cast<PyCFunction>(IDataTemplateExtension_ProcessBinding), METH_VARARGS, nullptr },
        { "process_bindings", reinterpret_cast<PyCFunction>(IDataTemplateExtension_ProcessBindings), METH_VARARGS, nullptr },
        { "reset_template", reinterpret_cast<PyCFunction>(IDataTemplateExtension_ResetTemplate), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IDataTemplateExtension, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IDataTemplateExtension), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IDataTemplateExtension[] = {
        { }
    };

    static PyType_Slot _type_slots_IDataTemplateExtension[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IDataTemplateExtension) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IDataTemplateExtension) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IDataTemplateExtension) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IDataTemplateExtension) },
        { },
    };

    static PyType_Spec type_spec_IDataTemplateExtension =
    {
        "_winrt_Windows_UI_Xaml.IDataTemplateExtension",
        sizeof(py::wrapper::Windows::UI::Xaml::IDataTemplateExtension),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IDataTemplateExtension
    };

    // ----- IElementFactory interface --------------------
    static constexpr const char* const type_name_IElementFactory = "IElementFactory";

    static PyObject* _new_IElementFactory(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IElementFactory);
        return nullptr;
    }

    static void _dealloc_IElementFactory(py::wrapper::Windows::UI::Xaml::IElementFactory* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IElementFactory_GetElement(py::wrapper::Windows::UI::Xaml::IElementFactory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.IElementFactory", L"GetElement", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::ElementFactoryGetArgs>(args, 0);

                return py::convert(self->obj.GetElement(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IElementFactory_RecycleElement(py::wrapper::Windows::UI::Xaml::IElementFactory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.IElementFactory", L"RecycleElement", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::ElementFactoryRecycleArgs>(args, 0);

                self->obj.RecycleElement(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IElementFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::IElementFactory>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IElementFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::IElementFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IElementFactory[] = {
        { "get_element", reinterpret_cast<PyCFunction>(IElementFactory_GetElement), METH_VARARGS, nullptr },
        { "recycle_element", reinterpret_cast<PyCFunction>(IElementFactory_RecycleElement), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IElementFactory, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IElementFactory), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IElementFactory[] = {
        { }
    };

    static PyType_Slot _type_slots_IElementFactory[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IElementFactory) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IElementFactory) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IElementFactory) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IElementFactory) },
        { },
    };

    static PyType_Spec type_spec_IElementFactory =
    {
        "_winrt_Windows_UI_Xaml.IElementFactory",
        sizeof(py::wrapper::Windows::UI::Xaml::IElementFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IElementFactory
    };

    // ----- CornerRadius struct --------------------
    static constexpr const char* const type_name_CornerRadius = "CornerRadius";

    PyObject* _new_CornerRadius(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::UI::Xaml::CornerRadius return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        double _TopLeft{};
        double _TopRight{};
        double _BottomRight{};
        double _BottomLeft{};

        static const char* kwlist[] = {"top_left", "top_right", "bottom_right", "bottom_left", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "dddd", const_cast<char**>(kwlist), &_TopLeft, &_TopRight, &_BottomRight, &_BottomLeft))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::UI::Xaml::CornerRadius return_value{ _TopLeft, _TopRight, _BottomRight, _BottomLeft };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_CornerRadius(py::wrapper::Windows::UI::Xaml::CornerRadius* self) noexcept
    {
    }

    static PyObject* CornerRadius_get_TopLeft(py::wrapper::Windows::UI::Xaml::CornerRadius* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TopLeft);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CornerRadius_set_TopLeft(py::wrapper::Windows::UI::Xaml::CornerRadius* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.TopLeft = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CornerRadius_get_TopRight(py::wrapper::Windows::UI::Xaml::CornerRadius* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TopRight);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CornerRadius_set_TopRight(py::wrapper::Windows::UI::Xaml::CornerRadius* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.TopRight = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CornerRadius_get_BottomRight(py::wrapper::Windows::UI::Xaml::CornerRadius* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BottomRight);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CornerRadius_set_BottomRight(py::wrapper::Windows::UI::Xaml::CornerRadius* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.BottomRight = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CornerRadius_get_BottomLeft(py::wrapper::Windows::UI::Xaml::CornerRadius* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BottomLeft);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CornerRadius_set_BottomLeft(py::wrapper::Windows::UI::Xaml::CornerRadius* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.BottomLeft = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_CornerRadius[] = {
        { "top_left", reinterpret_cast<getter>(CornerRadius_get_TopLeft), reinterpret_cast<setter>(CornerRadius_set_TopLeft), nullptr, nullptr },
        { "top_right", reinterpret_cast<getter>(CornerRadius_get_TopRight), reinterpret_cast<setter>(CornerRadius_set_TopRight), nullptr, nullptr },
        { "bottom_right", reinterpret_cast<getter>(CornerRadius_get_BottomRight), reinterpret_cast<setter>(CornerRadius_set_BottomRight), nullptr, nullptr },
        { "bottom_left", reinterpret_cast<getter>(CornerRadius_get_BottomLeft), reinterpret_cast<setter>(CornerRadius_set_BottomLeft), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CornerRadius[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CornerRadius) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CornerRadius) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CornerRadius) },
        { },
    };

    static PyType_Spec type_spec_CornerRadius =
    {
        "_winrt_Windows_UI_Xaml.CornerRadius",
        sizeof(py::wrapper::Windows::UI::Xaml::CornerRadius),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CornerRadius
    };

    // ----- Duration struct --------------------
    static constexpr const char* const type_name_Duration = "Duration";

    PyObject* _new_Duration(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::UI::Xaml::Duration return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        PyObject* _TimeSpan{};
        int32_t _Type{};

        static const char* kwlist[] = {"time_span", "type", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "Oi", const_cast<char**>(kwlist), &_TimeSpan, &_Type))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::UI::Xaml::Duration return_value{ py::converter<winrt::Windows::Foundation::TimeSpan>::convert_to(_TimeSpan), static_cast<winrt::Windows::UI::Xaml::DurationType>(_Type) };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_Duration(py::wrapper::Windows::UI::Xaml::Duration* self) noexcept
    {
    }

    static PyObject* Duration_get_TimeSpan(py::wrapper::Windows::UI::Xaml::Duration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TimeSpan);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Duration_set_TimeSpan(py::wrapper::Windows::UI::Xaml::Duration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.TimeSpan = py::converter<winrt::Windows::Foundation::TimeSpan>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Duration_get_Type(py::wrapper::Windows::UI::Xaml::Duration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Duration_set_Type(py::wrapper::Windows::UI::Xaml::Duration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Type = py::converter<winrt::Windows::UI::Xaml::DurationType>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_Duration[] = {
        { "time_span", reinterpret_cast<getter>(Duration_get_TimeSpan), reinterpret_cast<setter>(Duration_set_TimeSpan), nullptr, nullptr },
        { "type", reinterpret_cast<getter>(Duration_get_Type), reinterpret_cast<setter>(Duration_set_Type), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Duration[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Duration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Duration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Duration) },
        { },
    };

    static PyType_Spec type_spec_Duration =
    {
        "_winrt_Windows_UI_Xaml.Duration",
        sizeof(py::wrapper::Windows::UI::Xaml::Duration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Duration
    };

    // ----- GridLength struct --------------------
    static constexpr const char* const type_name_GridLength = "GridLength";

    PyObject* _new_GridLength(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::UI::Xaml::GridLength return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        double _Value{};
        int32_t _GridUnitType{};

        static const char* kwlist[] = {"value", "grid_unit_type", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "di", const_cast<char**>(kwlist), &_Value, &_GridUnitType))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::UI::Xaml::GridLength return_value{ _Value, static_cast<winrt::Windows::UI::Xaml::GridUnitType>(_GridUnitType) };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_GridLength(py::wrapper::Windows::UI::Xaml::GridLength* self) noexcept
    {
    }

    static PyObject* GridLength_get_Value(py::wrapper::Windows::UI::Xaml::GridLength* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridLength_set_Value(py::wrapper::Windows::UI::Xaml::GridLength* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Value = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridLength_get_GridUnitType(py::wrapper::Windows::UI::Xaml::GridLength* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.GridUnitType);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridLength_set_GridUnitType(py::wrapper::Windows::UI::Xaml::GridLength* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.GridUnitType = py::converter<winrt::Windows::UI::Xaml::GridUnitType>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_GridLength[] = {
        { "value", reinterpret_cast<getter>(GridLength_get_Value), reinterpret_cast<setter>(GridLength_set_Value), nullptr, nullptr },
        { "grid_unit_type", reinterpret_cast<getter>(GridLength_get_GridUnitType), reinterpret_cast<setter>(GridLength_set_GridUnitType), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GridLength[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GridLength) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GridLength) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GridLength) },
        { },
    };

    static PyType_Spec type_spec_GridLength =
    {
        "_winrt_Windows_UI_Xaml.GridLength",
        sizeof(py::wrapper::Windows::UI::Xaml::GridLength),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GridLength
    };

    // ----- Thickness struct --------------------
    static constexpr const char* const type_name_Thickness = "Thickness";

    PyObject* _new_Thickness(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::UI::Xaml::Thickness return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        double _Left{};
        double _Top{};
        double _Right{};
        double _Bottom{};

        static const char* kwlist[] = {"left", "top", "right", "bottom", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "dddd", const_cast<char**>(kwlist), &_Left, &_Top, &_Right, &_Bottom))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::UI::Xaml::Thickness return_value{ _Left, _Top, _Right, _Bottom };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_Thickness(py::wrapper::Windows::UI::Xaml::Thickness* self) noexcept
    {
    }

    static PyObject* Thickness_get_Left(py::wrapper::Windows::UI::Xaml::Thickness* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Left);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Thickness_set_Left(py::wrapper::Windows::UI::Xaml::Thickness* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Left = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Thickness_get_Top(py::wrapper::Windows::UI::Xaml::Thickness* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Top);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Thickness_set_Top(py::wrapper::Windows::UI::Xaml::Thickness* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Top = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Thickness_get_Right(py::wrapper::Windows::UI::Xaml::Thickness* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Right);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Thickness_set_Right(py::wrapper::Windows::UI::Xaml::Thickness* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Right = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Thickness_get_Bottom(py::wrapper::Windows::UI::Xaml::Thickness* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Bottom);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Thickness_set_Bottom(py::wrapper::Windows::UI::Xaml::Thickness* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Bottom = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_Thickness[] = {
        { "left", reinterpret_cast<getter>(Thickness_get_Left), reinterpret_cast<setter>(Thickness_set_Left), nullptr, nullptr },
        { "top", reinterpret_cast<getter>(Thickness_get_Top), reinterpret_cast<setter>(Thickness_set_Top), nullptr, nullptr },
        { "right", reinterpret_cast<getter>(Thickness_get_Right), reinterpret_cast<setter>(Thickness_set_Right), nullptr, nullptr },
        { "bottom", reinterpret_cast<getter>(Thickness_get_Bottom), reinterpret_cast<setter>(Thickness_set_Bottom), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Thickness[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Thickness) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Thickness) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Thickness) },
        { },
    };

    static PyType_Spec type_spec_Thickness =
    {
        "_winrt_Windows_UI_Xaml.Thickness",
        sizeof(py::wrapper::Windows::UI::Xaml::Thickness),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Thickness
    };

    // ----- Windows.UI.Xaml Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::UI::Xaml");

    static PyMethodDef module_methods[] = {
        {"_register_ApplicationHighContrastAdjustment", register_ApplicationHighContrastAdjustment, METH_O, "registers type"},
        {"_register_ApplicationRequiresPointerMode", register_ApplicationRequiresPointerMode, METH_O, "registers type"},
        {"_register_ApplicationTheme", register_ApplicationTheme, METH_O, "registers type"},
        {"_register_AutomationTextAttributesEnum", register_AutomationTextAttributesEnum, METH_O, "registers type"},
        {"_register_DurationType", register_DurationType, METH_O, "registers type"},
        {"_register_ElementHighContrastAdjustment", register_ElementHighContrastAdjustment, METH_O, "registers type"},
        {"_register_ElementSoundKind", register_ElementSoundKind, METH_O, "registers type"},
        {"_register_ElementSoundMode", register_ElementSoundMode, METH_O, "registers type"},
        {"_register_ElementSoundPlayerState", register_ElementSoundPlayerState, METH_O, "registers type"},
        {"_register_ElementSpatialAudioMode", register_ElementSpatialAudioMode, METH_O, "registers type"},
        {"_register_ElementTheme", register_ElementTheme, METH_O, "registers type"},
        {"_register_FlowDirection", register_FlowDirection, METH_O, "registers type"},
        {"_register_FocusState", register_FocusState, METH_O, "registers type"},
        {"_register_FocusVisualKind", register_FocusVisualKind, METH_O, "registers type"},
        {"_register_FontCapitals", register_FontCapitals, METH_O, "registers type"},
        {"_register_FontEastAsianLanguage", register_FontEastAsianLanguage, METH_O, "registers type"},
        {"_register_FontEastAsianWidths", register_FontEastAsianWidths, METH_O, "registers type"},
        {"_register_FontFraction", register_FontFraction, METH_O, "registers type"},
        {"_register_FontNumeralAlignment", register_FontNumeralAlignment, METH_O, "registers type"},
        {"_register_FontNumeralStyle", register_FontNumeralStyle, METH_O, "registers type"},
        {"_register_FontVariants", register_FontVariants, METH_O, "registers type"},
        {"_register_GridUnitType", register_GridUnitType, METH_O, "registers type"},
        {"_register_HorizontalAlignment", register_HorizontalAlignment, METH_O, "registers type"},
        {"_register_LineStackingStrategy", register_LineStackingStrategy, METH_O, "registers type"},
        {"_register_OpticalMarginAlignment", register_OpticalMarginAlignment, METH_O, "registers type"},
        {"_register_TextAlignment", register_TextAlignment, METH_O, "registers type"},
        {"_register_TextLineBounds", register_TextLineBounds, METH_O, "registers type"},
        {"_register_TextReadingOrder", register_TextReadingOrder, METH_O, "registers type"},
        {"_register_TextTrimming", register_TextTrimming, METH_O, "registers type"},
        {"_register_TextWrapping", register_TextWrapping, METH_O, "registers type"},
        {"_register_Vector3TransitionComponents", register_Vector3TransitionComponents, METH_O, "registers type"},
        {"_register_VerticalAlignment", register_VerticalAlignment, METH_O, "registers type"},
        {"_register_Visibility", register_Visibility, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_ApplicationHighContrastAdjustment);
        Py_VISIT(state->type_ApplicationRequiresPointerMode);
        Py_VISIT(state->type_ApplicationTheme);
        Py_VISIT(state->type_AutomationTextAttributesEnum);
        Py_VISIT(state->type_DurationType);
        Py_VISIT(state->type_ElementHighContrastAdjustment);
        Py_VISIT(state->type_ElementSoundKind);
        Py_VISIT(state->type_ElementSoundMode);
        Py_VISIT(state->type_ElementSoundPlayerState);
        Py_VISIT(state->type_ElementSpatialAudioMode);
        Py_VISIT(state->type_ElementTheme);
        Py_VISIT(state->type_FlowDirection);
        Py_VISIT(state->type_FocusState);
        Py_VISIT(state->type_FocusVisualKind);
        Py_VISIT(state->type_FontCapitals);
        Py_VISIT(state->type_FontEastAsianLanguage);
        Py_VISIT(state->type_FontEastAsianWidths);
        Py_VISIT(state->type_FontFraction);
        Py_VISIT(state->type_FontNumeralAlignment);
        Py_VISIT(state->type_FontNumeralStyle);
        Py_VISIT(state->type_FontVariants);
        Py_VISIT(state->type_GridUnitType);
        Py_VISIT(state->type_HorizontalAlignment);
        Py_VISIT(state->type_LineStackingStrategy);
        Py_VISIT(state->type_OpticalMarginAlignment);
        Py_VISIT(state->type_TextAlignment);
        Py_VISIT(state->type_TextLineBounds);
        Py_VISIT(state->type_TextReadingOrder);
        Py_VISIT(state->type_TextTrimming);
        Py_VISIT(state->type_TextWrapping);
        Py_VISIT(state->type_Vector3TransitionComponents);
        Py_VISIT(state->type_VerticalAlignment);
        Py_VISIT(state->type_Visibility);
        Py_VISIT(state->type_AdaptiveTrigger);
        Py_VISIT(state->type_Application);
        Py_VISIT(state->type_ApplicationInitializationCallbackParams);
        Py_VISIT(state->type_BindingFailedEventArgs);
        Py_VISIT(state->type_BringIntoViewOptions);
        Py_VISIT(state->type_BringIntoViewRequestedEventArgs);
        Py_VISIT(state->type_BrushTransition);
        Py_VISIT(state->type_ColorPaletteResources);
        Py_VISIT(state->type_CornerRadiusHelper);
        Py_VISIT(state->type_DataContextChangedEventArgs);
        Py_VISIT(state->type_DataTemplate);
        Py_VISIT(state->type_DataTemplateKey);
        Py_VISIT(state->type_DebugSettings);
        Py_VISIT(state->type_DependencyObject);
        Py_VISIT(state->type_DependencyObjectCollection);
        Py_VISIT(state->type_DependencyProperty);
        Py_VISIT(state->type_DependencyPropertyChangedEventArgs);
        Py_VISIT(state->type_DispatcherTimer);
        Py_VISIT(state->type_DragEventArgs);
        Py_VISIT(state->type_DragOperationDeferral);
        Py_VISIT(state->type_DragStartingEventArgs);
        Py_VISIT(state->type_DragUI);
        Py_VISIT(state->type_DragUIOverride);
        Py_VISIT(state->type_DropCompletedEventArgs);
        Py_VISIT(state->type_DurationHelper);
        Py_VISIT(state->type_EffectiveViewportChangedEventArgs);
        Py_VISIT(state->type_ElementFactoryGetArgs);
        Py_VISIT(state->type_ElementFactoryRecycleArgs);
        Py_VISIT(state->type_ElementSoundPlayer);
        Py_VISIT(state->type_EventTrigger);
        Py_VISIT(state->type_ExceptionRoutedEventArgs);
        Py_VISIT(state->type_FrameworkElement);
        Py_VISIT(state->type_FrameworkTemplate);
        Py_VISIT(state->type_FrameworkView);
        Py_VISIT(state->type_FrameworkViewSource);
        Py_VISIT(state->type_GridLengthHelper);
        Py_VISIT(state->type_MediaFailedRoutedEventArgs);
        Py_VISIT(state->type_PointHelper);
        Py_VISIT(state->type_PropertyMetadata);
        Py_VISIT(state->type_PropertyPath);
        Py_VISIT(state->type_RectHelper);
        Py_VISIT(state->type_ResourceDictionary);
        Py_VISIT(state->type_RoutedEvent);
        Py_VISIT(state->type_RoutedEventArgs);
        Py_VISIT(state->type_ScalarTransition);
        Py_VISIT(state->type_Setter);
        Py_VISIT(state->type_SetterBase);
        Py_VISIT(state->type_SetterBaseCollection);
        Py_VISIT(state->type_SizeChangedEventArgs);
        Py_VISIT(state->type_SizeHelper);
        Py_VISIT(state->type_StateTrigger);
        Py_VISIT(state->type_StateTriggerBase);
        Py_VISIT(state->type_Style);
        Py_VISIT(state->type_TargetPropertyPath);
        Py_VISIT(state->type_ThicknessHelper);
        Py_VISIT(state->type_TriggerAction);
        Py_VISIT(state->type_TriggerActionCollection);
        Py_VISIT(state->type_TriggerBase);
        Py_VISIT(state->type_TriggerCollection);
        Py_VISIT(state->type_UIElement);
        Py_VISIT(state->type_UIElementWeakCollection);
        Py_VISIT(state->type_UnhandledExceptionEventArgs);
        Py_VISIT(state->type_Vector3Transition);
        Py_VISIT(state->type_VisualState);
        Py_VISIT(state->type_VisualStateChangedEventArgs);
        Py_VISIT(state->type_VisualStateGroup);
        Py_VISIT(state->type_VisualStateManager);
        Py_VISIT(state->type_VisualTransition);
        Py_VISIT(state->type_Window);
        Py_VISIT(state->type_WindowCreatedEventArgs);
        Py_VISIT(state->type_XamlRoot);
        Py_VISIT(state->type_XamlRootChangedEventArgs);
        Py_VISIT(state->type_IDataTemplateExtension);
        Py_VISIT(state->type_IElementFactory);
        Py_VISIT(state->type_CornerRadius);
        Py_VISIT(state->type_Duration);
        Py_VISIT(state->type_GridLength);
        Py_VISIT(state->type_Thickness);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_ApplicationHighContrastAdjustment);
        Py_CLEAR(state->type_ApplicationRequiresPointerMode);
        Py_CLEAR(state->type_ApplicationTheme);
        Py_CLEAR(state->type_AutomationTextAttributesEnum);
        Py_CLEAR(state->type_DurationType);
        Py_CLEAR(state->type_ElementHighContrastAdjustment);
        Py_CLEAR(state->type_ElementSoundKind);
        Py_CLEAR(state->type_ElementSoundMode);
        Py_CLEAR(state->type_ElementSoundPlayerState);
        Py_CLEAR(state->type_ElementSpatialAudioMode);
        Py_CLEAR(state->type_ElementTheme);
        Py_CLEAR(state->type_FlowDirection);
        Py_CLEAR(state->type_FocusState);
        Py_CLEAR(state->type_FocusVisualKind);
        Py_CLEAR(state->type_FontCapitals);
        Py_CLEAR(state->type_FontEastAsianLanguage);
        Py_CLEAR(state->type_FontEastAsianWidths);
        Py_CLEAR(state->type_FontFraction);
        Py_CLEAR(state->type_FontNumeralAlignment);
        Py_CLEAR(state->type_FontNumeralStyle);
        Py_CLEAR(state->type_FontVariants);
        Py_CLEAR(state->type_GridUnitType);
        Py_CLEAR(state->type_HorizontalAlignment);
        Py_CLEAR(state->type_LineStackingStrategy);
        Py_CLEAR(state->type_OpticalMarginAlignment);
        Py_CLEAR(state->type_TextAlignment);
        Py_CLEAR(state->type_TextLineBounds);
        Py_CLEAR(state->type_TextReadingOrder);
        Py_CLEAR(state->type_TextTrimming);
        Py_CLEAR(state->type_TextWrapping);
        Py_CLEAR(state->type_Vector3TransitionComponents);
        Py_CLEAR(state->type_VerticalAlignment);
        Py_CLEAR(state->type_Visibility);
        Py_CLEAR(state->type_AdaptiveTrigger);
        Py_CLEAR(state->type_Application);
        Py_CLEAR(state->type_ApplicationInitializationCallbackParams);
        Py_CLEAR(state->type_BindingFailedEventArgs);
        Py_CLEAR(state->type_BringIntoViewOptions);
        Py_CLEAR(state->type_BringIntoViewRequestedEventArgs);
        Py_CLEAR(state->type_BrushTransition);
        Py_CLEAR(state->type_ColorPaletteResources);
        Py_CLEAR(state->type_CornerRadiusHelper);
        Py_CLEAR(state->type_DataContextChangedEventArgs);
        Py_CLEAR(state->type_DataTemplate);
        Py_CLEAR(state->type_DataTemplateKey);
        Py_CLEAR(state->type_DebugSettings);
        Py_CLEAR(state->type_DependencyObject);
        Py_CLEAR(state->type_DependencyObjectCollection);
        Py_CLEAR(state->type_DependencyProperty);
        Py_CLEAR(state->type_DependencyPropertyChangedEventArgs);
        Py_CLEAR(state->type_DispatcherTimer);
        Py_CLEAR(state->type_DragEventArgs);
        Py_CLEAR(state->type_DragOperationDeferral);
        Py_CLEAR(state->type_DragStartingEventArgs);
        Py_CLEAR(state->type_DragUI);
        Py_CLEAR(state->type_DragUIOverride);
        Py_CLEAR(state->type_DropCompletedEventArgs);
        Py_CLEAR(state->type_DurationHelper);
        Py_CLEAR(state->type_EffectiveViewportChangedEventArgs);
        Py_CLEAR(state->type_ElementFactoryGetArgs);
        Py_CLEAR(state->type_ElementFactoryRecycleArgs);
        Py_CLEAR(state->type_ElementSoundPlayer);
        Py_CLEAR(state->type_EventTrigger);
        Py_CLEAR(state->type_ExceptionRoutedEventArgs);
        Py_CLEAR(state->type_FrameworkElement);
        Py_CLEAR(state->type_FrameworkTemplate);
        Py_CLEAR(state->type_FrameworkView);
        Py_CLEAR(state->type_FrameworkViewSource);
        Py_CLEAR(state->type_GridLengthHelper);
        Py_CLEAR(state->type_MediaFailedRoutedEventArgs);
        Py_CLEAR(state->type_PointHelper);
        Py_CLEAR(state->type_PropertyMetadata);
        Py_CLEAR(state->type_PropertyPath);
        Py_CLEAR(state->type_RectHelper);
        Py_CLEAR(state->type_ResourceDictionary);
        Py_CLEAR(state->type_RoutedEvent);
        Py_CLEAR(state->type_RoutedEventArgs);
        Py_CLEAR(state->type_ScalarTransition);
        Py_CLEAR(state->type_Setter);
        Py_CLEAR(state->type_SetterBase);
        Py_CLEAR(state->type_SetterBaseCollection);
        Py_CLEAR(state->type_SizeChangedEventArgs);
        Py_CLEAR(state->type_SizeHelper);
        Py_CLEAR(state->type_StateTrigger);
        Py_CLEAR(state->type_StateTriggerBase);
        Py_CLEAR(state->type_Style);
        Py_CLEAR(state->type_TargetPropertyPath);
        Py_CLEAR(state->type_ThicknessHelper);
        Py_CLEAR(state->type_TriggerAction);
        Py_CLEAR(state->type_TriggerActionCollection);
        Py_CLEAR(state->type_TriggerBase);
        Py_CLEAR(state->type_TriggerCollection);
        Py_CLEAR(state->type_UIElement);
        Py_CLEAR(state->type_UIElementWeakCollection);
        Py_CLEAR(state->type_UnhandledExceptionEventArgs);
        Py_CLEAR(state->type_Vector3Transition);
        Py_CLEAR(state->type_VisualState);
        Py_CLEAR(state->type_VisualStateChangedEventArgs);
        Py_CLEAR(state->type_VisualStateGroup);
        Py_CLEAR(state->type_VisualStateManager);
        Py_CLEAR(state->type_VisualTransition);
        Py_CLEAR(state->type_Window);
        Py_CLEAR(state->type_WindowCreatedEventArgs);
        Py_CLEAR(state->type_XamlRoot);
        Py_CLEAR(state->type_XamlRootChangedEventArgs);
        Py_CLEAR(state->type_IDataTemplateExtension);
        Py_CLEAR(state->type_IElementFactory);
        Py_CLEAR(state->type_CornerRadius);
        Py_CLEAR(state->type_Duration);
        Py_CLEAR(state->type_GridLength);
        Py_CLEAR(state->type_Thickness);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_Windows_UI_Xaml",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::UI::Xaml

PyMODINIT_FUNC PyInit__winrt_Windows_UI_Xaml(void) noexcept
{
    using namespace py::cpp::Windows::UI::Xaml;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    WINRT_ASSERT(state);

    py::pyobj_handle type_AdaptiveTrigger_Meta{PyType_FromSpec(&type_spec_AdaptiveTrigger_Meta)};
    if (!type_AdaptiveTrigger_Meta)
    {
        return nullptr;
    }

    state->type_AdaptiveTrigger = py::register_python_type(module.get(), type_name_AdaptiveTrigger, &type_spec_AdaptiveTrigger, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AdaptiveTrigger_Meta.get()));
    if (!state->type_AdaptiveTrigger)
    {
        return nullptr;
    }

    py::pyobj_handle type_Application_Meta{PyType_FromSpec(&type_spec_Application_Meta)};
    if (!type_Application_Meta)
    {
        return nullptr;
    }

    state->type_Application = py::register_python_type(module.get(), type_name_Application, &type_spec_Application, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Application_Meta.get()));
    if (!state->type_Application)
    {
        return nullptr;
    }

    state->type_ApplicationInitializationCallbackParams = py::register_python_type(module.get(), type_name_ApplicationInitializationCallbackParams, &type_spec_ApplicationInitializationCallbackParams, object_bases.get(), nullptr);
    if (!state->type_ApplicationInitializationCallbackParams)
    {
        return nullptr;
    }

    state->type_BindingFailedEventArgs = py::register_python_type(module.get(), type_name_BindingFailedEventArgs, &type_spec_BindingFailedEventArgs, object_bases.get(), nullptr);
    if (!state->type_BindingFailedEventArgs)
    {
        return nullptr;
    }

    state->type_BringIntoViewOptions = py::register_python_type(module.get(), type_name_BringIntoViewOptions, &type_spec_BringIntoViewOptions, object_bases.get(), nullptr);
    if (!state->type_BringIntoViewOptions)
    {
        return nullptr;
    }

    state->type_BringIntoViewRequestedEventArgs = py::register_python_type(module.get(), type_name_BringIntoViewRequestedEventArgs, &type_spec_BringIntoViewRequestedEventArgs, object_bases.get(), nullptr);
    if (!state->type_BringIntoViewRequestedEventArgs)
    {
        return nullptr;
    }

    state->type_BrushTransition = py::register_python_type(module.get(), type_name_BrushTransition, &type_spec_BrushTransition, object_bases.get(), nullptr);
    if (!state->type_BrushTransition)
    {
        return nullptr;
    }

    state->type_ColorPaletteResources = py::register_python_type(module.get(), type_name_ColorPaletteResources, &type_spec_ColorPaletteResources, object_bases.get(), nullptr);
    if (!state->type_ColorPaletteResources)
    {
        return nullptr;
    }

    state->type_CornerRadiusHelper = py::register_python_type(module.get(), type_name_CornerRadiusHelper, &type_spec_CornerRadiusHelper, object_bases.get(), nullptr);
    if (!state->type_CornerRadiusHelper)
    {
        return nullptr;
    }

    state->type_DataContextChangedEventArgs = py::register_python_type(module.get(), type_name_DataContextChangedEventArgs, &type_spec_DataContextChangedEventArgs, object_bases.get(), nullptr);
    if (!state->type_DataContextChangedEventArgs)
    {
        return nullptr;
    }

    py::pyobj_handle type_DataTemplate_Meta{PyType_FromSpec(&type_spec_DataTemplate_Meta)};
    if (!type_DataTemplate_Meta)
    {
        return nullptr;
    }

    state->type_DataTemplate = py::register_python_type(module.get(), type_name_DataTemplate, &type_spec_DataTemplate, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_DataTemplate_Meta.get()));
    if (!state->type_DataTemplate)
    {
        return nullptr;
    }

    state->type_DataTemplateKey = py::register_python_type(module.get(), type_name_DataTemplateKey, &type_spec_DataTemplateKey, object_bases.get(), nullptr);
    if (!state->type_DataTemplateKey)
    {
        return nullptr;
    }

    state->type_DebugSettings = py::register_python_type(module.get(), type_name_DebugSettings, &type_spec_DebugSettings, object_bases.get(), nullptr);
    if (!state->type_DebugSettings)
    {
        return nullptr;
    }

    state->type_DependencyObject = py::register_python_type(module.get(), type_name_DependencyObject, &type_spec_DependencyObject, object_bases.get(), nullptr);
    if (!state->type_DependencyObject)
    {
        return nullptr;
    }

    state->type_DependencyObjectCollection = py::register_python_type(module.get(), type_name_DependencyObjectCollection, &type_spec_DependencyObjectCollection, object_bases.get(), nullptr);
    if (!state->type_DependencyObjectCollection)
    {
        return nullptr;
    }

    py::pyobj_handle type_DependencyProperty_Meta{PyType_FromSpec(&type_spec_DependencyProperty_Meta)};
    if (!type_DependencyProperty_Meta)
    {
        return nullptr;
    }

    state->type_DependencyProperty = py::register_python_type(module.get(), type_name_DependencyProperty, &type_spec_DependencyProperty, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_DependencyProperty_Meta.get()));
    if (!state->type_DependencyProperty)
    {
        return nullptr;
    }

    state->type_DependencyPropertyChangedEventArgs = py::register_python_type(module.get(), type_name_DependencyPropertyChangedEventArgs, &type_spec_DependencyPropertyChangedEventArgs, object_bases.get(), nullptr);
    if (!state->type_DependencyPropertyChangedEventArgs)
    {
        return nullptr;
    }

    state->type_DispatcherTimer = py::register_python_type(module.get(), type_name_DispatcherTimer, &type_spec_DispatcherTimer, object_bases.get(), nullptr);
    if (!state->type_DispatcherTimer)
    {
        return nullptr;
    }

    state->type_DragEventArgs = py::register_python_type(module.get(), type_name_DragEventArgs, &type_spec_DragEventArgs, object_bases.get(), nullptr);
    if (!state->type_DragEventArgs)
    {
        return nullptr;
    }

    state->type_DragOperationDeferral = py::register_python_type(module.get(), type_name_DragOperationDeferral, &type_spec_DragOperationDeferral, object_bases.get(), nullptr);
    if (!state->type_DragOperationDeferral)
    {
        return nullptr;
    }

    state->type_DragStartingEventArgs = py::register_python_type(module.get(), type_name_DragStartingEventArgs, &type_spec_DragStartingEventArgs, object_bases.get(), nullptr);
    if (!state->type_DragStartingEventArgs)
    {
        return nullptr;
    }

    state->type_DragUI = py::register_python_type(module.get(), type_name_DragUI, &type_spec_DragUI, object_bases.get(), nullptr);
    if (!state->type_DragUI)
    {
        return nullptr;
    }

    state->type_DragUIOverride = py::register_python_type(module.get(), type_name_DragUIOverride, &type_spec_DragUIOverride, object_bases.get(), nullptr);
    if (!state->type_DragUIOverride)
    {
        return nullptr;
    }

    state->type_DropCompletedEventArgs = py::register_python_type(module.get(), type_name_DropCompletedEventArgs, &type_spec_DropCompletedEventArgs, object_bases.get(), nullptr);
    if (!state->type_DropCompletedEventArgs)
    {
        return nullptr;
    }

    py::pyobj_handle type_DurationHelper_Meta{PyType_FromSpec(&type_spec_DurationHelper_Meta)};
    if (!type_DurationHelper_Meta)
    {
        return nullptr;
    }

    state->type_DurationHelper = py::register_python_type(module.get(), type_name_DurationHelper, &type_spec_DurationHelper, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_DurationHelper_Meta.get()));
    if (!state->type_DurationHelper)
    {
        return nullptr;
    }

    state->type_EffectiveViewportChangedEventArgs = py::register_python_type(module.get(), type_name_EffectiveViewportChangedEventArgs, &type_spec_EffectiveViewportChangedEventArgs, object_bases.get(), nullptr);
    if (!state->type_EffectiveViewportChangedEventArgs)
    {
        return nullptr;
    }

    state->type_ElementFactoryGetArgs = py::register_python_type(module.get(), type_name_ElementFactoryGetArgs, &type_spec_ElementFactoryGetArgs, object_bases.get(), nullptr);
    if (!state->type_ElementFactoryGetArgs)
    {
        return nullptr;
    }

    state->type_ElementFactoryRecycleArgs = py::register_python_type(module.get(), type_name_ElementFactoryRecycleArgs, &type_spec_ElementFactoryRecycleArgs, object_bases.get(), nullptr);
    if (!state->type_ElementFactoryRecycleArgs)
    {
        return nullptr;
    }

    py::pyobj_handle type_ElementSoundPlayer_Meta{PyType_FromSpec(&type_spec_ElementSoundPlayer_Meta)};
    if (!type_ElementSoundPlayer_Meta)
    {
        return nullptr;
    }

    state->type_ElementSoundPlayer = py::register_python_type(module.get(), type_name_ElementSoundPlayer, &type_spec_ElementSoundPlayer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ElementSoundPlayer_Meta.get()));
    if (!state->type_ElementSoundPlayer)
    {
        return nullptr;
    }

    state->type_EventTrigger = py::register_python_type(module.get(), type_name_EventTrigger, &type_spec_EventTrigger, object_bases.get(), nullptr);
    if (!state->type_EventTrigger)
    {
        return nullptr;
    }

    state->type_ExceptionRoutedEventArgs = py::register_python_type(module.get(), type_name_ExceptionRoutedEventArgs, &type_spec_ExceptionRoutedEventArgs, object_bases.get(), nullptr);
    if (!state->type_ExceptionRoutedEventArgs)
    {
        return nullptr;
    }

    py::pyobj_handle type_FrameworkElement_Meta{PyType_FromSpec(&type_spec_FrameworkElement_Meta)};
    if (!type_FrameworkElement_Meta)
    {
        return nullptr;
    }

    state->type_FrameworkElement = py::register_python_type(module.get(), type_name_FrameworkElement, &type_spec_FrameworkElement, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_FrameworkElement_Meta.get()));
    if (!state->type_FrameworkElement)
    {
        return nullptr;
    }

    state->type_FrameworkTemplate = py::register_python_type(module.get(), type_name_FrameworkTemplate, &type_spec_FrameworkTemplate, object_bases.get(), nullptr);
    if (!state->type_FrameworkTemplate)
    {
        return nullptr;
    }

    state->type_FrameworkView = py::register_python_type(module.get(), type_name_FrameworkView, &type_spec_FrameworkView, object_bases.get(), nullptr);
    if (!state->type_FrameworkView)
    {
        return nullptr;
    }

    state->type_FrameworkViewSource = py::register_python_type(module.get(), type_name_FrameworkViewSource, &type_spec_FrameworkViewSource, object_bases.get(), nullptr);
    if (!state->type_FrameworkViewSource)
    {
        return nullptr;
    }

    py::pyobj_handle type_GridLengthHelper_Meta{PyType_FromSpec(&type_spec_GridLengthHelper_Meta)};
    if (!type_GridLengthHelper_Meta)
    {
        return nullptr;
    }

    state->type_GridLengthHelper = py::register_python_type(module.get(), type_name_GridLengthHelper, &type_spec_GridLengthHelper, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_GridLengthHelper_Meta.get()));
    if (!state->type_GridLengthHelper)
    {
        return nullptr;
    }

    state->type_MediaFailedRoutedEventArgs = py::register_python_type(module.get(), type_name_MediaFailedRoutedEventArgs, &type_spec_MediaFailedRoutedEventArgs, object_bases.get(), nullptr);
    if (!state->type_MediaFailedRoutedEventArgs)
    {
        return nullptr;
    }

    state->type_PointHelper = py::register_python_type(module.get(), type_name_PointHelper, &type_spec_PointHelper, object_bases.get(), nullptr);
    if (!state->type_PointHelper)
    {
        return nullptr;
    }

    state->type_PropertyMetadata = py::register_python_type(module.get(), type_name_PropertyMetadata, &type_spec_PropertyMetadata, object_bases.get(), nullptr);
    if (!state->type_PropertyMetadata)
    {
        return nullptr;
    }

    state->type_PropertyPath = py::register_python_type(module.get(), type_name_PropertyPath, &type_spec_PropertyPath, object_bases.get(), nullptr);
    if (!state->type_PropertyPath)
    {
        return nullptr;
    }

    py::pyobj_handle type_RectHelper_Meta{PyType_FromSpec(&type_spec_RectHelper_Meta)};
    if (!type_RectHelper_Meta)
    {
        return nullptr;
    }

    state->type_RectHelper = py::register_python_type(module.get(), type_name_RectHelper, &type_spec_RectHelper, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RectHelper_Meta.get()));
    if (!state->type_RectHelper)
    {
        return nullptr;
    }

    state->type_ResourceDictionary = py::register_python_type(module.get(), type_name_ResourceDictionary, &type_spec_ResourceDictionary, object_bases.get(), nullptr);
    if (!state->type_ResourceDictionary)
    {
        return nullptr;
    }

    state->type_RoutedEvent = py::register_python_type(module.get(), type_name_RoutedEvent, &type_spec_RoutedEvent, object_bases.get(), nullptr);
    if (!state->type_RoutedEvent)
    {
        return nullptr;
    }

    state->type_RoutedEventArgs = py::register_python_type(module.get(), type_name_RoutedEventArgs, &type_spec_RoutedEventArgs, object_bases.get(), nullptr);
    if (!state->type_RoutedEventArgs)
    {
        return nullptr;
    }

    state->type_ScalarTransition = py::register_python_type(module.get(), type_name_ScalarTransition, &type_spec_ScalarTransition, object_bases.get(), nullptr);
    if (!state->type_ScalarTransition)
    {
        return nullptr;
    }

    state->type_Setter = py::register_python_type(module.get(), type_name_Setter, &type_spec_Setter, object_bases.get(), nullptr);
    if (!state->type_Setter)
    {
        return nullptr;
    }

    state->type_SetterBase = py::register_python_type(module.get(), type_name_SetterBase, &type_spec_SetterBase, object_bases.get(), nullptr);
    if (!state->type_SetterBase)
    {
        return nullptr;
    }

    state->type_SetterBaseCollection = py::register_python_type(module.get(), type_name_SetterBaseCollection, &type_spec_SetterBaseCollection, object_bases.get(), nullptr);
    if (!state->type_SetterBaseCollection)
    {
        return nullptr;
    }

    state->type_SizeChangedEventArgs = py::register_python_type(module.get(), type_name_SizeChangedEventArgs, &type_spec_SizeChangedEventArgs, object_bases.get(), nullptr);
    if (!state->type_SizeChangedEventArgs)
    {
        return nullptr;
    }

    py::pyobj_handle type_SizeHelper_Meta{PyType_FromSpec(&type_spec_SizeHelper_Meta)};
    if (!type_SizeHelper_Meta)
    {
        return nullptr;
    }

    state->type_SizeHelper = py::register_python_type(module.get(), type_name_SizeHelper, &type_spec_SizeHelper, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SizeHelper_Meta.get()));
    if (!state->type_SizeHelper)
    {
        return nullptr;
    }

    py::pyobj_handle type_StateTrigger_Meta{PyType_FromSpec(&type_spec_StateTrigger_Meta)};
    if (!type_StateTrigger_Meta)
    {
        return nullptr;
    }

    state->type_StateTrigger = py::register_python_type(module.get(), type_name_StateTrigger, &type_spec_StateTrigger, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_StateTrigger_Meta.get()));
    if (!state->type_StateTrigger)
    {
        return nullptr;
    }

    state->type_StateTriggerBase = py::register_python_type(module.get(), type_name_StateTriggerBase, &type_spec_StateTriggerBase, object_bases.get(), nullptr);
    if (!state->type_StateTriggerBase)
    {
        return nullptr;
    }

    state->type_Style = py::register_python_type(module.get(), type_name_Style, &type_spec_Style, object_bases.get(), nullptr);
    if (!state->type_Style)
    {
        return nullptr;
    }

    state->type_TargetPropertyPath = py::register_python_type(module.get(), type_name_TargetPropertyPath, &type_spec_TargetPropertyPath, object_bases.get(), nullptr);
    if (!state->type_TargetPropertyPath)
    {
        return nullptr;
    }

    state->type_ThicknessHelper = py::register_python_type(module.get(), type_name_ThicknessHelper, &type_spec_ThicknessHelper, object_bases.get(), nullptr);
    if (!state->type_ThicknessHelper)
    {
        return nullptr;
    }

    state->type_TriggerAction = py::register_python_type(module.get(), type_name_TriggerAction, &type_spec_TriggerAction, object_bases.get(), nullptr);
    if (!state->type_TriggerAction)
    {
        return nullptr;
    }

    state->type_TriggerActionCollection = py::register_python_type(module.get(), type_name_TriggerActionCollection, &type_spec_TriggerActionCollection, object_bases.get(), nullptr);
    if (!state->type_TriggerActionCollection)
    {
        return nullptr;
    }

    state->type_TriggerBase = py::register_python_type(module.get(), type_name_TriggerBase, &type_spec_TriggerBase, object_bases.get(), nullptr);
    if (!state->type_TriggerBase)
    {
        return nullptr;
    }

    state->type_TriggerCollection = py::register_python_type(module.get(), type_name_TriggerCollection, &type_spec_TriggerCollection, object_bases.get(), nullptr);
    if (!state->type_TriggerCollection)
    {
        return nullptr;
    }

    py::pyobj_handle type_UIElement_Meta{PyType_FromSpec(&type_spec_UIElement_Meta)};
    if (!type_UIElement_Meta)
    {
        return nullptr;
    }

    state->type_UIElement = py::register_python_type(module.get(), type_name_UIElement, &type_spec_UIElement, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_UIElement_Meta.get()));
    if (!state->type_UIElement)
    {
        return nullptr;
    }

    state->type_UIElementWeakCollection = py::register_python_type(module.get(), type_name_UIElementWeakCollection, &type_spec_UIElementWeakCollection, object_bases.get(), nullptr);
    if (!state->type_UIElementWeakCollection)
    {
        return nullptr;
    }

    state->type_UnhandledExceptionEventArgs = py::register_python_type(module.get(), type_name_UnhandledExceptionEventArgs, &type_spec_UnhandledExceptionEventArgs, object_bases.get(), nullptr);
    if (!state->type_UnhandledExceptionEventArgs)
    {
        return nullptr;
    }

    state->type_Vector3Transition = py::register_python_type(module.get(), type_name_Vector3Transition, &type_spec_Vector3Transition, object_bases.get(), nullptr);
    if (!state->type_Vector3Transition)
    {
        return nullptr;
    }

    state->type_VisualState = py::register_python_type(module.get(), type_name_VisualState, &type_spec_VisualState, object_bases.get(), nullptr);
    if (!state->type_VisualState)
    {
        return nullptr;
    }

    state->type_VisualStateChangedEventArgs = py::register_python_type(module.get(), type_name_VisualStateChangedEventArgs, &type_spec_VisualStateChangedEventArgs, object_bases.get(), nullptr);
    if (!state->type_VisualStateChangedEventArgs)
    {
        return nullptr;
    }

    state->type_VisualStateGroup = py::register_python_type(module.get(), type_name_VisualStateGroup, &type_spec_VisualStateGroup, object_bases.get(), nullptr);
    if (!state->type_VisualStateGroup)
    {
        return nullptr;
    }

    py::pyobj_handle type_VisualStateManager_Meta{PyType_FromSpec(&type_spec_VisualStateManager_Meta)};
    if (!type_VisualStateManager_Meta)
    {
        return nullptr;
    }

    state->type_VisualStateManager = py::register_python_type(module.get(), type_name_VisualStateManager, &type_spec_VisualStateManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_VisualStateManager_Meta.get()));
    if (!state->type_VisualStateManager)
    {
        return nullptr;
    }

    state->type_VisualTransition = py::register_python_type(module.get(), type_name_VisualTransition, &type_spec_VisualTransition, object_bases.get(), nullptr);
    if (!state->type_VisualTransition)
    {
        return nullptr;
    }

    py::pyobj_handle type_Window_Meta{PyType_FromSpec(&type_spec_Window_Meta)};
    if (!type_Window_Meta)
    {
        return nullptr;
    }

    state->type_Window = py::register_python_type(module.get(), type_name_Window, &type_spec_Window, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Window_Meta.get()));
    if (!state->type_Window)
    {
        return nullptr;
    }

    state->type_WindowCreatedEventArgs = py::register_python_type(module.get(), type_name_WindowCreatedEventArgs, &type_spec_WindowCreatedEventArgs, object_bases.get(), nullptr);
    if (!state->type_WindowCreatedEventArgs)
    {
        return nullptr;
    }

    state->type_XamlRoot = py::register_python_type(module.get(), type_name_XamlRoot, &type_spec_XamlRoot, object_bases.get(), nullptr);
    if (!state->type_XamlRoot)
    {
        return nullptr;
    }

    state->type_XamlRootChangedEventArgs = py::register_python_type(module.get(), type_name_XamlRootChangedEventArgs, &type_spec_XamlRootChangedEventArgs, object_bases.get(), nullptr);
    if (!state->type_XamlRootChangedEventArgs)
    {
        return nullptr;
    }

    state->type_IDataTemplateExtension = py::register_python_type(module.get(), type_name_IDataTemplateExtension, &type_spec_IDataTemplateExtension, object_bases.get(), nullptr);
    if (!state->type_IDataTemplateExtension)
    {
        return nullptr;
    }

    state->type_IElementFactory = py::register_python_type(module.get(), type_name_IElementFactory, &type_spec_IElementFactory, object_bases.get(), nullptr);
    if (!state->type_IElementFactory)
    {
        return nullptr;
    }

    state->type_CornerRadius = py::register_python_type(module.get(), type_name_CornerRadius, &type_spec_CornerRadius, nullptr, nullptr);
    if (!state->type_CornerRadius)
    {
        return nullptr;
    }

    state->type_Duration = py::register_python_type(module.get(), type_name_Duration, &type_spec_Duration, nullptr, nullptr);
    if (!state->type_Duration)
    {
        return nullptr;
    }

    state->type_GridLength = py::register_python_type(module.get(), type_name_GridLength, &type_spec_GridLength, nullptr, nullptr);
    if (!state->type_GridLength)
    {
        return nullptr;
    }

    state->type_Thickness = py::register_python_type(module.get(), type_name_Thickness, &type_spec_Thickness, nullptr, nullptr);
    if (!state->type_Thickness)
    {
        return nullptr;
    }


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::UI::Xaml::ApplicationHighContrastAdjustment>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ApplicationHighContrastAdjustment;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::ApplicationHighContrastAdjustment is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Xaml::ApplicationRequiresPointerMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ApplicationRequiresPointerMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::ApplicationRequiresPointerMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Xaml::ApplicationTheme>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ApplicationTheme;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::ApplicationTheme is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Xaml::AutomationTextAttributesEnum>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AutomationTextAttributesEnum;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::AutomationTextAttributesEnum is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Xaml::DurationType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DurationType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::DurationType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Xaml::ElementHighContrastAdjustment>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ElementHighContrastAdjustment;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::ElementHighContrastAdjustment is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Xaml::ElementSoundKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ElementSoundKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::ElementSoundKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Xaml::ElementSoundMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ElementSoundMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::ElementSoundMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Xaml::ElementSoundPlayerState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ElementSoundPlayerState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::ElementSoundPlayerState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Xaml::ElementSpatialAudioMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ElementSpatialAudioMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::ElementSpatialAudioMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Xaml::ElementTheme>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ElementTheme;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::ElementTheme is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Xaml::FlowDirection>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FlowDirection;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::FlowDirection is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Xaml::FocusState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FocusState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::FocusState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Xaml::FocusVisualKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FocusVisualKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::FocusVisualKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Xaml::FontCapitals>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FontCapitals;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::FontCapitals is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Xaml::FontEastAsianLanguage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FontEastAsianLanguage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::FontEastAsianLanguage is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Xaml::FontEastAsianWidths>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FontEastAsianWidths;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::FontEastAsianWidths is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Xaml::FontFraction>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FontFraction;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::FontFraction is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Xaml::FontNumeralAlignment>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FontNumeralAlignment;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::FontNumeralAlignment is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Xaml::FontNumeralStyle>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FontNumeralStyle;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::FontNumeralStyle is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Xaml::FontVariants>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FontVariants;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::FontVariants is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Xaml::GridUnitType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_GridUnitType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::GridUnitType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Xaml::HorizontalAlignment>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_HorizontalAlignment;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::HorizontalAlignment is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Xaml::LineStackingStrategy>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LineStackingStrategy;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::LineStackingStrategy is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Xaml::OpticalMarginAlignment>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_OpticalMarginAlignment;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::OpticalMarginAlignment is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Xaml::TextAlignment>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TextAlignment;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::TextAlignment is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Xaml::TextLineBounds>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TextLineBounds;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::TextLineBounds is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Xaml::TextReadingOrder>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TextReadingOrder;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::TextReadingOrder is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Xaml::TextTrimming>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TextTrimming;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::TextTrimming is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Xaml::TextWrapping>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TextWrapping;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::TextWrapping is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Xaml::Vector3TransitionComponents>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_Vector3TransitionComponents;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::Vector3TransitionComponents is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Xaml::VerticalAlignment>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_VerticalAlignment;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::VerticalAlignment is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Xaml::Visibility>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_Visibility;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::Visibility is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::AdaptiveTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AdaptiveTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::AdaptiveTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::Application>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_Application;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::Application is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::ApplicationInitializationCallbackParams>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ApplicationInitializationCallbackParams;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::ApplicationInitializationCallbackParams is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::BindingFailedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BindingFailedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::BindingFailedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::BringIntoViewOptions>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BringIntoViewOptions;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::BringIntoViewOptions is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::BringIntoViewRequestedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BringIntoViewRequestedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::BringIntoViewRequestedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::BrushTransition>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BrushTransition;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::BrushTransition is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::ColorPaletteResources>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ColorPaletteResources;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::ColorPaletteResources is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::CornerRadiusHelper>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CornerRadiusHelper;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::CornerRadiusHelper is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::DataContextChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DataContextChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::DataContextChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::DataTemplate>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DataTemplate;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::DataTemplate is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::DataTemplateKey>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DataTemplateKey;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::DataTemplateKey is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::DebugSettings>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DebugSettings;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::DebugSettings is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::DependencyObject>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DependencyObject;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::DependencyObject is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::DependencyObjectCollection>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DependencyObjectCollection;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::DependencyObjectCollection is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::DependencyProperty>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DependencyProperty;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::DependencyProperty is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::DependencyPropertyChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DependencyPropertyChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::DependencyPropertyChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::DispatcherTimer>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DispatcherTimer;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::DispatcherTimer is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::DragEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DragEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::DragEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::DragOperationDeferral>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DragOperationDeferral;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::DragOperationDeferral is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::DragStartingEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DragStartingEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::DragStartingEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::DragUI>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DragUI;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::DragUI is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::DragUIOverride>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DragUIOverride;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::DragUIOverride is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::DropCompletedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DropCompletedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::DropCompletedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::DurationHelper>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DurationHelper;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::DurationHelper is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::EffectiveViewportChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EffectiveViewportChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::EffectiveViewportChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::ElementFactoryGetArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ElementFactoryGetArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::ElementFactoryGetArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::ElementFactoryRecycleArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ElementFactoryRecycleArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::ElementFactoryRecycleArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::ElementSoundPlayer>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ElementSoundPlayer;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::ElementSoundPlayer is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::EventTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EventTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::EventTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::ExceptionRoutedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ExceptionRoutedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::ExceptionRoutedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::FrameworkElement>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FrameworkElement;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::FrameworkElement is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::FrameworkTemplate>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FrameworkTemplate;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::FrameworkTemplate is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::FrameworkView>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FrameworkView;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::FrameworkView is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::FrameworkViewSource>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FrameworkViewSource;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::FrameworkViewSource is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::GridLengthHelper>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_GridLengthHelper;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::GridLengthHelper is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::MediaFailedRoutedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaFailedRoutedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::MediaFailedRoutedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::PointHelper>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PointHelper;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::PointHelper is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::PropertyMetadata>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PropertyMetadata;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::PropertyMetadata is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::PropertyPath>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PropertyPath;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::PropertyPath is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::RectHelper>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_RectHelper;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::RectHelper is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::ResourceDictionary>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ResourceDictionary;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::ResourceDictionary is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::RoutedEvent>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_RoutedEvent;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::RoutedEvent is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::RoutedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_RoutedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::RoutedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::ScalarTransition>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ScalarTransition;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::ScalarTransition is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::Setter>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_Setter;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::Setter is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::SetterBase>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SetterBase;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::SetterBase is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::SetterBaseCollection>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SetterBaseCollection;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::SetterBaseCollection is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::SizeChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SizeChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::SizeChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::SizeHelper>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SizeHelper;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::SizeHelper is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::StateTrigger>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StateTrigger;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::StateTrigger is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::StateTriggerBase>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StateTriggerBase;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::StateTriggerBase is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::Style>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_Style;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::Style is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::TargetPropertyPath>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TargetPropertyPath;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::TargetPropertyPath is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::ThicknessHelper>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ThicknessHelper;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::ThicknessHelper is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::TriggerAction>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TriggerAction;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::TriggerAction is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::TriggerActionCollection>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TriggerActionCollection;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::TriggerActionCollection is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::TriggerBase>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TriggerBase;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::TriggerBase is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::TriggerCollection>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TriggerCollection;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::TriggerCollection is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::UIElement>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UIElement;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::UIElement is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::UIElementWeakCollection>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UIElementWeakCollection;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::UIElementWeakCollection is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::UnhandledExceptionEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UnhandledExceptionEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::UnhandledExceptionEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::Vector3Transition>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_Vector3Transition;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::Vector3Transition is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::VisualState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_VisualState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::VisualState is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::VisualStateChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_VisualStateChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::VisualStateChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::VisualStateGroup>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_VisualStateGroup;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::VisualStateGroup is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::VisualStateManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_VisualStateManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::VisualStateManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::VisualTransition>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_VisualTransition;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::VisualTransition is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::Window>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_Window;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::Window is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::WindowCreatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WindowCreatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::WindowCreatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::XamlRoot>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_XamlRoot;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::XamlRoot is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::XamlRootChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_XamlRootChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::XamlRootChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::IDataTemplateExtension>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IDataTemplateExtension;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::IDataTemplateExtension is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::IElementFactory>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IElementFactory;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::IElementFactory is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::CornerRadius>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CornerRadius;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::CornerRadius is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::Duration>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_Duration;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::Duration is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::GridLength>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_GridLength;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::GridLength is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Xaml::Thickness>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Xaml;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Xaml");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_Thickness;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Xaml::Thickness is not registered");
        return nullptr;
    }

    return python_type;
}
