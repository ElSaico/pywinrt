# WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

import enum
import datetime
import sys
import types
import typing

import winrt.system
import winrt.windows.devices.enumeration
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.foundation.numerics
import winrt.windows.media
import winrt.windows.media.capture
import winrt.windows.media.core
import winrt.windows.media.devices
import winrt.windows.media.effects
import winrt.windows.media.mediaproperties
import winrt.windows.media.render
import winrt.windows.media.transcoding
import winrt.windows.storage

class AudioDeviceNodeCreationStatus(enum.IntEnum):
    SUCCESS = 0
    DEVICE_NOT_AVAILABLE = 1
    FORMAT_NOT_SUPPORTED = 2
    UNKNOWN_FAILURE = 3
    ACCESS_DENIED = 4

class AudioFileNodeCreationStatus(enum.IntEnum):
    SUCCESS = 0
    FILE_NOT_FOUND = 1
    INVALID_FILE_TYPE = 2
    FORMAT_NOT_SUPPORTED = 3
    UNKNOWN_FAILURE = 4

class AudioGraphCreationStatus(enum.IntEnum):
    SUCCESS = 0
    DEVICE_NOT_AVAILABLE = 1
    FORMAT_NOT_SUPPORTED = 2
    UNKNOWN_FAILURE = 3

class AudioGraphUnrecoverableError(enum.IntEnum):
    NONE = 0
    AUDIO_DEVICE_LOST = 1
    AUDIO_SESSION_DISCONNECTED = 2
    UNKNOWN_FAILURE = 3

class AudioNodeEmitterDecayKind(enum.IntEnum):
    NATURAL = 0
    CUSTOM = 1

class AudioNodeEmitterSettings(enum.IntFlag):
    NONE = 0
    DISABLE_DOPPLER = 0x1

class AudioNodeEmitterShapeKind(enum.IntEnum):
    OMNIDIRECTIONAL = 0
    CONE = 1

class AudioPlaybackConnectionOpenResultStatus(enum.IntEnum):
    SUCCESS = 0
    REQUEST_TIMED_OUT = 1
    DENIED_BY_SYSTEM = 2
    UNKNOWN_FAILURE = 3

class AudioPlaybackConnectionState(enum.IntEnum):
    CLOSED = 0
    OPENED = 1

class MediaSourceAudioInputNodeCreationStatus(enum.IntEnum):
    SUCCESS = 0
    FORMAT_NOT_SUPPORTED = 1
    NETWORK_ERROR = 2
    UNKNOWN_FAILURE = 3

class MixedRealitySpatialAudioFormatPolicy(enum.IntEnum):
    USE_MIXED_REALITY_DEFAULT_SPATIAL_AUDIO_FORMAT = 0
    USE_DEVICE_CONFIGURATION_DEFAULT_SPATIAL_AUDIO_FORMAT = 1

class QuantumSizeSelectionMode(enum.IntEnum):
    SYSTEM_DEFAULT = 0
    LOWEST_LATENCY = 1
    CLOSEST_TO_DESIRED = 2

class SetDefaultSpatialAudioFormatStatus(enum.IntEnum):
    SUCCEEDED = 0
    ACCESS_DENIED = 1
    LICENSE_EXPIRED = 2
    LICENSE_NOT_VALID_FOR_AUDIO_ENDPOINT = 3
    NOT_SUPPORTED_ON_AUDIO_ENDPOINT = 4
    UNKNOWN_ERROR = 5

class SpatialAudioModel(enum.IntEnum):
    OBJECT_BASED = 0
    FOLD_DOWN = 1

Self = typing.TypeVar('Self')

class AudioDeviceInputNode(winrt.system.Object):
    device: typing.Optional[winrt.windows.devices.enumeration.DeviceInformation]
    outgoing_connections: typing.Optional[winrt.windows.foundation.collections.IVectorView[AudioGraphConnection]]
    emitter: typing.Optional[AudioNodeEmitter]
    outgoing_gain: winrt.system.Double
    consume_input: winrt.system.Boolean
    effect_definitions: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.media.effects.IAudioEffectDefinition]]
    encoding_properties: typing.Optional[winrt.windows.media.mediaproperties.AudioEncodingProperties]
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AudioDeviceInputNode: ...
    @typing.overload
    def add_outgoing_connection(self, destination: typing.Optional[IAudioNode], /) -> None: ...
    @typing.overload
    def add_outgoing_connection(self, destination: typing.Optional[IAudioNode], gain: winrt.system.Double, /) -> None: ...
    def close(self) -> None: ...
    def disable_effects_by_definition(self, definition: typing.Optional[winrt.windows.media.effects.IAudioEffectDefinition], /) -> None: ...
    def enable_effects_by_definition(self, definition: typing.Optional[winrt.windows.media.effects.IAudioEffectDefinition], /) -> None: ...
    def remove_outgoing_connection(self, destination: typing.Optional[IAudioNode], /) -> None: ...
    def reset(self) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...

class AudioDeviceOutputNode(winrt.system.Object):
    device: typing.Optional[winrt.windows.devices.enumeration.DeviceInformation]
    outgoing_gain: winrt.system.Double
    consume_input: winrt.system.Boolean
    effect_definitions: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.media.effects.IAudioEffectDefinition]]
    encoding_properties: typing.Optional[winrt.windows.media.mediaproperties.AudioEncodingProperties]
    listener: typing.Optional[AudioNodeListener]
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AudioDeviceOutputNode: ...
    def close(self) -> None: ...
    def disable_effects_by_definition(self, definition: typing.Optional[winrt.windows.media.effects.IAudioEffectDefinition], /) -> None: ...
    def enable_effects_by_definition(self, definition: typing.Optional[winrt.windows.media.effects.IAudioEffectDefinition], /) -> None: ...
    def reset(self) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...

class AudioFileInputNode(winrt.system.Object):
    playback_speed_factor: winrt.system.Double
    loop_count: typing.Optional[typing.Optional[winrt.system.Int32]]
    end_time: typing.Optional[typing.Optional[datetime.timedelta]]
    start_time: typing.Optional[typing.Optional[datetime.timedelta]]
    position: datetime.timedelta
    source_file: typing.Optional[winrt.windows.storage.StorageFile]
    duration: datetime.timedelta
    outgoing_connections: typing.Optional[winrt.windows.foundation.collections.IVectorView[AudioGraphConnection]]
    emitter: typing.Optional[AudioNodeEmitter]
    outgoing_gain: winrt.system.Double
    consume_input: winrt.system.Boolean
    effect_definitions: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.media.effects.IAudioEffectDefinition]]
    encoding_properties: typing.Optional[winrt.windows.media.mediaproperties.AudioEncodingProperties]
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AudioFileInputNode: ...
    @typing.overload
    def add_outgoing_connection(self, destination: typing.Optional[IAudioNode], /) -> None: ...
    @typing.overload
    def add_outgoing_connection(self, destination: typing.Optional[IAudioNode], gain: winrt.system.Double, /) -> None: ...
    def close(self) -> None: ...
    def disable_effects_by_definition(self, definition: typing.Optional[winrt.windows.media.effects.IAudioEffectDefinition], /) -> None: ...
    def enable_effects_by_definition(self, definition: typing.Optional[winrt.windows.media.effects.IAudioEffectDefinition], /) -> None: ...
    def remove_outgoing_connection(self, destination: typing.Optional[IAudioNode], /) -> None: ...
    def reset(self) -> None: ...
    def seek(self, position: datetime.timedelta, /) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def add_file_completed(self, handler: winrt.windows.foundation.TypedEventHandler[AudioFileInputNode, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_file_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class AudioFileOutputNode(winrt.system.Object):
    file: typing.Optional[winrt.windows.storage.IStorageFile]
    file_encoding_profile: typing.Optional[winrt.windows.media.mediaproperties.MediaEncodingProfile]
    outgoing_gain: winrt.system.Double
    consume_input: winrt.system.Boolean
    effect_definitions: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.media.effects.IAudioEffectDefinition]]
    encoding_properties: typing.Optional[winrt.windows.media.mediaproperties.AudioEncodingProperties]
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AudioFileOutputNode: ...
    def close(self) -> None: ...
    def disable_effects_by_definition(self, definition: typing.Optional[winrt.windows.media.effects.IAudioEffectDefinition], /) -> None: ...
    def enable_effects_by_definition(self, definition: typing.Optional[winrt.windows.media.effects.IAudioEffectDefinition], /) -> None: ...
    def finalize_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.media.transcoding.TranscodeFailureReason]: ...
    def reset(self) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...

class AudioFrameCompletedEventArgs(winrt.system.Object):
    frame: typing.Optional[winrt.windows.media.AudioFrame]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AudioFrameCompletedEventArgs: ...

class AudioFrameInputNode(winrt.system.Object):
    playback_speed_factor: winrt.system.Double
    queued_sample_count: winrt.system.UInt64
    outgoing_connections: typing.Optional[winrt.windows.foundation.collections.IVectorView[AudioGraphConnection]]
    emitter: typing.Optional[AudioNodeEmitter]
    outgoing_gain: winrt.system.Double
    consume_input: winrt.system.Boolean
    effect_definitions: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.media.effects.IAudioEffectDefinition]]
    encoding_properties: typing.Optional[winrt.windows.media.mediaproperties.AudioEncodingProperties]
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AudioFrameInputNode: ...
    def add_frame(self, frame: typing.Optional[winrt.windows.media.AudioFrame], /) -> None: ...
    @typing.overload
    def add_outgoing_connection(self, destination: typing.Optional[IAudioNode], /) -> None: ...
    @typing.overload
    def add_outgoing_connection(self, destination: typing.Optional[IAudioNode], gain: winrt.system.Double, /) -> None: ...
    def close(self) -> None: ...
    def disable_effects_by_definition(self, definition: typing.Optional[winrt.windows.media.effects.IAudioEffectDefinition], /) -> None: ...
    def discard_queued_frames(self) -> None: ...
    def enable_effects_by_definition(self, definition: typing.Optional[winrt.windows.media.effects.IAudioEffectDefinition], /) -> None: ...
    def remove_outgoing_connection(self, destination: typing.Optional[IAudioNode], /) -> None: ...
    def reset(self) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def add_audio_frame_completed(self, handler: winrt.windows.foundation.TypedEventHandler[AudioFrameInputNode, AudioFrameCompletedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_audio_frame_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_quantum_started(self, handler: winrt.windows.foundation.TypedEventHandler[AudioFrameInputNode, FrameInputNodeQuantumStartedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_quantum_started(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class AudioFrameOutputNode(winrt.system.Object):
    outgoing_gain: winrt.system.Double
    consume_input: winrt.system.Boolean
    effect_definitions: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.media.effects.IAudioEffectDefinition]]
    encoding_properties: typing.Optional[winrt.windows.media.mediaproperties.AudioEncodingProperties]
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AudioFrameOutputNode: ...
    def close(self) -> None: ...
    def disable_effects_by_definition(self, definition: typing.Optional[winrt.windows.media.effects.IAudioEffectDefinition], /) -> None: ...
    def enable_effects_by_definition(self, definition: typing.Optional[winrt.windows.media.effects.IAudioEffectDefinition], /) -> None: ...
    def get_frame(self) -> typing.Optional[winrt.windows.media.AudioFrame]: ...
    def reset(self) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...

class AudioGraph(winrt.system.Object):
    completed_quantum_count: winrt.system.UInt64
    encoding_properties: typing.Optional[winrt.windows.media.mediaproperties.AudioEncodingProperties]
    latency_in_samples: winrt.system.Int32
    primary_render_device: typing.Optional[winrt.windows.devices.enumeration.DeviceInformation]
    render_device_audio_processing: winrt.windows.media.AudioProcessing
    samples_per_quantum: winrt.system.Int32
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AudioGraph: ...
    def close(self) -> None: ...
    @staticmethod
    def create_async(settings: typing.Optional[AudioGraphSettings], /) -> winrt.windows.foundation.IAsyncOperation[CreateAudioGraphResult]: ...
    def create_batch_updater(self) -> typing.Optional[AudioGraphBatchUpdater]: ...
    @typing.overload
    def create_device_input_node_async(self, category: winrt.windows.media.capture.MediaCategory, /) -> winrt.windows.foundation.IAsyncOperation[CreateAudioDeviceInputNodeResult]: ...
    @typing.overload
    def create_device_input_node_async(self, category: winrt.windows.media.capture.MediaCategory, encoding_properties: typing.Optional[winrt.windows.media.mediaproperties.AudioEncodingProperties], /) -> winrt.windows.foundation.IAsyncOperation[CreateAudioDeviceInputNodeResult]: ...
    @typing.overload
    def create_device_input_node_async(self, category: winrt.windows.media.capture.MediaCategory, encoding_properties: typing.Optional[winrt.windows.media.mediaproperties.AudioEncodingProperties], device: typing.Optional[winrt.windows.devices.enumeration.DeviceInformation], /) -> winrt.windows.foundation.IAsyncOperation[CreateAudioDeviceInputNodeResult]: ...
    @typing.overload
    def create_device_input_node_async(self, category: winrt.windows.media.capture.MediaCategory, encoding_properties: typing.Optional[winrt.windows.media.mediaproperties.AudioEncodingProperties], device: typing.Optional[winrt.windows.devices.enumeration.DeviceInformation], emitter: typing.Optional[AudioNodeEmitter], /) -> winrt.windows.foundation.IAsyncOperation[CreateAudioDeviceInputNodeResult]: ...
    def create_device_output_node_async(self) -> winrt.windows.foundation.IAsyncOperation[CreateAudioDeviceOutputNodeResult]: ...
    @typing.overload
    def create_file_input_node_async(self, file: typing.Optional[winrt.windows.storage.IStorageFile], /) -> winrt.windows.foundation.IAsyncOperation[CreateAudioFileInputNodeResult]: ...
    @typing.overload
    def create_file_input_node_async(self, file: typing.Optional[winrt.windows.storage.IStorageFile], emitter: typing.Optional[AudioNodeEmitter], /) -> winrt.windows.foundation.IAsyncOperation[CreateAudioFileInputNodeResult]: ...
    @typing.overload
    def create_file_output_node_async(self, file: typing.Optional[winrt.windows.storage.IStorageFile], /) -> winrt.windows.foundation.IAsyncOperation[CreateAudioFileOutputNodeResult]: ...
    @typing.overload
    def create_file_output_node_async(self, file: typing.Optional[winrt.windows.storage.IStorageFile], file_encoding_profile: typing.Optional[winrt.windows.media.mediaproperties.MediaEncodingProfile], /) -> winrt.windows.foundation.IAsyncOperation[CreateAudioFileOutputNodeResult]: ...
    @typing.overload
    def create_frame_input_node(self) -> typing.Optional[AudioFrameInputNode]: ...
    @typing.overload
    def create_frame_input_node(self, encoding_properties: typing.Optional[winrt.windows.media.mediaproperties.AudioEncodingProperties], /) -> typing.Optional[AudioFrameInputNode]: ...
    @typing.overload
    def create_frame_input_node(self, encoding_properties: typing.Optional[winrt.windows.media.mediaproperties.AudioEncodingProperties], emitter: typing.Optional[AudioNodeEmitter], /) -> typing.Optional[AudioFrameInputNode]: ...
    @typing.overload
    def create_frame_output_node(self) -> typing.Optional[AudioFrameOutputNode]: ...
    @typing.overload
    def create_frame_output_node(self, encoding_properties: typing.Optional[winrt.windows.media.mediaproperties.AudioEncodingProperties], /) -> typing.Optional[AudioFrameOutputNode]: ...
    @typing.overload
    def create_media_source_audio_input_node_async(self, media_source: typing.Optional[winrt.windows.media.core.MediaSource], /) -> winrt.windows.foundation.IAsyncOperation[CreateMediaSourceAudioInputNodeResult]: ...
    @typing.overload
    def create_media_source_audio_input_node_async(self, media_source: typing.Optional[winrt.windows.media.core.MediaSource], emitter: typing.Optional[AudioNodeEmitter], /) -> winrt.windows.foundation.IAsyncOperation[CreateMediaSourceAudioInputNodeResult]: ...
    @typing.overload
    def create_submix_node(self) -> typing.Optional[AudioSubmixNode]: ...
    @typing.overload
    def create_submix_node(self, encoding_properties: typing.Optional[winrt.windows.media.mediaproperties.AudioEncodingProperties], /) -> typing.Optional[AudioSubmixNode]: ...
    @typing.overload
    def create_submix_node(self, encoding_properties: typing.Optional[winrt.windows.media.mediaproperties.AudioEncodingProperties], emitter: typing.Optional[AudioNodeEmitter], /) -> typing.Optional[AudioSubmixNode]: ...
    def reset_all_nodes(self) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def add_quantum_processed(self, handler: winrt.windows.foundation.TypedEventHandler[AudioGraph, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_quantum_processed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_quantum_started(self, handler: winrt.windows.foundation.TypedEventHandler[AudioGraph, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_quantum_started(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_unrecoverable_error_occurred(self, handler: winrt.windows.foundation.TypedEventHandler[AudioGraph, AudioGraphUnrecoverableErrorOccurredEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_unrecoverable_error_occurred(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class AudioGraphBatchUpdater(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AudioGraphBatchUpdater: ...
    def close(self) -> None: ...

class AudioGraphConnection(winrt.system.Object):
    gain: winrt.system.Double
    destination: typing.Optional[IAudioNode]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AudioGraphConnection: ...

class AudioGraphSettings(winrt.system.Object):
    quantum_size_selection_mode: QuantumSizeSelectionMode
    primary_render_device: typing.Optional[winrt.windows.devices.enumeration.DeviceInformation]
    encoding_properties: typing.Optional[winrt.windows.media.mediaproperties.AudioEncodingProperties]
    desired_samples_per_quantum: winrt.system.Int32
    desired_render_device_audio_processing: winrt.windows.media.AudioProcessing
    audio_render_category: winrt.windows.media.render.AudioRenderCategory
    max_playback_speed_factor: winrt.system.Double
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AudioGraphSettings: ...
    def __new__(cls: typing.Type[AudioGraphSettings], audio_render_category: winrt.windows.media.render.AudioRenderCategory) -> AudioGraphSettings:...

class AudioGraphUnrecoverableErrorOccurredEventArgs(winrt.system.Object):
    error: AudioGraphUnrecoverableError
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AudioGraphUnrecoverableErrorOccurredEventArgs: ...

class AudioNodeEmitter(winrt.system.Object):
    position: winrt.windows.foundation.numerics.Vector3
    gain: winrt.system.Double
    doppler_velocity: winrt.windows.foundation.numerics.Vector3
    doppler_scale: winrt.system.Double
    distance_scale: winrt.system.Double
    direction: winrt.windows.foundation.numerics.Vector3
    decay_model: typing.Optional[AudioNodeEmitterDecayModel]
    is_doppler_disabled: winrt.system.Boolean
    shape: typing.Optional[AudioNodeEmitterShape]
    spatial_audio_model: SpatialAudioModel
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AudioNodeEmitter: ...
    @typing.overload
    def __new__(cls: typing.Type[AudioNodeEmitter], shape: typing.Optional[AudioNodeEmitterShape], decay_model: typing.Optional[AudioNodeEmitterDecayModel], settings: AudioNodeEmitterSettings) -> AudioNodeEmitter:...
    @typing.overload
    def __new__(cls: typing.Type[AudioNodeEmitter]) -> AudioNodeEmitter:...

class AudioNodeEmitterConeProperties(winrt.system.Object):
    inner_angle: winrt.system.Double
    outer_angle: winrt.system.Double
    outer_angle_gain: winrt.system.Double
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AudioNodeEmitterConeProperties: ...

class AudioNodeEmitterDecayModel(winrt.system.Object):
    kind: AudioNodeEmitterDecayKind
    max_gain: winrt.system.Double
    min_gain: winrt.system.Double
    natural_properties: typing.Optional[AudioNodeEmitterNaturalDecayModelProperties]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AudioNodeEmitterDecayModel: ...
    @staticmethod
    def create_custom(min_gain: winrt.system.Double, max_gain: winrt.system.Double, /) -> typing.Optional[AudioNodeEmitterDecayModel]: ...
    @staticmethod
    def create_natural(min_gain: winrt.system.Double, max_gain: winrt.system.Double, unity_gain_distance: winrt.system.Double, cutoff_distance: winrt.system.Double, /) -> typing.Optional[AudioNodeEmitterDecayModel]: ...

class AudioNodeEmitterNaturalDecayModelProperties(winrt.system.Object):
    cutoff_distance: winrt.system.Double
    unity_gain_distance: winrt.system.Double
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AudioNodeEmitterNaturalDecayModelProperties: ...

class AudioNodeEmitterShape(winrt.system.Object):
    cone_properties: typing.Optional[AudioNodeEmitterConeProperties]
    kind: AudioNodeEmitterShapeKind
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AudioNodeEmitterShape: ...
    @staticmethod
    def create_cone(inner_angle: winrt.system.Double, outer_angle: winrt.system.Double, outer_angle_gain: winrt.system.Double, /) -> typing.Optional[AudioNodeEmitterShape]: ...
    @staticmethod
    def create_omnidirectional() -> typing.Optional[AudioNodeEmitterShape]: ...

class AudioNodeListener(winrt.system.Object):
    speed_of_sound: winrt.system.Double
    position: winrt.windows.foundation.numerics.Vector3
    orientation: winrt.windows.foundation.numerics.Quaternion
    doppler_velocity: winrt.windows.foundation.numerics.Vector3
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AudioNodeListener: ...
    def __new__(cls: typing.Type[AudioNodeListener]) -> AudioNodeListener:...

class AudioPlaybackConnection(winrt.system.Object):
    device_id: str
    state: AudioPlaybackConnectionState
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AudioPlaybackConnection: ...
    def close(self) -> None: ...
    @staticmethod
    def get_device_selector() -> str: ...
    def open(self) -> typing.Optional[AudioPlaybackConnectionOpenResult]: ...
    def open_async(self) -> winrt.windows.foundation.IAsyncOperation[AudioPlaybackConnectionOpenResult]: ...
    def start(self) -> None: ...
    def start_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    @staticmethod
    def try_create_from_id(id: str, /) -> typing.Optional[AudioPlaybackConnection]: ...
    def add_state_changed(self, handler: winrt.windows.foundation.TypedEventHandler[AudioPlaybackConnection, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_state_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class AudioPlaybackConnectionOpenResult(winrt.system.Object):
    extended_error: winrt.windows.foundation.HResult
    status: AudioPlaybackConnectionOpenResultStatus
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AudioPlaybackConnectionOpenResult: ...

class AudioStateMonitor(winrt.system.Object):
    sound_level: winrt.windows.media.SoundLevel
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AudioStateMonitor: ...
    @typing.overload
    @staticmethod
    def create_for_capture_monitoring() -> typing.Optional[AudioStateMonitor]: ...
    @typing.overload
    @staticmethod
    def create_for_capture_monitoring(category: winrt.windows.media.capture.MediaCategory, /) -> typing.Optional[AudioStateMonitor]: ...
    @typing.overload
    @staticmethod
    def create_for_capture_monitoring(category: winrt.windows.media.capture.MediaCategory, role: winrt.windows.media.devices.AudioDeviceRole, /) -> typing.Optional[AudioStateMonitor]: ...
    @staticmethod
    def create_for_capture_monitoring_with_category_and_device_id(category: winrt.windows.media.capture.MediaCategory, device_id: str, /) -> typing.Optional[AudioStateMonitor]: ...
    @typing.overload
    @staticmethod
    def create_for_render_monitoring() -> typing.Optional[AudioStateMonitor]: ...
    @typing.overload
    @staticmethod
    def create_for_render_monitoring(category: winrt.windows.media.render.AudioRenderCategory, /) -> typing.Optional[AudioStateMonitor]: ...
    @typing.overload
    @staticmethod
    def create_for_render_monitoring(category: winrt.windows.media.render.AudioRenderCategory, role: winrt.windows.media.devices.AudioDeviceRole, /) -> typing.Optional[AudioStateMonitor]: ...
    @staticmethod
    def create_for_render_monitoring_with_category_and_device_id(category: winrt.windows.media.render.AudioRenderCategory, device_id: str, /) -> typing.Optional[AudioStateMonitor]: ...
    def add_sound_level_changed(self, handler: winrt.windows.foundation.TypedEventHandler[AudioStateMonitor, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_sound_level_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class AudioSubmixNode(winrt.system.Object):
    outgoing_connections: typing.Optional[winrt.windows.foundation.collections.IVectorView[AudioGraphConnection]]
    emitter: typing.Optional[AudioNodeEmitter]
    outgoing_gain: winrt.system.Double
    consume_input: winrt.system.Boolean
    effect_definitions: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.media.effects.IAudioEffectDefinition]]
    encoding_properties: typing.Optional[winrt.windows.media.mediaproperties.AudioEncodingProperties]
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AudioSubmixNode: ...
    @typing.overload
    def add_outgoing_connection(self, destination: typing.Optional[IAudioNode], /) -> None: ...
    @typing.overload
    def add_outgoing_connection(self, destination: typing.Optional[IAudioNode], gain: winrt.system.Double, /) -> None: ...
    def close(self) -> None: ...
    def disable_effects_by_definition(self, definition: typing.Optional[winrt.windows.media.effects.IAudioEffectDefinition], /) -> None: ...
    def enable_effects_by_definition(self, definition: typing.Optional[winrt.windows.media.effects.IAudioEffectDefinition], /) -> None: ...
    def remove_outgoing_connection(self, destination: typing.Optional[IAudioNode], /) -> None: ...
    def reset(self) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...

class CreateAudioDeviceInputNodeResult(winrt.system.Object):
    device_input_node: typing.Optional[AudioDeviceInputNode]
    status: AudioDeviceNodeCreationStatus
    extended_error: winrt.windows.foundation.HResult
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CreateAudioDeviceInputNodeResult: ...

class CreateAudioDeviceOutputNodeResult(winrt.system.Object):
    device_output_node: typing.Optional[AudioDeviceOutputNode]
    status: AudioDeviceNodeCreationStatus
    extended_error: winrt.windows.foundation.HResult
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CreateAudioDeviceOutputNodeResult: ...

class CreateAudioFileInputNodeResult(winrt.system.Object):
    file_input_node: typing.Optional[AudioFileInputNode]
    status: AudioFileNodeCreationStatus
    extended_error: winrt.windows.foundation.HResult
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CreateAudioFileInputNodeResult: ...

class CreateAudioFileOutputNodeResult(winrt.system.Object):
    file_output_node: typing.Optional[AudioFileOutputNode]
    status: AudioFileNodeCreationStatus
    extended_error: winrt.windows.foundation.HResult
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CreateAudioFileOutputNodeResult: ...

class CreateAudioGraphResult(winrt.system.Object):
    graph: typing.Optional[AudioGraph]
    status: AudioGraphCreationStatus
    extended_error: winrt.windows.foundation.HResult
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CreateAudioGraphResult: ...

class CreateMediaSourceAudioInputNodeResult(winrt.system.Object):
    node: typing.Optional[MediaSourceAudioInputNode]
    status: MediaSourceAudioInputNodeCreationStatus
    extended_error: winrt.windows.foundation.HResult
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CreateMediaSourceAudioInputNodeResult: ...

class EchoEffectDefinition(winrt.system.Object):
    wet_dry_mix: winrt.system.Double
    feedback: winrt.system.Double
    delay: winrt.system.Double
    activatable_class_id: str
    properties: typing.Optional[winrt.windows.foundation.collections.IPropertySet]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EchoEffectDefinition: ...
    def __new__(cls: typing.Type[EchoEffectDefinition], audio_graph: typing.Optional[AudioGraph]) -> EchoEffectDefinition:...

class EqualizerBand(winrt.system.Object):
    gain: winrt.system.Double
    frequency_center: winrt.system.Double
    bandwidth: winrt.system.Double
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EqualizerBand: ...

class EqualizerEffectDefinition(winrt.system.Object):
    bands: typing.Optional[winrt.windows.foundation.collections.IVectorView[EqualizerBand]]
    activatable_class_id: str
    properties: typing.Optional[winrt.windows.foundation.collections.IPropertySet]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EqualizerEffectDefinition: ...
    def __new__(cls: typing.Type[EqualizerEffectDefinition], audio_graph: typing.Optional[AudioGraph]) -> EqualizerEffectDefinition:...

class FrameInputNodeQuantumStartedEventArgs(winrt.system.Object):
    required_samples: winrt.system.Int32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FrameInputNodeQuantumStartedEventArgs: ...

class LimiterEffectDefinition(winrt.system.Object):
    release: winrt.system.UInt32
    loudness: winrt.system.UInt32
    activatable_class_id: str
    properties: typing.Optional[winrt.windows.foundation.collections.IPropertySet]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LimiterEffectDefinition: ...
    def __new__(cls: typing.Type[LimiterEffectDefinition], audio_graph: typing.Optional[AudioGraph]) -> LimiterEffectDefinition:...

class MediaSourceAudioInputNode(winrt.system.Object):
    outgoing_connections: typing.Optional[winrt.windows.foundation.collections.IVectorView[AudioGraphConnection]]
    emitter: typing.Optional[AudioNodeEmitter]
    outgoing_gain: winrt.system.Double
    consume_input: winrt.system.Boolean
    effect_definitions: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.media.effects.IAudioEffectDefinition]]
    encoding_properties: typing.Optional[winrt.windows.media.mediaproperties.AudioEncodingProperties]
    start_time: typing.Optional[typing.Optional[datetime.timedelta]]
    playback_speed_factor: winrt.system.Double
    loop_count: typing.Optional[typing.Optional[winrt.system.Int32]]
    end_time: typing.Optional[typing.Optional[datetime.timedelta]]
    duration: datetime.timedelta
    media_source: typing.Optional[winrt.windows.media.core.MediaSource]
    position: datetime.timedelta
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaSourceAudioInputNode: ...
    @typing.overload
    def add_outgoing_connection(self, destination: typing.Optional[IAudioNode], /) -> None: ...
    @typing.overload
    def add_outgoing_connection(self, destination: typing.Optional[IAudioNode], gain: winrt.system.Double, /) -> None: ...
    def close(self) -> None: ...
    def disable_effects_by_definition(self, definition: typing.Optional[winrt.windows.media.effects.IAudioEffectDefinition], /) -> None: ...
    def enable_effects_by_definition(self, definition: typing.Optional[winrt.windows.media.effects.IAudioEffectDefinition], /) -> None: ...
    def remove_outgoing_connection(self, destination: typing.Optional[IAudioNode], /) -> None: ...
    def reset(self) -> None: ...
    def seek(self, position: datetime.timedelta, /) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def add_media_source_completed(self, handler: winrt.windows.foundation.TypedEventHandler[MediaSourceAudioInputNode, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_media_source_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class ReverbEffectDefinition(winrt.system.Object):
    high_e_q_gain: winrt.system.UInt8
    high_e_q_cutoff: winrt.system.UInt8
    disable_late_field: winrt.system.Boolean
    density: winrt.system.Double
    position_right: winrt.system.UInt8
    decay_time: winrt.system.Double
    late_diffusion: winrt.system.UInt8
    position_matrix_right: winrt.system.UInt8
    position_matrix_left: winrt.system.UInt8
    position_left: winrt.system.UInt8
    low_e_q_gain: winrt.system.UInt8
    low_e_q_cutoff: winrt.system.UInt8
    room_filter_freq: winrt.system.Double
    reverb_gain: winrt.system.Double
    reverb_delay: winrt.system.UInt8
    reflections_gain: winrt.system.Double
    reflections_delay: winrt.system.UInt32
    rear_delay: winrt.system.UInt8
    wet_dry_mix: winrt.system.Double
    early_diffusion: winrt.system.UInt8
    room_size: winrt.system.Double
    room_filter_main: winrt.system.Double
    room_filter_h_f: winrt.system.Double
    activatable_class_id: str
    properties: typing.Optional[winrt.windows.foundation.collections.IPropertySet]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ReverbEffectDefinition: ...
    def __new__(cls: typing.Type[ReverbEffectDefinition], audio_graph: typing.Optional[AudioGraph]) -> ReverbEffectDefinition:...

class SetDefaultSpatialAudioFormatResult(winrt.system.Object):
    status: SetDefaultSpatialAudioFormatStatus
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SetDefaultSpatialAudioFormatResult: ...

class SpatialAudioDeviceConfiguration(winrt.system.Object):
    active_spatial_audio_format: str
    default_spatial_audio_format: str
    device_id: str
    is_spatial_audio_supported: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpatialAudioDeviceConfiguration: ...
    @staticmethod
    def get_for_device_id(device_id: str, /) -> typing.Optional[SpatialAudioDeviceConfiguration]: ...
    def is_spatial_audio_format_supported(self, subtype: str, /) -> winrt.system.Boolean: ...
    def set_default_spatial_audio_format_async(self, subtype: str, /) -> winrt.windows.foundation.IAsyncOperation[SetDefaultSpatialAudioFormatResult]: ...
    def add_configuration_changed(self, handler: winrt.windows.foundation.TypedEventHandler[SpatialAudioDeviceConfiguration, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_configuration_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class SpatialAudioFormatConfiguration(winrt.system.Object):
    mixed_reality_exclusive_mode_policy: MixedRealitySpatialAudioFormatPolicy
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpatialAudioFormatConfiguration: ...
    @staticmethod
    def get_default() -> typing.Optional[SpatialAudioFormatConfiguration]: ...
    def report_configuration_changed_async(self, subtype: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    def report_license_changed_async(self, subtype: str, /) -> winrt.windows.foundation.IAsyncAction: ...

class SpatialAudioFormatSubtype(winrt.system.Object):
    d_t_s_headphone_x: typing.ClassVar[str]
    d_t_s_x_ultra: typing.ClassVar[str]
    dolby_atmos_for_headphones: typing.ClassVar[str]
    dolby_atmos_for_home_theater: typing.ClassVar[str]
    dolby_atmos_for_speakers: typing.ClassVar[str]
    windows_sonic: typing.ClassVar[str]
    d_t_s_x_for_home_theater: typing.ClassVar[str]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpatialAudioFormatSubtype: ...

class IAudioInputNode(winrt.system.Object):
    outgoing_connections: typing.Optional[winrt.windows.foundation.collections.IVectorView[AudioGraphConnection]]
    consume_input: winrt.system.Boolean
    effect_definitions: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.media.effects.IAudioEffectDefinition]]
    encoding_properties: typing.Optional[winrt.windows.media.mediaproperties.AudioEncodingProperties]
    outgoing_gain: winrt.system.Double
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IAudioInputNode: ...
    @typing.overload
    def add_outgoing_connection(self, destination: typing.Optional[IAudioNode], /) -> None: ...
    @typing.overload
    def add_outgoing_connection(self, destination: typing.Optional[IAudioNode], gain: winrt.system.Double, /) -> None: ...
    def close(self) -> None: ...
    def disable_effects_by_definition(self, definition: typing.Optional[winrt.windows.media.effects.IAudioEffectDefinition], /) -> None: ...
    def enable_effects_by_definition(self, definition: typing.Optional[winrt.windows.media.effects.IAudioEffectDefinition], /) -> None: ...
    def remove_outgoing_connection(self, destination: typing.Optional[IAudioNode], /) -> None: ...
    def reset(self) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...

class IAudioInputNode2(winrt.system.Object):
    emitter: typing.Optional[AudioNodeEmitter]
    consume_input: winrt.system.Boolean
    effect_definitions: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.media.effects.IAudioEffectDefinition]]
    encoding_properties: typing.Optional[winrt.windows.media.mediaproperties.AudioEncodingProperties]
    outgoing_gain: winrt.system.Double
    outgoing_connections: typing.Optional[winrt.windows.foundation.collections.IVectorView[AudioGraphConnection]]
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IAudioInputNode2: ...
    @typing.overload
    def add_outgoing_connection(self, destination: typing.Optional[IAudioNode], /) -> None: ...
    @typing.overload
    def add_outgoing_connection(self, destination: typing.Optional[IAudioNode], gain: winrt.system.Double, /) -> None: ...
    def close(self) -> None: ...
    def disable_effects_by_definition(self, definition: typing.Optional[winrt.windows.media.effects.IAudioEffectDefinition], /) -> None: ...
    def enable_effects_by_definition(self, definition: typing.Optional[winrt.windows.media.effects.IAudioEffectDefinition], /) -> None: ...
    def remove_outgoing_connection(self, destination: typing.Optional[IAudioNode], /) -> None: ...
    def reset(self) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...

class IAudioNode(winrt.system.Object):
    consume_input: winrt.system.Boolean
    effect_definitions: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.media.effects.IAudioEffectDefinition]]
    encoding_properties: typing.Optional[winrt.windows.media.mediaproperties.AudioEncodingProperties]
    outgoing_gain: winrt.system.Double
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IAudioNode: ...
    def close(self) -> None: ...
    def disable_effects_by_definition(self, definition: typing.Optional[winrt.windows.media.effects.IAudioEffectDefinition], /) -> None: ...
    def enable_effects_by_definition(self, definition: typing.Optional[winrt.windows.media.effects.IAudioEffectDefinition], /) -> None: ...
    def reset(self) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...

class IAudioNodeWithListener(winrt.system.Object):
    listener: typing.Optional[AudioNodeListener]
    consume_input: winrt.system.Boolean
    effect_definitions: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.media.effects.IAudioEffectDefinition]]
    encoding_properties: typing.Optional[winrt.windows.media.mediaproperties.AudioEncodingProperties]
    outgoing_gain: winrt.system.Double
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IAudioNodeWithListener: ...
    def close(self) -> None: ...
    def disable_effects_by_definition(self, definition: typing.Optional[winrt.windows.media.effects.IAudioEffectDefinition], /) -> None: ...
    def enable_effects_by_definition(self, definition: typing.Optional[winrt.windows.media.effects.IAudioEffectDefinition], /) -> None: ...
    def reset(self) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...

