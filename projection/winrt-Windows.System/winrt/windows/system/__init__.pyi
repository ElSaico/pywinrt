# WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

import enum
import datetime
import sys
import types
import typing

import winrt.system
import winrt.windows.applicationmodel
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.storage
import winrt.windows.storage.search
import winrt.windows.storage.streams
import winrt.windows.system.diagnostics
import winrt.windows.system.remotesystems
import winrt.windows.ui.popups
import winrt.windows.ui.viewmanagement

class AppDiagnosticInfoWatcherStatus(enum.IntEnum):
    CREATED = 0
    STARTED = 1
    ENUMERATION_COMPLETED = 2
    STOPPING = 3
    STOPPED = 4
    ABORTED = 5

class AppMemoryUsageLevel(enum.IntEnum):
    LOW = 0
    MEDIUM = 1
    HIGH = 2
    OVER_LIMIT = 3

class AppResourceGroupEnergyQuotaState(enum.IntEnum):
    UNKNOWN = 0
    OVER = 1
    UNDER = 2

class AppResourceGroupExecutionState(enum.IntEnum):
    UNKNOWN = 0
    RUNNING = 1
    SUSPENDING = 2
    SUSPENDED = 3
    NOT_RUNNING = 4

class AppResourceGroupInfoWatcherStatus(enum.IntEnum):
    CREATED = 0
    STARTED = 1
    ENUMERATION_COMPLETED = 2
    STOPPING = 3
    STOPPED = 4
    ABORTED = 5

class AutoUpdateTimeZoneStatus(enum.IntEnum):
    ATTEMPTED = 0
    TIMED_OUT = 1
    FAILED = 2

class DiagnosticAccessStatus(enum.IntEnum):
    UNSPECIFIED = 0
    DENIED = 1
    LIMITED = 2
    ALLOWED = 3

class DispatcherQueuePriority(enum.IntEnum):
    LOW = -10
    NORMAL = 0
    HIGH = 10

class LaunchFileStatus(enum.IntEnum):
    SUCCESS = 0
    APP_UNAVAILABLE = 1
    DENIED_BY_POLICY = 2
    FILE_TYPE_NOT_SUPPORTED = 3
    UNKNOWN = 4

class LaunchQuerySupportStatus(enum.IntEnum):
    AVAILABLE = 0
    APP_NOT_INSTALLED = 1
    APP_UNAVAILABLE = 2
    NOT_SUPPORTED = 3
    UNKNOWN = 4

class LaunchQuerySupportType(enum.IntEnum):
    URI = 0
    URI_FOR_RESULTS = 1

class LaunchUriStatus(enum.IntEnum):
    SUCCESS = 0
    APP_UNAVAILABLE = 1
    PROTOCOL_UNAVAILABLE = 2
    UNKNOWN = 3

class PowerState(enum.IntEnum):
    CONNECTED_STANDBY = 0
    SLEEP_S3 = 1

class ProcessorArchitecture(enum.IntEnum):
    X86 = 0
    ARM = 5
    X64 = 9
    NEUTRAL = 11
    ARM64 = 12
    X86_ON_ARM64 = 14
    UNKNOWN = 65535

class RemoteLaunchUriStatus(enum.IntEnum):
    UNKNOWN = 0
    SUCCESS = 1
    APP_UNAVAILABLE = 2
    PROTOCOL_UNAVAILABLE = 3
    REMOTE_SYSTEM_UNAVAILABLE = 4
    VALUE_SET_TOO_LARGE = 5
    DENIED_BY_LOCAL_SYSTEM = 6
    DENIED_BY_REMOTE_SYSTEM = 7

class ShutdownKind(enum.IntEnum):
    SHUTDOWN = 0
    RESTART = 1

class UserAgeConsentGroup(enum.IntEnum):
    CHILD = 0
    MINOR = 1
    ADULT = 2

class UserAgeConsentResult(enum.IntEnum):
    NOT_ENFORCED = 0
    INCLUDED = 1
    NOT_INCLUDED = 2
    UNKNOWN = 3
    AMBIGUOUS = 4

class UserAuthenticationStatus(enum.IntEnum):
    UNAUTHENTICATED = 0
    LOCALLY_AUTHENTICATED = 1
    REMOTELY_AUTHENTICATED = 2

class UserPictureSize(enum.IntEnum):
    SIZE64X64 = 0
    SIZE208X208 = 1
    SIZE424X424 = 2
    SIZE1080X1080 = 3

class UserType(enum.IntEnum):
    LOCAL_USER = 0
    REMOTE_USER = 1
    LOCAL_GUEST = 2
    REMOTE_GUEST = 3
    SYSTEM_MANAGED = 4

class UserWatcherStatus(enum.IntEnum):
    CREATED = 0
    STARTED = 1
    ENUMERATION_COMPLETED = 2
    STOPPING = 3
    STOPPED = 4
    ABORTED = 5

class UserWatcherUpdateKind(enum.IntEnum):
    PROPERTIES = 0
    PICTURE = 1

class VirtualKey(enum.IntEnum):
    NONE = 0
    LEFT_BUTTON = 1
    RIGHT_BUTTON = 2
    CANCEL = 3
    MIDDLE_BUTTON = 4
    X_BUTTON1 = 5
    X_BUTTON2 = 6
    BACK = 8
    TAB = 9
    CLEAR = 12
    ENTER = 13
    SHIFT = 16
    CONTROL = 17
    MENU = 18
    PAUSE = 19
    CAPITAL_LOCK = 20
    KANA = 21
    HANGUL = 21
    IME_ON = 22
    JUNJA = 23
    FINAL = 24
    HANJA = 25
    KANJI = 25
    IME_OFF = 26
    ESCAPE = 27
    CONVERT = 28
    NON_CONVERT = 29
    ACCEPT = 30
    MODE_CHANGE = 31
    SPACE = 32
    PAGE_UP = 33
    PAGE_DOWN = 34
    END = 35
    HOME = 36
    LEFT = 37
    UP = 38
    RIGHT = 39
    DOWN = 40
    SELECT = 41
    PRINT = 42
    EXECUTE = 43
    SNAPSHOT = 44
    INSERT = 45
    DELETE = 46
    HELP = 47
    NUMBER0 = 48
    NUMBER1 = 49
    NUMBER2 = 50
    NUMBER3 = 51
    NUMBER4 = 52
    NUMBER5 = 53
    NUMBER6 = 54
    NUMBER7 = 55
    NUMBER8 = 56
    NUMBER9 = 57
    A = 65
    B = 66
    C = 67
    D = 68
    E = 69
    F = 70
    G = 71
    H = 72
    I = 73
    J = 74
    K = 75
    L = 76
    M = 77
    N = 78
    O = 79
    P = 80
    Q = 81
    R = 82
    S = 83
    T = 84
    U = 85
    V = 86
    W = 87
    X = 88
    Y = 89
    Z = 90
    LEFT_WINDOWS = 91
    RIGHT_WINDOWS = 92
    APPLICATION = 93
    SLEEP = 95
    NUMBER_PAD0 = 96
    NUMBER_PAD1 = 97
    NUMBER_PAD2 = 98
    NUMBER_PAD3 = 99
    NUMBER_PAD4 = 100
    NUMBER_PAD5 = 101
    NUMBER_PAD6 = 102
    NUMBER_PAD7 = 103
    NUMBER_PAD8 = 104
    NUMBER_PAD9 = 105
    MULTIPLY = 106
    ADD = 107
    SEPARATOR = 108
    SUBTRACT = 109
    DECIMAL = 110
    DIVIDE = 111
    F1 = 112
    F2 = 113
    F3 = 114
    F4 = 115
    F5 = 116
    F6 = 117
    F7 = 118
    F8 = 119
    F9 = 120
    F10 = 121
    F11 = 122
    F12 = 123
    F13 = 124
    F14 = 125
    F15 = 126
    F16 = 127
    F17 = 128
    F18 = 129
    F19 = 130
    F20 = 131
    F21 = 132
    F22 = 133
    F23 = 134
    F24 = 135
    NAVIGATION_VIEW = 136
    NAVIGATION_MENU = 137
    NAVIGATION_UP = 138
    NAVIGATION_DOWN = 139
    NAVIGATION_LEFT = 140
    NAVIGATION_RIGHT = 141
    NAVIGATION_ACCEPT = 142
    NAVIGATION_CANCEL = 143
    NUMBER_KEY_LOCK = 144
    SCROLL = 145
    LEFT_SHIFT = 160
    RIGHT_SHIFT = 161
    LEFT_CONTROL = 162
    RIGHT_CONTROL = 163
    LEFT_MENU = 164
    RIGHT_MENU = 165
    GO_BACK = 166
    GO_FORWARD = 167
    REFRESH = 168
    STOP = 169
    SEARCH = 170
    FAVORITES = 171
    GO_HOME = 172
    GAMEPAD_A = 195
    GAMEPAD_B = 196
    GAMEPAD_X = 197
    GAMEPAD_Y = 198
    GAMEPAD_RIGHT_SHOULDER = 199
    GAMEPAD_LEFT_SHOULDER = 200
    GAMEPAD_LEFT_TRIGGER = 201
    GAMEPAD_RIGHT_TRIGGER = 202
    GAMEPAD_D_PAD_UP = 203
    GAMEPAD_D_PAD_DOWN = 204
    GAMEPAD_D_PAD_LEFT = 205
    GAMEPAD_D_PAD_RIGHT = 206
    GAMEPAD_MENU = 207
    GAMEPAD_VIEW = 208
    GAMEPAD_LEFT_THUMBSTICK_BUTTON = 209
    GAMEPAD_RIGHT_THUMBSTICK_BUTTON = 210
    GAMEPAD_LEFT_THUMBSTICK_UP = 211
    GAMEPAD_LEFT_THUMBSTICK_DOWN = 212
    GAMEPAD_LEFT_THUMBSTICK_RIGHT = 213
    GAMEPAD_LEFT_THUMBSTICK_LEFT = 214
    GAMEPAD_RIGHT_THUMBSTICK_UP = 215
    GAMEPAD_RIGHT_THUMBSTICK_DOWN = 216
    GAMEPAD_RIGHT_THUMBSTICK_RIGHT = 217
    GAMEPAD_RIGHT_THUMBSTICK_LEFT = 218

class VirtualKeyModifiers(enum.IntFlag):
    NONE = 0
    CONTROL = 0x1
    MENU = 0x2
    SHIFT = 0x4
    WINDOWS = 0x8

Self = typing.TypeVar('Self')

class AppActivationResult(winrt.system.Object):
    app_resource_group_info: typing.Optional[AppResourceGroupInfo]
    extended_error: winrt.windows.foundation.HResult
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppActivationResult: ...

class AppDiagnosticInfo(winrt.system.Object):
    app_info: typing.Optional[winrt.windows.applicationmodel.AppInfo]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppDiagnosticInfo: ...
    def create_resource_group_watcher(self) -> typing.Optional[AppResourceGroupInfoWatcher]: ...
    @staticmethod
    def create_watcher() -> typing.Optional[AppDiagnosticInfoWatcher]: ...
    def get_resource_groups(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[AppResourceGroupInfo]]: ...
    def launch_async(self) -> winrt.windows.foundation.IAsyncOperation[AppActivationResult]: ...
    @staticmethod
    def request_access_async() -> winrt.windows.foundation.IAsyncOperation[DiagnosticAccessStatus]: ...
    @staticmethod
    def request_info_async() -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVector[AppDiagnosticInfo]]: ...
    @typing.overload
    @staticmethod
    def request_info_for_app_async() -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVector[AppDiagnosticInfo]]: ...
    @typing.overload
    @staticmethod
    def request_info_for_app_async(app_user_model_id: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVector[AppDiagnosticInfo]]: ...
    @staticmethod
    def request_info_for_package_async(package_family_name: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVector[AppDiagnosticInfo]]: ...

class AppDiagnosticInfoWatcher(winrt.system.Object):
    status: AppDiagnosticInfoWatcherStatus
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppDiagnosticInfoWatcher: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def add_added(self, handler: winrt.windows.foundation.TypedEventHandler[AppDiagnosticInfoWatcher, AppDiagnosticInfoWatcherEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_added(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_enumeration_completed(self, handler: winrt.windows.foundation.TypedEventHandler[AppDiagnosticInfoWatcher, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_enumeration_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_removed(self, handler: winrt.windows.foundation.TypedEventHandler[AppDiagnosticInfoWatcher, AppDiagnosticInfoWatcherEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_removed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_stopped(self, handler: winrt.windows.foundation.TypedEventHandler[AppDiagnosticInfoWatcher, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_stopped(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class AppDiagnosticInfoWatcherEventArgs(winrt.system.Object):
    app_diagnostic_info: typing.Optional[AppDiagnosticInfo]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppDiagnosticInfoWatcherEventArgs: ...

class AppExecutionStateChangeResult(winrt.system.Object):
    extended_error: winrt.windows.foundation.HResult
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppExecutionStateChangeResult: ...

class AppMemoryReport(winrt.system.Object):
    peak_private_commit_usage: winrt.system.UInt64
    private_commit_usage: winrt.system.UInt64
    total_commit_limit: winrt.system.UInt64
    total_commit_usage: winrt.system.UInt64
    expected_total_commit_limit: winrt.system.UInt64
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppMemoryReport: ...

class AppMemoryUsageLimitChangingEventArgs(winrt.system.Object):
    new_limit: winrt.system.UInt64
    old_limit: winrt.system.UInt64
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppMemoryUsageLimitChangingEventArgs: ...

class AppResourceGroupBackgroundTaskReport(winrt.system.Object):
    entry_point: str
    name: str
    task_id: winrt.system.Guid
    trigger: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppResourceGroupBackgroundTaskReport: ...

class AppResourceGroupInfo(winrt.system.Object):
    instance_id: winrt.system.Guid
    is_shared: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppResourceGroupInfo: ...
    def get_background_task_reports(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[AppResourceGroupBackgroundTaskReport]]: ...
    def get_memory_report(self) -> typing.Optional[AppResourceGroupMemoryReport]: ...
    def get_process_diagnostic_infos(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.system.diagnostics.ProcessDiagnosticInfo]]: ...
    def get_state_report(self) -> typing.Optional[AppResourceGroupStateReport]: ...
    def start_resume_async(self) -> winrt.windows.foundation.IAsyncOperation[AppExecutionStateChangeResult]: ...
    def start_suspend_async(self) -> winrt.windows.foundation.IAsyncOperation[AppExecutionStateChangeResult]: ...
    def start_terminate_async(self) -> winrt.windows.foundation.IAsyncOperation[AppExecutionStateChangeResult]: ...

class AppResourceGroupInfoWatcher(winrt.system.Object):
    status: AppResourceGroupInfoWatcherStatus
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppResourceGroupInfoWatcher: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def add_added(self, handler: winrt.windows.foundation.TypedEventHandler[AppResourceGroupInfoWatcher, AppResourceGroupInfoWatcherEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_added(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_enumeration_completed(self, handler: winrt.windows.foundation.TypedEventHandler[AppResourceGroupInfoWatcher, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_enumeration_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_execution_state_changed(self, handler: winrt.windows.foundation.TypedEventHandler[AppResourceGroupInfoWatcher, AppResourceGroupInfoWatcherExecutionStateChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_execution_state_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_removed(self, handler: winrt.windows.foundation.TypedEventHandler[AppResourceGroupInfoWatcher, AppResourceGroupInfoWatcherEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_removed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_stopped(self, handler: winrt.windows.foundation.TypedEventHandler[AppResourceGroupInfoWatcher, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_stopped(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class AppResourceGroupInfoWatcherEventArgs(winrt.system.Object):
    app_diagnostic_infos: typing.Optional[winrt.windows.foundation.collections.IVectorView[AppDiagnosticInfo]]
    app_resource_group_info: typing.Optional[AppResourceGroupInfo]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppResourceGroupInfoWatcherEventArgs: ...

class AppResourceGroupInfoWatcherExecutionStateChangedEventArgs(winrt.system.Object):
    app_diagnostic_infos: typing.Optional[winrt.windows.foundation.collections.IVectorView[AppDiagnosticInfo]]
    app_resource_group_info: typing.Optional[AppResourceGroupInfo]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppResourceGroupInfoWatcherExecutionStateChangedEventArgs: ...

class AppResourceGroupMemoryReport(winrt.system.Object):
    commit_usage_level: AppMemoryUsageLevel
    commit_usage_limit: winrt.system.UInt64
    private_commit_usage: winrt.system.UInt64
    total_commit_usage: winrt.system.UInt64
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppResourceGroupMemoryReport: ...

class AppResourceGroupStateReport(winrt.system.Object):
    energy_quota_state: AppResourceGroupEnergyQuotaState
    execution_state: AppResourceGroupExecutionState
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppResourceGroupStateReport: ...

class AppUriHandlerHost(winrt.system.Object):
    name: str
    is_enabled: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppUriHandlerHost: ...
    @typing.overload
    def __new__(cls: typing.Type[AppUriHandlerHost], name: str) -> AppUriHandlerHost:...
    @typing.overload
    def __new__(cls: typing.Type[AppUriHandlerHost]) -> AppUriHandlerHost:...

class AppUriHandlerRegistration(winrt.system.Object):
    name: str
    user: typing.Optional[User]
    package_family_name: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppUriHandlerRegistration: ...
    def get_all_hosts(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[AppUriHandlerHost]]: ...
    def get_app_added_hosts_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVector[AppUriHandlerHost]]: ...
    def set_app_added_hosts_async(self, hosts: typing.Iterable[AppUriHandlerHost], /) -> winrt.windows.foundation.IAsyncAction: ...
    def update_hosts(self, hosts: typing.Iterable[AppUriHandlerHost], /) -> None: ...

class AppUriHandlerRegistrationManager(winrt.system.Object):
    user: typing.Optional[User]
    package_family_name: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppUriHandlerRegistrationManager: ...
    @staticmethod
    def get_default() -> typing.Optional[AppUriHandlerRegistrationManager]: ...
    @staticmethod
    def get_for_package(package_family_name: str, /) -> typing.Optional[AppUriHandlerRegistrationManager]: ...
    @staticmethod
    def get_for_package_for_user(package_family_name: str, user: typing.Optional[User], /) -> typing.Optional[AppUriHandlerRegistrationManager]: ...
    @staticmethod
    def get_for_user(user: typing.Optional[User], /) -> typing.Optional[AppUriHandlerRegistrationManager]: ...
    def try_get_registration(self, name: str, /) -> typing.Optional[AppUriHandlerRegistration]: ...

class DateTimeSettings(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DateTimeSettings: ...
    @staticmethod
    def set_system_date_time(utc_date_time: datetime.datetime, /) -> None: ...

class DispatcherQueue(winrt.system.Object):
    has_thread_access: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DispatcherQueue: ...
    def create_timer(self) -> typing.Optional[DispatcherQueueTimer]: ...
    @staticmethod
    def get_for_current_thread() -> typing.Optional[DispatcherQueue]: ...
    @typing.overload
    def try_enqueue(self, callback: typing.Optional[DispatcherQueueHandler], /) -> winrt.system.Boolean: ...
    @typing.overload
    def try_enqueue(self, priority: DispatcherQueuePriority, callback: typing.Optional[DispatcherQueueHandler], /) -> winrt.system.Boolean: ...
    def add_shutdown_completed(self, handler: winrt.windows.foundation.TypedEventHandler[DispatcherQueue, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_shutdown_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_shutdown_starting(self, handler: winrt.windows.foundation.TypedEventHandler[DispatcherQueue, DispatcherQueueShutdownStartingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_shutdown_starting(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class DispatcherQueueController(winrt.system.Object):
    dispatcher_queue: typing.Optional[DispatcherQueue]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DispatcherQueueController: ...
    @staticmethod
    def create_on_dedicated_thread() -> typing.Optional[DispatcherQueueController]: ...
    def shutdown_queue_async(self) -> winrt.windows.foundation.IAsyncAction: ...

class DispatcherQueueShutdownStartingEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DispatcherQueueShutdownStartingEventArgs: ...
    def get_deferral(self) -> typing.Optional[winrt.windows.foundation.Deferral]: ...

class DispatcherQueueTimer(winrt.system.Object):
    is_repeating: winrt.system.Boolean
    interval: datetime.timedelta
    is_running: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DispatcherQueueTimer: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def add_tick(self, handler: winrt.windows.foundation.TypedEventHandler[DispatcherQueueTimer, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_tick(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class FolderLauncherOptions(winrt.system.Object):
    items_to_select: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.storage.IStorageItem]]
    desired_remaining_view: winrt.windows.ui.viewmanagement.ViewSizePreference
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FolderLauncherOptions: ...
    def __new__(cls: typing.Type[FolderLauncherOptions]) -> FolderLauncherOptions:...

class KnownUserProperties(winrt.system.Object):
    account_name: typing.ClassVar[str]
    display_name: typing.ClassVar[str]
    domain_name: typing.ClassVar[str]
    first_name: typing.ClassVar[str]
    guest_host: typing.ClassVar[str]
    last_name: typing.ClassVar[str]
    principal_name: typing.ClassVar[str]
    provider_name: typing.ClassVar[str]
    session_initiation_protocol_uri: typing.ClassVar[str]
    age_enforcement_region: typing.ClassVar[str]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> KnownUserProperties: ...

class LaunchUriResult(winrt.system.Object):
    result: typing.Optional[winrt.windows.foundation.collections.ValueSet]
    status: LaunchUriStatus
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LaunchUriResult: ...

class Launcher(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Launcher: ...
    @staticmethod
    def find_app_uri_handlers_async(uri: typing.Optional[winrt.windows.foundation.Uri], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[winrt.windows.applicationmodel.AppInfo]]: ...
    @staticmethod
    def find_file_handlers_async(extension: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[winrt.windows.applicationmodel.AppInfo]]: ...
    @typing.overload
    @staticmethod
    def find_uri_scheme_handlers_async(scheme: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[winrt.windows.applicationmodel.AppInfo]]: ...
    @typing.overload
    @staticmethod
    def find_uri_scheme_handlers_async(scheme: str, launch_query_support_type: LaunchQuerySupportType, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[winrt.windows.applicationmodel.AppInfo]]: ...
    @typing.overload
    @staticmethod
    def launch_file_async(file: typing.Optional[winrt.windows.storage.IStorageFile], /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...
    @typing.overload
    @staticmethod
    def launch_file_async(file: typing.Optional[winrt.windows.storage.IStorageFile], options: typing.Optional[LauncherOptions], /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...
    @typing.overload
    @staticmethod
    def launch_folder_async(folder: typing.Optional[winrt.windows.storage.IStorageFolder], /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...
    @typing.overload
    @staticmethod
    def launch_folder_async(folder: typing.Optional[winrt.windows.storage.IStorageFolder], options: typing.Optional[FolderLauncherOptions], /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...
    @typing.overload
    @staticmethod
    def launch_folder_path_async(path: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...
    @typing.overload
    @staticmethod
    def launch_folder_path_async(path: str, options: typing.Optional[FolderLauncherOptions], /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...
    @typing.overload
    @staticmethod
    def launch_folder_path_for_user_async(user: typing.Optional[User], path: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...
    @typing.overload
    @staticmethod
    def launch_folder_path_for_user_async(user: typing.Optional[User], path: str, options: typing.Optional[FolderLauncherOptions], /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...
    @typing.overload
    @staticmethod
    def launch_uri_async(uri: typing.Optional[winrt.windows.foundation.Uri], /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...
    @typing.overload
    @staticmethod
    def launch_uri_async(uri: typing.Optional[winrt.windows.foundation.Uri], options: typing.Optional[LauncherOptions], /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...
    @typing.overload
    @staticmethod
    def launch_uri_async(uri: typing.Optional[winrt.windows.foundation.Uri], options: typing.Optional[LauncherOptions], input_data: typing.Optional[winrt.windows.foundation.collections.ValueSet], /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...
    @typing.overload
    @staticmethod
    def launch_uri_for_results_async(uri: typing.Optional[winrt.windows.foundation.Uri], options: typing.Optional[LauncherOptions], /) -> winrt.windows.foundation.IAsyncOperation[LaunchUriResult]: ...
    @typing.overload
    @staticmethod
    def launch_uri_for_results_async(uri: typing.Optional[winrt.windows.foundation.Uri], options: typing.Optional[LauncherOptions], input_data: typing.Optional[winrt.windows.foundation.collections.ValueSet], /) -> winrt.windows.foundation.IAsyncOperation[LaunchUriResult]: ...
    @typing.overload
    @staticmethod
    def launch_uri_for_results_for_user_async(user: typing.Optional[User], uri: typing.Optional[winrt.windows.foundation.Uri], options: typing.Optional[LauncherOptions], /) -> winrt.windows.foundation.IAsyncOperation[LaunchUriResult]: ...
    @typing.overload
    @staticmethod
    def launch_uri_for_results_for_user_async(user: typing.Optional[User], uri: typing.Optional[winrt.windows.foundation.Uri], options: typing.Optional[LauncherOptions], input_data: typing.Optional[winrt.windows.foundation.collections.ValueSet], /) -> winrt.windows.foundation.IAsyncOperation[LaunchUriResult]: ...
    @typing.overload
    @staticmethod
    def launch_uri_for_user_async(user: typing.Optional[User], uri: typing.Optional[winrt.windows.foundation.Uri], /) -> winrt.windows.foundation.IAsyncOperation[LaunchUriStatus]: ...
    @typing.overload
    @staticmethod
    def launch_uri_for_user_async(user: typing.Optional[User], uri: typing.Optional[winrt.windows.foundation.Uri], options: typing.Optional[LauncherOptions], /) -> winrt.windows.foundation.IAsyncOperation[LaunchUriStatus]: ...
    @typing.overload
    @staticmethod
    def launch_uri_for_user_async(user: typing.Optional[User], uri: typing.Optional[winrt.windows.foundation.Uri], options: typing.Optional[LauncherOptions], input_data: typing.Optional[winrt.windows.foundation.collections.ValueSet], /) -> winrt.windows.foundation.IAsyncOperation[LaunchUriStatus]: ...
    @typing.overload
    @staticmethod
    def query_app_uri_support_async(uri: typing.Optional[winrt.windows.foundation.Uri], /) -> winrt.windows.foundation.IAsyncOperation[LaunchQuerySupportStatus]: ...
    @typing.overload
    @staticmethod
    def query_app_uri_support_async(uri: typing.Optional[winrt.windows.foundation.Uri], package_family_name: str, /) -> winrt.windows.foundation.IAsyncOperation[LaunchQuerySupportStatus]: ...
    @typing.overload
    @staticmethod
    def query_file_support_async(file: typing.Optional[winrt.windows.storage.StorageFile], /) -> winrt.windows.foundation.IAsyncOperation[LaunchQuerySupportStatus]: ...
    @typing.overload
    @staticmethod
    def query_file_support_async(file: typing.Optional[winrt.windows.storage.StorageFile], package_family_name: str, /) -> winrt.windows.foundation.IAsyncOperation[LaunchQuerySupportStatus]: ...
    @typing.overload
    @staticmethod
    def query_uri_support_async(uri: typing.Optional[winrt.windows.foundation.Uri], launch_query_support_type: LaunchQuerySupportType, /) -> winrt.windows.foundation.IAsyncOperation[LaunchQuerySupportStatus]: ...
    @typing.overload
    @staticmethod
    def query_uri_support_async(uri: typing.Optional[winrt.windows.foundation.Uri], launch_query_support_type: LaunchQuerySupportType, package_family_name: str, /) -> winrt.windows.foundation.IAsyncOperation[LaunchQuerySupportStatus]: ...

class LauncherOptions(winrt.system.Object):
    treat_as_untrusted: winrt.system.Boolean
    preferred_application_package_family_name: str
    preferred_application_display_name: str
    fallback_uri: typing.Optional[winrt.windows.foundation.Uri]
    display_application_picker: winrt.system.Boolean
    content_type: str
    u_i: typing.Optional[LauncherUIOptions]
    target_application_package_family_name: str
    neighboring_files_query: typing.Optional[winrt.windows.storage.search.StorageFileQueryResult]
    ignore_app_uri_handlers: winrt.system.Boolean
    limit_picker_to_current_app_and_app_uri_handlers: winrt.system.Boolean
    desired_remaining_view: winrt.windows.ui.viewmanagement.ViewSizePreference
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LauncherOptions: ...
    def __new__(cls: typing.Type[LauncherOptions]) -> LauncherOptions:...

class LauncherUIOptions(winrt.system.Object):
    selection_rect: typing.Optional[typing.Optional[winrt.windows.foundation.Rect]]
    preferred_placement: winrt.windows.ui.popups.Placement
    invocation_point: typing.Optional[typing.Optional[winrt.windows.foundation.Point]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LauncherUIOptions: ...

class MemoryManager(winrt.system.Object):
    app_memory_usage: typing.ClassVar[winrt.system.UInt64]
    app_memory_usage_level: typing.ClassVar[AppMemoryUsageLevel]
    app_memory_usage_limit: typing.ClassVar[winrt.system.UInt64]
    expected_app_memory_usage_limit: typing.ClassVar[winrt.system.UInt64]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MemoryManager: ...
    @staticmethod
    def get_app_memory_report() -> typing.Optional[AppMemoryReport]: ...
    @staticmethod
    def get_process_memory_report() -> typing.Optional[ProcessMemoryReport]: ...
    @staticmethod
    def try_set_app_memory_usage_limit(value: winrt.system.UInt64, /) -> winrt.system.Boolean: ...
    @staticmethod
    def add_app_memory_usage_decreased(handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    @staticmethod
    def remove_app_memory_usage_decreased(token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @staticmethod
    def add_app_memory_usage_increased(handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    @staticmethod
    def remove_app_memory_usage_increased(token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @staticmethod
    def add_app_memory_usage_limit_changing(handler: winrt.windows.foundation.EventHandler[AppMemoryUsageLimitChangingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    @staticmethod
    def remove_app_memory_usage_limit_changing(token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class ProcessLauncher(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProcessLauncher: ...
    @typing.overload
    @staticmethod
    def run_to_completion_async(file_name: str, args: str, /) -> winrt.windows.foundation.IAsyncOperation[ProcessLauncherResult]: ...
    @typing.overload
    @staticmethod
    def run_to_completion_async(file_name: str, args: str, options: typing.Optional[ProcessLauncherOptions], /) -> winrt.windows.foundation.IAsyncOperation[ProcessLauncherResult]: ...

class ProcessLauncherOptions(winrt.system.Object):
    working_directory: str
    standard_output: typing.Optional[winrt.windows.storage.streams.IOutputStream]
    standard_input: typing.Optional[winrt.windows.storage.streams.IInputStream]
    standard_error: typing.Optional[winrt.windows.storage.streams.IOutputStream]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProcessLauncherOptions: ...
    def __new__(cls: typing.Type[ProcessLauncherOptions]) -> ProcessLauncherOptions:...

class ProcessLauncherResult(winrt.system.Object):
    exit_code: winrt.system.UInt32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProcessLauncherResult: ...

class ProcessMemoryReport(winrt.system.Object):
    private_working_set_usage: winrt.system.UInt64
    total_working_set_usage: winrt.system.UInt64
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProcessMemoryReport: ...

class ProtocolForResultsOperation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProtocolForResultsOperation: ...
    def report_completed(self, data: typing.Optional[winrt.windows.foundation.collections.ValueSet], /) -> None: ...

class RemoteLauncher(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RemoteLauncher: ...
    @typing.overload
    @staticmethod
    def launch_uri_async(remote_system_connection_request: typing.Optional[winrt.windows.system.remotesystems.RemoteSystemConnectionRequest], uri: typing.Optional[winrt.windows.foundation.Uri], /) -> winrt.windows.foundation.IAsyncOperation[RemoteLaunchUriStatus]: ...
    @typing.overload
    @staticmethod
    def launch_uri_async(remote_system_connection_request: typing.Optional[winrt.windows.system.remotesystems.RemoteSystemConnectionRequest], uri: typing.Optional[winrt.windows.foundation.Uri], options: typing.Optional[RemoteLauncherOptions], /) -> winrt.windows.foundation.IAsyncOperation[RemoteLaunchUriStatus]: ...
    @typing.overload
    @staticmethod
    def launch_uri_async(remote_system_connection_request: typing.Optional[winrt.windows.system.remotesystems.RemoteSystemConnectionRequest], uri: typing.Optional[winrt.windows.foundation.Uri], options: typing.Optional[RemoteLauncherOptions], input_data: typing.Optional[winrt.windows.foundation.collections.ValueSet], /) -> winrt.windows.foundation.IAsyncOperation[RemoteLaunchUriStatus]: ...

class RemoteLauncherOptions(winrt.system.Object):
    fallback_uri: typing.Optional[winrt.windows.foundation.Uri]
    preferred_app_ids: typing.Optional[winrt.windows.foundation.collections.IVector[str]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RemoteLauncherOptions: ...
    def __new__(cls: typing.Type[RemoteLauncherOptions]) -> RemoteLauncherOptions:...

class ShutdownManager(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ShutdownManager: ...
    @staticmethod
    def begin_shutdown(shutdown_kind: ShutdownKind, timeout: datetime.timedelta, /) -> None: ...
    @staticmethod
    def cancel_shutdown() -> None: ...
    @typing.overload
    @staticmethod
    def enter_power_state(power_state: PowerState, /) -> None: ...
    @typing.overload
    @staticmethod
    def enter_power_state(power_state: PowerState, wake_up_after: datetime.timedelta, /) -> None: ...
    @staticmethod
    def is_power_state_supported(power_state: PowerState, /) -> winrt.system.Boolean: ...

class TimeZoneSettings(winrt.system.Object):
    can_change_time_zone: typing.ClassVar[winrt.system.Boolean]
    current_time_zone_display_name: typing.ClassVar[str]
    supported_time_zone_display_names: typing.ClassVar[typing.Optional[winrt.windows.foundation.collections.IVectorView[str]]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TimeZoneSettings: ...
    @staticmethod
    def auto_update_time_zone_async(timeout: datetime.timedelta, /) -> winrt.windows.foundation.IAsyncOperation[AutoUpdateTimeZoneStatus]: ...
    @staticmethod
    def change_time_zone_by_display_name(time_zone_display_name: str, /) -> None: ...

class User(winrt.system.Object):
    authentication_status: UserAuthenticationStatus
    non_roamable_id: str
    type: UserType
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> User: ...
    def check_user_age_consent_group_async(self, consent_group: UserAgeConsentGroup, /) -> winrt.windows.foundation.IAsyncOperation[UserAgeConsentResult]: ...
    @staticmethod
    def create_watcher() -> typing.Optional[UserWatcher]: ...
    @typing.overload
    @staticmethod
    def find_all_async() -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[User]]: ...
    @typing.overload
    @staticmethod
    def find_all_async(type: UserType, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[User]]: ...
    @typing.overload
    @staticmethod
    def find_all_async(type: UserType, status: UserAuthenticationStatus, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[User]]: ...
    @staticmethod
    def get_default() -> typing.Optional[User]: ...
    @staticmethod
    def get_from_id(non_roamable_id: str, /) -> typing.Optional[User]: ...
    def get_picture_async(self, desired_size: UserPictureSize, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.streams.IRandomAccessStreamReference]: ...
    def get_properties_async(self, values: winrt.windows.foundation.collections.IVectorView[str], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IPropertySet]: ...
    def get_property_async(self, value: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Object]: ...

class UserAuthenticationStatusChangeDeferral(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UserAuthenticationStatusChangeDeferral: ...
    def complete(self) -> None: ...

class UserAuthenticationStatusChangingEventArgs(winrt.system.Object):
    current_status: UserAuthenticationStatus
    new_status: UserAuthenticationStatus
    user: typing.Optional[User]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UserAuthenticationStatusChangingEventArgs: ...
    def get_deferral(self) -> typing.Optional[UserAuthenticationStatusChangeDeferral]: ...

class UserChangedEventArgs(winrt.system.Object):
    user: typing.Optional[User]
    changed_property_kinds: typing.Optional[winrt.windows.foundation.collections.IVectorView[UserWatcherUpdateKind]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UserChangedEventArgs: ...

class UserDeviceAssociation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UserDeviceAssociation: ...
    @staticmethod
    def find_user_from_device_id(device_id: str, /) -> typing.Optional[User]: ...
    @staticmethod
    def add_user_device_association_changed(handler: winrt.windows.foundation.EventHandler[UserDeviceAssociationChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    @staticmethod
    def remove_user_device_association_changed(token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class UserDeviceAssociationChangedEventArgs(winrt.system.Object):
    device_id: str
    new_user: typing.Optional[User]
    old_user: typing.Optional[User]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UserDeviceAssociationChangedEventArgs: ...

class UserPicker(winrt.system.Object):
    suggested_selected_user: typing.Optional[User]
    allow_guest_accounts: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UserPicker: ...
    def __new__(cls: typing.Type[UserPicker]) -> UserPicker:...
    @staticmethod
    def is_supported() -> winrt.system.Boolean: ...
    def pick_single_user_async(self) -> winrt.windows.foundation.IAsyncOperation[User]: ...

class UserWatcher(winrt.system.Object):
    status: UserWatcherStatus
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UserWatcher: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def add_added(self, handler: winrt.windows.foundation.TypedEventHandler[UserWatcher, UserChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_added(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_authentication_status_changed(self, handler: winrt.windows.foundation.TypedEventHandler[UserWatcher, UserChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_authentication_status_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_authentication_status_changing(self, handler: winrt.windows.foundation.TypedEventHandler[UserWatcher, UserAuthenticationStatusChangingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_authentication_status_changing(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_enumeration_completed(self, handler: winrt.windows.foundation.TypedEventHandler[UserWatcher, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_enumeration_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_removed(self, handler: winrt.windows.foundation.TypedEventHandler[UserWatcher, UserChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_removed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_stopped(self, handler: winrt.windows.foundation.TypedEventHandler[UserWatcher, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_stopped(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_updated(self, handler: winrt.windows.foundation.TypedEventHandler[UserWatcher, UserChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_updated(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class ILauncherViewOptions(winrt.system.Object):
    desired_remaining_view: winrt.windows.ui.viewmanagement.ViewSizePreference
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ILauncherViewOptions: ...

DispatcherQueueHandler = typing.Callable[[], None]

