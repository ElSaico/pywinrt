# WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

import datetime
import sys
import types
import typing

import winrt.system
import winrt.windows.applicationmodel
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.storage
import winrt.windows.storage.search
import winrt.windows.storage.streams
import winrt.windows.system.diagnostics
import winrt.windows.system.remotesystems
import winrt.windows.ui.popups
import winrt.windows.ui.viewmanagement

from . import AppDiagnosticInfoWatcherStatus, AppMemoryUsageLevel, AppResourceGroupEnergyQuotaState, AppResourceGroupExecutionState, AppResourceGroupInfoWatcherStatus, AutoUpdateTimeZoneStatus, DiagnosticAccessStatus, DispatcherQueuePriority, LaunchFileStatus, LaunchQuerySupportStatus, LaunchQuerySupportType, LaunchUriStatus, PowerState, ProcessorArchitecture, RemoteLaunchUriStatus, ShutdownKind, UserAgeConsentGroup, UserAgeConsentResult, UserAuthenticationStatus, UserPictureSize, UserType, UserWatcherStatus, UserWatcherUpdateKind, VirtualKey, VirtualKeyModifiers
from . import DispatcherQueueHandler

Self = typing.TypeVar('Self')

class AppActivationResult(winrt.system.Object):
    app_resource_group_info: typing.Optional[AppResourceGroupInfo]
    extended_error: winrt.windows.foundation.HResult
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppActivationResult: ...

class AppDiagnosticInfo(winrt.system.Object):
    app_info: typing.Optional[winrt.windows.applicationmodel.AppInfo]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppDiagnosticInfo: ...
    def create_resource_group_watcher(self) -> typing.Optional[AppResourceGroupInfoWatcher]: ...
    @staticmethod
    def create_watcher() -> typing.Optional[AppDiagnosticInfoWatcher]: ...
    def get_resource_groups(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[AppResourceGroupInfo]]: ...
    def launch_async(self) -> winrt.windows.foundation.IAsyncOperation[AppActivationResult]: ...
    @staticmethod
    def request_access_async() -> winrt.windows.foundation.IAsyncOperation[DiagnosticAccessStatus]: ...
    @staticmethod
    def request_info_async() -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVector[AppDiagnosticInfo]]: ...
    @typing.overload
    @staticmethod
    def request_info_for_app_async() -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVector[AppDiagnosticInfo]]: ...
    @typing.overload
    @staticmethod
    def request_info_for_app_async(app_user_model_id: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVector[AppDiagnosticInfo]]: ...
    @staticmethod
    def request_info_for_package_async(package_family_name: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVector[AppDiagnosticInfo]]: ...

class AppDiagnosticInfoWatcher(winrt.system.Object):
    status: AppDiagnosticInfoWatcherStatus
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppDiagnosticInfoWatcher: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def add_added(self, handler: winrt.windows.foundation.TypedEventHandler[AppDiagnosticInfoWatcher, AppDiagnosticInfoWatcherEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_added(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_enumeration_completed(self, handler: winrt.windows.foundation.TypedEventHandler[AppDiagnosticInfoWatcher, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_enumeration_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_removed(self, handler: winrt.windows.foundation.TypedEventHandler[AppDiagnosticInfoWatcher, AppDiagnosticInfoWatcherEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_removed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_stopped(self, handler: winrt.windows.foundation.TypedEventHandler[AppDiagnosticInfoWatcher, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_stopped(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class AppDiagnosticInfoWatcherEventArgs(winrt.system.Object):
    app_diagnostic_info: typing.Optional[AppDiagnosticInfo]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppDiagnosticInfoWatcherEventArgs: ...

class AppExecutionStateChangeResult(winrt.system.Object):
    extended_error: winrt.windows.foundation.HResult
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppExecutionStateChangeResult: ...

class AppMemoryReport(winrt.system.Object):
    peak_private_commit_usage: winrt.system.UInt64
    private_commit_usage: winrt.system.UInt64
    total_commit_limit: winrt.system.UInt64
    total_commit_usage: winrt.system.UInt64
    expected_total_commit_limit: winrt.system.UInt64
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppMemoryReport: ...

class AppMemoryUsageLimitChangingEventArgs(winrt.system.Object):
    new_limit: winrt.system.UInt64
    old_limit: winrt.system.UInt64
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppMemoryUsageLimitChangingEventArgs: ...

class AppResourceGroupBackgroundTaskReport(winrt.system.Object):
    entry_point: str
    name: str
    task_id: winrt.system.Guid
    trigger: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppResourceGroupBackgroundTaskReport: ...

class AppResourceGroupInfo(winrt.system.Object):
    instance_id: winrt.system.Guid
    is_shared: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppResourceGroupInfo: ...
    def get_background_task_reports(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[AppResourceGroupBackgroundTaskReport]]: ...
    def get_memory_report(self) -> typing.Optional[AppResourceGroupMemoryReport]: ...
    def get_process_diagnostic_infos(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.system.diagnostics.ProcessDiagnosticInfo]]: ...
    def get_state_report(self) -> typing.Optional[AppResourceGroupStateReport]: ...
    def start_resume_async(self) -> winrt.windows.foundation.IAsyncOperation[AppExecutionStateChangeResult]: ...
    def start_suspend_async(self) -> winrt.windows.foundation.IAsyncOperation[AppExecutionStateChangeResult]: ...
    def start_terminate_async(self) -> winrt.windows.foundation.IAsyncOperation[AppExecutionStateChangeResult]: ...

class AppResourceGroupInfoWatcher(winrt.system.Object):
    status: AppResourceGroupInfoWatcherStatus
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppResourceGroupInfoWatcher: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def add_added(self, handler: winrt.windows.foundation.TypedEventHandler[AppResourceGroupInfoWatcher, AppResourceGroupInfoWatcherEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_added(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_enumeration_completed(self, handler: winrt.windows.foundation.TypedEventHandler[AppResourceGroupInfoWatcher, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_enumeration_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_execution_state_changed(self, handler: winrt.windows.foundation.TypedEventHandler[AppResourceGroupInfoWatcher, AppResourceGroupInfoWatcherExecutionStateChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_execution_state_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_removed(self, handler: winrt.windows.foundation.TypedEventHandler[AppResourceGroupInfoWatcher, AppResourceGroupInfoWatcherEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_removed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_stopped(self, handler: winrt.windows.foundation.TypedEventHandler[AppResourceGroupInfoWatcher, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_stopped(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class AppResourceGroupInfoWatcherEventArgs(winrt.system.Object):
    app_diagnostic_infos: typing.Optional[winrt.windows.foundation.collections.IVectorView[AppDiagnosticInfo]]
    app_resource_group_info: typing.Optional[AppResourceGroupInfo]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppResourceGroupInfoWatcherEventArgs: ...

class AppResourceGroupInfoWatcherExecutionStateChangedEventArgs(winrt.system.Object):
    app_diagnostic_infos: typing.Optional[winrt.windows.foundation.collections.IVectorView[AppDiagnosticInfo]]
    app_resource_group_info: typing.Optional[AppResourceGroupInfo]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppResourceGroupInfoWatcherExecutionStateChangedEventArgs: ...

class AppResourceGroupMemoryReport(winrt.system.Object):
    commit_usage_level: AppMemoryUsageLevel
    commit_usage_limit: winrt.system.UInt64
    private_commit_usage: winrt.system.UInt64
    total_commit_usage: winrt.system.UInt64
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppResourceGroupMemoryReport: ...

class AppResourceGroupStateReport(winrt.system.Object):
    energy_quota_state: AppResourceGroupEnergyQuotaState
    execution_state: AppResourceGroupExecutionState
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppResourceGroupStateReport: ...

class AppUriHandlerHost(winrt.system.Object):
    name: str
    is_enabled: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppUriHandlerHost: ...
    @typing.overload
    def __new__(cls: typing.Type[AppUriHandlerHost], name: str) -> AppUriHandlerHost:...
    @typing.overload
    def __new__(cls: typing.Type[AppUriHandlerHost]) -> AppUriHandlerHost:...

class AppUriHandlerRegistration(winrt.system.Object):
    name: str
    user: typing.Optional[User]
    package_family_name: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppUriHandlerRegistration: ...
    def get_all_hosts(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[AppUriHandlerHost]]: ...
    def get_app_added_hosts_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVector[AppUriHandlerHost]]: ...
    def set_app_added_hosts_async(self, hosts: typing.Iterable[AppUriHandlerHost], /) -> winrt.windows.foundation.IAsyncAction: ...
    def update_hosts(self, hosts: typing.Iterable[AppUriHandlerHost], /) -> None: ...

class AppUriHandlerRegistrationManager(winrt.system.Object):
    user: typing.Optional[User]
    package_family_name: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppUriHandlerRegistrationManager: ...
    @staticmethod
    def get_default() -> typing.Optional[AppUriHandlerRegistrationManager]: ...
    @staticmethod
    def get_for_package(package_family_name: str, /) -> typing.Optional[AppUriHandlerRegistrationManager]: ...
    @staticmethod
    def get_for_package_for_user(package_family_name: str, user: typing.Optional[User], /) -> typing.Optional[AppUriHandlerRegistrationManager]: ...
    @staticmethod
    def get_for_user(user: typing.Optional[User], /) -> typing.Optional[AppUriHandlerRegistrationManager]: ...
    def try_get_registration(self, name: str, /) -> typing.Optional[AppUriHandlerRegistration]: ...

class DateTimeSettings(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DateTimeSettings: ...
    @staticmethod
    def set_system_date_time(utc_date_time: datetime.datetime, /) -> None: ...

class DispatcherQueue(winrt.system.Object):
    has_thread_access: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DispatcherQueue: ...
    def create_timer(self) -> typing.Optional[DispatcherQueueTimer]: ...
    @staticmethod
    def get_for_current_thread() -> typing.Optional[DispatcherQueue]: ...
    @typing.overload
    def try_enqueue(self, callback: typing.Optional[DispatcherQueueHandler], /) -> winrt.system.Boolean: ...
    @typing.overload
    def try_enqueue(self, priority: DispatcherQueuePriority, callback: typing.Optional[DispatcherQueueHandler], /) -> winrt.system.Boolean: ...
    def add_shutdown_completed(self, handler: winrt.windows.foundation.TypedEventHandler[DispatcherQueue, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_shutdown_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_shutdown_starting(self, handler: winrt.windows.foundation.TypedEventHandler[DispatcherQueue, DispatcherQueueShutdownStartingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_shutdown_starting(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class DispatcherQueueController(winrt.system.Object):
    dispatcher_queue: typing.Optional[DispatcherQueue]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DispatcherQueueController: ...
    @staticmethod
    def create_on_dedicated_thread() -> typing.Optional[DispatcherQueueController]: ...
    def shutdown_queue_async(self) -> winrt.windows.foundation.IAsyncAction: ...

class DispatcherQueueShutdownStartingEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DispatcherQueueShutdownStartingEventArgs: ...
    def get_deferral(self) -> typing.Optional[winrt.windows.foundation.Deferral]: ...

class DispatcherQueueTimer(winrt.system.Object):
    is_repeating: winrt.system.Boolean
    interval: datetime.timedelta
    is_running: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DispatcherQueueTimer: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def add_tick(self, handler: winrt.windows.foundation.TypedEventHandler[DispatcherQueueTimer, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_tick(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class FolderLauncherOptions(winrt.system.Object):
    items_to_select: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.storage.IStorageItem]]
    desired_remaining_view: winrt.windows.ui.viewmanagement.ViewSizePreference
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FolderLauncherOptions: ...
    def __new__(cls: typing.Type[FolderLauncherOptions]) -> FolderLauncherOptions:...

class KnownUserProperties(winrt.system.Object):
    account_name: typing.ClassVar[str]
    display_name: typing.ClassVar[str]
    domain_name: typing.ClassVar[str]
    first_name: typing.ClassVar[str]
    guest_host: typing.ClassVar[str]
    last_name: typing.ClassVar[str]
    principal_name: typing.ClassVar[str]
    provider_name: typing.ClassVar[str]
    session_initiation_protocol_uri: typing.ClassVar[str]
    age_enforcement_region: typing.ClassVar[str]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> KnownUserProperties: ...

class LaunchUriResult(winrt.system.Object):
    result: typing.Optional[winrt.windows.foundation.collections.ValueSet]
    status: LaunchUriStatus
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LaunchUriResult: ...

class Launcher(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Launcher: ...
    @staticmethod
    def find_app_uri_handlers_async(uri: typing.Optional[winrt.windows.foundation.Uri], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[winrt.windows.applicationmodel.AppInfo]]: ...
    @staticmethod
    def find_file_handlers_async(extension: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[winrt.windows.applicationmodel.AppInfo]]: ...
    @typing.overload
    @staticmethod
    def find_uri_scheme_handlers_async(scheme: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[winrt.windows.applicationmodel.AppInfo]]: ...
    @typing.overload
    @staticmethod
    def find_uri_scheme_handlers_async(scheme: str, launch_query_support_type: LaunchQuerySupportType, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[winrt.windows.applicationmodel.AppInfo]]: ...
    @typing.overload
    @staticmethod
    def launch_file_async(file: typing.Optional[winrt.windows.storage.IStorageFile], /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...
    @typing.overload
    @staticmethod
    def launch_file_async(file: typing.Optional[winrt.windows.storage.IStorageFile], options: typing.Optional[LauncherOptions], /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...
    @typing.overload
    @staticmethod
    def launch_folder_async(folder: typing.Optional[winrt.windows.storage.IStorageFolder], /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...
    @typing.overload
    @staticmethod
    def launch_folder_async(folder: typing.Optional[winrt.windows.storage.IStorageFolder], options: typing.Optional[FolderLauncherOptions], /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...
    @typing.overload
    @staticmethod
    def launch_folder_path_async(path: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...
    @typing.overload
    @staticmethod
    def launch_folder_path_async(path: str, options: typing.Optional[FolderLauncherOptions], /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...
    @typing.overload
    @staticmethod
    def launch_folder_path_for_user_async(user: typing.Optional[User], path: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...
    @typing.overload
    @staticmethod
    def launch_folder_path_for_user_async(user: typing.Optional[User], path: str, options: typing.Optional[FolderLauncherOptions], /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...
    @typing.overload
    @staticmethod
    def launch_uri_async(uri: typing.Optional[winrt.windows.foundation.Uri], /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...
    @typing.overload
    @staticmethod
    def launch_uri_async(uri: typing.Optional[winrt.windows.foundation.Uri], options: typing.Optional[LauncherOptions], /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...
    @typing.overload
    @staticmethod
    def launch_uri_async(uri: typing.Optional[winrt.windows.foundation.Uri], options: typing.Optional[LauncherOptions], input_data: typing.Optional[winrt.windows.foundation.collections.ValueSet], /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...
    @typing.overload
    @staticmethod
    def launch_uri_for_results_async(uri: typing.Optional[winrt.windows.foundation.Uri], options: typing.Optional[LauncherOptions], /) -> winrt.windows.foundation.IAsyncOperation[LaunchUriResult]: ...
    @typing.overload
    @staticmethod
    def launch_uri_for_results_async(uri: typing.Optional[winrt.windows.foundation.Uri], options: typing.Optional[LauncherOptions], input_data: typing.Optional[winrt.windows.foundation.collections.ValueSet], /) -> winrt.windows.foundation.IAsyncOperation[LaunchUriResult]: ...
    @typing.overload
    @staticmethod
    def launch_uri_for_results_for_user_async(user: typing.Optional[User], uri: typing.Optional[winrt.windows.foundation.Uri], options: typing.Optional[LauncherOptions], /) -> winrt.windows.foundation.IAsyncOperation[LaunchUriResult]: ...
    @typing.overload
    @staticmethod
    def launch_uri_for_results_for_user_async(user: typing.Optional[User], uri: typing.Optional[winrt.windows.foundation.Uri], options: typing.Optional[LauncherOptions], input_data: typing.Optional[winrt.windows.foundation.collections.ValueSet], /) -> winrt.windows.foundation.IAsyncOperation[LaunchUriResult]: ...
    @typing.overload
    @staticmethod
    def launch_uri_for_user_async(user: typing.Optional[User], uri: typing.Optional[winrt.windows.foundation.Uri], /) -> winrt.windows.foundation.IAsyncOperation[LaunchUriStatus]: ...
    @typing.overload
    @staticmethod
    def launch_uri_for_user_async(user: typing.Optional[User], uri: typing.Optional[winrt.windows.foundation.Uri], options: typing.Optional[LauncherOptions], /) -> winrt.windows.foundation.IAsyncOperation[LaunchUriStatus]: ...
    @typing.overload
    @staticmethod
    def launch_uri_for_user_async(user: typing.Optional[User], uri: typing.Optional[winrt.windows.foundation.Uri], options: typing.Optional[LauncherOptions], input_data: typing.Optional[winrt.windows.foundation.collections.ValueSet], /) -> winrt.windows.foundation.IAsyncOperation[LaunchUriStatus]: ...
    @typing.overload
    @staticmethod
    def query_app_uri_support_async(uri: typing.Optional[winrt.windows.foundation.Uri], /) -> winrt.windows.foundation.IAsyncOperation[LaunchQuerySupportStatus]: ...
    @typing.overload
    @staticmethod
    def query_app_uri_support_async(uri: typing.Optional[winrt.windows.foundation.Uri], package_family_name: str, /) -> winrt.windows.foundation.IAsyncOperation[LaunchQuerySupportStatus]: ...
    @typing.overload
    @staticmethod
    def query_file_support_async(file: typing.Optional[winrt.windows.storage.StorageFile], /) -> winrt.windows.foundation.IAsyncOperation[LaunchQuerySupportStatus]: ...
    @typing.overload
    @staticmethod
    def query_file_support_async(file: typing.Optional[winrt.windows.storage.StorageFile], package_family_name: str, /) -> winrt.windows.foundation.IAsyncOperation[LaunchQuerySupportStatus]: ...
    @typing.overload
    @staticmethod
    def query_uri_support_async(uri: typing.Optional[winrt.windows.foundation.Uri], launch_query_support_type: LaunchQuerySupportType, /) -> winrt.windows.foundation.IAsyncOperation[LaunchQuerySupportStatus]: ...
    @typing.overload
    @staticmethod
    def query_uri_support_async(uri: typing.Optional[winrt.windows.foundation.Uri], launch_query_support_type: LaunchQuerySupportType, package_family_name: str, /) -> winrt.windows.foundation.IAsyncOperation[LaunchQuerySupportStatus]: ...

class LauncherOptions(winrt.system.Object):
    treat_as_untrusted: winrt.system.Boolean
    preferred_application_package_family_name: str
    preferred_application_display_name: str
    fallback_uri: typing.Optional[winrt.windows.foundation.Uri]
    display_application_picker: winrt.system.Boolean
    content_type: str
    u_i: typing.Optional[LauncherUIOptions]
    target_application_package_family_name: str
    neighboring_files_query: typing.Optional[winrt.windows.storage.search.StorageFileQueryResult]
    ignore_app_uri_handlers: winrt.system.Boolean
    limit_picker_to_current_app_and_app_uri_handlers: winrt.system.Boolean
    desired_remaining_view: winrt.windows.ui.viewmanagement.ViewSizePreference
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LauncherOptions: ...
    def __new__(cls: typing.Type[LauncherOptions]) -> LauncherOptions:...

class LauncherUIOptions(winrt.system.Object):
    selection_rect: typing.Optional[typing.Optional[winrt.windows.foundation.Rect]]
    preferred_placement: winrt.windows.ui.popups.Placement
    invocation_point: typing.Optional[typing.Optional[winrt.windows.foundation.Point]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LauncherUIOptions: ...

class MemoryManager(winrt.system.Object):
    app_memory_usage: typing.ClassVar[winrt.system.UInt64]
    app_memory_usage_level: typing.ClassVar[AppMemoryUsageLevel]
    app_memory_usage_limit: typing.ClassVar[winrt.system.UInt64]
    expected_app_memory_usage_limit: typing.ClassVar[winrt.system.UInt64]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MemoryManager: ...
    @staticmethod
    def get_app_memory_report() -> typing.Optional[AppMemoryReport]: ...
    @staticmethod
    def get_process_memory_report() -> typing.Optional[ProcessMemoryReport]: ...
    @staticmethod
    def try_set_app_memory_usage_limit(value: winrt.system.UInt64, /) -> winrt.system.Boolean: ...
    @staticmethod
    def add_app_memory_usage_decreased(handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    @staticmethod
    def remove_app_memory_usage_decreased(token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @staticmethod
    def add_app_memory_usage_increased(handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    @staticmethod
    def remove_app_memory_usage_increased(token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @staticmethod
    def add_app_memory_usage_limit_changing(handler: winrt.windows.foundation.EventHandler[AppMemoryUsageLimitChangingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    @staticmethod
    def remove_app_memory_usage_limit_changing(token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class ProcessLauncher(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProcessLauncher: ...
    @typing.overload
    @staticmethod
    def run_to_completion_async(file_name: str, args: str, /) -> winrt.windows.foundation.IAsyncOperation[ProcessLauncherResult]: ...
    @typing.overload
    @staticmethod
    def run_to_completion_async(file_name: str, args: str, options: typing.Optional[ProcessLauncherOptions], /) -> winrt.windows.foundation.IAsyncOperation[ProcessLauncherResult]: ...

class ProcessLauncherOptions(winrt.system.Object):
    working_directory: str
    standard_output: typing.Optional[winrt.windows.storage.streams.IOutputStream]
    standard_input: typing.Optional[winrt.windows.storage.streams.IInputStream]
    standard_error: typing.Optional[winrt.windows.storage.streams.IOutputStream]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProcessLauncherOptions: ...
    def __new__(cls: typing.Type[ProcessLauncherOptions]) -> ProcessLauncherOptions:...

class ProcessLauncherResult(winrt.system.Object):
    exit_code: winrt.system.UInt32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProcessLauncherResult: ...

class ProcessMemoryReport(winrt.system.Object):
    private_working_set_usage: winrt.system.UInt64
    total_working_set_usage: winrt.system.UInt64
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProcessMemoryReport: ...

class ProtocolForResultsOperation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProtocolForResultsOperation: ...
    def report_completed(self, data: typing.Optional[winrt.windows.foundation.collections.ValueSet], /) -> None: ...

class RemoteLauncher(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RemoteLauncher: ...
    @typing.overload
    @staticmethod
    def launch_uri_async(remote_system_connection_request: typing.Optional[winrt.windows.system.remotesystems.RemoteSystemConnectionRequest], uri: typing.Optional[winrt.windows.foundation.Uri], /) -> winrt.windows.foundation.IAsyncOperation[RemoteLaunchUriStatus]: ...
    @typing.overload
    @staticmethod
    def launch_uri_async(remote_system_connection_request: typing.Optional[winrt.windows.system.remotesystems.RemoteSystemConnectionRequest], uri: typing.Optional[winrt.windows.foundation.Uri], options: typing.Optional[RemoteLauncherOptions], /) -> winrt.windows.foundation.IAsyncOperation[RemoteLaunchUriStatus]: ...
    @typing.overload
    @staticmethod
    def launch_uri_async(remote_system_connection_request: typing.Optional[winrt.windows.system.remotesystems.RemoteSystemConnectionRequest], uri: typing.Optional[winrt.windows.foundation.Uri], options: typing.Optional[RemoteLauncherOptions], input_data: typing.Optional[winrt.windows.foundation.collections.ValueSet], /) -> winrt.windows.foundation.IAsyncOperation[RemoteLaunchUriStatus]: ...

class RemoteLauncherOptions(winrt.system.Object):
    fallback_uri: typing.Optional[winrt.windows.foundation.Uri]
    preferred_app_ids: typing.Optional[winrt.windows.foundation.collections.IVector[str]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RemoteLauncherOptions: ...
    def __new__(cls: typing.Type[RemoteLauncherOptions]) -> RemoteLauncherOptions:...

class ShutdownManager(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ShutdownManager: ...
    @staticmethod
    def begin_shutdown(shutdown_kind: ShutdownKind, timeout: datetime.timedelta, /) -> None: ...
    @staticmethod
    def cancel_shutdown() -> None: ...
    @typing.overload
    @staticmethod
    def enter_power_state(power_state: PowerState, /) -> None: ...
    @typing.overload
    @staticmethod
    def enter_power_state(power_state: PowerState, wake_up_after: datetime.timedelta, /) -> None: ...
    @staticmethod
    def is_power_state_supported(power_state: PowerState, /) -> winrt.system.Boolean: ...

class TimeZoneSettings(winrt.system.Object):
    can_change_time_zone: typing.ClassVar[winrt.system.Boolean]
    current_time_zone_display_name: typing.ClassVar[str]
    supported_time_zone_display_names: typing.ClassVar[typing.Optional[winrt.windows.foundation.collections.IVectorView[str]]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TimeZoneSettings: ...
    @staticmethod
    def auto_update_time_zone_async(timeout: datetime.timedelta, /) -> winrt.windows.foundation.IAsyncOperation[AutoUpdateTimeZoneStatus]: ...
    @staticmethod
    def change_time_zone_by_display_name(time_zone_display_name: str, /) -> None: ...

class User(winrt.system.Object):
    authentication_status: UserAuthenticationStatus
    non_roamable_id: str
    type: UserType
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> User: ...
    def check_user_age_consent_group_async(self, consent_group: UserAgeConsentGroup, /) -> winrt.windows.foundation.IAsyncOperation[UserAgeConsentResult]: ...
    @staticmethod
    def create_watcher() -> typing.Optional[UserWatcher]: ...
    @typing.overload
    @staticmethod
    def find_all_async() -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[User]]: ...
    @typing.overload
    @staticmethod
    def find_all_async(type: UserType, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[User]]: ...
    @typing.overload
    @staticmethod
    def find_all_async(type: UserType, status: UserAuthenticationStatus, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[User]]: ...
    @staticmethod
    def get_default() -> typing.Optional[User]: ...
    @staticmethod
    def get_from_id(non_roamable_id: str, /) -> typing.Optional[User]: ...
    def get_picture_async(self, desired_size: UserPictureSize, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.streams.IRandomAccessStreamReference]: ...
    def get_properties_async(self, values: winrt.windows.foundation.collections.IVectorView[str], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IPropertySet]: ...
    def get_property_async(self, value: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Object]: ...

class UserAuthenticationStatusChangeDeferral(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UserAuthenticationStatusChangeDeferral: ...
    def complete(self) -> None: ...

class UserAuthenticationStatusChangingEventArgs(winrt.system.Object):
    current_status: UserAuthenticationStatus
    new_status: UserAuthenticationStatus
    user: typing.Optional[User]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UserAuthenticationStatusChangingEventArgs: ...
    def get_deferral(self) -> typing.Optional[UserAuthenticationStatusChangeDeferral]: ...

class UserChangedEventArgs(winrt.system.Object):
    user: typing.Optional[User]
    changed_property_kinds: typing.Optional[winrt.windows.foundation.collections.IVectorView[UserWatcherUpdateKind]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UserChangedEventArgs: ...

class UserDeviceAssociation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UserDeviceAssociation: ...
    @staticmethod
    def find_user_from_device_id(device_id: str, /) -> typing.Optional[User]: ...
    @staticmethod
    def add_user_device_association_changed(handler: winrt.windows.foundation.EventHandler[UserDeviceAssociationChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    @staticmethod
    def remove_user_device_association_changed(token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class UserDeviceAssociationChangedEventArgs(winrt.system.Object):
    device_id: str
    new_user: typing.Optional[User]
    old_user: typing.Optional[User]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UserDeviceAssociationChangedEventArgs: ...

class UserPicker(winrt.system.Object):
    suggested_selected_user: typing.Optional[User]
    allow_guest_accounts: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UserPicker: ...
    def __new__(cls: typing.Type[UserPicker]) -> UserPicker:...
    @staticmethod
    def is_supported() -> winrt.system.Boolean: ...
    def pick_single_user_async(self) -> winrt.windows.foundation.IAsyncOperation[User]: ...

class UserWatcher(winrt.system.Object):
    status: UserWatcherStatus
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UserWatcher: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def add_added(self, handler: winrt.windows.foundation.TypedEventHandler[UserWatcher, UserChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_added(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_authentication_status_changed(self, handler: winrt.windows.foundation.TypedEventHandler[UserWatcher, UserChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_authentication_status_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_authentication_status_changing(self, handler: winrt.windows.foundation.TypedEventHandler[UserWatcher, UserAuthenticationStatusChangingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_authentication_status_changing(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_enumeration_completed(self, handler: winrt.windows.foundation.TypedEventHandler[UserWatcher, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_enumeration_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_removed(self, handler: winrt.windows.foundation.TypedEventHandler[UserWatcher, UserChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_removed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_stopped(self, handler: winrt.windows.foundation.TypedEventHandler[UserWatcher, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_stopped(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_updated(self, handler: winrt.windows.foundation.TypedEventHandler[UserWatcher, UserChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_updated(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class ILauncherViewOptions(winrt.system.Object):
    desired_remaining_view: winrt.windows.ui.viewmanagement.ViewSizePreference
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ILauncherViewOptions: ...

