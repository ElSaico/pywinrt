# WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

import datetime
import sys
import types
import typing
import uuid

import winrt.system
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.storage.fileproperties
import winrt.windows.storage.provider
import winrt.windows.storage.search
import winrt.windows.storage.streams
import winrt.windows.system

from . import ApplicationDataCreateDisposition, ApplicationDataLocality, CreationCollisionOption, FileAccessMode, FileAttributes, KnownFolderId, KnownFoldersAccessStatus, KnownLibraryId, NameCollisionOption, StorageDeleteOption, StorageItemTypes, StorageLibraryChangeType, StorageOpenOptions, StreamedFileFailureMode
from . import ApplicationDataSetVersionHandler, StreamedFileDataRequestedHandler

Self = typing.TypeVar('Self')

class AppDataPaths(winrt.system.Object):
    cookies: str
    desktop: str
    documents: str
    favorites: str
    history: str
    internet_cache: str
    local_app_data: str
    program_data: str
    roaming_app_data: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppDataPaths: ...
    @staticmethod
    def get_default() -> typing.Optional[AppDataPaths]: ...
    @staticmethod
    def get_for_user(user: typing.Optional[winrt.windows.system.User], /) -> typing.Optional[AppDataPaths]: ...

class ApplicationData(winrt.system.Object):
    local_folder: typing.Optional[StorageFolder]
    local_settings: typing.Optional[ApplicationDataContainer]
    roaming_folder: typing.Optional[StorageFolder]
    roaming_settings: typing.Optional[ApplicationDataContainer]
    roaming_storage_quota: winrt.system.UInt64
    temporary_folder: typing.Optional[StorageFolder]
    version: winrt.system.UInt32
    local_cache_folder: typing.Optional[StorageFolder]
    shared_local_folder: typing.Optional[StorageFolder]
    current: typing.ClassVar[typing.Optional[ApplicationData]]
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ApplicationData: ...
    @typing.overload
    def clear_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def clear_async(self, locality: ApplicationDataLocality, /) -> winrt.windows.foundation.IAsyncAction: ...
    def clear_publisher_cache_folder_async(self, folder_name: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    def close(self) -> None: ...
    @staticmethod
    def get_for_user_async(user: typing.Optional[winrt.windows.system.User], /) -> winrt.windows.foundation.IAsyncOperation[ApplicationData]: ...
    def get_publisher_cache_folder(self, folder_name: str, /) -> typing.Optional[StorageFolder]: ...
    def set_version_async(self, desired_version: winrt.system.UInt32, handler: typing.Optional[ApplicationDataSetVersionHandler], /) -> winrt.windows.foundation.IAsyncAction: ...
    def signal_data_changed(self) -> None: ...
    def add_data_changed(self, handler: winrt.windows.foundation.TypedEventHandler[ApplicationData, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_data_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class ApplicationDataCompositeValue(winrt.system.Object, typing.MutableMapping[str, winrt.system.Object]):
    size: winrt.system.UInt32
    def __len__(self) -> int: ...
    def __iter__(self) -> typing.Iterator[str]: ...
    def __contains__(self, key: object) -> bool:...
    def __setitem__(self, key: str, value: winrt.system.Object) -> None: ...
    def __getitem__(self, key: str) -> winrt.system.Object: ...
    def __delitem__(self, key: str) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ApplicationDataCompositeValue: ...
    def __new__(cls: typing.Type[ApplicationDataCompositeValue]) -> ApplicationDataCompositeValue:...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[winrt.windows.foundation.collections.IKeyValuePair[str, winrt.system.Object]]]: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IMapView[str, winrt.system.Object]]: ...
    def has_key(self, key: str, /) -> winrt.system.Boolean: ...
    def insert(self, key: str, value: typing.Optional[winrt.system.Object], /) -> winrt.system.Boolean: ...
    def lookup(self, key: str, /) -> typing.Optional[winrt.system.Object]: ...
    def remove(self, key: str, /) -> None: ...
    def add_map_changed(self, vhnd: winrt.windows.foundation.collections.MapChangedEventHandler[str, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_map_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class ApplicationDataContainer(winrt.system.Object):
    containers: typing.Optional[winrt.windows.foundation.collections.IMapView[str, ApplicationDataContainer]]
    locality: ApplicationDataLocality
    name: str
    values: typing.Optional[winrt.windows.foundation.collections.IPropertySet]
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ApplicationDataContainer: ...
    def close(self) -> None: ...
    def create_container(self, name: str, disposition: ApplicationDataCreateDisposition, /) -> typing.Optional[ApplicationDataContainer]: ...
    def delete_container(self, name: str, /) -> None: ...

class ApplicationDataContainerSettings(winrt.system.Object, typing.MutableMapping[str, winrt.system.Object]):
    size: winrt.system.UInt32
    def __len__(self) -> int: ...
    def __iter__(self) -> typing.Iterator[str]: ...
    def __contains__(self, key: object) -> bool:...
    def __setitem__(self, key: str, value: winrt.system.Object) -> None: ...
    def __getitem__(self, key: str) -> winrt.system.Object: ...
    def __delitem__(self, key: str) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ApplicationDataContainerSettings: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[winrt.windows.foundation.collections.IKeyValuePair[str, winrt.system.Object]]]: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IMapView[str, winrt.system.Object]]: ...
    def has_key(self, key: str, /) -> winrt.system.Boolean: ...
    def insert(self, key: str, value: typing.Optional[winrt.system.Object], /) -> winrt.system.Boolean: ...
    def lookup(self, key: str, /) -> typing.Optional[winrt.system.Object]: ...
    def remove(self, key: str, /) -> None: ...
    def add_map_changed(self, vhnd: winrt.windows.foundation.collections.MapChangedEventHandler[str, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_map_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class CachedFileManager(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CachedFileManager: ...
    @staticmethod
    def complete_updates_async(file: typing.Optional[IStorageFile], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.provider.FileUpdateStatus]: ...
    @staticmethod
    def defer_updates(file: typing.Optional[IStorageFile], /) -> None: ...

class DownloadsFolder(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DownloadsFolder: ...
    @typing.overload
    @staticmethod
    def create_file_async(desired_name: str, /) -> winrt.windows.foundation.IAsyncOperation[StorageFile]: ...
    @typing.overload
    @staticmethod
    def create_file_async(desired_name: str, option: CreationCollisionOption, /) -> winrt.windows.foundation.IAsyncOperation[StorageFile]: ...
    @typing.overload
    @staticmethod
    def create_file_for_user_async(user: typing.Optional[winrt.windows.system.User], desired_name: str, /) -> winrt.windows.foundation.IAsyncOperation[StorageFile]: ...
    @typing.overload
    @staticmethod
    def create_file_for_user_async(user: typing.Optional[winrt.windows.system.User], desired_name: str, option: CreationCollisionOption, /) -> winrt.windows.foundation.IAsyncOperation[StorageFile]: ...
    @typing.overload
    @staticmethod
    def create_folder_async(desired_name: str, /) -> winrt.windows.foundation.IAsyncOperation[StorageFolder]: ...
    @typing.overload
    @staticmethod
    def create_folder_async(desired_name: str, option: CreationCollisionOption, /) -> winrt.windows.foundation.IAsyncOperation[StorageFolder]: ...
    @typing.overload
    @staticmethod
    def create_folder_for_user_async(user: typing.Optional[winrt.windows.system.User], desired_name: str, /) -> winrt.windows.foundation.IAsyncOperation[StorageFolder]: ...
    @typing.overload
    @staticmethod
    def create_folder_for_user_async(user: typing.Optional[winrt.windows.system.User], desired_name: str, option: CreationCollisionOption, /) -> winrt.windows.foundation.IAsyncOperation[StorageFolder]: ...

class FileIO(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FileIO: ...
    @typing.overload
    @staticmethod
    def append_lines_async(file: typing.Optional[IStorageFile], lines: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    @staticmethod
    def append_lines_async(file: typing.Optional[IStorageFile], lines: typing.Iterable[str], encoding: winrt.windows.storage.streams.UnicodeEncoding, /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    @staticmethod
    def append_text_async(file: typing.Optional[IStorageFile], contents: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    @staticmethod
    def append_text_async(file: typing.Optional[IStorageFile], contents: str, encoding: winrt.windows.storage.streams.UnicodeEncoding, /) -> winrt.windows.foundation.IAsyncAction: ...
    @staticmethod
    def read_buffer_async(file: typing.Optional[IStorageFile], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.streams.IBuffer]: ...
    @typing.overload
    @staticmethod
    def read_lines_async(file: typing.Optional[IStorageFile], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVector[str]]: ...
    @typing.overload
    @staticmethod
    def read_lines_async(file: typing.Optional[IStorageFile], encoding: winrt.windows.storage.streams.UnicodeEncoding, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVector[str]]: ...
    @typing.overload
    @staticmethod
    def read_text_async(file: typing.Optional[IStorageFile], /) -> winrt.windows.foundation.IAsyncOperation[str]: ...
    @typing.overload
    @staticmethod
    def read_text_async(file: typing.Optional[IStorageFile], encoding: winrt.windows.storage.streams.UnicodeEncoding, /) -> winrt.windows.foundation.IAsyncOperation[str]: ...
    @staticmethod
    def write_buffer_async(file: typing.Optional[IStorageFile], buffer: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> winrt.windows.foundation.IAsyncAction: ...
    @staticmethod
    def write_bytes_async(file: typing.Optional[IStorageFile], buffer: winrt.system.Array[winrt.system.UInt8], /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    @staticmethod
    def write_lines_async(file: typing.Optional[IStorageFile], lines: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    @staticmethod
    def write_lines_async(file: typing.Optional[IStorageFile], lines: typing.Iterable[str], encoding: winrt.windows.storage.streams.UnicodeEncoding, /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    @staticmethod
    def write_text_async(file: typing.Optional[IStorageFile], contents: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    @staticmethod
    def write_text_async(file: typing.Optional[IStorageFile], contents: str, encoding: winrt.windows.storage.streams.UnicodeEncoding, /) -> winrt.windows.foundation.IAsyncAction: ...

class KnownFolders(winrt.system.Object):
    camera_roll: typing.ClassVar[typing.Optional[StorageFolder]]
    playlists: typing.ClassVar[typing.Optional[StorageFolder]]
    saved_pictures: typing.ClassVar[typing.Optional[StorageFolder]]
    documents_library: typing.ClassVar[typing.Optional[StorageFolder]]
    home_group: typing.ClassVar[typing.Optional[StorageFolder]]
    media_server_devices: typing.ClassVar[typing.Optional[StorageFolder]]
    music_library: typing.ClassVar[typing.Optional[StorageFolder]]
    pictures_library: typing.ClassVar[typing.Optional[StorageFolder]]
    removable_devices: typing.ClassVar[typing.Optional[StorageFolder]]
    videos_library: typing.ClassVar[typing.Optional[StorageFolder]]
    app_captures: typing.ClassVar[typing.Optional[StorageFolder]]
    objects3_d: typing.ClassVar[typing.Optional[StorageFolder]]
    recorded_calls: typing.ClassVar[typing.Optional[StorageFolder]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> KnownFolders: ...
    @staticmethod
    def get_folder_async(folder_id: KnownFolderId, /) -> winrt.windows.foundation.IAsyncOperation[StorageFolder]: ...
    @staticmethod
    def get_folder_for_user_async(user: typing.Optional[winrt.windows.system.User], folder_id: KnownFolderId, /) -> winrt.windows.foundation.IAsyncOperation[StorageFolder]: ...
    @staticmethod
    def request_access_async(folder_id: KnownFolderId, /) -> winrt.windows.foundation.IAsyncOperation[KnownFoldersAccessStatus]: ...
    @staticmethod
    def request_access_for_user_async(user: typing.Optional[winrt.windows.system.User], folder_id: KnownFolderId, /) -> winrt.windows.foundation.IAsyncOperation[KnownFoldersAccessStatus]: ...

class PathIO(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PathIO: ...
    @typing.overload
    @staticmethod
    def append_lines_async(absolute_path: str, lines: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    @staticmethod
    def append_lines_async(absolute_path: str, lines: typing.Iterable[str], encoding: winrt.windows.storage.streams.UnicodeEncoding, /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    @staticmethod
    def append_text_async(absolute_path: str, contents: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    @staticmethod
    def append_text_async(absolute_path: str, contents: str, encoding: winrt.windows.storage.streams.UnicodeEncoding, /) -> winrt.windows.foundation.IAsyncAction: ...
    @staticmethod
    def read_buffer_async(absolute_path: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.streams.IBuffer]: ...
    @typing.overload
    @staticmethod
    def read_lines_async(absolute_path: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVector[str]]: ...
    @typing.overload
    @staticmethod
    def read_lines_async(absolute_path: str, encoding: winrt.windows.storage.streams.UnicodeEncoding, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVector[str]]: ...
    @typing.overload
    @staticmethod
    def read_text_async(absolute_path: str, /) -> winrt.windows.foundation.IAsyncOperation[str]: ...
    @typing.overload
    @staticmethod
    def read_text_async(absolute_path: str, encoding: winrt.windows.storage.streams.UnicodeEncoding, /) -> winrt.windows.foundation.IAsyncOperation[str]: ...
    @staticmethod
    def write_buffer_async(absolute_path: str, buffer: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> winrt.windows.foundation.IAsyncAction: ...
    @staticmethod
    def write_bytes_async(absolute_path: str, buffer: winrt.system.Array[winrt.system.UInt8], /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    @staticmethod
    def write_lines_async(absolute_path: str, lines: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    @staticmethod
    def write_lines_async(absolute_path: str, lines: typing.Iterable[str], encoding: winrt.windows.storage.streams.UnicodeEncoding, /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    @staticmethod
    def write_text_async(absolute_path: str, contents: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    @staticmethod
    def write_text_async(absolute_path: str, contents: str, encoding: winrt.windows.storage.streams.UnicodeEncoding, /) -> winrt.windows.foundation.IAsyncAction: ...

class SetVersionDeferral(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SetVersionDeferral: ...
    def complete(self) -> None: ...

class SetVersionRequest(winrt.system.Object):
    current_version: winrt.system.UInt32
    desired_version: winrt.system.UInt32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SetVersionRequest: ...
    def get_deferral(self) -> typing.Optional[SetVersionDeferral]: ...

class StorageFile(winrt.system.Object):
    content_type: str
    file_type: str
    is_available: winrt.system.Boolean
    attributes: FileAttributes
    date_created: datetime.datetime
    name: str
    path: str
    display_name: str
    display_type: str
    folder_relative_id: str
    properties: typing.Optional[winrt.windows.storage.fileproperties.StorageItemContentProperties]
    provider: typing.Optional[StorageProvider]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StorageFile: ...
    def copy_and_replace_async(self, file_to_replace: typing.Optional[IStorageFile], /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def copy_async(self, destination_folder: typing.Optional[IStorageFolder], /) -> winrt.windows.foundation.IAsyncOperation[StorageFile]: ...
    @typing.overload
    def copy_async(self, destination_folder: typing.Optional[IStorageFolder], desired_new_name: str, /) -> winrt.windows.foundation.IAsyncOperation[StorageFile]: ...
    @typing.overload
    def copy_async(self, destination_folder: typing.Optional[IStorageFolder], desired_new_name: str, option: NameCollisionOption, /) -> winrt.windows.foundation.IAsyncOperation[StorageFile]: ...
    @staticmethod
    def create_streamed_file_async(display_name_with_extension: str, data_requested: typing.Optional[StreamedFileDataRequestedHandler], thumbnail: typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference], /) -> winrt.windows.foundation.IAsyncOperation[StorageFile]: ...
    @staticmethod
    def create_streamed_file_from_uri_async(display_name_with_extension: str, uri: typing.Optional[winrt.windows.foundation.Uri], thumbnail: typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference], /) -> winrt.windows.foundation.IAsyncOperation[StorageFile]: ...
    @typing.overload
    def delete_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def delete_async(self, option: StorageDeleteOption, /) -> winrt.windows.foundation.IAsyncAction: ...
    def get_basic_properties_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.BasicProperties]: ...
    @staticmethod
    def get_file_from_application_uri_async(uri: typing.Optional[winrt.windows.foundation.Uri], /) -> winrt.windows.foundation.IAsyncOperation[StorageFile]: ...
    @staticmethod
    def get_file_from_path_async(path: str, /) -> winrt.windows.foundation.IAsyncOperation[StorageFile]: ...
    @staticmethod
    def get_file_from_path_for_user_async(user: typing.Optional[winrt.windows.system.User], path: str, /) -> winrt.windows.foundation.IAsyncOperation[StorageFile]: ...
    def get_parent_async(self) -> winrt.windows.foundation.IAsyncOperation[StorageFolder]: ...
    @typing.overload
    def get_scaled_image_as_thumbnail_async(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_scaled_image_as_thumbnail_async(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_scaled_image_as_thumbnail_async(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, options: winrt.windows.storage.fileproperties.ThumbnailOptions, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_thumbnail_async(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_thumbnail_async(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_thumbnail_async(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, options: winrt.windows.storage.fileproperties.ThumbnailOptions, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.StorageItemThumbnail]: ...
    def is_equal(self, item: typing.Optional[IStorageItem], /) -> winrt.system.Boolean: ...
    def is_of_type(self, type: StorageItemTypes, /) -> winrt.system.Boolean: ...
    def move_and_replace_async(self, file_to_replace: typing.Optional[IStorageFile], /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def move_async(self, destination_folder: typing.Optional[IStorageFolder], /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def move_async(self, destination_folder: typing.Optional[IStorageFolder], desired_new_name: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def move_async(self, destination_folder: typing.Optional[IStorageFolder], desired_new_name: str, option: NameCollisionOption, /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def open_async(self, access_mode: FileAccessMode, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.streams.IRandomAccessStream]: ...
    @typing.overload
    def open_async(self, access_mode: FileAccessMode, options: StorageOpenOptions, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.streams.IRandomAccessStream]: ...
    def open_read_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.streams.IRandomAccessStreamWithContentType]: ...
    def open_sequential_read_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.streams.IInputStream]: ...
    @typing.overload
    def open_transacted_write_async(self) -> winrt.windows.foundation.IAsyncOperation[StorageStreamTransaction]: ...
    @typing.overload
    def open_transacted_write_async(self, options: StorageOpenOptions, /) -> winrt.windows.foundation.IAsyncOperation[StorageStreamTransaction]: ...
    @typing.overload
    def rename_async(self, desired_name: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def rename_async(self, desired_name: str, option: NameCollisionOption, /) -> winrt.windows.foundation.IAsyncAction: ...
    @staticmethod
    def replace_with_streamed_file_async(file_to_replace: typing.Optional[IStorageFile], data_requested: typing.Optional[StreamedFileDataRequestedHandler], thumbnail: typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference], /) -> winrt.windows.foundation.IAsyncOperation[StorageFile]: ...
    @staticmethod
    def replace_with_streamed_file_from_uri_async(file_to_replace: typing.Optional[IStorageFile], uri: typing.Optional[winrt.windows.foundation.Uri], thumbnail: typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference], /) -> winrt.windows.foundation.IAsyncOperation[StorageFile]: ...

class StorageFolder(winrt.system.Object):
    attributes: FileAttributes
    date_created: datetime.datetime
    name: str
    path: str
    display_name: str
    display_type: str
    folder_relative_id: str
    properties: typing.Optional[winrt.windows.storage.fileproperties.StorageItemContentProperties]
    provider: typing.Optional[StorageProvider]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StorageFolder: ...
    def are_query_options_supported(self, query_options: typing.Optional[winrt.windows.storage.search.QueryOptions], /) -> winrt.system.Boolean: ...
    @typing.overload
    def create_file_async(self, desired_name: str, /) -> winrt.windows.foundation.IAsyncOperation[StorageFile]: ...
    @typing.overload
    def create_file_async(self, desired_name: str, options: CreationCollisionOption, /) -> winrt.windows.foundation.IAsyncOperation[StorageFile]: ...
    @typing.overload
    def create_file_query(self) -> typing.Optional[winrt.windows.storage.search.StorageFileQueryResult]: ...
    @typing.overload
    def create_file_query(self, query: winrt.windows.storage.search.CommonFileQuery, /) -> typing.Optional[winrt.windows.storage.search.StorageFileQueryResult]: ...
    def create_file_query_with_options(self, query_options: typing.Optional[winrt.windows.storage.search.QueryOptions], /) -> typing.Optional[winrt.windows.storage.search.StorageFileQueryResult]: ...
    @typing.overload
    def create_folder_async(self, desired_name: str, /) -> winrt.windows.foundation.IAsyncOperation[StorageFolder]: ...
    @typing.overload
    def create_folder_async(self, desired_name: str, options: CreationCollisionOption, /) -> winrt.windows.foundation.IAsyncOperation[StorageFolder]: ...
    @typing.overload
    def create_folder_query(self) -> typing.Optional[winrt.windows.storage.search.StorageFolderQueryResult]: ...
    @typing.overload
    def create_folder_query(self, query: winrt.windows.storage.search.CommonFolderQuery, /) -> typing.Optional[winrt.windows.storage.search.StorageFolderQueryResult]: ...
    def create_folder_query_with_options(self, query_options: typing.Optional[winrt.windows.storage.search.QueryOptions], /) -> typing.Optional[winrt.windows.storage.search.StorageFolderQueryResult]: ...
    def create_item_query(self) -> typing.Optional[winrt.windows.storage.search.StorageItemQueryResult]: ...
    def create_item_query_with_options(self, query_options: typing.Optional[winrt.windows.storage.search.QueryOptions], /) -> typing.Optional[winrt.windows.storage.search.StorageItemQueryResult]: ...
    @typing.overload
    def delete_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def delete_async(self, option: StorageDeleteOption, /) -> winrt.windows.foundation.IAsyncAction: ...
    def get_basic_properties_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.BasicProperties]: ...
    def get_file_async(self, name: str, /) -> winrt.windows.foundation.IAsyncOperation[StorageFile]: ...
    @typing.overload
    def get_files_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[StorageFile]]: ...
    @typing.overload
    def get_files_async(self, query: winrt.windows.storage.search.CommonFileQuery, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[StorageFile]]: ...
    @typing.overload
    def get_files_async(self, query: winrt.windows.storage.search.CommonFileQuery, start_index: winrt.system.UInt32, max_items_to_retrieve: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[StorageFile]]: ...
    def get_folder_async(self, name: str, /) -> winrt.windows.foundation.IAsyncOperation[StorageFolder]: ...
    @staticmethod
    def get_folder_from_path_async(path: str, /) -> winrt.windows.foundation.IAsyncOperation[StorageFolder]: ...
    @staticmethod
    def get_folder_from_path_for_user_async(user: typing.Optional[winrt.windows.system.User], path: str, /) -> winrt.windows.foundation.IAsyncOperation[StorageFolder]: ...
    @typing.overload
    def get_folders_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[StorageFolder]]: ...
    @typing.overload
    def get_folders_async(self, query: winrt.windows.storage.search.CommonFolderQuery, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[StorageFolder]]: ...
    @typing.overload
    def get_folders_async(self, query: winrt.windows.storage.search.CommonFolderQuery, start_index: winrt.system.UInt32, max_items_to_retrieve: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[StorageFolder]]: ...
    def get_indexed_state_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.search.IndexedState]: ...
    def get_item_async(self, name: str, /) -> winrt.windows.foundation.IAsyncOperation[IStorageItem]: ...
    @typing.overload
    def get_items_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[IStorageItem]]: ...
    @typing.overload
    def get_items_async(self, start_index: winrt.system.UInt32, max_items_to_retrieve: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[IStorageItem]]: ...
    def get_parent_async(self) -> winrt.windows.foundation.IAsyncOperation[StorageFolder]: ...
    @typing.overload
    def get_scaled_image_as_thumbnail_async(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_scaled_image_as_thumbnail_async(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_scaled_image_as_thumbnail_async(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, options: winrt.windows.storage.fileproperties.ThumbnailOptions, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_thumbnail_async(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_thumbnail_async(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_thumbnail_async(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, options: winrt.windows.storage.fileproperties.ThumbnailOptions, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.StorageItemThumbnail]: ...
    def is_common_file_query_supported(self, query: winrt.windows.storage.search.CommonFileQuery, /) -> winrt.system.Boolean: ...
    def is_common_folder_query_supported(self, query: winrt.windows.storage.search.CommonFolderQuery, /) -> winrt.system.Boolean: ...
    def is_equal(self, item: typing.Optional[IStorageItem], /) -> winrt.system.Boolean: ...
    def is_of_type(self, type: StorageItemTypes, /) -> winrt.system.Boolean: ...
    @typing.overload
    def rename_async(self, desired_name: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def rename_async(self, desired_name: str, option: NameCollisionOption, /) -> winrt.windows.foundation.IAsyncAction: ...
    def try_get_change_tracker(self) -> typing.Optional[StorageLibraryChangeTracker]: ...
    def try_get_item_async(self, name: str, /) -> winrt.windows.foundation.IAsyncOperation[IStorageItem]: ...

class StorageLibrary(winrt.system.Object):
    folders: typing.Optional[winrt.windows.foundation.collections.IObservableVector[StorageFolder]]
    save_folder: typing.Optional[StorageFolder]
    change_tracker: typing.Optional[StorageLibraryChangeTracker]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StorageLibrary: ...
    def are_folder_suggestions_available_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...
    @staticmethod
    def get_library_async(library_id: KnownLibraryId, /) -> winrt.windows.foundation.IAsyncOperation[StorageLibrary]: ...
    @staticmethod
    def get_library_for_user_async(user: typing.Optional[winrt.windows.system.User], library_id: KnownLibraryId, /) -> winrt.windows.foundation.IAsyncOperation[StorageLibrary]: ...
    def request_add_folder_async(self) -> winrt.windows.foundation.IAsyncOperation[StorageFolder]: ...
    def request_remove_folder_async(self, folder: typing.Optional[StorageFolder], /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...
    def add_definition_changed(self, handler: winrt.windows.foundation.TypedEventHandler[StorageLibrary, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_definition_changed(self, event_cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class StorageLibraryChange(winrt.system.Object):
    change_type: StorageLibraryChangeType
    path: str
    previous_path: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StorageLibraryChange: ...
    def get_storage_item_async(self) -> winrt.windows.foundation.IAsyncOperation[IStorageItem]: ...
    def is_of_type(self, type: StorageItemTypes, /) -> winrt.system.Boolean: ...

class StorageLibraryChangeReader(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StorageLibraryChangeReader: ...
    def accept_changes_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def get_last_change_id(self) -> winrt.system.UInt64: ...
    def read_batch_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[StorageLibraryChange]]: ...

class StorageLibraryChangeTracker(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StorageLibraryChangeTracker: ...
    def disable(self) -> None: ...
    @typing.overload
    def enable(self) -> None: ...
    @typing.overload
    def enable(self, options: typing.Optional[StorageLibraryChangeTrackerOptions], /) -> None: ...
    def get_change_reader(self) -> typing.Optional[StorageLibraryChangeReader]: ...
    def reset(self) -> None: ...

class StorageLibraryChangeTrackerOptions(winrt.system.Object):
    track_change_details: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StorageLibraryChangeTrackerOptions: ...
    def __new__(cls: typing.Type[StorageLibraryChangeTrackerOptions]) -> StorageLibraryChangeTrackerOptions:...

class StorageLibraryLastChangeId(winrt.system.Object):
    unknown: typing.ClassVar[winrt.system.UInt64]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StorageLibraryLastChangeId: ...

class StorageProvider(winrt.system.Object):
    display_name: str
    id: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StorageProvider: ...
    def is_property_supported_for_partial_file_async(self, property_canonical_name: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...

class StorageStreamTransaction(winrt.system.Object):
    stream: typing.Optional[winrt.windows.storage.streams.IRandomAccessStream]
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StorageStreamTransaction: ...
    def close(self) -> None: ...
    def commit_async(self) -> winrt.windows.foundation.IAsyncAction: ...

class StreamedFileDataRequest(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StreamedFileDataRequest: ...
    def close(self) -> None: ...
    def fail_and_close(self, failure_mode: StreamedFileFailureMode, /) -> None: ...
    def flush_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...
    def write_async(self, buffer: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[winrt.system.UInt32, winrt.system.UInt32]: ...

class SystemAudioProperties(winrt.system.Object):
    encoding_bitrate: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SystemAudioProperties: ...

class SystemDataPaths(winrt.system.Object):
    fonts: str
    program_data: str
    public: str
    public_desktop: str
    public_documents: str
    public_downloads: str
    public_music: str
    public_pictures: str
    public_videos: str
    system: str
    system_arm: str
    system_host: str
    system_x64: str
    system_x86: str
    user_profiles: str
    windows: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SystemDataPaths: ...
    @staticmethod
    def get_default() -> typing.Optional[SystemDataPaths]: ...

class SystemGPSProperties(winrt.system.Object):
    latitude_decimal: str
    longitude_decimal: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SystemGPSProperties: ...

class SystemImageProperties(winrt.system.Object):
    horizontal_size: str
    vertical_size: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SystemImageProperties: ...

class SystemMediaProperties(winrt.system.Object):
    duration: str
    producer: str
    publisher: str
    sub_title: str
    writer: str
    year: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SystemMediaProperties: ...

class SystemMusicProperties(winrt.system.Object):
    album_artist: str
    album_title: str
    artist: str
    composer: str
    conductor: str
    display_artist: str
    genre: str
    track_number: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SystemMusicProperties: ...

class SystemPhotoProperties(winrt.system.Object):
    camera_manufacturer: str
    camera_model: str
    date_taken: str
    orientation: str
    people_names: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SystemPhotoProperties: ...

class SystemProperties(winrt.system.Object):
    audio: typing.ClassVar[typing.Optional[SystemAudioProperties]]
    author: typing.ClassVar[str]
    comment: typing.ClassVar[str]
    g_p_s: typing.ClassVar[typing.Optional[SystemGPSProperties]]
    image: typing.ClassVar[typing.Optional[SystemImageProperties]]
    item_name_display: typing.ClassVar[str]
    keywords: typing.ClassVar[str]
    media: typing.ClassVar[typing.Optional[SystemMediaProperties]]
    music: typing.ClassVar[typing.Optional[SystemMusicProperties]]
    photo: typing.ClassVar[typing.Optional[SystemPhotoProperties]]
    rating: typing.ClassVar[str]
    title: typing.ClassVar[str]
    video: typing.ClassVar[typing.Optional[SystemVideoProperties]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SystemProperties: ...

class SystemVideoProperties(winrt.system.Object):
    director: str
    frame_height: str
    frame_width: str
    orientation: str
    total_bitrate: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SystemVideoProperties: ...

class UserDataPaths(winrt.system.Object):
    camera_roll: str
    cookies: str
    desktop: str
    documents: str
    downloads: str
    favorites: str
    history: str
    internet_cache: str
    local_app_data: str
    local_app_data_low: str
    music: str
    pictures: str
    profile: str
    recent: str
    roaming_app_data: str
    saved_pictures: str
    screenshots: str
    templates: str
    videos: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UserDataPaths: ...
    @staticmethod
    def get_default() -> typing.Optional[UserDataPaths]: ...
    @staticmethod
    def get_for_user(user: typing.Optional[winrt.windows.system.User], /) -> typing.Optional[UserDataPaths]: ...

class IStorageFile(winrt.system.Object):
    content_type: str
    file_type: str
    attributes: FileAttributes
    date_created: datetime.datetime
    name: str
    path: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IStorageFile: ...
    def copy_and_replace_async(self, file_to_replace: typing.Optional[IStorageFile], /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def copy_async(self, destination_folder: typing.Optional[IStorageFolder], /) -> winrt.windows.foundation.IAsyncOperation[StorageFile]: ...
    @typing.overload
    def copy_async(self, destination_folder: typing.Optional[IStorageFolder], desired_new_name: str, /) -> winrt.windows.foundation.IAsyncOperation[StorageFile]: ...
    @typing.overload
    def copy_async(self, destination_folder: typing.Optional[IStorageFolder], desired_new_name: str, option: NameCollisionOption, /) -> winrt.windows.foundation.IAsyncOperation[StorageFile]: ...
    @typing.overload
    def delete_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def delete_async(self, option: StorageDeleteOption, /) -> winrt.windows.foundation.IAsyncAction: ...
    def get_basic_properties_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.BasicProperties]: ...
    def is_of_type(self, type: StorageItemTypes, /) -> winrt.system.Boolean: ...
    def move_and_replace_async(self, file_to_replace: typing.Optional[IStorageFile], /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def move_async(self, destination_folder: typing.Optional[IStorageFolder], /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def move_async(self, destination_folder: typing.Optional[IStorageFolder], desired_new_name: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def move_async(self, destination_folder: typing.Optional[IStorageFolder], desired_new_name: str, option: NameCollisionOption, /) -> winrt.windows.foundation.IAsyncAction: ...
    def open_async(self, access_mode: FileAccessMode, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.streams.IRandomAccessStream]: ...
    def open_read_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.streams.IRandomAccessStreamWithContentType]: ...
    def open_sequential_read_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.streams.IInputStream]: ...
    def open_transacted_write_async(self) -> winrt.windows.foundation.IAsyncOperation[StorageStreamTransaction]: ...
    @typing.overload
    def rename_async(self, desired_name: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def rename_async(self, desired_name: str, option: NameCollisionOption, /) -> winrt.windows.foundation.IAsyncAction: ...

class IStorageFile2(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IStorageFile2: ...
    def open_async(self, access_mode: FileAccessMode, options: StorageOpenOptions, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.streams.IRandomAccessStream]: ...
    def open_transacted_write_async(self, options: StorageOpenOptions, /) -> winrt.windows.foundation.IAsyncOperation[StorageStreamTransaction]: ...

class IStorageFilePropertiesWithAvailability(winrt.system.Object):
    is_available: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IStorageFilePropertiesWithAvailability: ...

class IStorageFolder(winrt.system.Object):
    attributes: FileAttributes
    date_created: datetime.datetime
    name: str
    path: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IStorageFolder: ...
    @typing.overload
    def create_file_async(self, desired_name: str, /) -> winrt.windows.foundation.IAsyncOperation[StorageFile]: ...
    @typing.overload
    def create_file_async(self, desired_name: str, options: CreationCollisionOption, /) -> winrt.windows.foundation.IAsyncOperation[StorageFile]: ...
    @typing.overload
    def create_folder_async(self, desired_name: str, /) -> winrt.windows.foundation.IAsyncOperation[StorageFolder]: ...
    @typing.overload
    def create_folder_async(self, desired_name: str, options: CreationCollisionOption, /) -> winrt.windows.foundation.IAsyncOperation[StorageFolder]: ...
    @typing.overload
    def delete_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def delete_async(self, option: StorageDeleteOption, /) -> winrt.windows.foundation.IAsyncAction: ...
    def get_basic_properties_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.BasicProperties]: ...
    def get_file_async(self, name: str, /) -> winrt.windows.foundation.IAsyncOperation[StorageFile]: ...
    def get_files_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[StorageFile]]: ...
    def get_folder_async(self, name: str, /) -> winrt.windows.foundation.IAsyncOperation[StorageFolder]: ...
    def get_folders_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[StorageFolder]]: ...
    def get_item_async(self, name: str, /) -> winrt.windows.foundation.IAsyncOperation[IStorageItem]: ...
    def get_items_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[IStorageItem]]: ...
    def is_of_type(self, type: StorageItemTypes, /) -> winrt.system.Boolean: ...
    @typing.overload
    def rename_async(self, desired_name: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def rename_async(self, desired_name: str, option: NameCollisionOption, /) -> winrt.windows.foundation.IAsyncAction: ...

class IStorageFolder2(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IStorageFolder2: ...
    def try_get_item_async(self, name: str, /) -> winrt.windows.foundation.IAsyncOperation[IStorageItem]: ...

class IStorageItem(winrt.system.Object):
    attributes: FileAttributes
    date_created: datetime.datetime
    name: str
    path: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IStorageItem: ...
    @typing.overload
    def delete_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def delete_async(self, option: StorageDeleteOption, /) -> winrt.windows.foundation.IAsyncAction: ...
    def get_basic_properties_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.BasicProperties]: ...
    def is_of_type(self, type: StorageItemTypes, /) -> winrt.system.Boolean: ...
    @typing.overload
    def rename_async(self, desired_name: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def rename_async(self, desired_name: str, option: NameCollisionOption, /) -> winrt.windows.foundation.IAsyncAction: ...

class IStorageItem2(winrt.system.Object):
    attributes: FileAttributes
    date_created: datetime.datetime
    name: str
    path: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IStorageItem2: ...
    @typing.overload
    def delete_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def delete_async(self, option: StorageDeleteOption, /) -> winrt.windows.foundation.IAsyncAction: ...
    def get_basic_properties_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.BasicProperties]: ...
    def get_parent_async(self) -> winrt.windows.foundation.IAsyncOperation[StorageFolder]: ...
    def is_equal(self, item: typing.Optional[IStorageItem], /) -> winrt.system.Boolean: ...
    def is_of_type(self, type: StorageItemTypes, /) -> winrt.system.Boolean: ...
    @typing.overload
    def rename_async(self, desired_name: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def rename_async(self, desired_name: str, option: NameCollisionOption, /) -> winrt.windows.foundation.IAsyncAction: ...

class IStorageItemProperties(winrt.system.Object):
    display_name: str
    display_type: str
    folder_relative_id: str
    properties: typing.Optional[winrt.windows.storage.fileproperties.StorageItemContentProperties]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IStorageItemProperties: ...
    @typing.overload
    def get_thumbnail_async(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_thumbnail_async(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_thumbnail_async(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, options: winrt.windows.storage.fileproperties.ThumbnailOptions, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.StorageItemThumbnail]: ...

class IStorageItemProperties2(winrt.system.Object):
    display_name: str
    display_type: str
    folder_relative_id: str
    properties: typing.Optional[winrt.windows.storage.fileproperties.StorageItemContentProperties]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IStorageItemProperties2: ...
    @typing.overload
    def get_scaled_image_as_thumbnail_async(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_scaled_image_as_thumbnail_async(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_scaled_image_as_thumbnail_async(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, options: winrt.windows.storage.fileproperties.ThumbnailOptions, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_thumbnail_async(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_thumbnail_async(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_thumbnail_async(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, options: winrt.windows.storage.fileproperties.ThumbnailOptions, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.StorageItemThumbnail]: ...

class IStorageItemPropertiesWithProvider(winrt.system.Object):
    provider: typing.Optional[StorageProvider]
    display_name: str
    display_type: str
    folder_relative_id: str
    properties: typing.Optional[winrt.windows.storage.fileproperties.StorageItemContentProperties]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IStorageItemPropertiesWithProvider: ...
    @typing.overload
    def get_thumbnail_async(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_thumbnail_async(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.StorageItemThumbnail]: ...
    @typing.overload
    def get_thumbnail_async(self, mode: winrt.windows.storage.fileproperties.ThumbnailMode, requested_size: winrt.system.UInt32, options: winrt.windows.storage.fileproperties.ThumbnailOptions, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.fileproperties.StorageItemThumbnail]: ...

class IStreamedFileDataRequest(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IStreamedFileDataRequest: ...
    def fail_and_close(self, failure_mode: StreamedFileFailureMode, /) -> None: ...

