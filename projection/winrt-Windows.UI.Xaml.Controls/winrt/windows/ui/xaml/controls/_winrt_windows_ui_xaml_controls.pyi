# WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

import enum
import datetime
import sys
import types
import typing

import winrt.system
import winrt.windows.applicationmodel.contacts
import winrt.windows.applicationmodel.datatransfer
import winrt.windows.applicationmodel.search
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.globalization
import winrt.windows.media.capture
import winrt.windows.media.casting
import winrt.windows.media.core
import winrt.windows.media.playto
import winrt.windows.media.playback
import winrt.windows.media.protection
import winrt.windows.storage.streams
import winrt.windows.system
import winrt.windows.ui
import winrt.windows.ui.composition
import winrt.windows.ui.core
import winrt.windows.ui.input.inking
import winrt.windows.ui.text
import winrt.windows.ui.xaml
import winrt.windows.ui.xaml.automation
import winrt.windows.ui.xaml.controls.primitives
import winrt.windows.ui.xaml.data
import winrt.windows.ui.xaml.documents
import winrt.windows.ui.xaml.input
import winrt.windows.ui.xaml.interop
import winrt.windows.ui.xaml.media
import winrt.windows.ui.xaml.media.animation
import winrt.windows.ui.xaml.navigation
import winrt.windows.web
import winrt.windows.web.http

class AppBarClosedDisplayMode(enum.IntEnum):
    COMPACT = 0
    MINIMAL = 1
    HIDDEN = 2

class AutoSuggestionBoxTextChangeReason(enum.IntEnum):
    USER_INPUT = 0
    PROGRAMMATIC_CHANGE = 1
    SUGGESTION_CHOSEN = 2

class BackgroundSizing(enum.IntEnum):
    INNER_BORDER_EDGE = 0
    OUTER_BORDER_EDGE = 1

class CalendarViewDisplayMode(enum.IntEnum):
    MONTH = 0
    YEAR = 1
    DECADE = 2

class CalendarViewSelectionMode(enum.IntEnum):
    NONE = 0
    SINGLE = 1
    MULTIPLE = 2

class CandidateWindowAlignment(enum.IntEnum):
    DEFAULT = 0
    BOTTOM_EDGE = 1

class CharacterCasing(enum.IntEnum):
    NORMAL = 0
    LOWER = 1
    UPPER = 2

class ClickMode(enum.IntEnum):
    RELEASE = 0
    PRESS = 1
    HOVER = 2

class ColorPickerHsvChannel(enum.IntEnum):
    HUE = 0
    SATURATION = 1
    VALUE = 2
    ALPHA = 3

class ColorSpectrumComponents(enum.IntEnum):
    HUE_VALUE = 0
    VALUE_HUE = 1
    HUE_SATURATION = 2
    SATURATION_HUE = 3
    SATURATION_VALUE = 4
    VALUE_SATURATION = 5

class ColorSpectrumShape(enum.IntEnum):
    BOX = 0
    RING = 1

class ComboBoxSelectionChangedTrigger(enum.IntEnum):
    COMMITTED = 0
    ALWAYS = 1

class CommandBarDefaultLabelPosition(enum.IntEnum):
    BOTTOM = 0
    RIGHT = 1
    COLLAPSED = 2

class CommandBarDynamicOverflowAction(enum.IntEnum):
    ADDING_TO_OVERFLOW = 0
    REMOVING_FROM_OVERFLOW = 1

class CommandBarLabelPosition(enum.IntEnum):
    DEFAULT = 0
    COLLAPSED = 1

class CommandBarOverflowButtonVisibility(enum.IntEnum):
    AUTO = 0
    VISIBLE = 1
    COLLAPSED = 2

class ContentDialogButton(enum.IntEnum):
    NONE = 0
    PRIMARY = 1
    SECONDARY = 2
    CLOSE = 3

class ContentDialogPlacement(enum.IntEnum):
    POPUP = 0
    IN_PLACE = 1

class ContentDialogResult(enum.IntEnum):
    NONE = 0
    PRIMARY = 1
    SECONDARY = 2

class ContentLinkChangeKind(enum.IntEnum):
    INSERTED = 0
    REMOVED = 1
    EDITED = 2

class DisabledFormattingAccelerators(enum.IntFlag):
    NONE = 0
    BOLD = 0x1
    ITALIC = 0x2
    UNDERLINE = 0x4
    ALL = 0xffffffff

class HandwritingPanelPlacementAlignment(enum.IntEnum):
    AUTO = 0
    TOP_LEFT = 1
    TOP_RIGHT = 2
    BOTTOM_LEFT = 3
    BOTTOM_RIGHT = 4

class IncrementalLoadingTrigger(enum.IntEnum):
    NONE = 0
    EDGE = 1

class InkToolbarButtonFlyoutPlacement(enum.IntEnum):
    AUTO = 0
    TOP = 1
    BOTTOM = 2
    LEFT = 3
    RIGHT = 4

class InkToolbarFlyoutItemKind(enum.IntEnum):
    SIMPLE = 0
    RADIO = 1
    CHECK = 2
    RADIO_CHECK = 3

class InkToolbarInitialControls(enum.IntEnum):
    ALL = 0
    NONE = 1
    PENS_ONLY = 2
    ALL_EXCEPT_PENS = 3

class InkToolbarMenuKind(enum.IntEnum):
    STENCIL = 0

class InkToolbarStencilKind(enum.IntEnum):
    RULER = 0
    PROTRACTOR = 1

class InkToolbarToggle(enum.IntEnum):
    RULER = 0
    CUSTOM = 1

class InkToolbarTool(enum.IntEnum):
    BALLPOINT_PEN = 0
    PENCIL = 1
    HIGHLIGHTER = 2
    ERASER = 3
    CUSTOM_PEN = 4
    CUSTOM_TOOL = 5

class ItemsUpdatingScrollMode(enum.IntEnum):
    KEEP_ITEMS_IN_VIEW = 0
    KEEP_SCROLL_OFFSET = 1
    KEEP_LAST_ITEM_IN_VIEW = 2

class LightDismissOverlayMode(enum.IntEnum):
    AUTO = 0
    ON = 1
    OFF = 2

class ListPickerFlyoutSelectionMode(enum.IntEnum):
    SINGLE = 0
    MULTIPLE = 1

class ListViewReorderMode(enum.IntEnum):
    DISABLED = 0
    ENABLED = 1

class ListViewSelectionMode(enum.IntEnum):
    NONE = 0
    SINGLE = 1
    MULTIPLE = 2
    EXTENDED = 3

class NavigationViewBackButtonVisible(enum.IntEnum):
    COLLAPSED = 0
    VISIBLE = 1
    AUTO = 2

class NavigationViewDisplayMode(enum.IntEnum):
    MINIMAL = 0
    COMPACT = 1
    EXPANDED = 2

class NavigationViewOverflowLabelMode(enum.IntEnum):
    MORE_LABEL = 0
    NO_LABEL = 1

class NavigationViewPaneDisplayMode(enum.IntEnum):
    AUTO = 0
    LEFT = 1
    TOP = 2
    LEFT_COMPACT = 3
    LEFT_MINIMAL = 4

class NavigationViewSelectionFollowsFocus(enum.IntEnum):
    DISABLED = 0
    ENABLED = 1

class NavigationViewShoulderNavigationEnabled(enum.IntEnum):
    WHEN_SELECTION_FOLLOWS_FOCUS = 0
    ALWAYS = 1
    NEVER = 2

class Orientation(enum.IntEnum):
    VERTICAL = 0
    HORIZONTAL = 1

class PanelScrollingDirection(enum.IntEnum):
    NONE = 0
    FORWARD = 1
    BACKWARD = 2

class ParallaxSourceOffsetKind(enum.IntEnum):
    ABSOLUTE = 0
    RELATIVE = 1

class PasswordRevealMode(enum.IntEnum):
    PEEK = 0
    HIDDEN = 1
    VISIBLE = 2

class PivotHeaderFocusVisualPlacement(enum.IntEnum):
    ITEM_HEADERS = 0
    SELECTED_ITEM_HEADER = 1

class PivotSlideInAnimationGroup(enum.IntEnum):
    DEFAULT = 0
    GROUP_ONE = 1
    GROUP_TWO = 2
    GROUP_THREE = 3

class RefreshPullDirection(enum.IntEnum):
    LEFT_TO_RIGHT = 0
    TOP_TO_BOTTOM = 1
    RIGHT_TO_LEFT = 2
    BOTTOM_TO_TOP = 3

class RefreshVisualizerOrientation(enum.IntEnum):
    AUTO = 0
    NORMAL = 1
    ROTATE90_DEGREES_COUNTERCLOCKWISE = 2
    ROTATE270_DEGREES_COUNTERCLOCKWISE = 3

class RefreshVisualizerState(enum.IntEnum):
    IDLE = 0
    PEEKING = 1
    INTERACTING = 2
    PENDING = 3
    REFRESHING = 4

class RequiresPointer(enum.IntEnum):
    NEVER = 0
    WHEN_ENGAGED = 1
    WHEN_FOCUSED = 2

class RichEditClipboardFormat(enum.IntEnum):
    ALL_FORMATS = 0
    PLAIN_TEXT = 1

class ScrollBarVisibility(enum.IntEnum):
    DISABLED = 0
    AUTO = 1
    HIDDEN = 2
    VISIBLE = 3

class ScrollIntoViewAlignment(enum.IntEnum):
    DEFAULT = 0
    LEADING = 1

class ScrollMode(enum.IntEnum):
    DISABLED = 0
    ENABLED = 1
    AUTO = 2

class SelectionMode(enum.IntEnum):
    SINGLE = 0
    MULTIPLE = 1
    EXTENDED = 2

class SnapPointsType(enum.IntEnum):
    NONE = 0
    OPTIONAL = 1
    MANDATORY = 2
    OPTIONAL_SINGLE = 3
    MANDATORY_SINGLE = 4

class SplitViewDisplayMode(enum.IntEnum):
    OVERLAY = 0
    INLINE = 1
    COMPACT_OVERLAY = 2
    COMPACT_INLINE = 3

class SplitViewPanePlacement(enum.IntEnum):
    LEFT = 0
    RIGHT = 1

class StretchDirection(enum.IntEnum):
    UP_ONLY = 0
    DOWN_ONLY = 1
    BOTH = 2

class SwipeBehaviorOnInvoked(enum.IntEnum):
    AUTO = 0
    CLOSE = 1
    REMAIN_OPEN = 2

class SwipeMode(enum.IntEnum):
    REVEAL = 0
    EXECUTE = 1

class Symbol(enum.IntEnum):
    PREVIOUS = 57600
    NEXT = 57601
    PLAY = 57602
    PAUSE = 57603
    EDIT = 57604
    SAVE = 57605
    CLEAR = 57606
    DELETE = 57607
    REMOVE = 57608
    ADD = 57609
    CANCEL = 57610
    ACCEPT = 57611
    MORE = 57612
    REDO = 57613
    UNDO = 57614
    HOME = 57615
    UP = 57616
    FORWARD = 57617
    BACK = 57618
    FAVORITE = 57619
    CAMERA = 57620
    SETTING = 57621
    VIDEO = 57622
    SYNC = 57623
    DOWNLOAD = 57624
    MAIL = 57625
    FIND = 57626
    HELP = 57627
    UPLOAD = 57628
    EMOJI = 57629
    TWO_PAGE = 57630
    LEAVE_CHAT = 57631
    MAIL_FORWARD = 57632
    CLOCK = 57633
    SEND = 57634
    CROP = 57635
    ROTATE_CAMERA = 57636
    PEOPLE = 57637
    OPEN_PANE = 57638
    CLOSE_PANE = 57639
    WORLD = 57640
    FLAG = 57641
    PREVIEW_LINK = 57642
    GLOBE = 57643
    TRIM = 57644
    ATTACH_CAMERA = 57645
    ZOOM_IN = 57646
    BOOKMARKS = 57647
    DOCUMENT = 57648
    PROTECTED_DOCUMENT = 57649
    PAGE = 57650
    BULLETS = 57651
    COMMENT = 57652
    MAIL_FILLED = 57653
    CONTACT_INFO = 57654
    HANG_UP = 57655
    VIEW_ALL = 57656
    MAP_PIN = 57657
    PHONE = 57658
    VIDEO_CHAT = 57659
    SWITCH = 57660
    CONTACT = 57661
    RENAME = 57662
    PIN = 57665
    MUSIC_INFO = 57666
    GO = 57667
    KEYBOARD = 57668
    DOCK_LEFT = 57669
    DOCK_RIGHT = 57670
    DOCK_BOTTOM = 57671
    REMOTE = 57672
    REFRESH = 57673
    ROTATE = 57674
    SHUFFLE = 57675
    LIST = 57676
    SHOP = 57677
    SELECT_ALL = 57678
    ORIENTATION = 57679
    IMPORT = 57680
    IMPORT_ALL = 57681
    BROWSE_PHOTOS = 57685
    WEB_CAM = 57686
    PICTURES = 57688
    SAVE_LOCAL = 57689
    CAPTION = 57690
    STOP = 57691
    SHOW_RESULTS = 57692
    VOLUME = 57693
    REPAIR = 57694
    MESSAGE = 57695
    PAGE2 = 57696
    CALENDAR_DAY = 57697
    CALENDAR_WEEK = 57698
    CALENDAR = 57699
    CHARACTER = 57700
    MAIL_REPLY_ALL = 57701
    READ = 57702
    LINK = 57703
    ACCOUNT = 57704
    SHOW_BCC = 57705
    HIDE_BCC = 57706
    CUT = 57707
    ATTACH = 57708
    PASTE = 57709
    FILTER = 57710
    COPY = 57711
    EMOJI2 = 57712
    IMPORTANT = 57713
    MAIL_REPLY = 57714
    SLIDE_SHOW = 57715
    SORT = 57716
    MANAGE = 57720
    ALL_APPS = 57721
    DISCONNECT_DRIVE = 57722
    MAP_DRIVE = 57723
    NEW_WINDOW = 57724
    OPEN_WITH = 57725
    CONTACT_PRESENCE = 57729
    PRIORITY = 57730
    GO_TO_TODAY = 57732
    FONT = 57733
    FONT_COLOR = 57734
    CONTACT2 = 57735
    FOLDER = 57736
    AUDIO = 57737
    PLACEHOLDER = 57738
    VIEW = 57739
    SET_LOCK_SCREEN = 57740
    SET_TILE = 57741
    CLOSED_CAPTION = 57744
    STOP_SLIDE_SHOW = 57745
    PERMISSIONS = 57746
    HIGHLIGHT = 57747
    DISABLE_UPDATES = 57748
    UN_FAVORITE = 57749
    UN_PIN = 57750
    OPEN_LOCAL = 57751
    MUTE = 57752
    ITALIC = 57753
    UNDERLINE = 57754
    BOLD = 57755
    MOVE_TO_FOLDER = 57756
    LIKE_DISLIKE = 57757
    DISLIKE = 57758
    LIKE = 57759
    ALIGN_RIGHT = 57760
    ALIGN_CENTER = 57761
    ALIGN_LEFT = 57762
    ZOOM = 57763
    ZOOM_OUT = 57764
    OPEN_FILE = 57765
    OTHER_USER = 57766
    ADMIN = 57767
    STREET = 57795
    MAP = 57796
    CLEAR_SELECTION = 57797
    FONT_DECREASE = 57798
    FONT_INCREASE = 57799
    FONT_SIZE = 57800
    CELL_PHONE = 57801
    RE_SHARE = 57802
    TAG = 57803
    REPEAT_ONE = 57804
    REPEAT_ALL = 57805
    OUTLINE_STAR = 57806
    SOLID_STAR = 57807
    CALCULATOR = 57808
    DIRECTIONS = 57809
    TARGET = 57810
    LIBRARY = 57811
    PHONE_BOOK = 57812
    MEMO = 57813
    MICROPHONE = 57814
    POST_UPDATE = 57815
    BACK_TO_WINDOW = 57816
    FULL_SCREEN = 57817
    NEW_FOLDER = 57818
    CALENDAR_REPLY = 57819
    UN_SYNC_FOLDER = 57821
    REPORT_HACKED = 57822
    SYNC_FOLDER = 57823
    BLOCK_CONTACT = 57824
    SWITCH_APPS = 57825
    ADD_FRIEND = 57826
    TOUCH_POINTER = 57827
    GO_TO_START = 57828
    ZERO_BARS = 57829
    ONE_BAR = 57830
    TWO_BARS = 57831
    THREE_BARS = 57832
    FOUR_BARS = 57833
    SCAN = 58004
    PREVIEW = 58005
    GLOBAL_NAVIGATION_BUTTON = 59136
    SHARE = 59181
    PRINT = 59209
    XBOX_ONE_CONSOLE = 59792

class TreeViewSelectionMode(enum.IntEnum):
    NONE = 0
    SINGLE = 1
    MULTIPLE = 2

class TwoPaneViewMode(enum.IntEnum):
    SINGLE_PANE = 0
    WIDE = 1
    TALL = 2

class TwoPaneViewPriority(enum.IntEnum):
    PANE1 = 0
    PANE2 = 1

class TwoPaneViewTallModeConfiguration(enum.IntEnum):
    SINGLE_PANE = 0
    TOP_BOTTOM = 1
    BOTTOM_TOP = 2

class TwoPaneViewWideModeConfiguration(enum.IntEnum):
    SINGLE_PANE = 0
    LEFT_RIGHT = 1
    RIGHT_LEFT = 2

class VirtualizationMode(enum.IntEnum):
    STANDARD = 0
    RECYCLING = 1

class WebViewExecutionMode(enum.IntEnum):
    SAME_THREAD = 0
    SEPARATE_THREAD = 1
    SEPARATE_PROCESS = 2

class WebViewPermissionState(enum.IntEnum):
    UNKNOWN = 0
    DEFER = 1
    ALLOW = 2
    DENY = 3

class WebViewPermissionType(enum.IntEnum):
    GEOLOCATION = 0
    UNLIMITED_INDEXED_D_B_QUOTA = 1
    MEDIA = 2
    POINTER_LOCK = 3
    WEB_NOTIFICATIONS = 4
    SCREEN = 5
    IMMERSIVE_VIEW = 6

class ZoomMode(enum.IntEnum):
    DISABLED = 0
    ENABLED = 1

Self = typing.TypeVar('Self')

class AnchorRequestedEventArgs(winrt.system.Object):
    anchor: typing.Optional[winrt.windows.ui.xaml.UIElement]
    anchor_candidates: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.ui.xaml.UIElement]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AnchorRequestedEventArgs: ...

class AppBar(winrt.system.Object):
    is_sticky: winrt.system.Boolean
    is_open: winrt.system.Boolean
    closed_display_mode: AppBarClosedDisplayMode
    template_settings: typing.Optional[winrt.windows.ui.xaml.controls.primitives.AppBarTemplateSettings]
    light_dismiss_overlay_mode: LightDismissOverlayMode
    is_open_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_sticky_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    closed_display_mode_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    light_dismiss_overlay_mode_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppBar: ...
    def __new__(cls: typing.Type[AppBar]) -> AppBar:...
    def on_closed(self, e: typing.Optional[winrt.system.Object], /) -> None: ...
    def on_closing(self, e: typing.Optional[winrt.system.Object], /) -> None: ...
    def on_opened(self, e: typing.Optional[winrt.system.Object], /) -> None: ...
    def on_opening(self, e: typing.Optional[winrt.system.Object], /) -> None: ...
    def add_closed(self, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_closed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_opened(self, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_opened(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_closing(self, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_closing(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_opening(self, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_opening(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class AppBarButton(winrt.system.Object):
    label: str
    icon: typing.Optional[IconElement]
    label_position: CommandBarLabelPosition
    keyboard_accelerator_text_override: str
    template_settings: typing.Optional[winrt.windows.ui.xaml.controls.primitives.AppBarButtonTemplateSettings]
    is_compact: winrt.system.Boolean
    dynamic_overflow_order: winrt.system.Int32
    is_in_overflow: winrt.system.Boolean
    icon_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_compact_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    label_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    dynamic_overflow_order_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_in_overflow_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    label_position_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    keyboard_accelerator_text_override_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppBarButton: ...
    def __new__(cls: typing.Type[AppBarButton]) -> AppBarButton:...

class AppBarElementContainer(winrt.system.Object):
    is_compact: winrt.system.Boolean
    dynamic_overflow_order: winrt.system.Int32
    is_in_overflow: winrt.system.Boolean
    dynamic_overflow_order_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_compact_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_in_overflow_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppBarElementContainer: ...
    def __new__(cls: typing.Type[AppBarElementContainer]) -> AppBarElementContainer:...

class AppBarSeparator(winrt.system.Object):
    is_compact: winrt.system.Boolean
    dynamic_overflow_order: winrt.system.Int32
    is_in_overflow: winrt.system.Boolean
    is_compact_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    dynamic_overflow_order_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_in_overflow_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppBarSeparator: ...
    def __new__(cls: typing.Type[AppBarSeparator]) -> AppBarSeparator:...

class AppBarToggleButton(winrt.system.Object):
    label: str
    icon: typing.Optional[IconElement]
    label_position: CommandBarLabelPosition
    keyboard_accelerator_text_override: str
    template_settings: typing.Optional[winrt.windows.ui.xaml.controls.primitives.AppBarToggleButtonTemplateSettings]
    is_compact: winrt.system.Boolean
    dynamic_overflow_order: winrt.system.Int32
    is_in_overflow: winrt.system.Boolean
    icon_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_compact_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    label_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    dynamic_overflow_order_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_in_overflow_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    label_position_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    keyboard_accelerator_text_override_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppBarToggleButton: ...
    def __new__(cls: typing.Type[AppBarToggleButton]) -> AppBarToggleButton:...

class AutoSuggestBox(winrt.system.Object):
    update_text_on_select: winrt.system.Boolean
    text_member_path: str
    text_box_style: typing.Optional[winrt.windows.ui.xaml.Style]
    text: str
    placeholder_text: str
    max_suggestion_list_height: winrt.system.Double
    is_suggestion_list_open: winrt.system.Boolean
    header: typing.Optional[winrt.system.Object]
    auto_maximize_suggestion_area: winrt.system.Boolean
    query_icon: typing.Optional[IconElement]
    light_dismiss_overlay_mode: LightDismissOverlayMode
    description: typing.Optional[winrt.system.Object]
    auto_maximize_suggestion_area_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    header_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_suggestion_list_open_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    max_suggestion_list_height_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    placeholder_text_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    text_box_style_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    text_member_path_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    text_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    update_text_on_select_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    query_icon_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    light_dismiss_overlay_mode_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    description_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AutoSuggestBox: ...
    def __new__(cls: typing.Type[AutoSuggestBox]) -> AutoSuggestBox:...
    def add_suggestion_chosen(self, handler: winrt.windows.foundation.TypedEventHandler[AutoSuggestBox, AutoSuggestBoxSuggestionChosenEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_suggestion_chosen(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_text_changed(self, handler: winrt.windows.foundation.TypedEventHandler[AutoSuggestBox, AutoSuggestBoxTextChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_text_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_query_submitted(self, handler: winrt.windows.foundation.TypedEventHandler[AutoSuggestBox, AutoSuggestBoxQuerySubmittedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_query_submitted(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class AutoSuggestBoxQuerySubmittedEventArgs(winrt.system.Object):
    chosen_suggestion: typing.Optional[winrt.system.Object]
    query_text: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AutoSuggestBoxQuerySubmittedEventArgs: ...
    def __new__(cls: typing.Type[AutoSuggestBoxQuerySubmittedEventArgs]) -> AutoSuggestBoxQuerySubmittedEventArgs:...

class AutoSuggestBoxSuggestionChosenEventArgs(winrt.system.Object):
    selected_item: typing.Optional[winrt.system.Object]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AutoSuggestBoxSuggestionChosenEventArgs: ...
    def __new__(cls: typing.Type[AutoSuggestBoxSuggestionChosenEventArgs]) -> AutoSuggestBoxSuggestionChosenEventArgs:...

class AutoSuggestBoxTextChangedEventArgs(winrt.system.Object):
    reason: AutoSuggestionBoxTextChangeReason
    reason_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AutoSuggestBoxTextChangedEventArgs: ...
    def __new__(cls: typing.Type[AutoSuggestBoxTextChangedEventArgs]) -> AutoSuggestBoxTextChangedEventArgs:...
    def check_current(self) -> winrt.system.Boolean: ...

class BackClickEventArgs(winrt.system.Object):
    handled: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BackClickEventArgs: ...
    def __new__(cls: typing.Type[BackClickEventArgs]) -> BackClickEventArgs:...

class BitmapIcon(winrt.system.Object):
    uri_source: typing.Optional[winrt.windows.foundation.Uri]
    show_as_monochrome: winrt.system.Boolean
    uri_source_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    show_as_monochrome_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BitmapIcon: ...
    def __new__(cls: typing.Type[BitmapIcon]) -> BitmapIcon:...

class BitmapIconSource(winrt.system.Object):
    uri_source: typing.Optional[winrt.windows.foundation.Uri]
    show_as_monochrome: winrt.system.Boolean
    show_as_monochrome_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    uri_source_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BitmapIconSource: ...
    def __new__(cls: typing.Type[BitmapIconSource]) -> BitmapIconSource:...

class Border(winrt.system.Object):
    padding: winrt.windows.ui.xaml.Thickness
    corner_radius: winrt.windows.ui.xaml.CornerRadius
    child_transitions: typing.Optional[winrt.windows.ui.xaml.media.animation.TransitionCollection]
    child: typing.Optional[winrt.windows.ui.xaml.UIElement]
    border_thickness: winrt.windows.ui.xaml.Thickness
    border_brush: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    background: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    background_transition: typing.Optional[winrt.windows.ui.xaml.BrushTransition]
    background_sizing: BackgroundSizing
    background_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    border_brush_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    border_thickness_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    child_transitions_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    corner_radius_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    padding_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    background_sizing_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Border: ...
    def __new__(cls: typing.Type[Border]) -> Border:...

class Button(winrt.system.Object):
    flyout: typing.Optional[winrt.windows.ui.xaml.controls.primitives.FlyoutBase]
    flyout_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Button: ...
    def __new__(cls: typing.Type[Button]) -> Button:...

class CalendarDatePicker(winrt.system.Object):
    placeholder_text: str
    min_date: datetime.datetime
    max_date: datetime.datetime
    is_today_highlighted: winrt.system.Boolean
    is_out_of_scope_enabled: winrt.system.Boolean
    is_group_label_visible: winrt.system.Boolean
    is_calendar_open: winrt.system.Boolean
    header_template: typing.Optional[winrt.windows.ui.xaml.DataTemplate]
    header: typing.Optional[winrt.system.Object]
    first_day_of_week: winrt.windows.globalization.DayOfWeek
    display_mode: CalendarViewDisplayMode
    day_of_week_format: str
    date_format: str
    date: typing.Optional[typing.Optional[datetime.datetime]]
    calendar_view_style: typing.Optional[winrt.windows.ui.xaml.Style]
    calendar_identifier: str
    light_dismiss_overlay_mode: LightDismissOverlayMode
    description: typing.Optional[winrt.system.Object]
    calendar_identifier_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    calendar_view_style_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    date_format_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    date_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    day_of_week_format_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    display_mode_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    first_day_of_week_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    header_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    header_template_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_calendar_open_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_group_label_visible_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_out_of_scope_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_today_highlighted_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    max_date_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    min_date_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    placeholder_text_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    light_dismiss_overlay_mode_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    description_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CalendarDatePicker: ...
    def __new__(cls: typing.Type[CalendarDatePicker]) -> CalendarDatePicker:...
    def set_display_date(self, date: datetime.datetime, /) -> None: ...
    def set_year_decade_display_dimensions(self, columns: winrt.system.Int32, rows: winrt.system.Int32, /) -> None: ...
    def add_calendar_view_day_item_changing(self, handler: typing.Optional[CalendarViewDayItemChangingEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_calendar_view_day_item_changing(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_closed(self, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_closed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_date_changed(self, handler: winrt.windows.foundation.TypedEventHandler[CalendarDatePicker, CalendarDatePickerDateChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_date_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_opened(self, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_opened(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class CalendarDatePickerDateChangedEventArgs(winrt.system.Object):
    new_date: typing.Optional[typing.Optional[datetime.datetime]]
    old_date: typing.Optional[typing.Optional[datetime.datetime]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CalendarDatePickerDateChangedEventArgs: ...

class CalendarView(winrt.system.Object):
    first_of_month_label_font_weight: winrt.windows.ui.text.FontWeight
    first_of_month_label_font_style: winrt.windows.ui.text.FontStyle
    first_of_month_label_font_size: winrt.system.Double
    first_of_month_label_font_family: typing.Optional[winrt.windows.ui.xaml.media.FontFamily]
    first_day_of_week: winrt.windows.globalization.DayOfWeek
    display_mode: CalendarViewDisplayMode
    day_of_week_format: str
    day_item_font_weight: winrt.windows.ui.text.FontWeight
    is_today_highlighted: winrt.system.Boolean
    day_item_font_size: winrt.system.Double
    day_item_font_family: typing.Optional[winrt.windows.ui.xaml.media.FontFamily]
    calendar_view_day_item_style: typing.Optional[winrt.windows.ui.xaml.Style]
    calendar_item_foreground: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    calendar_item_border_thickness: winrt.windows.ui.xaml.Thickness
    calendar_item_border_brush: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    calendar_item_background: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    calendar_identifier: str
    out_of_scope_background: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    blackout_foreground: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    first_of_year_decade_label_font_family: typing.Optional[winrt.windows.ui.xaml.media.FontFamily]
    number_of_weeks_in_view: winrt.system.Int32
    month_year_item_font_weight: winrt.windows.ui.text.FontWeight
    month_year_item_font_style: winrt.windows.ui.text.FontStyle
    month_year_item_font_size: winrt.system.Double
    month_year_item_font_family: typing.Optional[winrt.windows.ui.xaml.media.FontFamily]
    min_date: datetime.datetime
    max_date: datetime.datetime
    out_of_scope_foreground: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    is_out_of_scope_enabled: winrt.system.Boolean
    is_group_label_visible: winrt.system.Boolean
    hover_border_brush: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    horizontal_first_of_month_label_alignment: winrt.windows.ui.xaml.HorizontalAlignment
    horizontal_day_item_alignment: winrt.windows.ui.xaml.HorizontalAlignment
    focus_border_brush: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    first_of_year_decade_label_font_weight: winrt.windows.ui.text.FontWeight
    first_of_year_decade_label_font_style: winrt.windows.ui.text.FontStyle
    first_of_year_decade_label_font_size: winrt.system.Double
    day_item_font_style: winrt.windows.ui.text.FontStyle
    vertical_first_of_month_label_alignment: winrt.windows.ui.xaml.VerticalAlignment
    vertical_day_item_alignment: winrt.windows.ui.xaml.VerticalAlignment
    today_foreground: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    today_font_weight: winrt.windows.ui.text.FontWeight
    selection_mode: CalendarViewSelectionMode
    selected_pressed_border_brush: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    selected_hover_border_brush: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    selected_foreground: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    selected_border_brush: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    pressed_foreground: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    pressed_border_brush: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    selected_dates: typing.Optional[winrt.windows.foundation.collections.IVector[datetime.datetime]]
    template_settings: typing.Optional[winrt.windows.ui.xaml.controls.primitives.CalendarViewTemplateSettings]
    calendar_item_hover_background: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    calendar_item_disabled_background: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    calendar_item_corner_radius: winrt.windows.ui.xaml.CornerRadius
    blackout_strikethrough_brush: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    blackout_background: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    calendar_item_pressed_background: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    today_selected_inner_border_brush: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    today_pressed_background: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    today_hover_background: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    today_disabled_background: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    today_blackout_foreground: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    today_blackout_background: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    today_background: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    selected_pressed_foreground: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    selected_hover_foreground: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    selected_disabled_foreground: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    selected_disabled_border_brush: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    out_of_scope_pressed_foreground: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    out_of_scope_hover_foreground: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    month_year_item_margin: winrt.windows.ui.xaml.Thickness
    first_of_year_decade_label_margin: winrt.windows.ui.xaml.Thickness
    first_of_month_label_margin: winrt.windows.ui.xaml.Thickness
    disabled_foreground: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    day_item_margin: winrt.windows.ui.xaml.Thickness
    is_out_of_scope_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_today_highlighted_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    max_date_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    min_date_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    month_year_item_font_family_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    month_year_item_font_size_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    month_year_item_font_style_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    month_year_item_font_weight_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    number_of_weeks_in_view_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    first_day_of_week_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    out_of_scope_background_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    out_of_scope_foreground_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    pressed_border_brush_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    pressed_foreground_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    selected_border_brush_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    selected_foreground_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    selected_hover_border_brush_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    selected_pressed_border_brush_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    selection_mode_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    template_settings_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    today_font_weight_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    today_foreground_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    vertical_day_item_alignment_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    vertical_first_of_month_label_alignment_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    blackout_foreground_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    calendar_identifier_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    calendar_item_background_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    calendar_item_border_brush_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    calendar_item_border_thickness_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    calendar_item_foreground_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    calendar_view_day_item_style_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    day_item_font_family_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    day_item_font_size_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    day_item_font_style_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    day_item_font_weight_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    day_of_week_format_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    display_mode_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    selected_dates_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    first_of_month_label_font_family_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    first_of_month_label_font_size_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    first_of_month_label_font_style_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    first_of_month_label_font_weight_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    first_of_year_decade_label_font_family_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    first_of_year_decade_label_font_size_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    first_of_year_decade_label_font_style_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    first_of_year_decade_label_font_weight_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    focus_border_brush_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    horizontal_day_item_alignment_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    horizontal_first_of_month_label_alignment_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    hover_border_brush_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_group_label_visible_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    blackout_background_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    blackout_strikethrough_brush_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    calendar_item_corner_radius_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    calendar_item_disabled_background_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    calendar_item_hover_background_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    calendar_item_pressed_background_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    day_item_margin_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    disabled_foreground_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    first_of_month_label_margin_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    month_year_item_margin_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    out_of_scope_hover_foreground_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    out_of_scope_pressed_foreground_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    selected_disabled_border_brush_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    selected_disabled_foreground_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    selected_hover_foreground_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    selected_pressed_foreground_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    today_background_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    today_blackout_background_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    today_blackout_foreground_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    today_disabled_background_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    today_hover_background_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    today_pressed_background_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    today_selected_inner_border_brush_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    first_of_year_decade_label_margin_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CalendarView: ...
    def __new__(cls: typing.Type[CalendarView]) -> CalendarView:...
    def set_display_date(self, date: datetime.datetime, /) -> None: ...
    def set_year_decade_display_dimensions(self, columns: winrt.system.Int32, rows: winrt.system.Int32, /) -> None: ...
    def add_calendar_view_day_item_changing(self, handler: winrt.windows.foundation.TypedEventHandler[CalendarView, CalendarViewDayItemChangingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_calendar_view_day_item_changing(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_selected_dates_changed(self, handler: winrt.windows.foundation.TypedEventHandler[CalendarView, CalendarViewSelectedDatesChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_selected_dates_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class CalendarViewDayItem(winrt.system.Object):
    is_blackout: winrt.system.Boolean
    date: datetime.datetime
    date_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_blackout_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CalendarViewDayItem: ...
    def __new__(cls: typing.Type[CalendarViewDayItem]) -> CalendarViewDayItem:...
    def set_density_colors(self, colors: typing.Iterable[winrt.windows.ui.Color], /) -> None: ...

class CalendarViewDayItemChangingEventArgs(winrt.system.Object):
    in_recycle_queue: winrt.system.Boolean
    item: typing.Optional[CalendarViewDayItem]
    phase: winrt.system.UInt32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CalendarViewDayItemChangingEventArgs: ...
    @typing.overload
    def register_update_callback(self, callback: winrt.windows.foundation.TypedEventHandler[CalendarView, CalendarViewDayItemChangingEventArgs], /) -> None: ...
    @typing.overload
    def register_update_callback(self, callback_phase: winrt.system.UInt32, callback: winrt.windows.foundation.TypedEventHandler[CalendarView, CalendarViewDayItemChangingEventArgs], /) -> None: ...

class CalendarViewSelectedDatesChangedEventArgs(winrt.system.Object):
    added_dates: typing.Optional[winrt.windows.foundation.collections.IVectorView[datetime.datetime]]
    removed_dates: typing.Optional[winrt.windows.foundation.collections.IVectorView[datetime.datetime]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CalendarViewSelectedDatesChangedEventArgs: ...

class CandidateWindowBoundsChangedEventArgs(winrt.system.Object):
    bounds: winrt.windows.foundation.Rect
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CandidateWindowBoundsChangedEventArgs: ...

class Canvas(winrt.system.Object):
    left_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    top_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    z_index_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Canvas: ...
    def __new__(cls: typing.Type[Canvas]) -> Canvas:...
    @staticmethod
    def get_left(element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> winrt.system.Double: ...
    @staticmethod
    def get_top(element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> winrt.system.Double: ...
    @staticmethod
    def get_z_index(element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> winrt.system.Int32: ...
    @staticmethod
    def set_left(element: typing.Optional[winrt.windows.ui.xaml.UIElement], length: winrt.system.Double, /) -> None: ...
    @staticmethod
    def set_top(element: typing.Optional[winrt.windows.ui.xaml.UIElement], length: winrt.system.Double, /) -> None: ...
    @staticmethod
    def set_z_index(element: typing.Optional[winrt.windows.ui.xaml.UIElement], value: winrt.system.Int32, /) -> None: ...

class CaptureElement(winrt.system.Object):
    stretch: winrt.windows.ui.xaml.media.Stretch
    source: typing.Optional[winrt.windows.media.capture.MediaCapture]
    source_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    stretch_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CaptureElement: ...
    def __new__(cls: typing.Type[CaptureElement]) -> CaptureElement:...

class CheckBox(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CheckBox: ...
    def __new__(cls: typing.Type[CheckBox]) -> CheckBox:...

class ChoosingGroupHeaderContainerEventArgs(winrt.system.Object):
    group_header_container: typing.Optional[ListViewBaseHeaderItem]
    group: typing.Optional[winrt.system.Object]
    group_index: winrt.system.Int32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChoosingGroupHeaderContainerEventArgs: ...
    def __new__(cls: typing.Type[ChoosingGroupHeaderContainerEventArgs]) -> ChoosingGroupHeaderContainerEventArgs:...

class ChoosingItemContainerEventArgs(winrt.system.Object):
    item_container: typing.Optional[winrt.windows.ui.xaml.controls.primitives.SelectorItem]
    is_container_prepared: winrt.system.Boolean
    item: typing.Optional[winrt.system.Object]
    item_index: winrt.system.Int32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChoosingItemContainerEventArgs: ...
    def __new__(cls: typing.Type[ChoosingItemContainerEventArgs]) -> ChoosingItemContainerEventArgs:...

class CleanUpVirtualizedItemEventArgs(winrt.system.Object):
    cancel: winrt.system.Boolean
    u_i_element: typing.Optional[winrt.windows.ui.xaml.UIElement]
    value: typing.Optional[winrt.system.Object]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CleanUpVirtualizedItemEventArgs: ...

class ColorChangedEventArgs(winrt.system.Object):
    new_color: winrt.windows.ui.Color
    old_color: winrt.windows.ui.Color
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ColorChangedEventArgs: ...

class ColorPicker(winrt.system.Object):
    previous_color: typing.Optional[typing.Optional[winrt.windows.ui.Color]]
    min_value: winrt.system.Int32
    min_saturation: winrt.system.Int32
    min_hue: winrt.system.Int32
    max_value: winrt.system.Int32
    max_saturation: winrt.system.Int32
    max_hue: winrt.system.Int32
    is_more_button_visible: winrt.system.Boolean
    is_hex_input_visible: winrt.system.Boolean
    is_color_spectrum_visible: winrt.system.Boolean
    is_color_slider_visible: winrt.system.Boolean
    is_color_preview_visible: winrt.system.Boolean
    is_color_channel_text_input_visible: winrt.system.Boolean
    is_alpha_text_input_visible: winrt.system.Boolean
    is_alpha_slider_visible: winrt.system.Boolean
    is_alpha_enabled: winrt.system.Boolean
    color_spectrum_shape: ColorSpectrumShape
    color_spectrum_components: ColorSpectrumComponents
    color: winrt.windows.ui.Color
    color_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    color_spectrum_components_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    color_spectrum_shape_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_alpha_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_alpha_slider_visible_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_alpha_text_input_visible_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_color_channel_text_input_visible_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_color_preview_visible_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_color_slider_visible_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_color_spectrum_visible_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_hex_input_visible_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_more_button_visible_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    max_hue_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    max_saturation_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    max_value_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    min_hue_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    min_saturation_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    min_value_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    previous_color_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ColorPicker: ...
    def __new__(cls: typing.Type[ColorPicker]) -> ColorPicker:...
    def add_color_changed(self, handler: winrt.windows.foundation.TypedEventHandler[ColorPicker, ColorChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_color_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class ColumnDefinition(winrt.system.Object):
    width: winrt.windows.ui.xaml.GridLength
    min_width: winrt.system.Double
    max_width: winrt.system.Double
    actual_width: winrt.system.Double
    max_width_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    min_width_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    width_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ColumnDefinition: ...
    def __new__(cls: typing.Type[ColumnDefinition]) -> ColumnDefinition:...

class ColumnDefinitionCollection(winrt.system.Object, typing.MutableSequence[ColumnDefinition]):
    size: winrt.system.UInt32
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> ColumnDefinition: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[ColumnDefinition]: ...
    def insert(self, index: int, value: ColumnDefinition) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: ColumnDefinition) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[ColumnDefinition]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ColumnDefinitionCollection: ...
    def append(self, value: typing.Optional[ColumnDefinition], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[ColumnDefinition]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[ColumnDefinition]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[ColumnDefinition], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[ColumnDefinition]]: ...
    def index_of(self, value: typing.Optional[ColumnDefinition], /) -> typing.Tuple[winrt.system.Boolean, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[ColumnDefinition], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[ColumnDefinition], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[ColumnDefinition], /) -> None: ...

class ComboBox(winrt.system.Object):
    max_drop_down_height: winrt.system.Double
    is_editable: winrt.system.Boolean
    is_drop_down_open: winrt.system.Boolean
    is_selection_box_highlighted: winrt.system.Boolean
    selection_box_item: typing.Optional[winrt.system.Object]
    selection_box_item_template: typing.Optional[winrt.windows.ui.xaml.DataTemplate]
    template_settings: typing.Optional[winrt.windows.ui.xaml.controls.primitives.ComboBoxTemplateSettings]
    placeholder_text: str
    header_template: typing.Optional[winrt.windows.ui.xaml.DataTemplate]
    header: typing.Optional[winrt.system.Object]
    light_dismiss_overlay_mode: LightDismissOverlayMode
    is_text_search_enabled: winrt.system.Boolean
    selection_changed_trigger: ComboBoxSelectionChangedTrigger
    placeholder_foreground: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    text_box_style: typing.Optional[winrt.windows.ui.xaml.Style]
    text: str
    description: typing.Optional[winrt.system.Object]
    is_drop_down_open_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    max_drop_down_height_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    header_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    header_template_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    placeholder_text_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_text_search_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    light_dismiss_overlay_mode_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    selection_changed_trigger_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    placeholder_foreground_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    description_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_editable_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    text_box_style_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    text_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ComboBox: ...
    def __new__(cls: typing.Type[ComboBox]) -> ComboBox:...
    def on_drop_down_closed(self, e: typing.Optional[winrt.system.Object], /) -> None: ...
    def on_drop_down_opened(self, e: typing.Optional[winrt.system.Object], /) -> None: ...
    def add_drop_down_closed(self, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_drop_down_closed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_drop_down_opened(self, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_drop_down_opened(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_text_submitted(self, handler: winrt.windows.foundation.TypedEventHandler[ComboBox, ComboBoxTextSubmittedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_text_submitted(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class ComboBoxItem(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ComboBoxItem: ...
    def __new__(cls: typing.Type[ComboBoxItem]) -> ComboBoxItem:...

class ComboBoxTextSubmittedEventArgs(winrt.system.Object):
    handled: winrt.system.Boolean
    text: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ComboBoxTextSubmittedEventArgs: ...

class CommandBar(winrt.system.Object):
    primary_commands: typing.Optional[winrt.windows.foundation.collections.IObservableVector[ICommandBarElement]]
    secondary_commands: typing.Optional[winrt.windows.foundation.collections.IObservableVector[ICommandBarElement]]
    command_bar_overflow_presenter_style: typing.Optional[winrt.windows.ui.xaml.Style]
    command_bar_template_settings: typing.Optional[winrt.windows.ui.xaml.controls.primitives.CommandBarTemplateSettings]
    overflow_button_visibility: CommandBarOverflowButtonVisibility
    is_dynamic_overflow_enabled: winrt.system.Boolean
    default_label_position: CommandBarDefaultLabelPosition
    primary_commands_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    secondary_commands_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    command_bar_overflow_presenter_style_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    default_label_position_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_dynamic_overflow_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    overflow_button_visibility_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CommandBar: ...
    def __new__(cls: typing.Type[CommandBar]) -> CommandBar:...
    def add_dynamic_overflow_items_changing(self, handler: winrt.windows.foundation.TypedEventHandler[CommandBar, DynamicOverflowItemsChangingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_dynamic_overflow_items_changing(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class CommandBarFlyout(winrt.system.Object):
    primary_commands: typing.Optional[winrt.windows.foundation.collections.IObservableVector[ICommandBarElement]]
    secondary_commands: typing.Optional[winrt.windows.foundation.collections.IObservableVector[ICommandBarElement]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CommandBarFlyout: ...
    def __new__(cls: typing.Type[CommandBarFlyout]) -> CommandBarFlyout:...

class CommandBarOverflowPresenter(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CommandBarOverflowPresenter: ...
    def __new__(cls: typing.Type[CommandBarOverflowPresenter]) -> CommandBarOverflowPresenter:...

class ContainerContentChangingEventArgs(winrt.system.Object):
    handled: winrt.system.Boolean
    in_recycle_queue: winrt.system.Boolean
    item: typing.Optional[winrt.system.Object]
    item_container: typing.Optional[winrt.windows.ui.xaml.controls.primitives.SelectorItem]
    item_index: winrt.system.Int32
    phase: winrt.system.UInt32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ContainerContentChangingEventArgs: ...
    def __new__(cls: typing.Type[ContainerContentChangingEventArgs]) -> ContainerContentChangingEventArgs:...
    @typing.overload
    def register_update_callback(self, callback: winrt.windows.foundation.TypedEventHandler[ListViewBase, ContainerContentChangingEventArgs], /) -> None: ...
    @typing.overload
    def register_update_callback(self, callback_phase: winrt.system.UInt32, callback: winrt.windows.foundation.TypedEventHandler[ListViewBase, ContainerContentChangingEventArgs], /) -> None: ...

class ContentControl(winrt.system.Object):
    content_transitions: typing.Optional[winrt.windows.ui.xaml.media.animation.TransitionCollection]
    content_template_selector: typing.Optional[DataTemplateSelector]
    content_template: typing.Optional[winrt.windows.ui.xaml.DataTemplate]
    content: typing.Optional[winrt.system.Object]
    content_template_root: typing.Optional[winrt.windows.ui.xaml.UIElement]
    content_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    content_template_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    content_template_selector_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    content_transitions_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ContentControl: ...
    def __new__(cls: typing.Type[ContentControl]) -> ContentControl:...
    def on_content_changed(self, old_content: typing.Optional[winrt.system.Object], new_content: typing.Optional[winrt.system.Object], /) -> None: ...
    def on_content_template_changed(self, old_content_template: typing.Optional[winrt.windows.ui.xaml.DataTemplate], new_content_template: typing.Optional[winrt.windows.ui.xaml.DataTemplate], /) -> None: ...
    def on_content_template_selector_changed(self, old_content_template_selector: typing.Optional[DataTemplateSelector], new_content_template_selector: typing.Optional[DataTemplateSelector], /) -> None: ...

class ContentDialog(winrt.system.Object):
    title_template: typing.Optional[winrt.windows.ui.xaml.DataTemplate]
    title: typing.Optional[winrt.system.Object]
    secondary_button_text: str
    secondary_button_command_parameter: typing.Optional[winrt.system.Object]
    secondary_button_command: typing.Optional[winrt.windows.ui.xaml.input.ICommand]
    primary_button_text: str
    primary_button_command_parameter: typing.Optional[winrt.system.Object]
    primary_button_command: typing.Optional[winrt.windows.ui.xaml.input.ICommand]
    is_secondary_button_enabled: winrt.system.Boolean
    is_primary_button_enabled: winrt.system.Boolean
    full_size_desired: winrt.system.Boolean
    secondary_button_style: typing.Optional[winrt.windows.ui.xaml.Style]
    primary_button_style: typing.Optional[winrt.windows.ui.xaml.Style]
    default_button: ContentDialogButton
    close_button_text: str
    close_button_style: typing.Optional[winrt.windows.ui.xaml.Style]
    close_button_command_parameter: typing.Optional[winrt.system.Object]
    close_button_command: typing.Optional[winrt.windows.ui.xaml.input.ICommand]
    full_size_desired_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_primary_button_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_secondary_button_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    primary_button_command_parameter_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    primary_button_command_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    primary_button_text_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    secondary_button_command_parameter_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    secondary_button_command_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    secondary_button_text_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    title_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    title_template_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    close_button_command_parameter_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    close_button_command_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    close_button_style_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    close_button_text_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    default_button_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    primary_button_style_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    secondary_button_style_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ContentDialog: ...
    def __new__(cls: typing.Type[ContentDialog]) -> ContentDialog:...
    def hide(self) -> None: ...
    @typing.overload
    def show_async(self) -> winrt.windows.foundation.IAsyncOperation[ContentDialogResult]: ...
    @typing.overload
    def show_async(self, placement: ContentDialogPlacement, /) -> winrt.windows.foundation.IAsyncOperation[ContentDialogResult]: ...
    def add_closed(self, handler: winrt.windows.foundation.TypedEventHandler[ContentDialog, ContentDialogClosedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_closed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_closing(self, handler: winrt.windows.foundation.TypedEventHandler[ContentDialog, ContentDialogClosingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_closing(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_opened(self, handler: winrt.windows.foundation.TypedEventHandler[ContentDialog, ContentDialogOpenedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_opened(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_primary_button_click(self, handler: winrt.windows.foundation.TypedEventHandler[ContentDialog, ContentDialogButtonClickEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_primary_button_click(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_secondary_button_click(self, handler: winrt.windows.foundation.TypedEventHandler[ContentDialog, ContentDialogButtonClickEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_secondary_button_click(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_close_button_click(self, handler: winrt.windows.foundation.TypedEventHandler[ContentDialog, ContentDialogButtonClickEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_close_button_click(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class ContentDialogButtonClickDeferral(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ContentDialogButtonClickDeferral: ...
    def complete(self) -> None: ...

class ContentDialogButtonClickEventArgs(winrt.system.Object):
    cancel: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ContentDialogButtonClickEventArgs: ...
    def get_deferral(self) -> typing.Optional[ContentDialogButtonClickDeferral]: ...

class ContentDialogClosedEventArgs(winrt.system.Object):
    result: ContentDialogResult
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ContentDialogClosedEventArgs: ...

class ContentDialogClosingDeferral(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ContentDialogClosingDeferral: ...
    def complete(self) -> None: ...

class ContentDialogClosingEventArgs(winrt.system.Object):
    cancel: winrt.system.Boolean
    result: ContentDialogResult
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ContentDialogClosingEventArgs: ...
    def get_deferral(self) -> typing.Optional[ContentDialogClosingDeferral]: ...

class ContentDialogOpenedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ContentDialogOpenedEventArgs: ...

class ContentLinkChangedEventArgs(winrt.system.Object):
    change_kind: ContentLinkChangeKind
    content_link_info: typing.Optional[winrt.windows.ui.text.ContentLinkInfo]
    text_range: winrt.windows.ui.xaml.documents.TextRange
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ContentLinkChangedEventArgs: ...

class ContentPresenter(winrt.system.Object):
    foreground: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    font_weight: winrt.windows.ui.text.FontWeight
    font_style: winrt.windows.ui.text.FontStyle
    font_stretch: winrt.windows.ui.text.FontStretch
    font_size: winrt.system.Double
    font_family: typing.Optional[winrt.windows.ui.xaml.media.FontFamily]
    content_transitions: typing.Optional[winrt.windows.ui.xaml.media.animation.TransitionCollection]
    content_template_selector: typing.Optional[DataTemplateSelector]
    content_template: typing.Optional[winrt.windows.ui.xaml.DataTemplate]
    content: typing.Optional[winrt.system.Object]
    character_spacing: winrt.system.Int32
    text_line_bounds: winrt.windows.ui.xaml.TextLineBounds
    optical_margin_alignment: winrt.windows.ui.xaml.OpticalMarginAlignment
    is_text_scale_factor_enabled: winrt.system.Boolean
    vertical_content_alignment: winrt.windows.ui.xaml.VerticalAlignment
    text_wrapping: winrt.windows.ui.xaml.TextWrapping
    padding: winrt.windows.ui.xaml.Thickness
    max_lines: winrt.system.Int32
    line_stacking_strategy: winrt.windows.ui.xaml.LineStackingStrategy
    line_height: winrt.system.Double
    horizontal_content_alignment: winrt.windows.ui.xaml.HorizontalAlignment
    corner_radius: winrt.windows.ui.xaml.CornerRadius
    border_thickness: winrt.windows.ui.xaml.Thickness
    border_brush: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    background: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    background_transition: typing.Optional[winrt.windows.ui.xaml.BrushTransition]
    background_sizing: BackgroundSizing
    character_spacing_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    content_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    content_template_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    content_template_selector_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    content_transitions_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    font_family_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    font_size_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    font_stretch_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    font_style_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    font_weight_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    foreground_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    optical_margin_alignment_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    text_line_bounds_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_text_scale_factor_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    background_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    border_brush_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    border_thickness_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    corner_radius_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    horizontal_content_alignment_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    line_height_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    line_stacking_strategy_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    max_lines_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    padding_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    text_wrapping_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    vertical_content_alignment_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    background_sizing_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ContentPresenter: ...
    def __new__(cls: typing.Type[ContentPresenter]) -> ContentPresenter:...
    def on_content_template_changed(self, old_content_template: typing.Optional[winrt.windows.ui.xaml.DataTemplate], new_content_template: typing.Optional[winrt.windows.ui.xaml.DataTemplate], /) -> None: ...
    def on_content_template_selector_changed(self, old_content_template_selector: typing.Optional[DataTemplateSelector], new_content_template_selector: typing.Optional[DataTemplateSelector], /) -> None: ...

class ContextMenuEventArgs(winrt.system.Object):
    handled: winrt.system.Boolean
    cursor_left: winrt.system.Double
    cursor_top: winrt.system.Double
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ContextMenuEventArgs: ...

class Control(winrt.system.Object):
    padding: winrt.windows.ui.xaml.Thickness
    is_tab_stop: winrt.system.Boolean
    is_enabled: winrt.system.Boolean
    horizontal_content_alignment: winrt.windows.ui.xaml.HorizontalAlignment
    foreground: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    font_weight: winrt.windows.ui.text.FontWeight
    font_style: winrt.windows.ui.text.FontStyle
    font_stretch: winrt.windows.ui.text.FontStretch
    font_size: winrt.system.Double
    font_family: typing.Optional[winrt.windows.ui.xaml.media.FontFamily]
    tab_index: winrt.system.Int32
    character_spacing: winrt.system.Int32
    border_thickness: winrt.windows.ui.xaml.Thickness
    border_brush: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    tab_navigation: winrt.windows.ui.xaml.input.KeyboardNavigationMode
    background: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    vertical_content_alignment: winrt.windows.ui.xaml.VerticalAlignment
    template: typing.Optional[ControlTemplate]
    focus_state: winrt.windows.ui.xaml.FocusState
    is_text_scale_factor_enabled: winrt.system.Boolean
    use_system_focus_visuals: winrt.system.Boolean
    x_y_focus_up: typing.Optional[winrt.windows.ui.xaml.DependencyObject]
    x_y_focus_right: typing.Optional[winrt.windows.ui.xaml.DependencyObject]
    x_y_focus_left: typing.Optional[winrt.windows.ui.xaml.DependencyObject]
    x_y_focus_down: typing.Optional[winrt.windows.ui.xaml.DependencyObject]
    requires_pointer: RequiresPointer
    is_focus_engagement_enabled: winrt.system.Boolean
    is_focus_engaged: winrt.system.Boolean
    element_sound_mode: winrt.windows.ui.xaml.ElementSoundMode
    default_style_resource_uri: typing.Optional[winrt.windows.foundation.Uri]
    corner_radius: winrt.windows.ui.xaml.CornerRadius
    background_sizing: BackgroundSizing
    default_style_key: typing.Optional[winrt.system.Object]
    border_thickness_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    focus_state_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    font_family_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    font_size_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    font_stretch_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    font_style_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    font_weight_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    foreground_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    horizontal_content_alignment_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_tab_stop_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    padding_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    tab_index_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    tab_navigation_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    template_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    background_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    border_brush_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    vertical_content_alignment_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    character_spacing_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    default_style_key_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_text_scale_factor_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_template_focus_target_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    use_system_focus_visuals_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    element_sound_mode_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_focus_engaged_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_focus_engagement_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    requires_pointer_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    x_y_focus_down_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    x_y_focus_left_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    x_y_focus_right_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    x_y_focus_up_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    default_style_resource_uri_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_template_key_tip_target_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    corner_radius_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    background_sizing_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Control: ...
    def apply_template(self) -> winrt.system.Boolean: ...
    def focus(self, value: winrt.windows.ui.xaml.FocusState, /) -> winrt.system.Boolean: ...
    @staticmethod
    def get_is_template_focus_target(element: typing.Optional[winrt.windows.ui.xaml.FrameworkElement], /) -> winrt.system.Boolean: ...
    @staticmethod
    def get_is_template_key_tip_target(element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> winrt.system.Boolean: ...
    def get_template_child(self, child_name: str, /) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    def on_character_received(self, e: typing.Optional[winrt.windows.ui.xaml.input.CharacterReceivedRoutedEventArgs], /) -> None: ...
    def on_double_tapped(self, e: typing.Optional[winrt.windows.ui.xaml.input.DoubleTappedRoutedEventArgs], /) -> None: ...
    def on_drag_enter(self, e: typing.Optional[winrt.windows.ui.xaml.DragEventArgs], /) -> None: ...
    def on_drag_leave(self, e: typing.Optional[winrt.windows.ui.xaml.DragEventArgs], /) -> None: ...
    def on_drag_over(self, e: typing.Optional[winrt.windows.ui.xaml.DragEventArgs], /) -> None: ...
    def on_drop(self, e: typing.Optional[winrt.windows.ui.xaml.DragEventArgs], /) -> None: ...
    def on_got_focus(self, e: typing.Optional[winrt.windows.ui.xaml.RoutedEventArgs], /) -> None: ...
    def on_holding(self, e: typing.Optional[winrt.windows.ui.xaml.input.HoldingRoutedEventArgs], /) -> None: ...
    def on_key_down(self, e: typing.Optional[winrt.windows.ui.xaml.input.KeyRoutedEventArgs], /) -> None: ...
    def on_key_up(self, e: typing.Optional[winrt.windows.ui.xaml.input.KeyRoutedEventArgs], /) -> None: ...
    def on_lost_focus(self, e: typing.Optional[winrt.windows.ui.xaml.RoutedEventArgs], /) -> None: ...
    def on_manipulation_completed(self, e: typing.Optional[winrt.windows.ui.xaml.input.ManipulationCompletedRoutedEventArgs], /) -> None: ...
    def on_manipulation_delta(self, e: typing.Optional[winrt.windows.ui.xaml.input.ManipulationDeltaRoutedEventArgs], /) -> None: ...
    def on_manipulation_inertia_starting(self, e: typing.Optional[winrt.windows.ui.xaml.input.ManipulationInertiaStartingRoutedEventArgs], /) -> None: ...
    def on_manipulation_started(self, e: typing.Optional[winrt.windows.ui.xaml.input.ManipulationStartedRoutedEventArgs], /) -> None: ...
    def on_manipulation_starting(self, e: typing.Optional[winrt.windows.ui.xaml.input.ManipulationStartingRoutedEventArgs], /) -> None: ...
    def on_pointer_canceled(self, e: typing.Optional[winrt.windows.ui.xaml.input.PointerRoutedEventArgs], /) -> None: ...
    def on_pointer_capture_lost(self, e: typing.Optional[winrt.windows.ui.xaml.input.PointerRoutedEventArgs], /) -> None: ...
    def on_pointer_entered(self, e: typing.Optional[winrt.windows.ui.xaml.input.PointerRoutedEventArgs], /) -> None: ...
    def on_pointer_exited(self, e: typing.Optional[winrt.windows.ui.xaml.input.PointerRoutedEventArgs], /) -> None: ...
    def on_pointer_moved(self, e: typing.Optional[winrt.windows.ui.xaml.input.PointerRoutedEventArgs], /) -> None: ...
    def on_pointer_pressed(self, e: typing.Optional[winrt.windows.ui.xaml.input.PointerRoutedEventArgs], /) -> None: ...
    def on_pointer_released(self, e: typing.Optional[winrt.windows.ui.xaml.input.PointerRoutedEventArgs], /) -> None: ...
    def on_pointer_wheel_changed(self, e: typing.Optional[winrt.windows.ui.xaml.input.PointerRoutedEventArgs], /) -> None: ...
    def on_preview_key_down(self, e: typing.Optional[winrt.windows.ui.xaml.input.KeyRoutedEventArgs], /) -> None: ...
    def on_preview_key_up(self, e: typing.Optional[winrt.windows.ui.xaml.input.KeyRoutedEventArgs], /) -> None: ...
    def on_right_tapped(self, e: typing.Optional[winrt.windows.ui.xaml.input.RightTappedRoutedEventArgs], /) -> None: ...
    def on_tapped(self, e: typing.Optional[winrt.windows.ui.xaml.input.TappedRoutedEventArgs], /) -> None: ...
    def remove_focus_engagement(self) -> None: ...
    @staticmethod
    def set_is_template_focus_target(element: typing.Optional[winrt.windows.ui.xaml.FrameworkElement], value: winrt.system.Boolean, /) -> None: ...
    @staticmethod
    def set_is_template_key_tip_target(element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], value: winrt.system.Boolean, /) -> None: ...
    def add_is_enabled_changed(self, handler: typing.Optional[winrt.windows.ui.xaml.DependencyPropertyChangedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_is_enabled_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_focus_disengaged(self, handler: winrt.windows.foundation.TypedEventHandler[Control, FocusDisengagedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_focus_disengaged(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_focus_engaged(self, handler: winrt.windows.foundation.TypedEventHandler[Control, FocusEngagedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_focus_engaged(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class ControlTemplate(winrt.system.Object):
    target_type: winrt.windows.ui.xaml.interop.TypeName
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ControlTemplate: ...
    def __new__(cls: typing.Type[ControlTemplate]) -> ControlTemplate:...

class DataTemplateSelector(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DataTemplateSelector: ...
    def __new__(cls: typing.Type[DataTemplateSelector]) -> DataTemplateSelector:...
    def get_element(self, args: typing.Optional[winrt.windows.ui.xaml.ElementFactoryGetArgs], /) -> typing.Optional[winrt.windows.ui.xaml.UIElement]: ...
    def recycle_element(self, args: typing.Optional[winrt.windows.ui.xaml.ElementFactoryRecycleArgs], /) -> None: ...
    @typing.overload
    def select_template(self, item: typing.Optional[winrt.system.Object], /) -> typing.Optional[winrt.windows.ui.xaml.DataTemplate]: ...
    @typing.overload
    def select_template(self, item: typing.Optional[winrt.system.Object], container: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> typing.Optional[winrt.windows.ui.xaml.DataTemplate]: ...
    @typing.overload
    def select_template_core(self, item: typing.Optional[winrt.system.Object], /) -> typing.Optional[winrt.windows.ui.xaml.DataTemplate]: ...
    @typing.overload
    def select_template_core(self, item: typing.Optional[winrt.system.Object], container: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> typing.Optional[winrt.windows.ui.xaml.DataTemplate]: ...

class DatePickedEventArgs(winrt.system.Object):
    new_date: datetime.datetime
    old_date: datetime.datetime
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DatePickedEventArgs: ...
    def __new__(cls: typing.Type[DatePickedEventArgs]) -> DatePickedEventArgs:...

class DatePicker(winrt.system.Object):
    year_visible: winrt.system.Boolean
    year_format: str
    orientation: Orientation
    month_visible: winrt.system.Boolean
    month_format: str
    min_year: datetime.datetime
    max_year: datetime.datetime
    header_template: typing.Optional[winrt.windows.ui.xaml.DataTemplate]
    header: typing.Optional[winrt.system.Object]
    day_visible: winrt.system.Boolean
    day_format: str
    date: datetime.datetime
    calendar_identifier: str
    light_dismiss_overlay_mode: LightDismissOverlayMode
    selected_date: typing.Optional[typing.Optional[datetime.datetime]]
    calendar_identifier_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    date_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    day_format_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    day_visible_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    header_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    header_template_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    max_year_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    min_year_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    month_format_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    month_visible_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    orientation_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    year_format_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    year_visible_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    light_dismiss_overlay_mode_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    selected_date_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DatePicker: ...
    def __new__(cls: typing.Type[DatePicker]) -> DatePicker:...
    def add_date_changed(self, handler: winrt.windows.foundation.EventHandler[DatePickerValueChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_date_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_selected_date_changed(self, handler: winrt.windows.foundation.TypedEventHandler[DatePicker, DatePickerSelectedValueChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_selected_date_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class DatePickerFlyout(winrt.system.Object):
    year_visible: winrt.system.Boolean
    month_visible: winrt.system.Boolean
    min_year: datetime.datetime
    max_year: datetime.datetime
    day_visible: winrt.system.Boolean
    date: datetime.datetime
    calendar_identifier: str
    year_format: str
    month_format: str
    day_format: str
    calendar_identifier_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    date_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    day_visible_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    max_year_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    min_year_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    month_visible_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    year_visible_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    day_format_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    month_format_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    year_format_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DatePickerFlyout: ...
    def __new__(cls: typing.Type[DatePickerFlyout]) -> DatePickerFlyout:...
    def show_at_async(self, target: typing.Optional[winrt.windows.ui.xaml.FrameworkElement], /) -> winrt.windows.foundation.IAsyncOperation[typing.Optional[datetime.datetime]]: ...
    def add_date_picked(self, handler: winrt.windows.foundation.TypedEventHandler[DatePickerFlyout, DatePickedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_date_picked(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class DatePickerFlyoutItem(winrt.system.Object):
    secondary_text: str
    primary_text: str
    type: winrt.windows.ui.xaml.interop.TypeName
    primary_text_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    secondary_text_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DatePickerFlyoutItem: ...
    def get_custom_property(self, name: str, /) -> typing.Optional[winrt.windows.ui.xaml.data.ICustomProperty]: ...
    def get_indexed_property(self, name: str, type: winrt.windows.ui.xaml.interop.TypeName, /) -> typing.Optional[winrt.windows.ui.xaml.data.ICustomProperty]: ...
    def get_string_representation(self) -> str: ...

class DatePickerFlyoutPresenter(winrt.system.Object):
    is_default_shadow_enabled: winrt.system.Boolean
    is_default_shadow_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DatePickerFlyoutPresenter: ...

class DatePickerSelectedValueChangedEventArgs(winrt.system.Object):
    new_date: typing.Optional[typing.Optional[datetime.datetime]]
    old_date: typing.Optional[typing.Optional[datetime.datetime]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DatePickerSelectedValueChangedEventArgs: ...

class DatePickerValueChangedEventArgs(winrt.system.Object):
    new_date: datetime.datetime
    old_date: datetime.datetime
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DatePickerValueChangedEventArgs: ...

class DragItemsCompletedEventArgs(winrt.system.Object):
    drop_result: winrt.windows.applicationmodel.datatransfer.DataPackageOperation
    items: typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Object]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DragItemsCompletedEventArgs: ...

class DragItemsStartingEventArgs(winrt.system.Object):
    cancel: winrt.system.Boolean
    data: typing.Optional[winrt.windows.applicationmodel.datatransfer.DataPackage]
    items: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.system.Object]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DragItemsStartingEventArgs: ...
    def __new__(cls: typing.Type[DragItemsStartingEventArgs]) -> DragItemsStartingEventArgs:...

class DropDownButton(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DropDownButton: ...
    def __new__(cls: typing.Type[DropDownButton]) -> DropDownButton:...

class DropDownButtonAutomationPeer(winrt.system.Object):
    expand_collapse_state: winrt.windows.ui.xaml.automation.ExpandCollapseState
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DropDownButtonAutomationPeer: ...
    def __new__(cls: typing.Type[DropDownButtonAutomationPeer], owner: typing.Optional[DropDownButton]) -> DropDownButtonAutomationPeer:...
    def collapse(self) -> None: ...
    def expand(self) -> None: ...

class DynamicOverflowItemsChangingEventArgs(winrt.system.Object):
    action: CommandBarDynamicOverflowAction
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DynamicOverflowItemsChangingEventArgs: ...
    def __new__(cls: typing.Type[DynamicOverflowItemsChangingEventArgs]) -> DynamicOverflowItemsChangingEventArgs:...

class FlipView(winrt.system.Object):
    use_touch_animations_for_all_navigation: winrt.system.Boolean
    use_touch_animations_for_all_navigation_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FlipView: ...
    def __new__(cls: typing.Type[FlipView]) -> FlipView:...

class FlipViewItem(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FlipViewItem: ...
    def __new__(cls: typing.Type[FlipViewItem]) -> FlipViewItem:...

class Flyout(winrt.system.Object):
    flyout_presenter_style: typing.Optional[winrt.windows.ui.xaml.Style]
    content: typing.Optional[winrt.windows.ui.xaml.UIElement]
    content_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    flyout_presenter_style_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Flyout: ...
    def __new__(cls: typing.Type[Flyout]) -> Flyout:...

class FlyoutPresenter(winrt.system.Object):
    is_default_shadow_enabled: winrt.system.Boolean
    is_default_shadow_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FlyoutPresenter: ...
    def __new__(cls: typing.Type[FlyoutPresenter]) -> FlyoutPresenter:...

class FocusDisengagedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FocusDisengagedEventArgs: ...

class FocusEngagedEventArgs(winrt.system.Object):
    handled: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FocusEngagedEventArgs: ...

class FontIcon(winrt.system.Object):
    glyph: str
    font_weight: winrt.windows.ui.text.FontWeight
    font_style: winrt.windows.ui.text.FontStyle
    font_size: winrt.system.Double
    font_family: typing.Optional[winrt.windows.ui.xaml.media.FontFamily]
    is_text_scale_factor_enabled: winrt.system.Boolean
    mirrored_when_right_to_left: winrt.system.Boolean
    font_family_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    font_size_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    font_style_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    font_weight_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    glyph_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_text_scale_factor_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    mirrored_when_right_to_left_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FontIcon: ...
    def __new__(cls: typing.Type[FontIcon]) -> FontIcon:...

class FontIconSource(winrt.system.Object):
    mirrored_when_right_to_left: winrt.system.Boolean
    is_text_scale_factor_enabled: winrt.system.Boolean
    glyph: str
    font_weight: winrt.windows.ui.text.FontWeight
    font_style: winrt.windows.ui.text.FontStyle
    font_size: winrt.system.Double
    font_family: typing.Optional[winrt.windows.ui.xaml.media.FontFamily]
    font_family_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    font_size_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    font_style_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    font_weight_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    glyph_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_text_scale_factor_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    mirrored_when_right_to_left_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FontIconSource: ...
    def __new__(cls: typing.Type[FontIconSource]) -> FontIconSource:...

class Frame(winrt.system.Object):
    source_page_type: winrt.windows.ui.xaml.interop.TypeName
    cache_size: winrt.system.Int32
    back_stack_depth: winrt.system.Int32
    can_go_back: winrt.system.Boolean
    can_go_forward: winrt.system.Boolean
    current_source_page_type: winrt.windows.ui.xaml.interop.TypeName
    back_stack: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.ui.xaml.navigation.PageStackEntry]]
    forward_stack: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.ui.xaml.navigation.PageStackEntry]]
    is_navigation_stack_enabled: winrt.system.Boolean
    back_stack_depth_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    cache_size_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    can_go_back_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    can_go_forward_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    current_source_page_type_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    source_page_type_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    back_stack_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    forward_stack_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_navigation_stack_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Frame: ...
    def __new__(cls: typing.Type[Frame]) -> Frame:...
    def get_navigation_state(self) -> str: ...
    @typing.overload
    def go_back(self) -> None: ...
    @typing.overload
    def go_back(self, transition_info_override: typing.Optional[winrt.windows.ui.xaml.media.animation.NavigationTransitionInfo], /) -> None: ...
    def go_forward(self) -> None: ...
    @typing.overload
    def navigate(self, source_page_type: winrt.windows.ui.xaml.interop.TypeName, /) -> winrt.system.Boolean: ...
    @typing.overload
    def navigate(self, source_page_type: winrt.windows.ui.xaml.interop.TypeName, parameter: typing.Optional[winrt.system.Object], /) -> winrt.system.Boolean: ...
    @typing.overload
    def navigate(self, source_page_type: winrt.windows.ui.xaml.interop.TypeName, parameter: typing.Optional[winrt.system.Object], info_override: typing.Optional[winrt.windows.ui.xaml.media.animation.NavigationTransitionInfo], /) -> winrt.system.Boolean: ...
    def navigate_to_type(self, source_page_type: winrt.windows.ui.xaml.interop.TypeName, parameter: typing.Optional[winrt.system.Object], navigation_options: typing.Optional[winrt.windows.ui.xaml.navigation.FrameNavigationOptions], /) -> winrt.system.Boolean: ...
    @typing.overload
    def set_navigation_state(self, navigation_state: str, /) -> None: ...
    @typing.overload
    def set_navigation_state(self, navigation_state: str, suppress_navigate: winrt.system.Boolean, /) -> None: ...
    def add_navigated(self, handler: typing.Optional[winrt.windows.ui.xaml.navigation.NavigatedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_navigated(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_navigating(self, handler: typing.Optional[winrt.windows.ui.xaml.navigation.NavigatingCancelEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_navigating(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_navigation_failed(self, handler: typing.Optional[winrt.windows.ui.xaml.navigation.NavigationFailedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_navigation_failed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_navigation_stopped(self, handler: typing.Optional[winrt.windows.ui.xaml.navigation.NavigationStoppedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_navigation_stopped(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class Grid(winrt.system.Object):
    column_definitions: typing.Optional[ColumnDefinitionCollection]
    row_definitions: typing.Optional[RowDefinitionCollection]
    padding: winrt.windows.ui.xaml.Thickness
    corner_radius: winrt.windows.ui.xaml.CornerRadius
    border_thickness: winrt.windows.ui.xaml.Thickness
    border_brush: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    row_spacing: winrt.system.Double
    column_spacing: winrt.system.Double
    background_sizing: BackgroundSizing
    column_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    column_span_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    row_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    row_span_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    border_brush_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    border_thickness_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    corner_radius_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    padding_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    column_spacing_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    row_spacing_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    background_sizing_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Grid: ...
    def __new__(cls: typing.Type[Grid]) -> Grid:...
    @staticmethod
    def get_column(element: typing.Optional[winrt.windows.ui.xaml.FrameworkElement], /) -> winrt.system.Int32: ...
    @staticmethod
    def get_column_span(element: typing.Optional[winrt.windows.ui.xaml.FrameworkElement], /) -> winrt.system.Int32: ...
    @staticmethod
    def get_row(element: typing.Optional[winrt.windows.ui.xaml.FrameworkElement], /) -> winrt.system.Int32: ...
    @staticmethod
    def get_row_span(element: typing.Optional[winrt.windows.ui.xaml.FrameworkElement], /) -> winrt.system.Int32: ...
    @staticmethod
    def set_column(element: typing.Optional[winrt.windows.ui.xaml.FrameworkElement], value: winrt.system.Int32, /) -> None: ...
    @staticmethod
    def set_column_span(element: typing.Optional[winrt.windows.ui.xaml.FrameworkElement], value: winrt.system.Int32, /) -> None: ...
    @staticmethod
    def set_row(element: typing.Optional[winrt.windows.ui.xaml.FrameworkElement], value: winrt.system.Int32, /) -> None: ...
    @staticmethod
    def set_row_span(element: typing.Optional[winrt.windows.ui.xaml.FrameworkElement], value: winrt.system.Int32, /) -> None: ...

class GridView(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GridView: ...
    def __new__(cls: typing.Type[GridView]) -> GridView:...

class GridViewHeaderItem(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GridViewHeaderItem: ...
    def __new__(cls: typing.Type[GridViewHeaderItem]) -> GridViewHeaderItem:...

class GridViewItem(winrt.system.Object):
    template_settings: typing.Optional[winrt.windows.ui.xaml.controls.primitives.GridViewItemTemplateSettings]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GridViewItem: ...
    def __new__(cls: typing.Type[GridViewItem]) -> GridViewItem:...

class GroupItem(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GroupItem: ...
    def __new__(cls: typing.Type[GroupItem]) -> GroupItem:...

class GroupStyle(winrt.system.Object):
    panel: typing.Optional[ItemsPanelTemplate]
    hides_if_empty: winrt.system.Boolean
    header_template_selector: typing.Optional[DataTemplateSelector]
    header_template: typing.Optional[winrt.windows.ui.xaml.DataTemplate]
    container_style_selector: typing.Optional[StyleSelector]
    container_style: typing.Optional[winrt.windows.ui.xaml.Style]
    header_container_style: typing.Optional[winrt.windows.ui.xaml.Style]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GroupStyle: ...
    def __new__(cls: typing.Type[GroupStyle]) -> GroupStyle:...
    def add_property_changed(self, handler: typing.Optional[winrt.windows.ui.xaml.data.PropertyChangedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_property_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class GroupStyleSelector(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GroupStyleSelector: ...
    def __new__(cls: typing.Type[GroupStyleSelector]) -> GroupStyleSelector:...
    def select_group_style(self, group: typing.Optional[winrt.system.Object], level: winrt.system.UInt32, /) -> typing.Optional[GroupStyle]: ...
    def select_group_style_core(self, group: typing.Optional[winrt.system.Object], level: winrt.system.UInt32, /) -> typing.Optional[GroupStyle]: ...

class HandwritingPanelClosedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HandwritingPanelClosedEventArgs: ...

class HandwritingPanelOpenedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HandwritingPanelOpenedEventArgs: ...

class HandwritingView(winrt.system.Object):
    placement_target: typing.Optional[winrt.windows.ui.xaml.UIElement]
    placement_alignment: HandwritingPanelPlacementAlignment
    are_candidates_enabled: winrt.system.Boolean
    is_open: winrt.system.Boolean
    is_switch_to_keyboard_enabled: winrt.system.Boolean
    is_command_bar_open: winrt.system.Boolean
    input_device_types: winrt.windows.ui.core.CoreInputDeviceTypes
    are_candidates_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_open_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    placement_alignment_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    placement_target_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_command_bar_open_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_switch_to_keyboard_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HandwritingView: ...
    def __new__(cls: typing.Type[HandwritingView]) -> HandwritingView:...
    def get_candidates(self, candidates_session_id: winrt.system.UInt32, /) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[str]]: ...
    def select_candidate(self, candidates_session_id: winrt.system.UInt32, selected_candidate_index: winrt.system.UInt32, /) -> None: ...
    def try_close(self) -> winrt.system.Boolean: ...
    def try_open(self) -> winrt.system.Boolean: ...
    def add_closed(self, handler: winrt.windows.foundation.TypedEventHandler[HandwritingView, HandwritingPanelClosedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_closed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_opened(self, handler: winrt.windows.foundation.TypedEventHandler[HandwritingView, HandwritingPanelOpenedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_opened(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_candidates_changed(self, handler: winrt.windows.foundation.TypedEventHandler[HandwritingView, HandwritingViewCandidatesChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_candidates_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_text_submitted(self, handler: winrt.windows.foundation.TypedEventHandler[HandwritingView, HandwritingViewTextSubmittedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_text_submitted(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class HandwritingViewCandidatesChangedEventArgs(winrt.system.Object):
    candidates_session_id: winrt.system.UInt32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HandwritingViewCandidatesChangedEventArgs: ...

class HandwritingViewTextSubmittedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HandwritingViewTextSubmittedEventArgs: ...

class Hub(winrt.system.Object):
    orientation: Orientation
    header_template: typing.Optional[winrt.windows.ui.xaml.DataTemplate]
    header: typing.Optional[winrt.system.Object]
    default_section_index: winrt.system.Int32
    section_headers: typing.Optional[winrt.windows.foundation.collections.IObservableVector[winrt.system.Object]]
    sections: typing.Optional[winrt.windows.foundation.collections.IVector[HubSection]]
    sections_in_view: typing.Optional[winrt.windows.foundation.collections.IVector[HubSection]]
    semantic_zoom_owner: typing.Optional[SemanticZoom]
    is_zoomed_in_view: winrt.system.Boolean
    is_active_view: winrt.system.Boolean
    default_section_index_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    header_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    header_template_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_active_view_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_zoomed_in_view_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    orientation_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    semantic_zoom_owner_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Hub: ...
    def __new__(cls: typing.Type[Hub]) -> Hub:...
    def complete_view_change(self) -> None: ...
    def complete_view_change_from(self, source: typing.Optional[SemanticZoomLocation], destination: typing.Optional[SemanticZoomLocation], /) -> None: ...
    def complete_view_change_to(self, source: typing.Optional[SemanticZoomLocation], destination: typing.Optional[SemanticZoomLocation], /) -> None: ...
    def initialize_view_change(self) -> None: ...
    def make_visible(self, item: typing.Optional[SemanticZoomLocation], /) -> None: ...
    def scroll_to_section(self, section: typing.Optional[HubSection], /) -> None: ...
    def start_view_change_from(self, source: typing.Optional[SemanticZoomLocation], destination: typing.Optional[SemanticZoomLocation], /) -> None: ...
    def start_view_change_to(self, source: typing.Optional[SemanticZoomLocation], destination: typing.Optional[SemanticZoomLocation], /) -> None: ...
    def add_section_header_click(self, handler: typing.Optional[HubSectionHeaderClickEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_section_header_click(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_sections_in_view_changed(self, handler: typing.Optional[SectionsInViewChangedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_sections_in_view_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class HubSection(winrt.system.Object):
    is_header_interactive: winrt.system.Boolean
    header_template: typing.Optional[winrt.windows.ui.xaml.DataTemplate]
    header: typing.Optional[winrt.system.Object]
    content_template: typing.Optional[winrt.windows.ui.xaml.DataTemplate]
    content_template_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    header_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    header_template_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_header_interactive_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HubSection: ...
    def __new__(cls: typing.Type[HubSection]) -> HubSection:...

class HubSectionCollection(winrt.system.Object, typing.MutableSequence[HubSection]):
    size: winrt.system.UInt32
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> HubSection: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[HubSection]: ...
    def insert(self, index: int, value: HubSection) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: HubSection) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[HubSection]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HubSectionCollection: ...
    def append(self, value: typing.Optional[HubSection], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[HubSection]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[HubSection]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[HubSection], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[HubSection]]: ...
    def index_of(self, value: typing.Optional[HubSection], /) -> typing.Tuple[winrt.system.Boolean, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[HubSection], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[HubSection], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[HubSection], /) -> None: ...

class HubSectionHeaderClickEventArgs(winrt.system.Object):
    section: typing.Optional[HubSection]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HubSectionHeaderClickEventArgs: ...
    def __new__(cls: typing.Type[HubSectionHeaderClickEventArgs]) -> HubSectionHeaderClickEventArgs:...

class HyperlinkButton(winrt.system.Object):
    navigate_uri: typing.Optional[winrt.windows.foundation.Uri]
    navigate_uri_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HyperlinkButton: ...
    def __new__(cls: typing.Type[HyperlinkButton]) -> HyperlinkButton:...

class IconElement(winrt.system.Object):
    foreground: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    foreground_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IconElement: ...

class IconSource(winrt.system.Object):
    foreground: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    foreground_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IconSource: ...

class IconSourceElement(winrt.system.Object):
    icon_source: typing.Optional[IconSource]
    icon_source_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IconSourceElement: ...
    def __new__(cls: typing.Type[IconSourceElement]) -> IconSourceElement:...

class Image(winrt.system.Object):
    stretch: winrt.windows.ui.xaml.media.Stretch
    source: typing.Optional[winrt.windows.ui.xaml.media.ImageSource]
    nine_grid: winrt.windows.ui.xaml.Thickness
    play_to_source: typing.Optional[winrt.windows.media.playto.PlayToSource]
    nine_grid_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    play_to_source_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    source_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    stretch_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Image: ...
    def __new__(cls: typing.Type[Image]) -> Image:...
    def get_alpha_mask(self) -> typing.Optional[winrt.windows.ui.composition.CompositionBrush]: ...
    def get_as_casting_source(self) -> typing.Optional[winrt.windows.media.casting.CastingSource]: ...
    def add_image_failed(self, handler: typing.Optional[winrt.windows.ui.xaml.ExceptionRoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_image_failed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_image_opened(self, handler: typing.Optional[winrt.windows.ui.xaml.RoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_image_opened(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class InkCanvas(winrt.system.Object):
    ink_presenter: typing.Optional[winrt.windows.ui.input.inking.InkPresenter]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkCanvas: ...
    def __new__(cls: typing.Type[InkCanvas]) -> InkCanvas:...

class InkToolbar(winrt.system.Object):
    target_ink_canvas: typing.Optional[InkCanvas]
    is_ruler_button_checked: winrt.system.Boolean
    initial_controls: InkToolbarInitialControls
    active_tool: typing.Optional[InkToolbarToolButton]
    children: typing.Optional[winrt.windows.ui.xaml.DependencyObjectCollection]
    ink_drawing_attributes: typing.Optional[winrt.windows.ui.input.inking.InkDrawingAttributes]
    orientation: Orientation
    is_stencil_button_checked: winrt.system.Boolean
    button_flyout_placement: InkToolbarButtonFlyoutPlacement
    target_ink_presenter: typing.Optional[winrt.windows.ui.input.inking.InkPresenter]
    active_tool_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    children_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    initial_controls_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    ink_drawing_attributes_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_ruler_button_checked_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    target_ink_canvas_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    button_flyout_placement_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_stencil_button_checked_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    orientation_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    target_ink_presenter_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkToolbar: ...
    def __new__(cls: typing.Type[InkToolbar]) -> InkToolbar:...
    def get_menu_button(self, menu: InkToolbarMenuKind, /) -> typing.Optional[InkToolbarMenuButton]: ...
    def get_toggle_button(self, tool: InkToolbarToggle, /) -> typing.Optional[InkToolbarToggleButton]: ...
    def get_tool_button(self, tool: InkToolbarTool, /) -> typing.Optional[InkToolbarToolButton]: ...
    def add_active_tool_changed(self, handler: winrt.windows.foundation.TypedEventHandler[InkToolbar, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_active_tool_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_erase_all_clicked(self, handler: winrt.windows.foundation.TypedEventHandler[InkToolbar, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_erase_all_clicked(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_ink_drawing_attributes_changed(self, handler: winrt.windows.foundation.TypedEventHandler[InkToolbar, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_ink_drawing_attributes_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_is_ruler_button_checked_changed(self, handler: winrt.windows.foundation.TypedEventHandler[InkToolbar, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_is_ruler_button_checked_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_is_stencil_button_checked_changed(self, handler: winrt.windows.foundation.TypedEventHandler[InkToolbar, InkToolbarIsStencilButtonCheckedChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_is_stencil_button_checked_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class InkToolbarBallpointPenButton(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkToolbarBallpointPenButton: ...
    def __new__(cls: typing.Type[InkToolbarBallpointPenButton]) -> InkToolbarBallpointPenButton:...

class InkToolbarCustomPen(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkToolbarCustomPen: ...
    def create_ink_drawing_attributes(self, brush: typing.Optional[winrt.windows.ui.xaml.media.Brush], stroke_width: winrt.system.Double, /) -> typing.Optional[winrt.windows.ui.input.inking.InkDrawingAttributes]: ...
    def create_ink_drawing_attributes_core(self, brush: typing.Optional[winrt.windows.ui.xaml.media.Brush], stroke_width: winrt.system.Double, /) -> typing.Optional[winrt.windows.ui.input.inking.InkDrawingAttributes]: ...

class InkToolbarCustomPenButton(winrt.system.Object):
    custom_pen: typing.Optional[InkToolbarCustomPen]
    configuration_content: typing.Optional[winrt.windows.ui.xaml.UIElement]
    configuration_content_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    custom_pen_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkToolbarCustomPenButton: ...
    def __new__(cls: typing.Type[InkToolbarCustomPenButton]) -> InkToolbarCustomPenButton:...

class InkToolbarCustomToggleButton(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkToolbarCustomToggleButton: ...
    def __new__(cls: typing.Type[InkToolbarCustomToggleButton]) -> InkToolbarCustomToggleButton:...

class InkToolbarCustomToolButton(winrt.system.Object):
    configuration_content: typing.Optional[winrt.windows.ui.xaml.UIElement]
    configuration_content_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkToolbarCustomToolButton: ...
    def __new__(cls: typing.Type[InkToolbarCustomToolButton]) -> InkToolbarCustomToolButton:...

class InkToolbarEraserButton(winrt.system.Object):
    is_clear_all_visible: winrt.system.Boolean
    is_clear_all_visible_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkToolbarEraserButton: ...
    def __new__(cls: typing.Type[InkToolbarEraserButton]) -> InkToolbarEraserButton:...

class InkToolbarFlyoutItem(winrt.system.Object):
    kind: InkToolbarFlyoutItemKind
    is_checked: winrt.system.Boolean
    is_checked_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    kind_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkToolbarFlyoutItem: ...
    def __new__(cls: typing.Type[InkToolbarFlyoutItem]) -> InkToolbarFlyoutItem:...
    def add_checked(self, handler: winrt.windows.foundation.TypedEventHandler[InkToolbarFlyoutItem, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_checked(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_unchecked(self, handler: winrt.windows.foundation.TypedEventHandler[InkToolbarFlyoutItem, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_unchecked(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class InkToolbarHighlighterButton(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkToolbarHighlighterButton: ...
    def __new__(cls: typing.Type[InkToolbarHighlighterButton]) -> InkToolbarHighlighterButton:...

class InkToolbarIsStencilButtonCheckedChangedEventArgs(winrt.system.Object):
    stencil_button: typing.Optional[InkToolbarStencilButton]
    stencil_kind: InkToolbarStencilKind
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkToolbarIsStencilButtonCheckedChangedEventArgs: ...
    def __new__(cls: typing.Type[InkToolbarIsStencilButtonCheckedChangedEventArgs]) -> InkToolbarIsStencilButtonCheckedChangedEventArgs:...

class InkToolbarMenuButton(winrt.system.Object):
    is_extension_glyph_shown: winrt.system.Boolean
    menu_kind: InkToolbarMenuKind
    is_extension_glyph_shown_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkToolbarMenuButton: ...

class InkToolbarPenButton(winrt.system.Object):
    selected_stroke_width: winrt.system.Double
    selected_brush_index: winrt.system.Int32
    palette: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.ui.xaml.media.Brush]]
    min_stroke_width: winrt.system.Double
    max_stroke_width: winrt.system.Double
    selected_brush: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    max_stroke_width_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    min_stroke_width_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    palette_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    selected_brush_index_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    selected_brush_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    selected_stroke_width_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkToolbarPenButton: ...

class InkToolbarPenConfigurationControl(winrt.system.Object):
    pen_button: typing.Optional[InkToolbarPenButton]
    pen_button_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkToolbarPenConfigurationControl: ...
    def __new__(cls: typing.Type[InkToolbarPenConfigurationControl]) -> InkToolbarPenConfigurationControl:...

class InkToolbarPencilButton(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkToolbarPencilButton: ...
    def __new__(cls: typing.Type[InkToolbarPencilButton]) -> InkToolbarPencilButton:...

class InkToolbarRulerButton(winrt.system.Object):
    ruler: typing.Optional[winrt.windows.ui.input.inking.InkPresenterRuler]
    ruler_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkToolbarRulerButton: ...
    def __new__(cls: typing.Type[InkToolbarRulerButton]) -> InkToolbarRulerButton:...

class InkToolbarStencilButton(winrt.system.Object):
    selected_stencil: InkToolbarStencilKind
    is_ruler_item_visible: winrt.system.Boolean
    is_protractor_item_visible: winrt.system.Boolean
    protractor: typing.Optional[winrt.windows.ui.input.inking.InkPresenterProtractor]
    ruler: typing.Optional[winrt.windows.ui.input.inking.InkPresenterRuler]
    is_protractor_item_visible_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_ruler_item_visible_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    protractor_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    ruler_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    selected_stencil_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkToolbarStencilButton: ...
    def __new__(cls: typing.Type[InkToolbarStencilButton]) -> InkToolbarStencilButton:...

class InkToolbarToggleButton(winrt.system.Object):
    toggle_kind: InkToolbarToggle
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkToolbarToggleButton: ...

class InkToolbarToolButton(winrt.system.Object):
    is_extension_glyph_shown: winrt.system.Boolean
    tool_kind: InkToolbarTool
    is_extension_glyph_shown_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InkToolbarToolButton: ...

class IsTextTrimmedChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IsTextTrimmedChangedEventArgs: ...

class ItemClickEventArgs(winrt.system.Object):
    clicked_item: typing.Optional[winrt.system.Object]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ItemClickEventArgs: ...
    def __new__(cls: typing.Type[ItemClickEventArgs]) -> ItemClickEventArgs:...

class ItemCollection(winrt.system.Object, typing.MutableSequence[winrt.system.Object]):
    size: winrt.system.UInt32
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> winrt.system.Object: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[winrt.system.Object]: ...
    def insert(self, index: int, value: winrt.system.Object) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: winrt.system.Object) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[winrt.system.Object]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ItemCollection: ...
    def append(self, value: typing.Optional[winrt.system.Object], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[winrt.system.Object]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[winrt.system.Object]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[winrt.system.Object], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Object]]: ...
    def index_of(self, value: typing.Optional[winrt.system.Object], /) -> typing.Tuple[winrt.system.Boolean, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[winrt.system.Object], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[winrt.system.Object], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[winrt.system.Object], /) -> None: ...
    def add_vector_changed(self, vhnd: winrt.windows.foundation.collections.VectorChangedEventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_vector_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class ItemContainerGenerator(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ItemContainerGenerator: ...
    def container_from_index(self, index: winrt.system.Int32, /) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    def container_from_item(self, item: typing.Optional[winrt.system.Object], /) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    def generate_next(self) -> typing.Tuple[typing.Optional[winrt.windows.ui.xaml.DependencyObject], winrt.system.Boolean]: ...
    def generator_position_from_index(self, item_index: winrt.system.Int32, /) -> winrt.windows.ui.xaml.controls.primitives.GeneratorPosition: ...
    def get_item_container_generator_for_panel(self, panel: typing.Optional[Panel], /) -> typing.Optional[ItemContainerGenerator]: ...
    def index_from_container(self, container: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> winrt.system.Int32: ...
    def index_from_generator_position(self, position: winrt.windows.ui.xaml.controls.primitives.GeneratorPosition, /) -> winrt.system.Int32: ...
    def item_from_container(self, container: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> typing.Optional[winrt.system.Object]: ...
    def prepare_item_container(self, container: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> None: ...
    def recycle(self, position: winrt.windows.ui.xaml.controls.primitives.GeneratorPosition, count: winrt.system.Int32, /) -> None: ...
    def remove(self, position: winrt.windows.ui.xaml.controls.primitives.GeneratorPosition, count: winrt.system.Int32, /) -> None: ...
    def remove_all(self) -> None: ...
    def start_at(self, position: winrt.windows.ui.xaml.controls.primitives.GeneratorPosition, direction: winrt.windows.ui.xaml.controls.primitives.GeneratorDirection, allow_start_at_realized_item: winrt.system.Boolean, /) -> None: ...
    def stop(self) -> None: ...
    def add_items_changed(self, handler: typing.Optional[winrt.windows.ui.xaml.controls.primitives.ItemsChangedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_items_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class ItemsControl(winrt.system.Object):
    items_source: typing.Optional[winrt.system.Object]
    items_panel: typing.Optional[ItemsPanelTemplate]
    item_template_selector: typing.Optional[DataTemplateSelector]
    item_template: typing.Optional[winrt.windows.ui.xaml.DataTemplate]
    item_container_transitions: typing.Optional[winrt.windows.ui.xaml.media.animation.TransitionCollection]
    item_container_style_selector: typing.Optional[StyleSelector]
    item_container_style: typing.Optional[winrt.windows.ui.xaml.Style]
    group_style_selector: typing.Optional[GroupStyleSelector]
    display_member_path: str
    group_style: typing.Optional[winrt.windows.foundation.collections.IObservableVector[GroupStyle]]
    is_grouping: winrt.system.Boolean
    item_container_generator: typing.Optional[ItemContainerGenerator]
    items: typing.Optional[ItemCollection]
    items_panel_root: typing.Optional[Panel]
    display_member_path_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    group_style_selector_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_grouping_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    item_container_style_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    item_container_style_selector_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    item_container_transitions_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    item_template_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    item_template_selector_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    items_panel_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    items_source_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ItemsControl: ...
    def __new__(cls: typing.Type[ItemsControl]) -> ItemsControl:...
    def clear_container_for_item_override(self, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], item: typing.Optional[winrt.system.Object], /) -> None: ...
    def container_from_index(self, index: winrt.system.Int32, /) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    def container_from_item(self, item: typing.Optional[winrt.system.Object], /) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    def get_container_for_item_override(self) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    @staticmethod
    def get_items_owner(element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> typing.Optional[ItemsControl]: ...
    def group_header_container_from_item_container(self, item_container: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    def index_from_container(self, container: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> winrt.system.Int32: ...
    def is_item_its_own_container_override(self, item: typing.Optional[winrt.system.Object], /) -> winrt.system.Boolean: ...
    def item_from_container(self, container: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> typing.Optional[winrt.system.Object]: ...
    @staticmethod
    def items_control_from_item_container(container: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> typing.Optional[ItemsControl]: ...
    def on_group_style_selector_changed(self, old_group_style_selector: typing.Optional[GroupStyleSelector], new_group_style_selector: typing.Optional[GroupStyleSelector], /) -> None: ...
    def on_item_container_style_changed(self, old_item_container_style: typing.Optional[winrt.windows.ui.xaml.Style], new_item_container_style: typing.Optional[winrt.windows.ui.xaml.Style], /) -> None: ...
    def on_item_container_style_selector_changed(self, old_item_container_style_selector: typing.Optional[StyleSelector], new_item_container_style_selector: typing.Optional[StyleSelector], /) -> None: ...
    def on_item_template_changed(self, old_item_template: typing.Optional[winrt.windows.ui.xaml.DataTemplate], new_item_template: typing.Optional[winrt.windows.ui.xaml.DataTemplate], /) -> None: ...
    def on_item_template_selector_changed(self, old_item_template_selector: typing.Optional[DataTemplateSelector], new_item_template_selector: typing.Optional[DataTemplateSelector], /) -> None: ...
    def on_items_changed(self, e: typing.Optional[winrt.system.Object], /) -> None: ...
    def prepare_container_for_item_override(self, element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], item: typing.Optional[winrt.system.Object], /) -> None: ...

class ItemsPanelTemplate(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ItemsPanelTemplate: ...
    def __new__(cls: typing.Type[ItemsPanelTemplate]) -> ItemsPanelTemplate:...

class ItemsPickedEventArgs(winrt.system.Object):
    added_items: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.system.Object]]
    removed_items: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.system.Object]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ItemsPickedEventArgs: ...
    def __new__(cls: typing.Type[ItemsPickedEventArgs]) -> ItemsPickedEventArgs:...

class ItemsPresenter(winrt.system.Object):
    padding: winrt.windows.ui.xaml.Thickness
    header_transitions: typing.Optional[winrt.windows.ui.xaml.media.animation.TransitionCollection]
    header_template: typing.Optional[winrt.windows.ui.xaml.DataTemplate]
    header: typing.Optional[winrt.system.Object]
    footer_transitions: typing.Optional[winrt.windows.ui.xaml.media.animation.TransitionCollection]
    footer_template: typing.Optional[winrt.windows.ui.xaml.DataTemplate]
    footer: typing.Optional[winrt.system.Object]
    are_horizontal_snap_points_regular: winrt.system.Boolean
    are_vertical_snap_points_regular: winrt.system.Boolean
    header_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    header_template_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    header_transitions_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    padding_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    footer_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    footer_template_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    footer_transitions_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ItemsPresenter: ...
    def __new__(cls: typing.Type[ItemsPresenter]) -> ItemsPresenter:...
    def get_irregular_snap_points(self, orientation: Orientation, alignment: winrt.windows.ui.xaml.controls.primitives.SnapPointsAlignment, /) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Single]]: ...
    def get_regular_snap_points(self, orientation: Orientation, alignment: winrt.windows.ui.xaml.controls.primitives.SnapPointsAlignment, /) -> typing.Tuple[winrt.system.Single, winrt.system.Single]: ...
    def add_horizontal_snap_points_changed(self, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_horizontal_snap_points_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_vertical_snap_points_changed(self, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_vertical_snap_points_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class ItemsStackPanel(winrt.system.Object):
    orientation: Orientation
    items_updating_scroll_mode: ItemsUpdatingScrollMode
    group_padding: winrt.windows.ui.xaml.Thickness
    group_header_placement: winrt.windows.ui.xaml.controls.primitives.GroupHeaderPlacement
    cache_length: winrt.system.Double
    first_cache_index: winrt.system.Int32
    first_visible_index: winrt.system.Int32
    last_cache_index: winrt.system.Int32
    last_visible_index: winrt.system.Int32
    scrolling_direction: PanelScrollingDirection
    are_sticky_group_headers_enabled: winrt.system.Boolean
    cache_length_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    group_header_placement_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    group_padding_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    orientation_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    are_sticky_group_headers_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ItemsStackPanel: ...
    def __new__(cls: typing.Type[ItemsStackPanel]) -> ItemsStackPanel:...

class ItemsWrapGrid(winrt.system.Object):
    orientation: Orientation
    maximum_rows_or_columns: winrt.system.Int32
    item_width: winrt.system.Double
    item_height: winrt.system.Double
    group_padding: winrt.windows.ui.xaml.Thickness
    group_header_placement: winrt.windows.ui.xaml.controls.primitives.GroupHeaderPlacement
    cache_length: winrt.system.Double
    first_cache_index: winrt.system.Int32
    first_visible_index: winrt.system.Int32
    last_cache_index: winrt.system.Int32
    last_visible_index: winrt.system.Int32
    scrolling_direction: PanelScrollingDirection
    are_sticky_group_headers_enabled: winrt.system.Boolean
    cache_length_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    group_header_placement_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    group_padding_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    item_height_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    item_width_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    maximum_rows_or_columns_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    orientation_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    are_sticky_group_headers_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ItemsWrapGrid: ...
    def __new__(cls: typing.Type[ItemsWrapGrid]) -> ItemsWrapGrid:...

class ListBox(winrt.system.Object):
    selection_mode: SelectionMode
    selected_items: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.system.Object]]
    single_selection_follows_focus: winrt.system.Boolean
    selection_mode_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    single_selection_follows_focus_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ListBox: ...
    def __new__(cls: typing.Type[ListBox]) -> ListBox:...
    def scroll_into_view(self, item: typing.Optional[winrt.system.Object], /) -> None: ...
    def select_all(self) -> None: ...

class ListBoxItem(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ListBoxItem: ...
    def __new__(cls: typing.Type[ListBoxItem]) -> ListBoxItem:...

class ListPickerFlyout(winrt.system.Object):
    selection_mode: ListPickerFlyoutSelectionMode
    selected_value_path: str
    selected_value: typing.Optional[winrt.system.Object]
    selected_item: typing.Optional[winrt.system.Object]
    selected_index: winrt.system.Int32
    items_source: typing.Optional[winrt.system.Object]
    item_template: typing.Optional[winrt.windows.ui.xaml.DataTemplate]
    display_member_path: str
    selected_items: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.system.Object]]
    display_member_path_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    item_template_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    items_source_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    selected_index_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    selected_item_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    selected_value_path_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    selected_value_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    selection_mode_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ListPickerFlyout: ...
    def __new__(cls: typing.Type[ListPickerFlyout]) -> ListPickerFlyout:...
    def show_at_async(self, target: typing.Optional[winrt.windows.ui.xaml.FrameworkElement], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[winrt.system.Object]]: ...
    def add_items_picked(self, handler: winrt.windows.foundation.TypedEventHandler[ListPickerFlyout, ItemsPickedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_items_picked(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class ListPickerFlyoutPresenter(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ListPickerFlyoutPresenter: ...

class ListView(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ListView: ...
    def __new__(cls: typing.Type[ListView]) -> ListView:...

class ListViewBase(winrt.system.Object):
    selection_mode: ListViewSelectionMode
    is_swipe_enabled: winrt.system.Boolean
    is_item_click_enabled: winrt.system.Boolean
    incremental_loading_trigger: IncrementalLoadingTrigger
    incremental_loading_threshold: winrt.system.Double
    header_transitions: typing.Optional[winrt.windows.ui.xaml.media.animation.TransitionCollection]
    header_template: typing.Optional[winrt.windows.ui.xaml.DataTemplate]
    header: typing.Optional[winrt.system.Object]
    data_fetch_size: winrt.system.Double
    can_reorder_items: winrt.system.Boolean
    can_drag_items: winrt.system.Boolean
    selected_items: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.system.Object]]
    shows_scrolling_placeholders: winrt.system.Boolean
    footer_transitions: typing.Optional[winrt.windows.ui.xaml.media.animation.TransitionCollection]
    footer_template: typing.Optional[winrt.windows.ui.xaml.DataTemplate]
    footer: typing.Optional[winrt.system.Object]
    reorder_mode: ListViewReorderMode
    is_multi_select_check_box_enabled: winrt.system.Boolean
    selected_ranges: typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.ui.xaml.data.ItemIndexRange]]
    single_selection_follows_focus: winrt.system.Boolean
    semantic_zoom_owner: typing.Optional[SemanticZoom]
    is_zoomed_in_view: winrt.system.Boolean
    is_active_view: winrt.system.Boolean
    can_drag_items_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    can_reorder_items_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    data_fetch_size_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    header_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    header_template_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    header_transitions_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    incremental_loading_threshold_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    incremental_loading_trigger_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_active_view_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_item_click_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_swipe_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_zoomed_in_view_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    selection_mode_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    semantic_zoom_owner_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    footer_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    footer_template_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    footer_transitions_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    shows_scrolling_placeholders_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    reorder_mode_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_multi_select_check_box_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    single_selection_follows_focus_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ListViewBase: ...
    def complete_view_change(self) -> None: ...
    def complete_view_change_from(self, source: typing.Optional[SemanticZoomLocation], destination: typing.Optional[SemanticZoomLocation], /) -> None: ...
    def complete_view_change_to(self, source: typing.Optional[SemanticZoomLocation], destination: typing.Optional[SemanticZoomLocation], /) -> None: ...
    def deselect_range(self, item_index_range: typing.Optional[winrt.windows.ui.xaml.data.ItemIndexRange], /) -> None: ...
    def initialize_view_change(self) -> None: ...
    def is_drag_source(self) -> winrt.system.Boolean: ...
    def load_more_items_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.ui.xaml.data.LoadMoreItemsResult]: ...
    def make_visible(self, item: typing.Optional[SemanticZoomLocation], /) -> None: ...
    def prepare_connected_animation(self, key: str, item: typing.Optional[winrt.system.Object], element_name: str, /) -> typing.Optional[winrt.windows.ui.xaml.media.animation.ConnectedAnimation]: ...
    @typing.overload
    def scroll_into_view(self, item: typing.Optional[winrt.system.Object], /) -> None: ...
    @typing.overload
    def scroll_into_view(self, item: typing.Optional[winrt.system.Object], alignment: ScrollIntoViewAlignment, /) -> None: ...
    def select_all(self) -> None: ...
    def select_range(self, item_index_range: typing.Optional[winrt.windows.ui.xaml.data.ItemIndexRange], /) -> None: ...
    def set_desired_container_update_duration(self, duration: datetime.timedelta, /) -> None: ...
    def start_view_change_from(self, source: typing.Optional[SemanticZoomLocation], destination: typing.Optional[SemanticZoomLocation], /) -> None: ...
    def start_view_change_to(self, source: typing.Optional[SemanticZoomLocation], destination: typing.Optional[SemanticZoomLocation], /) -> None: ...
    def try_start_connected_animation_async(self, animation: typing.Optional[winrt.windows.ui.xaml.media.animation.ConnectedAnimation], item: typing.Optional[winrt.system.Object], element_name: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...
    def add_drag_items_starting(self, handler: typing.Optional[DragItemsStartingEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_drag_items_starting(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_item_click(self, handler: typing.Optional[ItemClickEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_item_click(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_container_content_changing(self, handler: winrt.windows.foundation.TypedEventHandler[ListViewBase, ContainerContentChangingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_container_content_changing(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_choosing_group_header_container(self, handler: winrt.windows.foundation.TypedEventHandler[ListViewBase, ChoosingGroupHeaderContainerEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_choosing_group_header_container(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_choosing_item_container(self, handler: winrt.windows.foundation.TypedEventHandler[ListViewBase, ChoosingItemContainerEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_choosing_item_container(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_drag_items_completed(self, handler: winrt.windows.foundation.TypedEventHandler[ListViewBase, DragItemsCompletedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_drag_items_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class ListViewBaseHeaderItem(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ListViewBaseHeaderItem: ...

class ListViewHeaderItem(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ListViewHeaderItem: ...
    def __new__(cls: typing.Type[ListViewHeaderItem]) -> ListViewHeaderItem:...

class ListViewItem(winrt.system.Object):
    template_settings: typing.Optional[winrt.windows.ui.xaml.controls.primitives.ListViewItemTemplateSettings]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ListViewItem: ...
    def __new__(cls: typing.Type[ListViewItem]) -> ListViewItem:...

class ListViewPersistenceHelper(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ListViewPersistenceHelper: ...
    @staticmethod
    def get_relative_scroll_position(list_view_base: typing.Optional[ListViewBase], item_to_key_handler: typing.Optional[ListViewItemToKeyHandler], /) -> str: ...
    @staticmethod
    def set_relative_scroll_position_async(list_view_base: typing.Optional[ListViewBase], relative_scroll_position: str, key_to_item_handler: typing.Optional[ListViewKeyToItemHandler], /) -> winrt.windows.foundation.IAsyncAction: ...

class MediaElement(winrt.system.Object):
    volume: winrt.system.Double
    stereo3_d_video_render_mode: winrt.windows.ui.xaml.media.Stereo3DVideoRenderMode
    stereo3_d_video_packing_mode: winrt.windows.ui.xaml.media.Stereo3DVideoPackingMode
    source: typing.Optional[winrt.windows.foundation.Uri]
    real_time_playback: winrt.system.Boolean
    protection_manager: typing.Optional[winrt.windows.media.protection.MediaProtectionManager]
    poster_source: typing.Optional[winrt.windows.ui.xaml.media.ImageSource]
    position: datetime.timedelta
    playback_rate: winrt.system.Double
    auto_play: winrt.system.Boolean
    audio_stream_index: typing.Optional[typing.Optional[winrt.system.Int32]]
    is_muted: winrt.system.Boolean
    audio_device_type: winrt.windows.ui.xaml.media.AudioDeviceType
    audio_category: winrt.windows.ui.xaml.media.AudioCategory
    default_playback_rate: winrt.system.Double
    is_looping: winrt.system.Boolean
    balance: winrt.system.Double
    download_progress_offset: winrt.system.Double
    is_audio_only: winrt.system.Boolean
    is_stereo3_d_video: winrt.system.Boolean
    markers: typing.Optional[winrt.windows.ui.xaml.media.TimelineMarkerCollection]
    natural_duration: winrt.windows.ui.xaml.Duration
    natural_video_height: winrt.system.Int32
    natural_video_width: winrt.system.Int32
    play_to_source: typing.Optional[winrt.windows.media.playto.PlayToSource]
    actual_stereo3_d_video_packing_mode: winrt.windows.ui.xaml.media.Stereo3DVideoPackingMode
    aspect_ratio_height: winrt.system.Int32
    aspect_ratio_width: winrt.system.Int32
    audio_stream_count: winrt.system.Int32
    buffering_progress: winrt.system.Double
    can_pause: winrt.system.Boolean
    can_seek: winrt.system.Boolean
    current_state: winrt.windows.ui.xaml.media.MediaElementState
    download_progress: winrt.system.Double
    stretch: winrt.windows.ui.xaml.media.Stretch
    play_to_preferred_source_uri: typing.Optional[winrt.windows.foundation.Uri]
    is_full_window: winrt.system.Boolean
    are_transport_controls_enabled: winrt.system.Boolean
    transport_controls: typing.Optional[MediaTransportControls]
    download_progress_offset_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    source_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    stereo3_d_video_packing_mode_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    stereo3_d_video_render_mode_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    actual_stereo3_d_video_packing_mode_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    aspect_ratio_height_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    aspect_ratio_width_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    audio_category_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    audio_device_type_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    audio_stream_count_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    audio_stream_index_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    auto_play_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    balance_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    buffering_progress_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    can_pause_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    can_seek_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    current_state_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    default_playback_rate_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    volume_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    download_progress_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_audio_only_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_looping_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_muted_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_stereo3_d_video_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    natural_duration_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    natural_video_height_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    natural_video_width_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    play_to_source_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    playback_rate_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    position_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    poster_source_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    protection_manager_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    real_time_playback_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_full_window_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    play_to_preferred_source_uri_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    stretch_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    are_transport_controls_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaElement: ...
    def __new__(cls: typing.Type[MediaElement]) -> MediaElement:...
    def add_audio_effect(self, effect_i_d: str, effect_optional: winrt.system.Boolean, effect_configuration: typing.Optional[winrt.windows.foundation.collections.IPropertySet], /) -> None: ...
    def add_video_effect(self, effect_i_d: str, effect_optional: winrt.system.Boolean, effect_configuration: typing.Optional[winrt.windows.foundation.collections.IPropertySet], /) -> None: ...
    def can_play_type(self, type: str, /) -> winrt.windows.ui.xaml.media.MediaCanPlayResponse: ...
    def get_as_casting_source(self) -> typing.Optional[winrt.windows.media.casting.CastingSource]: ...
    def get_audio_stream_language(self, index: typing.Optional[winrt.system.Int32], /) -> str: ...
    def pause(self) -> None: ...
    def play(self) -> None: ...
    def remove_all_effects(self) -> None: ...
    def set_media_stream_source(self, source: typing.Optional[winrt.windows.media.core.IMediaSource], /) -> None: ...
    def set_playback_source(self, source: typing.Optional[winrt.windows.media.playback.IMediaPlaybackSource], /) -> None: ...
    def set_source(self, stream: typing.Optional[winrt.windows.storage.streams.IRandomAccessStream], mime_type: str, /) -> None: ...
    def stop(self) -> None: ...
    def add_buffering_progress_changed(self, handler: typing.Optional[winrt.windows.ui.xaml.RoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_buffering_progress_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_current_state_changed(self, handler: typing.Optional[winrt.windows.ui.xaml.RoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_current_state_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_download_progress_changed(self, handler: typing.Optional[winrt.windows.ui.xaml.RoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_download_progress_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_marker_reached(self, handler: typing.Optional[winrt.windows.ui.xaml.media.TimelineMarkerRoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_marker_reached(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_media_ended(self, handler: typing.Optional[winrt.windows.ui.xaml.RoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_media_ended(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_media_failed(self, handler: typing.Optional[winrt.windows.ui.xaml.ExceptionRoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_media_failed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_media_opened(self, handler: typing.Optional[winrt.windows.ui.xaml.RoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_media_opened(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_rate_changed(self, handler: typing.Optional[winrt.windows.ui.xaml.media.RateChangedRoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_rate_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_seek_completed(self, handler: typing.Optional[winrt.windows.ui.xaml.RoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_seek_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_volume_changed(self, handler: typing.Optional[winrt.windows.ui.xaml.RoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_volume_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_partial_media_failure_detected(self, handler: winrt.windows.foundation.TypedEventHandler[MediaElement, winrt.windows.ui.xaml.media.PartialMediaFailureDetectedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_partial_media_failure_detected(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class MediaPlayerElement(winrt.system.Object):
    transport_controls: typing.Optional[MediaTransportControls]
    stretch: winrt.windows.ui.xaml.media.Stretch
    source: typing.Optional[winrt.windows.media.playback.IMediaPlaybackSource]
    poster_source: typing.Optional[winrt.windows.ui.xaml.media.ImageSource]
    is_full_window: winrt.system.Boolean
    auto_play: winrt.system.Boolean
    are_transport_controls_enabled: winrt.system.Boolean
    media_player: typing.Optional[winrt.windows.media.playback.MediaPlayer]
    are_transport_controls_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    auto_play_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_full_window_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    media_player_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    poster_source_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    source_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    stretch_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaPlayerElement: ...
    def __new__(cls: typing.Type[MediaPlayerElement]) -> MediaPlayerElement:...
    def set_media_player(self, media_player: typing.Optional[winrt.windows.media.playback.MediaPlayer], /) -> None: ...

class MediaPlayerPresenter(winrt.system.Object):
    stretch: winrt.windows.ui.xaml.media.Stretch
    media_player: typing.Optional[winrt.windows.media.playback.MediaPlayer]
    is_full_window: winrt.system.Boolean
    is_full_window_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    media_player_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    stretch_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaPlayerPresenter: ...
    def __new__(cls: typing.Type[MediaPlayerPresenter]) -> MediaPlayerPresenter:...

class MediaTransportControls(winrt.system.Object):
    is_zoom_enabled: winrt.system.Boolean
    is_zoom_button_visible: winrt.system.Boolean
    is_volume_enabled: winrt.system.Boolean
    is_volume_button_visible: winrt.system.Boolean
    is_stop_enabled: winrt.system.Boolean
    is_stop_button_visible: winrt.system.Boolean
    is_seek_enabled: winrt.system.Boolean
    is_seek_bar_visible: winrt.system.Boolean
    is_playback_rate_enabled: winrt.system.Boolean
    is_playback_rate_button_visible: winrt.system.Boolean
    is_full_window_enabled: winrt.system.Boolean
    is_full_window_button_visible: winrt.system.Boolean
    is_fast_rewind_enabled: winrt.system.Boolean
    is_fast_rewind_button_visible: winrt.system.Boolean
    is_fast_forward_enabled: winrt.system.Boolean
    is_fast_forward_button_visible: winrt.system.Boolean
    is_compact: winrt.system.Boolean
    is_skip_forward_enabled: winrt.system.Boolean
    is_skip_forward_button_visible: winrt.system.Boolean
    is_skip_backward_enabled: winrt.system.Boolean
    is_skip_backward_button_visible: winrt.system.Boolean
    is_previous_track_button_visible: winrt.system.Boolean
    is_next_track_button_visible: winrt.system.Boolean
    fast_play_fallback_behaviour: winrt.windows.ui.xaml.media.FastPlayFallbackBehaviour
    show_and_hide_automatically: winrt.system.Boolean
    is_repeat_enabled: winrt.system.Boolean
    is_repeat_button_visible: winrt.system.Boolean
    is_compact_overlay_enabled: winrt.system.Boolean
    is_compact_overlay_button_visible: winrt.system.Boolean
    is_compact_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_fast_forward_button_visible_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_fast_forward_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_fast_rewind_button_visible_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_fast_rewind_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_full_window_button_visible_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_full_window_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_playback_rate_button_visible_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_playback_rate_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_seek_bar_visible_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_seek_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_stop_button_visible_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_stop_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_volume_button_visible_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_volume_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_zoom_button_visible_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_zoom_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    fast_play_fallback_behaviour_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_next_track_button_visible_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_previous_track_button_visible_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_skip_backward_button_visible_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_skip_backward_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_skip_forward_button_visible_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_skip_forward_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_repeat_button_visible_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_repeat_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    show_and_hide_automatically_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_compact_overlay_button_visible_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_compact_overlay_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaTransportControls: ...
    def __new__(cls: typing.Type[MediaTransportControls]) -> MediaTransportControls:...
    def hide(self) -> None: ...
    def show(self) -> None: ...
    def add_thumbnail_requested(self, handler: winrt.windows.foundation.TypedEventHandler[MediaTransportControls, winrt.windows.ui.xaml.media.MediaTransportControlsThumbnailRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_thumbnail_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class MediaTransportControlsHelper(winrt.system.Object):
    dropout_order_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaTransportControlsHelper: ...
    @staticmethod
    def get_dropout_order(element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> typing.Optional[typing.Optional[winrt.system.Int32]]: ...
    @staticmethod
    def set_dropout_order(element: typing.Optional[winrt.windows.ui.xaml.UIElement], value: typing.Optional[winrt.system.Int32], /) -> None: ...

class MenuBar(winrt.system.Object):
    items: typing.Optional[winrt.windows.foundation.collections.IVector[MenuBarItem]]
    items_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MenuBar: ...
    def __new__(cls: typing.Type[MenuBar]) -> MenuBar:...

class MenuBarItem(winrt.system.Object):
    title: str
    items: typing.Optional[winrt.windows.foundation.collections.IVector[MenuFlyoutItemBase]]
    items_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    title_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MenuBarItem: ...
    def __new__(cls: typing.Type[MenuBarItem]) -> MenuBarItem:...

class MenuBarItemFlyout(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MenuBarItemFlyout: ...
    def __new__(cls: typing.Type[MenuBarItemFlyout]) -> MenuBarItemFlyout:...

class MenuFlyout(winrt.system.Object):
    menu_flyout_presenter_style: typing.Optional[winrt.windows.ui.xaml.Style]
    items: typing.Optional[winrt.windows.foundation.collections.IVector[MenuFlyoutItemBase]]
    menu_flyout_presenter_style_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MenuFlyout: ...
    def __new__(cls: typing.Type[MenuFlyout]) -> MenuFlyout:...
    def show_at(self, target_element: typing.Optional[winrt.windows.ui.xaml.UIElement], point: winrt.windows.foundation.Point, /) -> None: ...

class MenuFlyoutItem(winrt.system.Object):
    text: str
    command_parameter: typing.Optional[winrt.system.Object]
    command: typing.Optional[winrt.windows.ui.xaml.input.ICommand]
    icon: typing.Optional[IconElement]
    keyboard_accelerator_text_override: str
    template_settings: typing.Optional[winrt.windows.ui.xaml.controls.primitives.MenuFlyoutItemTemplateSettings]
    command_parameter_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    command_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    text_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    icon_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    keyboard_accelerator_text_override_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MenuFlyoutItem: ...
    def __new__(cls: typing.Type[MenuFlyoutItem]) -> MenuFlyoutItem:...
    def add_click(self, handler: typing.Optional[winrt.windows.ui.xaml.RoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_click(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class MenuFlyoutItemBase(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MenuFlyoutItemBase: ...

class MenuFlyoutPresenter(winrt.system.Object):
    template_settings: typing.Optional[winrt.windows.ui.xaml.controls.primitives.MenuFlyoutPresenterTemplateSettings]
    is_default_shadow_enabled: winrt.system.Boolean
    is_default_shadow_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MenuFlyoutPresenter: ...
    def __new__(cls: typing.Type[MenuFlyoutPresenter]) -> MenuFlyoutPresenter:...

class MenuFlyoutSeparator(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MenuFlyoutSeparator: ...
    def __new__(cls: typing.Type[MenuFlyoutSeparator]) -> MenuFlyoutSeparator:...

class MenuFlyoutSubItem(winrt.system.Object):
    text: str
    items: typing.Optional[winrt.windows.foundation.collections.IVector[MenuFlyoutItemBase]]
    icon: typing.Optional[IconElement]
    text_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    icon_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MenuFlyoutSubItem: ...
    def __new__(cls: typing.Type[MenuFlyoutSubItem]) -> MenuFlyoutSubItem:...

class NavigationView(winrt.system.Object):
    menu_item_template_selector: typing.Optional[DataTemplateSelector]
    menu_item_template: typing.Optional[winrt.windows.ui.xaml.DataTemplate]
    menu_item_container_style_selector: typing.Optional[StyleSelector]
    menu_item_container_style: typing.Optional[winrt.windows.ui.xaml.Style]
    is_settings_visible: winrt.system.Boolean
    is_pane_toggle_button_visible: winrt.system.Boolean
    is_pane_open: winrt.system.Boolean
    header_template: typing.Optional[winrt.windows.ui.xaml.DataTemplate]
    header: typing.Optional[winrt.system.Object]
    expanded_mode_threshold_width: winrt.system.Double
    menu_items_source: typing.Optional[winrt.system.Object]
    compact_pane_length: winrt.system.Double
    compact_mode_threshold_width: winrt.system.Double
    auto_suggest_box: typing.Optional[AutoSuggestBox]
    open_pane_length: winrt.system.Double
    always_show_header: winrt.system.Boolean
    selected_item: typing.Optional[winrt.system.Object]
    pane_toggle_button_style: typing.Optional[winrt.windows.ui.xaml.Style]
    pane_footer: typing.Optional[winrt.windows.ui.xaml.UIElement]
    display_mode: NavigationViewDisplayMode
    menu_items: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.system.Object]]
    settings_item: typing.Optional[winrt.system.Object]
    pane_title: str
    is_back_enabled: winrt.system.Boolean
    is_back_button_visible: NavigationViewBackButtonVisible
    shoulder_navigation_enabled: NavigationViewShoulderNavigationEnabled
    selection_follows_focus: NavigationViewSelectionFollowsFocus
    pane_header: typing.Optional[winrt.windows.ui.xaml.UIElement]
    pane_display_mode: NavigationViewPaneDisplayMode
    pane_custom_content: typing.Optional[winrt.windows.ui.xaml.UIElement]
    overflow_label_mode: NavigationViewOverflowLabelMode
    is_pane_visible: winrt.system.Boolean
    content_overlay: typing.Optional[winrt.windows.ui.xaml.UIElement]
    template_settings: typing.Optional[NavigationViewTemplateSettings]
    expanded_mode_threshold_width_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_settings_visible_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    menu_item_container_style_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    menu_item_container_style_selector_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    menu_item_template_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    menu_item_template_selector_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    menu_items_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    menu_items_source_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    open_pane_length_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    pane_footer_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    pane_toggle_button_style_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    selected_item_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    always_show_header_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    auto_suggest_box_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    compact_mode_threshold_width_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    compact_pane_length_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    display_mode_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    settings_item_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    header_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    header_template_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_pane_open_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_pane_toggle_button_visible_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_back_button_visible_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_back_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    pane_title_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_pane_visible_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    overflow_label_mode_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    pane_custom_content_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    pane_display_mode_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    pane_header_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    selection_follows_focus_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    shoulder_navigation_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    template_settings_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    content_overlay_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NavigationView: ...
    def __new__(cls: typing.Type[NavigationView]) -> NavigationView:...
    def container_from_menu_item(self, item: typing.Optional[winrt.system.Object], /) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    def menu_item_from_container(self, container: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> typing.Optional[winrt.system.Object]: ...
    def add_display_mode_changed(self, handler: winrt.windows.foundation.TypedEventHandler[NavigationView, NavigationViewDisplayModeChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_display_mode_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_item_invoked(self, handler: winrt.windows.foundation.TypedEventHandler[NavigationView, NavigationViewItemInvokedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_item_invoked(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_selection_changed(self, handler: winrt.windows.foundation.TypedEventHandler[NavigationView, NavigationViewSelectionChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_selection_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_back_requested(self, handler: winrt.windows.foundation.TypedEventHandler[NavigationView, NavigationViewBackRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_back_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_pane_closed(self, handler: winrt.windows.foundation.TypedEventHandler[NavigationView, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_pane_closed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_pane_closing(self, handler: winrt.windows.foundation.TypedEventHandler[NavigationView, NavigationViewPaneClosingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_pane_closing(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_pane_opened(self, handler: winrt.windows.foundation.TypedEventHandler[NavigationView, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_pane_opened(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_pane_opening(self, handler: winrt.windows.foundation.TypedEventHandler[NavigationView, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_pane_opening(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class NavigationViewBackRequestedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NavigationViewBackRequestedEventArgs: ...

class NavigationViewDisplayModeChangedEventArgs(winrt.system.Object):
    display_mode: NavigationViewDisplayMode
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NavigationViewDisplayModeChangedEventArgs: ...

class NavigationViewItem(winrt.system.Object):
    icon: typing.Optional[IconElement]
    compact_pane_length: winrt.system.Double
    selects_on_invoked: winrt.system.Boolean
    compact_pane_length_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    icon_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    selects_on_invoked_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NavigationViewItem: ...
    def __new__(cls: typing.Type[NavigationViewItem]) -> NavigationViewItem:...

class NavigationViewItemBase(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NavigationViewItemBase: ...

class NavigationViewItemHeader(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NavigationViewItemHeader: ...
    def __new__(cls: typing.Type[NavigationViewItemHeader]) -> NavigationViewItemHeader:...

class NavigationViewItemInvokedEventArgs(winrt.system.Object):
    invoked_item: typing.Optional[winrt.system.Object]
    is_settings_invoked: winrt.system.Boolean
    invoked_item_container: typing.Optional[NavigationViewItemBase]
    recommended_navigation_transition_info: typing.Optional[winrt.windows.ui.xaml.media.animation.NavigationTransitionInfo]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NavigationViewItemInvokedEventArgs: ...
    def __new__(cls: typing.Type[NavigationViewItemInvokedEventArgs]) -> NavigationViewItemInvokedEventArgs:...

class NavigationViewItemSeparator(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NavigationViewItemSeparator: ...
    def __new__(cls: typing.Type[NavigationViewItemSeparator]) -> NavigationViewItemSeparator:...

class NavigationViewList(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NavigationViewList: ...
    def __new__(cls: typing.Type[NavigationViewList]) -> NavigationViewList:...

class NavigationViewPaneClosingEventArgs(winrt.system.Object):
    cancel: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NavigationViewPaneClosingEventArgs: ...

class NavigationViewSelectionChangedEventArgs(winrt.system.Object):
    is_settings_selected: winrt.system.Boolean
    selected_item: typing.Optional[winrt.system.Object]
    recommended_navigation_transition_info: typing.Optional[winrt.windows.ui.xaml.media.animation.NavigationTransitionInfo]
    selected_item_container: typing.Optional[NavigationViewItemBase]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NavigationViewSelectionChangedEventArgs: ...

class NavigationViewTemplateSettings(winrt.system.Object):
    back_button_visibility: winrt.windows.ui.xaml.Visibility
    left_pane_visibility: winrt.windows.ui.xaml.Visibility
    overflow_button_visibility: winrt.windows.ui.xaml.Visibility
    pane_toggle_button_visibility: winrt.windows.ui.xaml.Visibility
    single_selection_follows_focus: winrt.system.Boolean
    top_padding: winrt.system.Double
    top_pane_visibility: winrt.windows.ui.xaml.Visibility
    back_button_visibility_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    left_pane_visibility_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    overflow_button_visibility_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    pane_toggle_button_visibility_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    single_selection_follows_focus_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    top_padding_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    top_pane_visibility_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NavigationViewTemplateSettings: ...
    def __new__(cls: typing.Type[NavigationViewTemplateSettings]) -> NavigationViewTemplateSettings:...

class NotifyEventArgs(winrt.system.Object):
    value: str
    calling_uri: typing.Optional[winrt.windows.foundation.Uri]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NotifyEventArgs: ...

class Page(winrt.system.Object):
    top_app_bar: typing.Optional[AppBar]
    navigation_cache_mode: winrt.windows.ui.xaml.navigation.NavigationCacheMode
    bottom_app_bar: typing.Optional[AppBar]
    frame: typing.Optional[Frame]
    bottom_app_bar_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    frame_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    top_app_bar_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Page: ...
    def __new__(cls: typing.Type[Page]) -> Page:...
    def on_navigated_from(self, e: typing.Optional[winrt.windows.ui.xaml.navigation.NavigationEventArgs], /) -> None: ...
    def on_navigated_to(self, e: typing.Optional[winrt.windows.ui.xaml.navigation.NavigationEventArgs], /) -> None: ...
    def on_navigating_from(self, e: typing.Optional[winrt.windows.ui.xaml.navigation.NavigatingCancelEventArgs], /) -> None: ...

class Panel(winrt.system.Object):
    children_transitions: typing.Optional[winrt.windows.ui.xaml.media.animation.TransitionCollection]
    background: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    children: typing.Optional[UIElementCollection]
    is_items_host: winrt.system.Boolean
    background_transition: typing.Optional[winrt.windows.ui.xaml.BrushTransition]
    background_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    children_transitions_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_items_host_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Panel: ...

class ParallaxView(winrt.system.Object):
    vertical_source_start_offset: winrt.system.Double
    vertical_source_offset_kind: ParallaxSourceOffsetKind
    vertical_source_end_offset: winrt.system.Double
    vertical_shift: winrt.system.Double
    source: typing.Optional[winrt.windows.ui.xaml.UIElement]
    max_vertical_shift_ratio: winrt.system.Double
    max_horizontal_shift_ratio: winrt.system.Double
    is_vertical_shift_clamped: winrt.system.Boolean
    is_horizontal_shift_clamped: winrt.system.Boolean
    horizontal_source_start_offset: winrt.system.Double
    horizontal_source_offset_kind: ParallaxSourceOffsetKind
    horizontal_source_end_offset: winrt.system.Double
    horizontal_shift: winrt.system.Double
    child: typing.Optional[winrt.windows.ui.xaml.UIElement]
    child_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    horizontal_shift_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    horizontal_source_end_offset_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    horizontal_source_offset_kind_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    horizontal_source_start_offset_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_horizontal_shift_clamped_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_vertical_shift_clamped_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    max_horizontal_shift_ratio_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    max_vertical_shift_ratio_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    source_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    vertical_shift_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    vertical_source_end_offset_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    vertical_source_offset_kind_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    vertical_source_start_offset_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ParallaxView: ...
    def __new__(cls: typing.Type[ParallaxView]) -> ParallaxView:...
    def refresh_automatic_horizontal_offsets(self) -> None: ...
    def refresh_automatic_vertical_offsets(self) -> None: ...

class PasswordBox(winrt.system.Object):
    password_char: str
    password: str
    max_length: winrt.system.Int32
    is_password_reveal_button_enabled: winrt.system.Boolean
    selection_highlight_color: typing.Optional[winrt.windows.ui.xaml.media.SolidColorBrush]
    prevent_keyboard_display_on_programmatic_focus: winrt.system.Boolean
    placeholder_text: str
    header_template: typing.Optional[winrt.windows.ui.xaml.DataTemplate]
    header: typing.Optional[winrt.system.Object]
    text_reading_order: winrt.windows.ui.xaml.TextReadingOrder
    password_reveal_mode: PasswordRevealMode
    input_scope: typing.Optional[winrt.windows.ui.xaml.input.InputScope]
    selection_flyout: typing.Optional[winrt.windows.ui.xaml.controls.primitives.FlyoutBase]
    description: typing.Optional[winrt.system.Object]
    can_paste_clipboard_content: winrt.system.Boolean
    is_password_reveal_button_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    max_length_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    password_char_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    password_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    header_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    header_template_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    placeholder_text_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    prevent_keyboard_display_on_programmatic_focus_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    selection_highlight_color_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    input_scope_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    password_reveal_mode_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    text_reading_order_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    can_paste_clipboard_content_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    description_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    selection_flyout_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PasswordBox: ...
    def __new__(cls: typing.Type[PasswordBox]) -> PasswordBox:...
    def paste_from_clipboard(self) -> None: ...
    def select_all(self) -> None: ...
    def add_context_menu_opening(self, handler: typing.Optional[ContextMenuOpeningEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_context_menu_opening(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_password_changed(self, handler: typing.Optional[winrt.windows.ui.xaml.RoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_password_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_paste(self, handler: typing.Optional[TextControlPasteEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_paste(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_password_changing(self, handler: winrt.windows.foundation.TypedEventHandler[PasswordBox, PasswordBoxPasswordChangingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_password_changing(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class PasswordBoxPasswordChangingEventArgs(winrt.system.Object):
    is_content_changing: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PasswordBoxPasswordChangingEventArgs: ...

class PathIcon(winrt.system.Object):
    data: typing.Optional[winrt.windows.ui.xaml.media.Geometry]
    data_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PathIcon: ...
    def __new__(cls: typing.Type[PathIcon]) -> PathIcon:...

class PathIconSource(winrt.system.Object):
    data: typing.Optional[winrt.windows.ui.xaml.media.Geometry]
    data_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PathIconSource: ...
    def __new__(cls: typing.Type[PathIconSource]) -> PathIconSource:...

class PersonPicture(winrt.system.Object):
    profile_picture: typing.Optional[winrt.windows.ui.xaml.media.ImageSource]
    prefer_small_image: winrt.system.Boolean
    is_group: winrt.system.Boolean
    initials: str
    display_name: str
    contact: typing.Optional[winrt.windows.applicationmodel.contacts.Contact]
    badge_text: str
    badge_number: winrt.system.Int32
    badge_image_source: typing.Optional[winrt.windows.ui.xaml.media.ImageSource]
    badge_glyph: str
    badge_glyph_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    badge_image_source_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    badge_number_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    badge_text_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    contact_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    display_name_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    initials_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_group_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    prefer_small_image_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    profile_picture_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PersonPicture: ...
    def __new__(cls: typing.Type[PersonPicture]) -> PersonPicture:...

class PickerConfirmedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PickerConfirmedEventArgs: ...
    def __new__(cls: typing.Type[PickerConfirmedEventArgs]) -> PickerConfirmedEventArgs:...

class PickerFlyout(winrt.system.Object):
    content: typing.Optional[winrt.windows.ui.xaml.UIElement]
    confirmation_buttons_visible: winrt.system.Boolean
    confirmation_buttons_visible_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    content_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PickerFlyout: ...
    def __new__(cls: typing.Type[PickerFlyout]) -> PickerFlyout:...
    def show_at_async(self, target: typing.Optional[winrt.windows.ui.xaml.FrameworkElement], /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...
    def add_confirmed(self, handler: winrt.windows.foundation.TypedEventHandler[PickerFlyout, PickerConfirmedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_confirmed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class PickerFlyoutPresenter(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PickerFlyoutPresenter: ...

class Pivot(winrt.system.Object):
    title_template: typing.Optional[winrt.windows.ui.xaml.DataTemplate]
    title: typing.Optional[winrt.system.Object]
    selected_item: typing.Optional[winrt.system.Object]
    selected_index: winrt.system.Int32
    is_locked: winrt.system.Boolean
    header_template: typing.Optional[winrt.windows.ui.xaml.DataTemplate]
    right_header_template: typing.Optional[winrt.windows.ui.xaml.DataTemplate]
    right_header: typing.Optional[winrt.system.Object]
    left_header_template: typing.Optional[winrt.windows.ui.xaml.DataTemplate]
    left_header: typing.Optional[winrt.system.Object]
    is_header_items_carousel_enabled: winrt.system.Boolean
    header_focus_visual_placement: PivotHeaderFocusVisualPlacement
    header_template_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_locked_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    selected_index_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    selected_item_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    slide_in_animation_group_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    title_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    title_template_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    left_header_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    left_header_template_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    right_header_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    right_header_template_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    header_focus_visual_placement_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_header_items_carousel_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Pivot: ...
    def __new__(cls: typing.Type[Pivot]) -> Pivot:...
    @staticmethod
    def get_slide_in_animation_group(element: typing.Optional[winrt.windows.ui.xaml.FrameworkElement], /) -> PivotSlideInAnimationGroup: ...
    @staticmethod
    def set_slide_in_animation_group(element: typing.Optional[winrt.windows.ui.xaml.FrameworkElement], value: PivotSlideInAnimationGroup, /) -> None: ...
    def add_pivot_item_loaded(self, handler: winrt.windows.foundation.TypedEventHandler[Pivot, PivotItemEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_pivot_item_loaded(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_pivot_item_loading(self, handler: winrt.windows.foundation.TypedEventHandler[Pivot, PivotItemEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_pivot_item_loading(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_pivot_item_unloaded(self, handler: winrt.windows.foundation.TypedEventHandler[Pivot, PivotItemEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_pivot_item_unloaded(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_pivot_item_unloading(self, handler: winrt.windows.foundation.TypedEventHandler[Pivot, PivotItemEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_pivot_item_unloading(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_selection_changed(self, handler: typing.Optional[SelectionChangedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_selection_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class PivotItem(winrt.system.Object):
    header: typing.Optional[winrt.system.Object]
    header_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PivotItem: ...
    def __new__(cls: typing.Type[PivotItem]) -> PivotItem:...

class PivotItemEventArgs(winrt.system.Object):
    item: typing.Optional[PivotItem]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PivotItemEventArgs: ...
    def __new__(cls: typing.Type[PivotItemEventArgs]) -> PivotItemEventArgs:...

class ProgressBar(winrt.system.Object):
    show_paused: winrt.system.Boolean
    show_error: winrt.system.Boolean
    is_indeterminate: winrt.system.Boolean
    template_settings: typing.Optional[winrt.windows.ui.xaml.controls.primitives.ProgressBarTemplateSettings]
    is_indeterminate_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    show_error_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    show_paused_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProgressBar: ...
    def __new__(cls: typing.Type[ProgressBar]) -> ProgressBar:...

class ProgressRing(winrt.system.Object):
    is_active: winrt.system.Boolean
    template_settings: typing.Optional[winrt.windows.ui.xaml.controls.primitives.ProgressRingTemplateSettings]
    is_active_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProgressRing: ...
    def __new__(cls: typing.Type[ProgressRing]) -> ProgressRing:...

class RadioButton(winrt.system.Object):
    group_name: str
    group_name_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RadioButton: ...
    def __new__(cls: typing.Type[RadioButton]) -> RadioButton:...

class RatingControl(winrt.system.Object):
    value: winrt.system.Double
    placeholder_value: winrt.system.Double
    max_rating: winrt.system.Int32
    item_info: typing.Optional[RatingItemInfo]
    is_read_only: winrt.system.Boolean
    is_clear_enabled: winrt.system.Boolean
    initial_set_value: winrt.system.Int32
    caption: str
    caption_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    initial_set_value_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_clear_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_read_only_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    item_info_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    max_rating_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    placeholder_value_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    value_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RatingControl: ...
    def __new__(cls: typing.Type[RatingControl]) -> RatingControl:...
    def add_value_changed(self, handler: winrt.windows.foundation.TypedEventHandler[RatingControl, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_value_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class RatingItemFontInfo(winrt.system.Object):
    unset_glyph: str
    pointer_over_placeholder_glyph: str
    pointer_over_glyph: str
    placeholder_glyph: str
    glyph: str
    disabled_glyph: str
    disabled_glyph_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    glyph_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    placeholder_glyph_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    pointer_over_glyph_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    pointer_over_placeholder_glyph_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    unset_glyph_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RatingItemFontInfo: ...
    def __new__(cls: typing.Type[RatingItemFontInfo]) -> RatingItemFontInfo:...

class RatingItemImageInfo(winrt.system.Object):
    unset_image: typing.Optional[winrt.windows.ui.xaml.media.ImageSource]
    pointer_over_placeholder_image: typing.Optional[winrt.windows.ui.xaml.media.ImageSource]
    pointer_over_image: typing.Optional[winrt.windows.ui.xaml.media.ImageSource]
    placeholder_image: typing.Optional[winrt.windows.ui.xaml.media.ImageSource]
    image: typing.Optional[winrt.windows.ui.xaml.media.ImageSource]
    disabled_image: typing.Optional[winrt.windows.ui.xaml.media.ImageSource]
    disabled_image_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    image_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    placeholder_image_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    pointer_over_image_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    pointer_over_placeholder_image_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    unset_image_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RatingItemImageInfo: ...
    def __new__(cls: typing.Type[RatingItemImageInfo]) -> RatingItemImageInfo:...

class RatingItemInfo(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RatingItemInfo: ...
    def __new__(cls: typing.Type[RatingItemInfo]) -> RatingItemInfo:...

class RefreshContainer(winrt.system.Object):
    visualizer: typing.Optional[RefreshVisualizer]
    pull_direction: RefreshPullDirection
    pull_direction_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    visualizer_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RefreshContainer: ...
    def __new__(cls: typing.Type[RefreshContainer]) -> RefreshContainer:...
    def request_refresh(self) -> None: ...
    def add_refresh_requested(self, handler: winrt.windows.foundation.TypedEventHandler[RefreshContainer, RefreshRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_refresh_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class RefreshInteractionRatioChangedEventArgs(winrt.system.Object):
    interaction_ratio: winrt.system.Double
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RefreshInteractionRatioChangedEventArgs: ...

class RefreshRequestedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RefreshRequestedEventArgs: ...
    def get_deferral(self) -> typing.Optional[winrt.windows.foundation.Deferral]: ...

class RefreshStateChangedEventArgs(winrt.system.Object):
    new_state: RefreshVisualizerState
    old_state: RefreshVisualizerState
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RefreshStateChangedEventArgs: ...

class RefreshVisualizer(winrt.system.Object):
    orientation: RefreshVisualizerOrientation
    content: typing.Optional[winrt.windows.ui.xaml.UIElement]
    state: RefreshVisualizerState
    content_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    info_provider_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    orientation_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    state_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RefreshVisualizer: ...
    def __new__(cls: typing.Type[RefreshVisualizer]) -> RefreshVisualizer:...
    def request_refresh(self) -> None: ...
    def add_refresh_requested(self, handler: winrt.windows.foundation.TypedEventHandler[RefreshVisualizer, RefreshRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_refresh_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_refresh_state_changed(self, handler: winrt.windows.foundation.TypedEventHandler[RefreshVisualizer, RefreshStateChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_refresh_state_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class RelativePanel(winrt.system.Object):
    padding: winrt.windows.ui.xaml.Thickness
    corner_radius: winrt.windows.ui.xaml.CornerRadius
    border_thickness: winrt.windows.ui.xaml.Thickness
    border_brush: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    background_sizing: BackgroundSizing
    above_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    align_bottom_with_panel_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    align_bottom_with_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    align_horizontal_center_with_panel_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    align_horizontal_center_with_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    align_left_with_panel_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    align_left_with_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    align_right_with_panel_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    align_right_with_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    align_top_with_panel_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    align_top_with_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    align_vertical_center_with_panel_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    align_vertical_center_with_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    below_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    border_brush_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    border_thickness_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    corner_radius_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    left_of_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    padding_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    right_of_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    background_sizing_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RelativePanel: ...
    def __new__(cls: typing.Type[RelativePanel]) -> RelativePanel:...
    @staticmethod
    def get_above(element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> typing.Optional[winrt.system.Object]: ...
    @staticmethod
    def get_align_bottom_with(element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> typing.Optional[winrt.system.Object]: ...
    @staticmethod
    def get_align_bottom_with_panel(element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> winrt.system.Boolean: ...
    @staticmethod
    def get_align_horizontal_center_with(element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> typing.Optional[winrt.system.Object]: ...
    @staticmethod
    def get_align_horizontal_center_with_panel(element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> winrt.system.Boolean: ...
    @staticmethod
    def get_align_left_with(element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> typing.Optional[winrt.system.Object]: ...
    @staticmethod
    def get_align_left_with_panel(element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> winrt.system.Boolean: ...
    @staticmethod
    def get_align_right_with(element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> typing.Optional[winrt.system.Object]: ...
    @staticmethod
    def get_align_right_with_panel(element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> winrt.system.Boolean: ...
    @staticmethod
    def get_align_top_with(element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> typing.Optional[winrt.system.Object]: ...
    @staticmethod
    def get_align_top_with_panel(element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> winrt.system.Boolean: ...
    @staticmethod
    def get_align_vertical_center_with(element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> typing.Optional[winrt.system.Object]: ...
    @staticmethod
    def get_align_vertical_center_with_panel(element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> winrt.system.Boolean: ...
    @staticmethod
    def get_below(element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> typing.Optional[winrt.system.Object]: ...
    @staticmethod
    def get_left_of(element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> typing.Optional[winrt.system.Object]: ...
    @staticmethod
    def get_right_of(element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> typing.Optional[winrt.system.Object]: ...
    @staticmethod
    def set_above(element: typing.Optional[winrt.windows.ui.xaml.UIElement], value: typing.Optional[winrt.system.Object], /) -> None: ...
    @staticmethod
    def set_align_bottom_with(element: typing.Optional[winrt.windows.ui.xaml.UIElement], value: typing.Optional[winrt.system.Object], /) -> None: ...
    @staticmethod
    def set_align_bottom_with_panel(element: typing.Optional[winrt.windows.ui.xaml.UIElement], value: winrt.system.Boolean, /) -> None: ...
    @staticmethod
    def set_align_horizontal_center_with(element: typing.Optional[winrt.windows.ui.xaml.UIElement], value: typing.Optional[winrt.system.Object], /) -> None: ...
    @staticmethod
    def set_align_horizontal_center_with_panel(element: typing.Optional[winrt.windows.ui.xaml.UIElement], value: winrt.system.Boolean, /) -> None: ...
    @staticmethod
    def set_align_left_with(element: typing.Optional[winrt.windows.ui.xaml.UIElement], value: typing.Optional[winrt.system.Object], /) -> None: ...
    @staticmethod
    def set_align_left_with_panel(element: typing.Optional[winrt.windows.ui.xaml.UIElement], value: winrt.system.Boolean, /) -> None: ...
    @staticmethod
    def set_align_right_with(element: typing.Optional[winrt.windows.ui.xaml.UIElement], value: typing.Optional[winrt.system.Object], /) -> None: ...
    @staticmethod
    def set_align_right_with_panel(element: typing.Optional[winrt.windows.ui.xaml.UIElement], value: winrt.system.Boolean, /) -> None: ...
    @staticmethod
    def set_align_top_with(element: typing.Optional[winrt.windows.ui.xaml.UIElement], value: typing.Optional[winrt.system.Object], /) -> None: ...
    @staticmethod
    def set_align_top_with_panel(element: typing.Optional[winrt.windows.ui.xaml.UIElement], value: winrt.system.Boolean, /) -> None: ...
    @staticmethod
    def set_align_vertical_center_with(element: typing.Optional[winrt.windows.ui.xaml.UIElement], value: typing.Optional[winrt.system.Object], /) -> None: ...
    @staticmethod
    def set_align_vertical_center_with_panel(element: typing.Optional[winrt.windows.ui.xaml.UIElement], value: winrt.system.Boolean, /) -> None: ...
    @staticmethod
    def set_below(element: typing.Optional[winrt.windows.ui.xaml.UIElement], value: typing.Optional[winrt.system.Object], /) -> None: ...
    @staticmethod
    def set_left_of(element: typing.Optional[winrt.windows.ui.xaml.UIElement], value: typing.Optional[winrt.system.Object], /) -> None: ...
    @staticmethod
    def set_right_of(element: typing.Optional[winrt.windows.ui.xaml.UIElement], value: typing.Optional[winrt.system.Object], /) -> None: ...

class RichEditBox(winrt.system.Object):
    text_wrapping: winrt.windows.ui.xaml.TextWrapping
    text_alignment: winrt.windows.ui.xaml.TextAlignment
    is_text_prediction_enabled: winrt.system.Boolean
    is_spell_check_enabled: winrt.system.Boolean
    is_read_only: winrt.system.Boolean
    input_scope: typing.Optional[winrt.windows.ui.xaml.input.InputScope]
    accepts_return: winrt.system.Boolean
    document: typing.Optional[winrt.windows.ui.text.ITextDocument]
    selection_highlight_color: typing.Optional[winrt.windows.ui.xaml.media.SolidColorBrush]
    prevent_keyboard_display_on_programmatic_focus: winrt.system.Boolean
    placeholder_text: str
    is_color_font_enabled: winrt.system.Boolean
    header_template: typing.Optional[winrt.windows.ui.xaml.DataTemplate]
    header: typing.Optional[winrt.system.Object]
    text_reading_order: winrt.windows.ui.xaml.TextReadingOrder
    desired_candidate_window_alignment: CandidateWindowAlignment
    clipboard_copy_format: RichEditClipboardFormat
    selection_highlight_color_when_not_focused: typing.Optional[winrt.windows.ui.xaml.media.SolidColorBrush]
    max_length: winrt.system.Int32
    horizontal_text_alignment: winrt.windows.ui.xaml.TextAlignment
    disabled_formatting_accelerators: DisabledFormattingAccelerators
    character_casing: CharacterCasing
    is_handwriting_view_enabled: winrt.system.Boolean
    handwriting_view: typing.Optional[HandwritingView]
    content_link_providers: typing.Optional[winrt.windows.ui.xaml.documents.ContentLinkProviderCollection]
    content_link_foreground_color: typing.Optional[winrt.windows.ui.xaml.media.SolidColorBrush]
    content_link_background_color: typing.Optional[winrt.windows.ui.xaml.media.SolidColorBrush]
    selection_flyout: typing.Optional[winrt.windows.ui.xaml.controls.primitives.FlyoutBase]
    description: typing.Optional[winrt.system.Object]
    proofing_menu_flyout: typing.Optional[winrt.windows.ui.xaml.controls.primitives.FlyoutBase]
    text_document: typing.Optional[winrt.windows.ui.text.RichEditTextDocument]
    accepts_return_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    input_scope_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_read_only_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_spell_check_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_text_prediction_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    text_alignment_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    text_wrapping_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    header_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    header_template_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_color_font_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    placeholder_text_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    prevent_keyboard_display_on_programmatic_focus_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    selection_highlight_color_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    desired_candidate_window_alignment_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    text_reading_order_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    clipboard_copy_format_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    max_length_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    selection_highlight_color_when_not_focused_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    character_casing_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    disabled_formatting_accelerators_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    horizontal_text_alignment_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    content_link_background_color_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    content_link_foreground_color_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    content_link_providers_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    handwriting_view_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_handwriting_view_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    description_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    proofing_menu_flyout_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    selection_flyout_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RichEditBox: ...
    def __new__(cls: typing.Type[RichEditBox]) -> RichEditBox:...
    def get_linguistic_alternatives_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[str]]: ...
    def add_context_menu_opening(self, handler: typing.Optional[ContextMenuOpeningEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_context_menu_opening(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_selection_changed(self, handler: typing.Optional[winrt.windows.ui.xaml.RoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_selection_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_text_changed(self, handler: typing.Optional[winrt.windows.ui.xaml.RoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_text_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_paste(self, handler: typing.Optional[TextControlPasteEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_paste(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_candidate_window_bounds_changed(self, handler: winrt.windows.foundation.TypedEventHandler[RichEditBox, CandidateWindowBoundsChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_candidate_window_bounds_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_text_changing(self, handler: winrt.windows.foundation.TypedEventHandler[RichEditBox, RichEditBoxTextChangingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_text_changing(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_text_composition_changed(self, handler: winrt.windows.foundation.TypedEventHandler[RichEditBox, TextCompositionChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_text_composition_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_text_composition_ended(self, handler: winrt.windows.foundation.TypedEventHandler[RichEditBox, TextCompositionEndedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_text_composition_ended(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_text_composition_started(self, handler: winrt.windows.foundation.TypedEventHandler[RichEditBox, TextCompositionStartedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_text_composition_started(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_copying_to_clipboard(self, handler: winrt.windows.foundation.TypedEventHandler[RichEditBox, TextControlCopyingToClipboardEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_copying_to_clipboard(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_cutting_to_clipboard(self, handler: winrt.windows.foundation.TypedEventHandler[RichEditBox, TextControlCuttingToClipboardEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_cutting_to_clipboard(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_content_link_changed(self, handler: winrt.windows.foundation.TypedEventHandler[RichEditBox, ContentLinkChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_content_link_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_content_link_invoked(self, handler: winrt.windows.foundation.TypedEventHandler[RichEditBox, winrt.windows.ui.xaml.documents.ContentLinkInvokedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_content_link_invoked(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_selection_changing(self, handler: winrt.windows.foundation.TypedEventHandler[RichEditBox, RichEditBoxSelectionChangingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_selection_changing(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class RichEditBoxSelectionChangingEventArgs(winrt.system.Object):
    cancel: winrt.system.Boolean
    selection_length: winrt.system.Int32
    selection_start: winrt.system.Int32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RichEditBoxSelectionChangingEventArgs: ...

class RichEditBoxTextChangingEventArgs(winrt.system.Object):
    is_content_changing: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RichEditBoxTextChangingEventArgs: ...

class RichTextBlock(winrt.system.Object):
    text_wrapping: winrt.windows.ui.xaml.TextWrapping
    text_trimming: winrt.windows.ui.xaml.TextTrimming
    text_indent: winrt.system.Double
    text_alignment: winrt.windows.ui.xaml.TextAlignment
    padding: winrt.windows.ui.xaml.Thickness
    foreground: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    font_weight: winrt.windows.ui.text.FontWeight
    font_style: winrt.windows.ui.text.FontStyle
    font_stretch: winrt.windows.ui.text.FontStretch
    font_size: winrt.system.Double
    font_family: typing.Optional[winrt.windows.ui.xaml.media.FontFamily]
    overflow_content_target: typing.Optional[RichTextBlockOverflow]
    line_stacking_strategy: winrt.windows.ui.xaml.LineStackingStrategy
    character_spacing: winrt.system.Int32
    line_height: winrt.system.Double
    is_text_selection_enabled: winrt.system.Boolean
    has_overflow_content: winrt.system.Boolean
    selected_text: str
    selection_end: typing.Optional[winrt.windows.ui.xaml.documents.TextPointer]
    selection_start: typing.Optional[winrt.windows.ui.xaml.documents.TextPointer]
    baseline_offset: winrt.system.Double
    blocks: typing.Optional[winrt.windows.ui.xaml.documents.BlockCollection]
    content_end: typing.Optional[winrt.windows.ui.xaml.documents.TextPointer]
    content_start: typing.Optional[winrt.windows.ui.xaml.documents.TextPointer]
    text_reading_order: winrt.windows.ui.xaml.TextReadingOrder
    text_line_bounds: winrt.windows.ui.xaml.TextLineBounds
    selection_highlight_color: typing.Optional[winrt.windows.ui.xaml.media.SolidColorBrush]
    optical_margin_alignment: winrt.windows.ui.xaml.OpticalMarginAlignment
    max_lines: winrt.system.Int32
    is_color_font_enabled: winrt.system.Boolean
    is_text_scale_factor_enabled: winrt.system.Boolean
    text_decorations: winrt.windows.ui.text.TextDecorations
    horizontal_text_alignment: winrt.windows.ui.xaml.TextAlignment
    is_text_trimmed: winrt.system.Boolean
    text_highlighters: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.ui.xaml.documents.TextHighlighter]]
    selection_flyout: typing.Optional[winrt.windows.ui.xaml.controls.primitives.FlyoutBase]
    character_spacing_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    font_family_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    font_size_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    font_stretch_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    font_style_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    font_weight_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    foreground_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    has_overflow_content_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_text_selection_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    line_height_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    line_stacking_strategy_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    overflow_content_target_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    padding_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    selected_text_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    text_alignment_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    text_indent_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    text_trimming_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    text_wrapping_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_color_font_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    max_lines_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    optical_margin_alignment_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    selection_highlight_color_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    text_line_bounds_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    text_reading_order_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_text_scale_factor_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    text_decorations_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    horizontal_text_alignment_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_text_trimmed_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    selection_flyout_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RichTextBlock: ...
    def __new__(cls: typing.Type[RichTextBlock]) -> RichTextBlock:...
    def copy_selection_to_clipboard(self) -> None: ...
    def focus(self, value: winrt.windows.ui.xaml.FocusState, /) -> winrt.system.Boolean: ...
    def get_position_from_point(self, point: winrt.windows.foundation.Point, /) -> typing.Optional[winrt.windows.ui.xaml.documents.TextPointer]: ...
    def select(self, start: typing.Optional[winrt.windows.ui.xaml.documents.TextPointer], end: typing.Optional[winrt.windows.ui.xaml.documents.TextPointer], /) -> None: ...
    def select_all(self) -> None: ...
    def add_context_menu_opening(self, handler: typing.Optional[ContextMenuOpeningEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_context_menu_opening(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_selection_changed(self, handler: typing.Optional[winrt.windows.ui.xaml.RoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_selection_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_is_text_trimmed_changed(self, handler: winrt.windows.foundation.TypedEventHandler[RichTextBlock, IsTextTrimmedChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_is_text_trimmed_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class RichTextBlockOverflow(winrt.system.Object):
    padding: winrt.windows.ui.xaml.Thickness
    overflow_content_target: typing.Optional[RichTextBlockOverflow]
    baseline_offset: winrt.system.Double
    content_end: typing.Optional[winrt.windows.ui.xaml.documents.TextPointer]
    content_source: typing.Optional[RichTextBlock]
    content_start: typing.Optional[winrt.windows.ui.xaml.documents.TextPointer]
    has_overflow_content: winrt.system.Boolean
    max_lines: winrt.system.Int32
    is_text_trimmed: winrt.system.Boolean
    has_overflow_content_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    overflow_content_target_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    padding_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    max_lines_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_text_trimmed_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RichTextBlockOverflow: ...
    def __new__(cls: typing.Type[RichTextBlockOverflow]) -> RichTextBlockOverflow:...
    def focus(self, value: winrt.windows.ui.xaml.FocusState, /) -> winrt.system.Boolean: ...
    def get_position_from_point(self, point: winrt.windows.foundation.Point, /) -> typing.Optional[winrt.windows.ui.xaml.documents.TextPointer]: ...
    def add_is_text_trimmed_changed(self, handler: winrt.windows.foundation.TypedEventHandler[RichTextBlockOverflow, IsTextTrimmedChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_is_text_trimmed_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class RowDefinition(winrt.system.Object):
    min_height: winrt.system.Double
    max_height: winrt.system.Double
    height: winrt.windows.ui.xaml.GridLength
    actual_height: winrt.system.Double
    height_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    max_height_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    min_height_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RowDefinition: ...
    def __new__(cls: typing.Type[RowDefinition]) -> RowDefinition:...

class RowDefinitionCollection(winrt.system.Object, typing.MutableSequence[RowDefinition]):
    size: winrt.system.UInt32
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> RowDefinition: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[RowDefinition]: ...
    def insert(self, index: int, value: RowDefinition) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: RowDefinition) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[RowDefinition]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RowDefinitionCollection: ...
    def append(self, value: typing.Optional[RowDefinition], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[RowDefinition]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[RowDefinition]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[RowDefinition], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[RowDefinition]]: ...
    def index_of(self, value: typing.Optional[RowDefinition], /) -> typing.Tuple[winrt.system.Boolean, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[RowDefinition], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[RowDefinition], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[RowDefinition], /) -> None: ...

class ScrollContentPresenter(winrt.system.Object):
    scroll_owner: typing.Optional[winrt.system.Object]
    can_vertically_scroll: winrt.system.Boolean
    can_horizontally_scroll: winrt.system.Boolean
    extent_height: winrt.system.Double
    extent_width: winrt.system.Double
    horizontal_offset: winrt.system.Double
    vertical_offset: winrt.system.Double
    viewport_height: winrt.system.Double
    viewport_width: winrt.system.Double
    sizes_content_to_templated_parent: winrt.system.Boolean
    can_content_render_outside_bounds: winrt.system.Boolean
    can_content_render_outside_bounds_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    sizes_content_to_templated_parent_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ScrollContentPresenter: ...
    def __new__(cls: typing.Type[ScrollContentPresenter]) -> ScrollContentPresenter:...
    def line_down(self) -> None: ...
    def line_left(self) -> None: ...
    def line_right(self) -> None: ...
    def line_up(self) -> None: ...
    def make_visible(self, visual: typing.Optional[winrt.windows.ui.xaml.UIElement], rectangle: winrt.windows.foundation.Rect, /) -> winrt.windows.foundation.Rect: ...
    def mouse_wheel_down(self) -> None: ...
    def mouse_wheel_left(self) -> None: ...
    def mouse_wheel_right(self) -> None: ...
    def mouse_wheel_up(self) -> None: ...
    def page_down(self) -> None: ...
    def page_left(self) -> None: ...
    def page_right(self) -> None: ...
    def page_up(self) -> None: ...
    def set_horizontal_offset(self, offset: winrt.system.Double, /) -> None: ...
    def set_vertical_offset(self, offset: winrt.system.Double, /) -> None: ...

class ScrollViewer(winrt.system.Object):
    current_anchor: typing.Optional[winrt.windows.ui.xaml.UIElement]
    is_vertical_rail_enabled: winrt.system.Boolean
    is_scroll_inertia_enabled: winrt.system.Boolean
    is_horizontal_scroll_chaining_enabled: winrt.system.Boolean
    is_horizontal_rail_enabled: winrt.system.Boolean
    is_deferred_scrolling_enabled: winrt.system.Boolean
    horizontal_snap_points_type: SnapPointsType
    horizontal_snap_points_alignment: winrt.windows.ui.xaml.controls.primitives.SnapPointsAlignment
    horizontal_scroll_mode: ScrollMode
    horizontal_scroll_bar_visibility: ScrollBarVisibility
    min_zoom_factor: winrt.system.Single
    max_zoom_factor: winrt.system.Single
    is_zoom_inertia_enabled: winrt.system.Boolean
    is_zoom_chaining_enabled: winrt.system.Boolean
    is_vertical_scroll_chaining_enabled: winrt.system.Boolean
    bring_into_view_on_focus_change: winrt.system.Boolean
    zoom_snap_points_type: SnapPointsType
    zoom_mode: ZoomMode
    vertical_snap_points_type: SnapPointsType
    vertical_snap_points_alignment: winrt.windows.ui.xaml.controls.primitives.SnapPointsAlignment
    vertical_scroll_mode: ScrollMode
    vertical_scroll_bar_visibility: ScrollBarVisibility
    computed_horizontal_scroll_bar_visibility: winrt.windows.ui.xaml.Visibility
    computed_vertical_scroll_bar_visibility: winrt.windows.ui.xaml.Visibility
    extent_height: winrt.system.Double
    extent_width: winrt.system.Double
    horizontal_offset: winrt.system.Double
    scrollable_width: winrt.system.Double
    vertical_offset: winrt.system.Double
    viewport_height: winrt.system.Double
    viewport_width: winrt.system.Double
    zoom_factor: winrt.system.Single
    zoom_snap_points: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.system.Single]]
    scrollable_height: winrt.system.Double
    top_left_header: typing.Optional[winrt.windows.ui.xaml.UIElement]
    top_header: typing.Optional[winrt.windows.ui.xaml.UIElement]
    left_header: typing.Optional[winrt.windows.ui.xaml.UIElement]
    vertical_anchor_ratio: winrt.system.Double
    reduce_viewport_for_core_input_view_occlusions: winrt.system.Boolean
    horizontal_anchor_ratio: winrt.system.Double
    can_content_render_outside_bounds: winrt.system.Boolean
    is_scroll_inertia_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    vertical_snap_points_type_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    viewport_height_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    viewport_width_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    zoom_factor_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    zoom_mode_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    zoom_snap_points_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    bring_into_view_on_focus_change_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    computed_horizontal_scroll_bar_visibility_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    computed_vertical_scroll_bar_visibility_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    extent_height_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    extent_width_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    horizontal_offset_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    horizontal_scroll_bar_visibility_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    horizontal_scroll_mode_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    horizontal_snap_points_alignment_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    horizontal_snap_points_type_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_deferred_scrolling_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_horizontal_rail_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_horizontal_scroll_chaining_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    zoom_snap_points_type_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_vertical_rail_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_vertical_scroll_chaining_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_zoom_chaining_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_zoom_inertia_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    max_zoom_factor_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    min_zoom_factor_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    scrollable_height_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    scrollable_width_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    vertical_offset_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    vertical_scroll_bar_visibility_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    vertical_scroll_mode_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    vertical_snap_points_alignment_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    left_header_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    top_header_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    top_left_header_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    horizontal_anchor_ratio_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    reduce_viewport_for_core_input_view_occlusions_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    vertical_anchor_ratio_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    can_content_render_outside_bounds_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ScrollViewer: ...
    def __new__(cls: typing.Type[ScrollViewer]) -> ScrollViewer:...
    @typing.overload
    def change_view(self, horizontal_offset: typing.Optional[winrt.system.Double], vertical_offset: typing.Optional[winrt.system.Double], zoom_factor: typing.Optional[winrt.system.Single], /) -> winrt.system.Boolean: ...
    @typing.overload
    def change_view(self, horizontal_offset: typing.Optional[winrt.system.Double], vertical_offset: typing.Optional[winrt.system.Double], zoom_factor: typing.Optional[winrt.system.Single], disable_animation: winrt.system.Boolean, /) -> winrt.system.Boolean: ...
    @staticmethod
    def get_bring_into_view_on_focus_change(element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> winrt.system.Boolean: ...
    @staticmethod
    def get_can_content_render_outside_bounds(element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> winrt.system.Boolean: ...
    @staticmethod
    def get_horizontal_scroll_bar_visibility(element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> ScrollBarVisibility: ...
    @staticmethod
    def get_horizontal_scroll_mode(element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> ScrollMode: ...
    @staticmethod
    def get_is_deferred_scrolling_enabled(element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> winrt.system.Boolean: ...
    @staticmethod
    def get_is_horizontal_rail_enabled(element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> winrt.system.Boolean: ...
    @staticmethod
    def get_is_horizontal_scroll_chaining_enabled(element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> winrt.system.Boolean: ...
    @staticmethod
    def get_is_scroll_inertia_enabled(element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> winrt.system.Boolean: ...
    @staticmethod
    def get_is_vertical_rail_enabled(element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> winrt.system.Boolean: ...
    @staticmethod
    def get_is_vertical_scroll_chaining_enabled(element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> winrt.system.Boolean: ...
    @staticmethod
    def get_is_zoom_chaining_enabled(element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> winrt.system.Boolean: ...
    @staticmethod
    def get_is_zoom_inertia_enabled(element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> winrt.system.Boolean: ...
    @staticmethod
    def get_vertical_scroll_bar_visibility(element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> ScrollBarVisibility: ...
    @staticmethod
    def get_vertical_scroll_mode(element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> ScrollMode: ...
    @staticmethod
    def get_zoom_mode(element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> ZoomMode: ...
    def invalidate_scroll_info(self) -> None: ...
    def register_anchor_candidate(self, element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> None: ...
    def scroll_to_horizontal_offset(self, offset: winrt.system.Double, /) -> None: ...
    def scroll_to_vertical_offset(self, offset: winrt.system.Double, /) -> None: ...
    @staticmethod
    def set_bring_into_view_on_focus_change(element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], bring_into_view_on_focus_change: winrt.system.Boolean, /) -> None: ...
    @staticmethod
    def set_can_content_render_outside_bounds(element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], can_content_render_outside_bounds: winrt.system.Boolean, /) -> None: ...
    @staticmethod
    def set_horizontal_scroll_bar_visibility(element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], horizontal_scroll_bar_visibility: ScrollBarVisibility, /) -> None: ...
    @staticmethod
    def set_horizontal_scroll_mode(element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], horizontal_scroll_mode: ScrollMode, /) -> None: ...
    @staticmethod
    def set_is_deferred_scrolling_enabled(element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], is_deferred_scrolling_enabled: winrt.system.Boolean, /) -> None: ...
    @staticmethod
    def set_is_horizontal_rail_enabled(element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], is_horizontal_rail_enabled: winrt.system.Boolean, /) -> None: ...
    @staticmethod
    def set_is_horizontal_scroll_chaining_enabled(element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], is_horizontal_scroll_chaining_enabled: winrt.system.Boolean, /) -> None: ...
    @staticmethod
    def set_is_scroll_inertia_enabled(element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], is_scroll_inertia_enabled: winrt.system.Boolean, /) -> None: ...
    @staticmethod
    def set_is_vertical_rail_enabled(element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], is_vertical_rail_enabled: winrt.system.Boolean, /) -> None: ...
    @staticmethod
    def set_is_vertical_scroll_chaining_enabled(element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], is_vertical_scroll_chaining_enabled: winrt.system.Boolean, /) -> None: ...
    @staticmethod
    def set_is_zoom_chaining_enabled(element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], is_zoom_chaining_enabled: winrt.system.Boolean, /) -> None: ...
    @staticmethod
    def set_is_zoom_inertia_enabled(element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], is_zoom_inertia_enabled: winrt.system.Boolean, /) -> None: ...
    @staticmethod
    def set_vertical_scroll_bar_visibility(element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], vertical_scroll_bar_visibility: ScrollBarVisibility, /) -> None: ...
    @staticmethod
    def set_vertical_scroll_mode(element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], vertical_scroll_mode: ScrollMode, /) -> None: ...
    @staticmethod
    def set_zoom_mode(element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], zoom_mode: ZoomMode, /) -> None: ...
    def unregister_anchor_candidate(self, element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> None: ...
    def zoom_to_factor(self, factor: winrt.system.Single, /) -> None: ...
    def add_view_changed(self, handler: winrt.windows.foundation.EventHandler[ScrollViewerViewChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_view_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_view_changing(self, handler: winrt.windows.foundation.EventHandler[ScrollViewerViewChangingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_view_changing(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_direct_manipulation_completed(self, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_direct_manipulation_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_direct_manipulation_started(self, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_direct_manipulation_started(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_anchor_requested(self, handler: winrt.windows.foundation.TypedEventHandler[ScrollViewer, AnchorRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_anchor_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class ScrollViewerView(winrt.system.Object):
    horizontal_offset: winrt.system.Double
    vertical_offset: winrt.system.Double
    zoom_factor: winrt.system.Single
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ScrollViewerView: ...

class ScrollViewerViewChangedEventArgs(winrt.system.Object):
    is_intermediate: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ScrollViewerViewChangedEventArgs: ...
    def __new__(cls: typing.Type[ScrollViewerViewChangedEventArgs]) -> ScrollViewerViewChangedEventArgs:...

class ScrollViewerViewChangingEventArgs(winrt.system.Object):
    final_view: typing.Optional[ScrollViewerView]
    is_inertial: winrt.system.Boolean
    next_view: typing.Optional[ScrollViewerView]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ScrollViewerViewChangingEventArgs: ...

class SearchBox(winrt.system.Object):
    search_history_enabled: winrt.system.Boolean
    search_history_context: str
    query_text: str
    placeholder_text: str
    focus_on_keyboard_input: winrt.system.Boolean
    choose_suggestion_on_enter: winrt.system.Boolean
    choose_suggestion_on_enter_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    focus_on_keyboard_input_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    placeholder_text_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    query_text_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    search_history_context_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    search_history_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SearchBox: ...
    def __new__(cls: typing.Type[SearchBox]) -> SearchBox:...
    def set_local_content_suggestion_settings(self, settings: typing.Optional[winrt.windows.applicationmodel.search.LocalContentSuggestionSettings], /) -> None: ...
    def add_prepare_for_focus_on_keyboard_input(self, handler: winrt.windows.foundation.TypedEventHandler[SearchBox, winrt.windows.ui.xaml.RoutedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_prepare_for_focus_on_keyboard_input(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_query_changed(self, handler: winrt.windows.foundation.TypedEventHandler[SearchBox, SearchBoxQueryChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_query_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_query_submitted(self, handler: winrt.windows.foundation.TypedEventHandler[SearchBox, SearchBoxQuerySubmittedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_query_submitted(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_result_suggestion_chosen(self, handler: winrt.windows.foundation.TypedEventHandler[SearchBox, SearchBoxResultSuggestionChosenEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_result_suggestion_chosen(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_suggestions_requested(self, handler: winrt.windows.foundation.TypedEventHandler[SearchBox, SearchBoxSuggestionsRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_suggestions_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class SearchBoxQueryChangedEventArgs(winrt.system.Object):
    language: str
    linguistic_details: typing.Optional[winrt.windows.applicationmodel.search.SearchQueryLinguisticDetails]
    query_text: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SearchBoxQueryChangedEventArgs: ...

class SearchBoxQuerySubmittedEventArgs(winrt.system.Object):
    key_modifiers: winrt.windows.system.VirtualKeyModifiers
    language: str
    linguistic_details: typing.Optional[winrt.windows.applicationmodel.search.SearchQueryLinguisticDetails]
    query_text: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SearchBoxQuerySubmittedEventArgs: ...

class SearchBoxResultSuggestionChosenEventArgs(winrt.system.Object):
    key_modifiers: winrt.windows.system.VirtualKeyModifiers
    tag: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SearchBoxResultSuggestionChosenEventArgs: ...
    def __new__(cls: typing.Type[SearchBoxResultSuggestionChosenEventArgs]) -> SearchBoxResultSuggestionChosenEventArgs:...

class SearchBoxSuggestionsRequestedEventArgs(winrt.system.Object):
    language: str
    linguistic_details: typing.Optional[winrt.windows.applicationmodel.search.SearchQueryLinguisticDetails]
    query_text: str
    request: typing.Optional[winrt.windows.applicationmodel.search.SearchSuggestionsRequest]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SearchBoxSuggestionsRequestedEventArgs: ...

class SectionsInViewChangedEventArgs(winrt.system.Object):
    added_sections: typing.Optional[winrt.windows.foundation.collections.IVector[HubSection]]
    removed_sections: typing.Optional[winrt.windows.foundation.collections.IVector[HubSection]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SectionsInViewChangedEventArgs: ...

class SelectionChangedEventArgs(winrt.system.Object):
    added_items: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.system.Object]]
    removed_items: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.system.Object]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SelectionChangedEventArgs: ...
    def __new__(cls: typing.Type[SelectionChangedEventArgs], removed_items: winrt.windows.foundation.collections.IVector[winrt.system.Object], added_items: winrt.windows.foundation.collections.IVector[winrt.system.Object]) -> SelectionChangedEventArgs:...

class SemanticZoom(winrt.system.Object):
    zoomed_out_view: typing.Optional[ISemanticZoomInformation]
    zoomed_in_view: typing.Optional[ISemanticZoomInformation]
    is_zoomed_in_view_active: winrt.system.Boolean
    is_zoom_out_button_enabled: winrt.system.Boolean
    can_change_views: winrt.system.Boolean
    can_change_views_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_zoom_out_button_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_zoomed_in_view_active_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    zoomed_in_view_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    zoomed_out_view_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SemanticZoom: ...
    def __new__(cls: typing.Type[SemanticZoom]) -> SemanticZoom:...
    def toggle_active_view(self) -> None: ...
    def add_view_change_completed(self, handler: typing.Optional[SemanticZoomViewChangedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_view_change_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_view_change_started(self, handler: typing.Optional[SemanticZoomViewChangedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_view_change_started(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class SemanticZoomLocation(winrt.system.Object):
    item: typing.Optional[winrt.system.Object]
    bounds: winrt.windows.foundation.Rect
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SemanticZoomLocation: ...
    def __new__(cls: typing.Type[SemanticZoomLocation]) -> SemanticZoomLocation:...

class SemanticZoomViewChangedEventArgs(winrt.system.Object):
    source_item: typing.Optional[SemanticZoomLocation]
    is_source_zoomed_in_view: winrt.system.Boolean
    destination_item: typing.Optional[SemanticZoomLocation]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SemanticZoomViewChangedEventArgs: ...
    def __new__(cls: typing.Type[SemanticZoomViewChangedEventArgs]) -> SemanticZoomViewChangedEventArgs:...

class SettingsFlyout(winrt.system.Object):
    title: str
    icon_source: typing.Optional[winrt.windows.ui.xaml.media.ImageSource]
    header_foreground: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    header_background: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    template_settings: typing.Optional[winrt.windows.ui.xaml.controls.primitives.SettingsFlyoutTemplateSettings]
    header_background_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    header_foreground_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    icon_source_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    title_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SettingsFlyout: ...
    def __new__(cls: typing.Type[SettingsFlyout]) -> SettingsFlyout:...
    def hide(self) -> None: ...
    def show(self) -> None: ...
    def show_independent(self) -> None: ...
    def add_back_click(self, handler: typing.Optional[BackClickEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_back_click(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class Slider(winrt.system.Object):
    tick_placement: winrt.windows.ui.xaml.controls.primitives.TickPlacement
    tick_frequency: winrt.system.Double
    thumb_tool_tip_value_converter: typing.Optional[winrt.windows.ui.xaml.data.IValueConverter]
    step_frequency: winrt.system.Double
    snaps_to: winrt.windows.ui.xaml.controls.primitives.SliderSnapsTo
    orientation: Orientation
    is_thumb_tool_tip_enabled: winrt.system.Boolean
    is_direction_reversed: winrt.system.Boolean
    intermediate_value: winrt.system.Double
    header_template: typing.Optional[winrt.windows.ui.xaml.DataTemplate]
    header: typing.Optional[winrt.system.Object]
    intermediate_value_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_direction_reversed_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_thumb_tool_tip_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    orientation_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    snaps_to_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    step_frequency_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    thumb_tool_tip_value_converter_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    tick_frequency_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    tick_placement_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    header_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    header_template_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Slider: ...
    def __new__(cls: typing.Type[Slider]) -> Slider:...

class SplitButton(winrt.system.Object):
    flyout: typing.Optional[winrt.windows.ui.xaml.controls.primitives.FlyoutBase]
    command_parameter: typing.Optional[winrt.system.Object]
    command: typing.Optional[winrt.windows.ui.xaml.input.ICommand]
    command_parameter_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    command_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    flyout_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SplitButton: ...
    def __new__(cls: typing.Type[SplitButton]) -> SplitButton:...
    def add_click(self, handler: winrt.windows.foundation.TypedEventHandler[SplitButton, SplitButtonClickEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_click(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class SplitButtonAutomationPeer(winrt.system.Object):
    expand_collapse_state: winrt.windows.ui.xaml.automation.ExpandCollapseState
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SplitButtonAutomationPeer: ...
    def __new__(cls: typing.Type[SplitButtonAutomationPeer], owner: typing.Optional[SplitButton]) -> SplitButtonAutomationPeer:...
    def collapse(self) -> None: ...
    def expand(self) -> None: ...
    def invoke(self) -> None: ...

class SplitButtonClickEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SplitButtonClickEventArgs: ...

class SplitView(winrt.system.Object):
    pane_placement: SplitViewPanePlacement
    pane_background: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    pane: typing.Optional[winrt.windows.ui.xaml.UIElement]
    open_pane_length: winrt.system.Double
    is_pane_open: winrt.system.Boolean
    display_mode: SplitViewDisplayMode
    content: typing.Optional[winrt.windows.ui.xaml.UIElement]
    compact_pane_length: winrt.system.Double
    template_settings: typing.Optional[winrt.windows.ui.xaml.controls.primitives.SplitViewTemplateSettings]
    light_dismiss_overlay_mode: LightDismissOverlayMode
    compact_pane_length_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    content_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    display_mode_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_pane_open_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    open_pane_length_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    pane_background_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    pane_placement_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    pane_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    template_settings_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    light_dismiss_overlay_mode_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SplitView: ...
    def __new__(cls: typing.Type[SplitView]) -> SplitView:...
    def add_pane_closed(self, handler: winrt.windows.foundation.TypedEventHandler[SplitView, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_pane_closed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_pane_closing(self, handler: winrt.windows.foundation.TypedEventHandler[SplitView, SplitViewPaneClosingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_pane_closing(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_pane_opened(self, handler: winrt.windows.foundation.TypedEventHandler[SplitView, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_pane_opened(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_pane_opening(self, handler: winrt.windows.foundation.TypedEventHandler[SplitView, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_pane_opening(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class SplitViewPaneClosingEventArgs(winrt.system.Object):
    cancel: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SplitViewPaneClosingEventArgs: ...

class StackPanel(winrt.system.Object):
    orientation: Orientation
    are_scroll_snap_points_regular: winrt.system.Boolean
    padding: winrt.windows.ui.xaml.Thickness
    corner_radius: winrt.windows.ui.xaml.CornerRadius
    border_thickness: winrt.windows.ui.xaml.Thickness
    border_brush: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    spacing: winrt.system.Double
    background_sizing: BackgroundSizing
    are_horizontal_snap_points_regular: winrt.system.Boolean
    are_vertical_snap_points_regular: winrt.system.Boolean
    are_scroll_snap_points_regular_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    orientation_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    border_brush_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    border_thickness_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    corner_radius_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    padding_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    spacing_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    background_sizing_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StackPanel: ...
    def __new__(cls: typing.Type[StackPanel]) -> StackPanel:...
    def get_insertion_indexes(self, position: winrt.windows.foundation.Point, /) -> typing.Tuple[winrt.system.Int32, winrt.system.Int32]: ...
    def get_irregular_snap_points(self, orientation: Orientation, alignment: winrt.windows.ui.xaml.controls.primitives.SnapPointsAlignment, /) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Single]]: ...
    def get_regular_snap_points(self, orientation: Orientation, alignment: winrt.windows.ui.xaml.controls.primitives.SnapPointsAlignment, /) -> typing.Tuple[winrt.system.Single, winrt.system.Single]: ...
    def add_horizontal_snap_points_changed(self, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_horizontal_snap_points_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_vertical_snap_points_changed(self, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_vertical_snap_points_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class StyleSelector(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StyleSelector: ...
    def __new__(cls: typing.Type[StyleSelector]) -> StyleSelector:...
    def select_style(self, item: typing.Optional[winrt.system.Object], container: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> typing.Optional[winrt.windows.ui.xaml.Style]: ...
    def select_style_core(self, item: typing.Optional[winrt.system.Object], container: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> typing.Optional[winrt.windows.ui.xaml.Style]: ...

class SwapChainBackgroundPanel(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SwapChainBackgroundPanel: ...
    def __new__(cls: typing.Type[SwapChainBackgroundPanel]) -> SwapChainBackgroundPanel:...
    def create_core_independent_input_source(self, device_types: winrt.windows.ui.core.CoreInputDeviceTypes, /) -> typing.Optional[winrt.windows.ui.core.CoreIndependentInputSource]: ...

class SwapChainPanel(winrt.system.Object):
    composition_scale_x: winrt.system.Single
    composition_scale_y: winrt.system.Single
    composition_scale_x_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    composition_scale_y_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SwapChainPanel: ...
    def __new__(cls: typing.Type[SwapChainPanel]) -> SwapChainPanel:...
    def create_core_independent_input_source(self, device_types: winrt.windows.ui.core.CoreInputDeviceTypes, /) -> typing.Optional[winrt.windows.ui.core.CoreIndependentInputSource]: ...
    def add_composition_scale_changed(self, handler: winrt.windows.foundation.TypedEventHandler[SwapChainPanel, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_composition_scale_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class SwipeControl(winrt.system.Object):
    top_items: typing.Optional[SwipeItems]
    right_items: typing.Optional[SwipeItems]
    left_items: typing.Optional[SwipeItems]
    bottom_items: typing.Optional[SwipeItems]
    bottom_items_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    left_items_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    right_items_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    top_items_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SwipeControl: ...
    def __new__(cls: typing.Type[SwipeControl]) -> SwipeControl:...
    def close(self) -> None: ...

class SwipeItem(winrt.system.Object):
    text: str
    icon_source: typing.Optional[IconSource]
    foreground: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    command_parameter: typing.Optional[winrt.system.Object]
    command: typing.Optional[winrt.windows.ui.xaml.input.ICommand]
    behavior_on_invoked: SwipeBehaviorOnInvoked
    background: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    background_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    behavior_on_invoked_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    command_parameter_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    command_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    foreground_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    icon_source_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    text_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SwipeItem: ...
    def __new__(cls: typing.Type[SwipeItem]) -> SwipeItem:...
    def add_invoked(self, handler: winrt.windows.foundation.TypedEventHandler[SwipeItem, SwipeItemInvokedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_invoked(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class SwipeItemInvokedEventArgs(winrt.system.Object):
    swipe_control: typing.Optional[SwipeControl]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SwipeItemInvokedEventArgs: ...

class SwipeItems(winrt.system.Object, typing.MutableSequence[SwipeItem]):
    size: winrt.system.UInt32
    mode: SwipeMode
    mode_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> SwipeItem: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[SwipeItem]: ...
    def insert(self, index: int, value: SwipeItem) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: SwipeItem) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[SwipeItem]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SwipeItems: ...
    def __new__(cls: typing.Type[SwipeItems]) -> SwipeItems:...
    def append(self, value: typing.Optional[SwipeItem], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[SwipeItem]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[SwipeItem]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[SwipeItem], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[SwipeItem]]: ...
    def index_of(self, value: typing.Optional[SwipeItem], /) -> typing.Tuple[winrt.system.Boolean, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[SwipeItem], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[SwipeItem], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[SwipeItem], /) -> None: ...

class SymbolIcon(winrt.system.Object):
    symbol: Symbol
    symbol_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SymbolIcon: ...
    @typing.overload
    def __new__(cls: typing.Type[SymbolIcon], symbol: Symbol) -> SymbolIcon:...
    @typing.overload
    def __new__(cls: typing.Type[SymbolIcon]) -> SymbolIcon:...

class SymbolIconSource(winrt.system.Object):
    symbol: Symbol
    symbol_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SymbolIconSource: ...
    def __new__(cls: typing.Type[SymbolIconSource]) -> SymbolIconSource:...

class TextBlock(winrt.system.Object):
    text_wrapping: winrt.windows.ui.xaml.TextWrapping
    text_trimming: winrt.windows.ui.xaml.TextTrimming
    text_alignment: winrt.windows.ui.xaml.TextAlignment
    text: str
    padding: winrt.windows.ui.xaml.Thickness
    foreground: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    font_weight: winrt.windows.ui.text.FontWeight
    font_style: winrt.windows.ui.text.FontStyle
    font_stretch: winrt.windows.ui.text.FontStretch
    font_size: winrt.system.Double
    font_family: typing.Optional[winrt.windows.ui.xaml.media.FontFamily]
    line_stacking_strategy: winrt.windows.ui.xaml.LineStackingStrategy
    line_height: winrt.system.Double
    character_spacing: winrt.system.Int32
    is_text_selection_enabled: winrt.system.Boolean
    selected_text: str
    selection_end: typing.Optional[winrt.windows.ui.xaml.documents.TextPointer]
    selection_start: typing.Optional[winrt.windows.ui.xaml.documents.TextPointer]
    baseline_offset: winrt.system.Double
    content_end: typing.Optional[winrt.windows.ui.xaml.documents.TextPointer]
    content_start: typing.Optional[winrt.windows.ui.xaml.documents.TextPointer]
    inlines: typing.Optional[winrt.windows.ui.xaml.documents.InlineCollection]
    text_reading_order: winrt.windows.ui.xaml.TextReadingOrder
    text_line_bounds: winrt.windows.ui.xaml.TextLineBounds
    selection_highlight_color: typing.Optional[winrt.windows.ui.xaml.media.SolidColorBrush]
    optical_margin_alignment: winrt.windows.ui.xaml.OpticalMarginAlignment
    max_lines: winrt.system.Int32
    is_color_font_enabled: winrt.system.Boolean
    is_text_scale_factor_enabled: winrt.system.Boolean
    text_decorations: winrt.windows.ui.text.TextDecorations
    horizontal_text_alignment: winrt.windows.ui.xaml.TextAlignment
    is_text_trimmed: winrt.system.Boolean
    text_highlighters: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.ui.xaml.documents.TextHighlighter]]
    selection_flyout: typing.Optional[winrt.windows.ui.xaml.controls.primitives.FlyoutBase]
    character_spacing_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    font_family_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    font_size_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    font_stretch_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    font_style_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    font_weight_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    foreground_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_text_selection_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    line_height_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    line_stacking_strategy_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    padding_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    selected_text_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    text_alignment_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    text_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    text_trimming_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    text_wrapping_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_color_font_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    max_lines_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    optical_margin_alignment_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    selection_highlight_color_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    text_line_bounds_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    text_reading_order_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_text_scale_factor_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    text_decorations_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    horizontal_text_alignment_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_text_trimmed_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    selection_flyout_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TextBlock: ...
    def __new__(cls: typing.Type[TextBlock]) -> TextBlock:...
    def copy_selection_to_clipboard(self) -> None: ...
    def focus(self, value: winrt.windows.ui.xaml.FocusState, /) -> winrt.system.Boolean: ...
    def get_alpha_mask(self) -> typing.Optional[winrt.windows.ui.composition.CompositionBrush]: ...
    def select(self, start: typing.Optional[winrt.windows.ui.xaml.documents.TextPointer], end: typing.Optional[winrt.windows.ui.xaml.documents.TextPointer], /) -> None: ...
    def select_all(self) -> None: ...
    def add_context_menu_opening(self, handler: typing.Optional[ContextMenuOpeningEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_context_menu_opening(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_selection_changed(self, handler: typing.Optional[winrt.windows.ui.xaml.RoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_selection_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_is_text_trimmed_changed(self, handler: winrt.windows.foundation.TypedEventHandler[TextBlock, IsTextTrimmedChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_is_text_trimmed_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class TextBox(winrt.system.Object):
    text_wrapping: winrt.windows.ui.xaml.TextWrapping
    text_alignment: winrt.windows.ui.xaml.TextAlignment
    text: str
    selection_start: winrt.system.Int32
    selection_length: winrt.system.Int32
    selected_text: str
    max_length: winrt.system.Int32
    is_text_prediction_enabled: winrt.system.Boolean
    is_spell_check_enabled: winrt.system.Boolean
    is_read_only: winrt.system.Boolean
    input_scope: typing.Optional[winrt.windows.ui.xaml.input.InputScope]
    accepts_return: winrt.system.Boolean
    is_color_font_enabled: winrt.system.Boolean
    placeholder_text: str
    prevent_keyboard_display_on_programmatic_focus: winrt.system.Boolean
    selection_highlight_color: typing.Optional[winrt.windows.ui.xaml.media.SolidColorBrush]
    header_template: typing.Optional[winrt.windows.ui.xaml.DataTemplate]
    header: typing.Optional[winrt.system.Object]
    desired_candidate_window_alignment: CandidateWindowAlignment
    text_reading_order: winrt.windows.ui.xaml.TextReadingOrder
    selection_highlight_color_when_not_focused: typing.Optional[winrt.windows.ui.xaml.media.SolidColorBrush]
    placeholder_foreground: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    horizontal_text_alignment: winrt.windows.ui.xaml.TextAlignment
    character_casing: CharacterCasing
    is_handwriting_view_enabled: winrt.system.Boolean
    handwriting_view: typing.Optional[HandwritingView]
    selection_flyout: typing.Optional[winrt.windows.ui.xaml.controls.primitives.FlyoutBase]
    description: typing.Optional[winrt.system.Object]
    can_paste_clipboard_content: winrt.system.Boolean
    can_redo: winrt.system.Boolean
    can_undo: winrt.system.Boolean
    proofing_menu_flyout: typing.Optional[winrt.windows.ui.xaml.controls.primitives.FlyoutBase]
    text_wrapping_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    text_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    text_alignment_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    max_length_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_text_prediction_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_spell_check_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_read_only_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    input_scope_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    accepts_return_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    header_template_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    header_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    selection_highlight_color_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    prevent_keyboard_display_on_programmatic_focus_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    placeholder_text_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_color_font_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    desired_candidate_window_alignment_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    text_reading_order_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    selection_highlight_color_when_not_focused_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    placeholder_foreground_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    horizontal_text_alignment_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    character_casing_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_handwriting_view_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    handwriting_view_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    selection_flyout_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    proofing_menu_flyout_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    description_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    can_undo_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    can_redo_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    can_paste_clipboard_content_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TextBox: ...
    def __new__(cls: typing.Type[TextBox]) -> TextBox:...
    def clear_undo_redo_history(self) -> None: ...
    def copy_selection_to_clipboard(self) -> None: ...
    def cut_selection_to_clipboard(self) -> None: ...
    def get_linguistic_alternatives_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[str]]: ...
    def get_rect_from_character_index(self, char_index: winrt.system.Int32, trailing_edge: winrt.system.Boolean, /) -> winrt.windows.foundation.Rect: ...
    def paste_from_clipboard(self) -> None: ...
    def redo(self) -> None: ...
    def select(self, start: winrt.system.Int32, length: winrt.system.Int32, /) -> None: ...
    def select_all(self) -> None: ...
    def undo(self) -> None: ...
    def add_context_menu_opening(self, handler: typing.Optional[ContextMenuOpeningEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_context_menu_opening(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_selection_changed(self, handler: typing.Optional[winrt.windows.ui.xaml.RoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_selection_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_text_changed(self, handler: typing.Optional[TextChangedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_text_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_paste(self, handler: typing.Optional[TextControlPasteEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_paste(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_candidate_window_bounds_changed(self, handler: winrt.windows.foundation.TypedEventHandler[TextBox, CandidateWindowBoundsChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_candidate_window_bounds_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_text_changing(self, handler: winrt.windows.foundation.TypedEventHandler[TextBox, TextBoxTextChangingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_text_changing(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_text_composition_changed(self, handler: winrt.windows.foundation.TypedEventHandler[TextBox, TextCompositionChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_text_composition_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_text_composition_ended(self, handler: winrt.windows.foundation.TypedEventHandler[TextBox, TextCompositionEndedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_text_composition_ended(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_text_composition_started(self, handler: winrt.windows.foundation.TypedEventHandler[TextBox, TextCompositionStartedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_text_composition_started(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_before_text_changing(self, handler: winrt.windows.foundation.TypedEventHandler[TextBox, TextBoxBeforeTextChangingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_before_text_changing(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_copying_to_clipboard(self, handler: winrt.windows.foundation.TypedEventHandler[TextBox, TextControlCopyingToClipboardEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_copying_to_clipboard(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_cutting_to_clipboard(self, handler: winrt.windows.foundation.TypedEventHandler[TextBox, TextControlCuttingToClipboardEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_cutting_to_clipboard(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_selection_changing(self, handler: winrt.windows.foundation.TypedEventHandler[TextBox, TextBoxSelectionChangingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_selection_changing(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class TextBoxBeforeTextChangingEventArgs(winrt.system.Object):
    cancel: winrt.system.Boolean
    new_text: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TextBoxBeforeTextChangingEventArgs: ...

class TextBoxSelectionChangingEventArgs(winrt.system.Object):
    cancel: winrt.system.Boolean
    selection_length: winrt.system.Int32
    selection_start: winrt.system.Int32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TextBoxSelectionChangingEventArgs: ...

class TextBoxTextChangingEventArgs(winrt.system.Object):
    is_content_changing: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TextBoxTextChangingEventArgs: ...

class TextChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TextChangedEventArgs: ...

class TextCommandBarFlyout(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TextCommandBarFlyout: ...
    def __new__(cls: typing.Type[TextCommandBarFlyout]) -> TextCommandBarFlyout:...

class TextCompositionChangedEventArgs(winrt.system.Object):
    length: winrt.system.Int32
    start_index: winrt.system.Int32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TextCompositionChangedEventArgs: ...

class TextCompositionEndedEventArgs(winrt.system.Object):
    length: winrt.system.Int32
    start_index: winrt.system.Int32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TextCompositionEndedEventArgs: ...

class TextCompositionStartedEventArgs(winrt.system.Object):
    length: winrt.system.Int32
    start_index: winrt.system.Int32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TextCompositionStartedEventArgs: ...

class TextControlCopyingToClipboardEventArgs(winrt.system.Object):
    handled: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TextControlCopyingToClipboardEventArgs: ...

class TextControlCuttingToClipboardEventArgs(winrt.system.Object):
    handled: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TextControlCuttingToClipboardEventArgs: ...

class TextControlPasteEventArgs(winrt.system.Object):
    handled: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TextControlPasteEventArgs: ...

class TimePickedEventArgs(winrt.system.Object):
    new_time: datetime.timedelta
    old_time: datetime.timedelta
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TimePickedEventArgs: ...
    def __new__(cls: typing.Type[TimePickedEventArgs]) -> TimePickedEventArgs:...

class TimePicker(winrt.system.Object):
    time: datetime.timedelta
    minute_increment: winrt.system.Int32
    header_template: typing.Optional[winrt.windows.ui.xaml.DataTemplate]
    header: typing.Optional[winrt.system.Object]
    clock_identifier: str
    light_dismiss_overlay_mode: LightDismissOverlayMode
    selected_time: typing.Optional[typing.Optional[datetime.timedelta]]
    clock_identifier_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    header_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    header_template_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    minute_increment_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    time_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    light_dismiss_overlay_mode_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    selected_time_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TimePicker: ...
    def __new__(cls: typing.Type[TimePicker]) -> TimePicker:...
    def add_time_changed(self, handler: winrt.windows.foundation.EventHandler[TimePickerValueChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_time_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_selected_time_changed(self, handler: winrt.windows.foundation.TypedEventHandler[TimePicker, TimePickerSelectedValueChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_selected_time_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class TimePickerFlyout(winrt.system.Object):
    time: datetime.timedelta
    minute_increment: winrt.system.Int32
    clock_identifier: str
    clock_identifier_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    minute_increment_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    time_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TimePickerFlyout: ...
    def __new__(cls: typing.Type[TimePickerFlyout]) -> TimePickerFlyout:...
    def show_at_async(self, target: typing.Optional[winrt.windows.ui.xaml.FrameworkElement], /) -> winrt.windows.foundation.IAsyncOperation[typing.Optional[datetime.timedelta]]: ...
    def add_time_picked(self, handler: winrt.windows.foundation.TypedEventHandler[TimePickerFlyout, TimePickedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_time_picked(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class TimePickerFlyoutPresenter(winrt.system.Object):
    is_default_shadow_enabled: winrt.system.Boolean
    is_default_shadow_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TimePickerFlyoutPresenter: ...

class TimePickerSelectedValueChangedEventArgs(winrt.system.Object):
    new_time: typing.Optional[typing.Optional[datetime.timedelta]]
    old_time: typing.Optional[typing.Optional[datetime.timedelta]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TimePickerSelectedValueChangedEventArgs: ...

class TimePickerValueChangedEventArgs(winrt.system.Object):
    new_time: datetime.timedelta
    old_time: datetime.timedelta
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TimePickerValueChangedEventArgs: ...

class ToggleMenuFlyoutItem(winrt.system.Object):
    is_checked: winrt.system.Boolean
    is_checked_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ToggleMenuFlyoutItem: ...
    def __new__(cls: typing.Type[ToggleMenuFlyoutItem]) -> ToggleMenuFlyoutItem:...

class ToggleSplitButton(winrt.system.Object):
    is_checked: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ToggleSplitButton: ...
    def __new__(cls: typing.Type[ToggleSplitButton]) -> ToggleSplitButton:...
    def add_is_checked_changed(self, handler: winrt.windows.foundation.TypedEventHandler[ToggleSplitButton, ToggleSplitButtonIsCheckedChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_is_checked_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class ToggleSplitButtonAutomationPeer(winrt.system.Object):
    expand_collapse_state: winrt.windows.ui.xaml.automation.ExpandCollapseState
    toggle_state: winrt.windows.ui.xaml.automation.ToggleState
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ToggleSplitButtonAutomationPeer: ...
    def __new__(cls: typing.Type[ToggleSplitButtonAutomationPeer], owner: typing.Optional[ToggleSplitButton]) -> ToggleSplitButtonAutomationPeer:...
    def collapse(self) -> None: ...
    def expand(self) -> None: ...
    def toggle(self) -> None: ...

class ToggleSplitButtonIsCheckedChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ToggleSplitButtonIsCheckedChangedEventArgs: ...

class ToggleSwitch(winrt.system.Object):
    on_content_template: typing.Optional[winrt.windows.ui.xaml.DataTemplate]
    on_content: typing.Optional[winrt.system.Object]
    off_content_template: typing.Optional[winrt.windows.ui.xaml.DataTemplate]
    off_content: typing.Optional[winrt.system.Object]
    is_on: winrt.system.Boolean
    header_template: typing.Optional[winrt.windows.ui.xaml.DataTemplate]
    header: typing.Optional[winrt.system.Object]
    template_settings: typing.Optional[winrt.windows.ui.xaml.controls.primitives.ToggleSwitchTemplateSettings]
    header_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    header_template_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_on_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    off_content_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    off_content_template_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    on_content_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    on_content_template_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ToggleSwitch: ...
    def __new__(cls: typing.Type[ToggleSwitch]) -> ToggleSwitch:...
    def on_header_changed(self, old_content: typing.Optional[winrt.system.Object], new_content: typing.Optional[winrt.system.Object], /) -> None: ...
    def on_off_content_changed(self, old_content: typing.Optional[winrt.system.Object], new_content: typing.Optional[winrt.system.Object], /) -> None: ...
    def on_on_content_changed(self, old_content: typing.Optional[winrt.system.Object], new_content: typing.Optional[winrt.system.Object], /) -> None: ...
    def on_toggled(self) -> None: ...
    def add_toggled(self, handler: typing.Optional[winrt.windows.ui.xaml.RoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_toggled(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class ToolTip(winrt.system.Object):
    vertical_offset: winrt.system.Double
    placement_target: typing.Optional[winrt.windows.ui.xaml.UIElement]
    placement: winrt.windows.ui.xaml.controls.primitives.PlacementMode
    is_open: winrt.system.Boolean
    horizontal_offset: winrt.system.Double
    template_settings: typing.Optional[winrt.windows.ui.xaml.controls.primitives.ToolTipTemplateSettings]
    placement_rect: typing.Optional[typing.Optional[winrt.windows.foundation.Rect]]
    horizontal_offset_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_open_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    placement_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    placement_target_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    vertical_offset_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    placement_rect_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ToolTip: ...
    def __new__(cls: typing.Type[ToolTip]) -> ToolTip:...
    def add_closed(self, handler: typing.Optional[winrt.windows.ui.xaml.RoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_closed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_opened(self, handler: typing.Optional[winrt.windows.ui.xaml.RoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_opened(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class ToolTipService(winrt.system.Object):
    placement_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    placement_target_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    tool_tip_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ToolTipService: ...
    @staticmethod
    def get_placement(element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> winrt.windows.ui.xaml.controls.primitives.PlacementMode: ...
    @staticmethod
    def get_placement_target(element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> typing.Optional[winrt.windows.ui.xaml.UIElement]: ...
    @staticmethod
    def get_tool_tip(element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> typing.Optional[winrt.system.Object]: ...
    @staticmethod
    def set_placement(element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], value: winrt.windows.ui.xaml.controls.primitives.PlacementMode, /) -> None: ...
    @staticmethod
    def set_placement_target(element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], value: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> None: ...
    @staticmethod
    def set_tool_tip(element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], value: typing.Optional[winrt.system.Object], /) -> None: ...

class TreeView(winrt.system.Object):
    selection_mode: TreeViewSelectionMode
    root_nodes: typing.Optional[winrt.windows.foundation.collections.IVector[TreeViewNode]]
    selected_nodes: typing.Optional[winrt.windows.foundation.collections.IVector[TreeViewNode]]
    items_source: typing.Optional[winrt.system.Object]
    item_template_selector: typing.Optional[DataTemplateSelector]
    item_template: typing.Optional[winrt.windows.ui.xaml.DataTemplate]
    item_container_transitions: typing.Optional[winrt.windows.ui.xaml.media.animation.TransitionCollection]
    item_container_style_selector: typing.Optional[StyleSelector]
    item_container_style: typing.Optional[winrt.windows.ui.xaml.Style]
    can_reorder_items: winrt.system.Boolean
    can_drag_items: winrt.system.Boolean
    selection_mode_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    can_drag_items_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    can_reorder_items_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    item_container_style_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    item_container_style_selector_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    item_container_transitions_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    item_template_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    item_template_selector_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    items_source_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TreeView: ...
    def __new__(cls: typing.Type[TreeView]) -> TreeView:...
    def collapse(self, value: typing.Optional[TreeViewNode], /) -> None: ...
    def container_from_item(self, item: typing.Optional[winrt.system.Object], /) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    def container_from_node(self, node: typing.Optional[TreeViewNode], /) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    def expand(self, value: typing.Optional[TreeViewNode], /) -> None: ...
    def item_from_container(self, container: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> typing.Optional[winrt.system.Object]: ...
    def node_from_container(self, container: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> typing.Optional[TreeViewNode]: ...
    def select_all(self) -> None: ...
    def add_collapsed(self, handler: winrt.windows.foundation.TypedEventHandler[TreeView, TreeViewCollapsedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_collapsed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_expanding(self, handler: winrt.windows.foundation.TypedEventHandler[TreeView, TreeViewExpandingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_expanding(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_item_invoked(self, handler: winrt.windows.foundation.TypedEventHandler[TreeView, TreeViewItemInvokedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_item_invoked(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_drag_items_completed(self, handler: winrt.windows.foundation.TypedEventHandler[TreeView, TreeViewDragItemsCompletedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_drag_items_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_drag_items_starting(self, handler: winrt.windows.foundation.TypedEventHandler[TreeView, TreeViewDragItemsStartingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_drag_items_starting(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class TreeViewCollapsedEventArgs(winrt.system.Object):
    node: typing.Optional[TreeViewNode]
    item: typing.Optional[winrt.system.Object]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TreeViewCollapsedEventArgs: ...

class TreeViewDragItemsCompletedEventArgs(winrt.system.Object):
    drop_result: winrt.windows.applicationmodel.datatransfer.DataPackageOperation
    items: typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Object]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TreeViewDragItemsCompletedEventArgs: ...

class TreeViewDragItemsStartingEventArgs(winrt.system.Object):
    cancel: winrt.system.Boolean
    data: typing.Optional[winrt.windows.applicationmodel.datatransfer.DataPackage]
    items: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.system.Object]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TreeViewDragItemsStartingEventArgs: ...

class TreeViewExpandingEventArgs(winrt.system.Object):
    node: typing.Optional[TreeViewNode]
    item: typing.Optional[winrt.system.Object]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TreeViewExpandingEventArgs: ...

class TreeViewItem(winrt.system.Object):
    is_expanded: winrt.system.Boolean
    glyph_size: winrt.system.Double
    glyph_opacity: winrt.system.Double
    glyph_brush: typing.Optional[winrt.windows.ui.xaml.media.Brush]
    expanded_glyph: str
    collapsed_glyph: str
    tree_view_item_template_settings: typing.Optional[TreeViewItemTemplateSettings]
    items_source: typing.Optional[winrt.system.Object]
    has_unrealized_children: winrt.system.Boolean
    collapsed_glyph_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    expanded_glyph_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    glyph_brush_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    glyph_opacity_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    glyph_size_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_expanded_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    tree_view_item_template_settings_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    has_unrealized_children_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    items_source_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TreeViewItem: ...
    def __new__(cls: typing.Type[TreeViewItem]) -> TreeViewItem:...

class TreeViewItemInvokedEventArgs(winrt.system.Object):
    handled: winrt.system.Boolean
    invoked_item: typing.Optional[winrt.system.Object]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TreeViewItemInvokedEventArgs: ...

class TreeViewItemTemplateSettings(winrt.system.Object):
    collapsed_glyph_visibility: winrt.windows.ui.xaml.Visibility
    drag_items_count: winrt.system.Int32
    expanded_glyph_visibility: winrt.windows.ui.xaml.Visibility
    indentation: winrt.windows.ui.xaml.Thickness
    collapsed_glyph_visibility_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    drag_items_count_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    expanded_glyph_visibility_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    indentation_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TreeViewItemTemplateSettings: ...
    def __new__(cls: typing.Type[TreeViewItemTemplateSettings]) -> TreeViewItemTemplateSettings:...

class TreeViewList(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TreeViewList: ...
    def __new__(cls: typing.Type[TreeViewList]) -> TreeViewList:...

class TreeViewNode(winrt.system.Object):
    is_expanded: winrt.system.Boolean
    has_unrealized_children: winrt.system.Boolean
    content: typing.Optional[winrt.system.Object]
    children: typing.Optional[winrt.windows.foundation.collections.IVector[TreeViewNode]]
    depth: winrt.system.Int32
    has_children: winrt.system.Boolean
    parent: typing.Optional[TreeViewNode]
    content_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    depth_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    has_children_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_expanded_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TreeViewNode: ...
    def __new__(cls: typing.Type[TreeViewNode]) -> TreeViewNode:...

class TwoPaneView(winrt.system.Object):
    wide_mode_configuration: TwoPaneViewWideModeConfiguration
    tall_mode_configuration: TwoPaneViewTallModeConfiguration
    pane_priority: TwoPaneViewPriority
    pane2_length: winrt.windows.ui.xaml.GridLength
    pane2: typing.Optional[winrt.windows.ui.xaml.UIElement]
    pane1_length: winrt.windows.ui.xaml.GridLength
    pane1: typing.Optional[winrt.windows.ui.xaml.UIElement]
    min_wide_mode_width: winrt.system.Double
    min_tall_mode_height: winrt.system.Double
    mode: TwoPaneViewMode
    min_tall_mode_height_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    min_wide_mode_width_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    mode_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    pane1_length_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    pane1_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    pane2_length_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    pane2_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    pane_priority_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    tall_mode_configuration_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    wide_mode_configuration_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TwoPaneView: ...
    def __new__(cls: typing.Type[TwoPaneView]) -> TwoPaneView:...
    def add_mode_changed(self, handler: winrt.windows.foundation.TypedEventHandler[TwoPaneView, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_mode_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class UIElementCollection(winrt.system.Object, typing.MutableSequence[winrt.windows.ui.xaml.UIElement]):
    size: winrt.system.UInt32
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> winrt.windows.ui.xaml.UIElement: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[winrt.windows.ui.xaml.UIElement]: ...
    def insert(self, index: int, value: winrt.windows.ui.xaml.UIElement) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: winrt.windows.ui.xaml.UIElement) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[winrt.windows.ui.xaml.UIElement]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UIElementCollection: ...
    def append(self, value: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[winrt.windows.ui.xaml.UIElement]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[winrt.windows.ui.xaml.UIElement]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[winrt.windows.ui.xaml.UIElement], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.ui.xaml.UIElement]]: ...
    def index_of(self, value: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> typing.Tuple[winrt.system.Boolean, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> None: ...
    def move(self, old_index: winrt.system.UInt32, new_index: winrt.system.UInt32, /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[winrt.windows.ui.xaml.UIElement], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> None: ...

class UserControl(winrt.system.Object):
    content: typing.Optional[winrt.windows.ui.xaml.UIElement]
    content_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UserControl: ...
    def __new__(cls: typing.Type[UserControl]) -> UserControl:...

class VariableSizedWrapGrid(winrt.system.Object):
    vertical_children_alignment: winrt.windows.ui.xaml.VerticalAlignment
    orientation: Orientation
    maximum_rows_or_columns: winrt.system.Int32
    item_width: winrt.system.Double
    item_height: winrt.system.Double
    horizontal_children_alignment: winrt.windows.ui.xaml.HorizontalAlignment
    column_span_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    horizontal_children_alignment_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    item_height_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    item_width_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    maximum_rows_or_columns_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    orientation_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    row_span_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    vertical_children_alignment_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VariableSizedWrapGrid: ...
    def __new__(cls: typing.Type[VariableSizedWrapGrid]) -> VariableSizedWrapGrid:...
    @staticmethod
    def get_column_span(element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> winrt.system.Int32: ...
    @staticmethod
    def get_row_span(element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> winrt.system.Int32: ...
    @staticmethod
    def set_column_span(element: typing.Optional[winrt.windows.ui.xaml.UIElement], value: winrt.system.Int32, /) -> None: ...
    @staticmethod
    def set_row_span(element: typing.Optional[winrt.windows.ui.xaml.UIElement], value: winrt.system.Int32, /) -> None: ...

class Viewbox(winrt.system.Object):
    stretch_direction: StretchDirection
    stretch: winrt.windows.ui.xaml.media.Stretch
    child: typing.Optional[winrt.windows.ui.xaml.UIElement]
    stretch_direction_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    stretch_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Viewbox: ...
    def __new__(cls: typing.Type[Viewbox]) -> Viewbox:...

class VirtualizingPanel(winrt.system.Object):
    item_container_generator: typing.Optional[ItemContainerGenerator]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VirtualizingPanel: ...
    def add_internal_child(self, child: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> None: ...
    def bring_index_into_view(self, index: winrt.system.Int32, /) -> None: ...
    def insert_internal_child(self, index: winrt.system.Int32, child: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> None: ...
    def on_clear_children(self) -> None: ...
    def on_items_changed(self, sender: typing.Optional[winrt.system.Object], args: typing.Optional[winrt.windows.ui.xaml.controls.primitives.ItemsChangedEventArgs], /) -> None: ...
    def remove_internal_child_range(self, index: winrt.system.Int32, range: winrt.system.Int32, /) -> None: ...

class VirtualizingStackPanel(winrt.system.Object):
    orientation: Orientation
    are_scroll_snap_points_regular: winrt.system.Boolean
    are_scroll_snap_points_regular_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_virtualizing_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    orientation_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    virtualization_mode_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VirtualizingStackPanel: ...
    def __new__(cls: typing.Type[VirtualizingStackPanel]) -> VirtualizingStackPanel:...
    @staticmethod
    def get_is_virtualizing(o: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> winrt.system.Boolean: ...
    @staticmethod
    def get_virtualization_mode(element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> VirtualizationMode: ...
    def on_clean_up_virtualized_item(self, e: typing.Optional[CleanUpVirtualizedItemEventArgs], /) -> None: ...
    @staticmethod
    def set_virtualization_mode(element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], value: VirtualizationMode, /) -> None: ...
    def add_clean_up_virtualized_item_event(self, handler: typing.Optional[CleanUpVirtualizedItemEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_clean_up_virtualized_item_event(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class WebView(winrt.system.Object):
    source: typing.Optional[winrt.windows.foundation.Uri]
    allowed_script_notify_uris: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.foundation.Uri]]
    data_transfer_package: typing.Optional[winrt.windows.applicationmodel.datatransfer.DataPackage]
    default_background_color: winrt.windows.ui.Color
    can_go_back: winrt.system.Boolean
    can_go_forward: winrt.system.Boolean
    document_title: str
    contains_full_screen_element: winrt.system.Boolean
    deferred_permission_requests: typing.Optional[winrt.windows.foundation.collections.IVector[WebViewDeferredPermissionRequest]]
    execution_mode: WebViewExecutionMode
    settings: typing.Optional[WebViewSettings]
    x_y_focus_up: typing.Optional[winrt.windows.ui.xaml.DependencyObject]
    x_y_focus_right: typing.Optional[winrt.windows.ui.xaml.DependencyObject]
    x_y_focus_left: typing.Optional[winrt.windows.ui.xaml.DependencyObject]
    x_y_focus_down: typing.Optional[winrt.windows.ui.xaml.DependencyObject]
    allowed_script_notify_uris_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    any_script_notify_uri: typing.ClassVar[typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.foundation.Uri]]]
    data_transfer_package_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    source_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    can_go_back_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    can_go_forward_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    default_background_color_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    document_title_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    contains_full_screen_element_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    default_execution_mode: typing.ClassVar[WebViewExecutionMode]
    x_y_focus_down_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    x_y_focus_left_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    x_y_focus_right_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    x_y_focus_up_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WebView: ...
    @typing.overload
    def __new__(cls: typing.Type[WebView], execution_mode: WebViewExecutionMode) -> WebView:...
    @typing.overload
    def __new__(cls: typing.Type[WebView]) -> WebView:...
    def add_web_allowed_object(self, name: str, p_object: typing.Optional[winrt.system.Object], /) -> None: ...
    def build_local_stream_uri(self, content_identifier: str, relative_path: str, /) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    def capture_preview_to_stream_async(self, stream: typing.Optional[winrt.windows.storage.streams.IRandomAccessStream], /) -> winrt.windows.foundation.IAsyncAction: ...
    def capture_selected_content_to_data_package_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.applicationmodel.datatransfer.DataPackage]: ...
    @staticmethod
    def clear_temporary_web_data_async() -> winrt.windows.foundation.IAsyncAction: ...
    def deferred_permission_request_by_id(self, id: winrt.system.UInt32, /) -> typing.Optional[WebViewDeferredPermissionRequest]: ...
    def focus(self, value: winrt.windows.ui.xaml.FocusState, /) -> winrt.system.Boolean: ...
    def go_back(self) -> None: ...
    def go_forward(self) -> None: ...
    def invoke_script(self, script_name: str, arguments: winrt.system.Array[str], /) -> str: ...
    def invoke_script_async(self, script_name: str, arguments: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncOperation[str]: ...
    def navigate(self, source: typing.Optional[winrt.windows.foundation.Uri], /) -> None: ...
    def navigate_to_local_stream_uri(self, source: typing.Optional[winrt.windows.foundation.Uri], stream_resolver: typing.Optional[winrt.windows.web.IUriToStreamResolver], /) -> None: ...
    def navigate_to_string(self, text: str, /) -> None: ...
    def navigate_with_http_request_message(self, request_message: typing.Optional[winrt.windows.web.http.HttpRequestMessage], /) -> None: ...
    def refresh(self) -> None: ...
    def stop(self) -> None: ...
    def add_load_completed(self, handler: typing.Optional[winrt.windows.ui.xaml.navigation.LoadCompletedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_load_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_navigation_failed(self, handler: typing.Optional[WebViewNavigationFailedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_navigation_failed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_script_notify(self, handler: typing.Optional[NotifyEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_script_notify(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_content_loading(self, handler: winrt.windows.foundation.TypedEventHandler[WebView, WebViewContentLoadingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_content_loading(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_d_o_m_content_loaded(self, handler: winrt.windows.foundation.TypedEventHandler[WebView, WebViewDOMContentLoadedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_d_o_m_content_loaded(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_frame_content_loading(self, handler: winrt.windows.foundation.TypedEventHandler[WebView, WebViewContentLoadingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_frame_content_loading(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_frame_d_o_m_content_loaded(self, handler: winrt.windows.foundation.TypedEventHandler[WebView, WebViewDOMContentLoadedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_frame_d_o_m_content_loaded(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_frame_navigation_completed(self, handler: winrt.windows.foundation.TypedEventHandler[WebView, WebViewNavigationCompletedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_frame_navigation_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_frame_navigation_starting(self, handler: winrt.windows.foundation.TypedEventHandler[WebView, WebViewNavigationStartingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_frame_navigation_starting(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_long_running_script_detected(self, handler: winrt.windows.foundation.TypedEventHandler[WebView, WebViewLongRunningScriptDetectedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_long_running_script_detected(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_navigation_completed(self, handler: winrt.windows.foundation.TypedEventHandler[WebView, WebViewNavigationCompletedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_navigation_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_navigation_starting(self, handler: winrt.windows.foundation.TypedEventHandler[WebView, WebViewNavigationStartingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_navigation_starting(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_unsafe_content_warning_displaying(self, handler: winrt.windows.foundation.TypedEventHandler[WebView, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_unsafe_content_warning_displaying(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_unviewable_content_identified(self, handler: winrt.windows.foundation.TypedEventHandler[WebView, WebViewUnviewableContentIdentifiedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_unviewable_content_identified(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_contains_full_screen_element_changed(self, handler: winrt.windows.foundation.TypedEventHandler[WebView, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_contains_full_screen_element_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_new_window_requested(self, handler: winrt.windows.foundation.TypedEventHandler[WebView, WebViewNewWindowRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_new_window_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_permission_requested(self, handler: winrt.windows.foundation.TypedEventHandler[WebView, WebViewPermissionRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_permission_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_unsupported_uri_scheme_identified(self, handler: winrt.windows.foundation.TypedEventHandler[WebView, WebViewUnsupportedUriSchemeIdentifiedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_unsupported_uri_scheme_identified(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_separate_process_lost(self, handler: winrt.windows.foundation.TypedEventHandler[WebView, WebViewSeparateProcessLostEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_separate_process_lost(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_web_resource_requested(self, handler: winrt.windows.foundation.TypedEventHandler[WebView, WebViewWebResourceRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_web_resource_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class WebViewBrush(winrt.system.Object):
    source_name: str
    source_name_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WebViewBrush: ...
    def __new__(cls: typing.Type[WebViewBrush]) -> WebViewBrush:...
    def redraw(self) -> None: ...
    def set_source(self, source: typing.Optional[WebView], /) -> None: ...

class WebViewContentLoadingEventArgs(winrt.system.Object):
    uri: typing.Optional[winrt.windows.foundation.Uri]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WebViewContentLoadingEventArgs: ...

class WebViewDOMContentLoadedEventArgs(winrt.system.Object):
    uri: typing.Optional[winrt.windows.foundation.Uri]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WebViewDOMContentLoadedEventArgs: ...

class WebViewDeferredPermissionRequest(winrt.system.Object):
    id: winrt.system.UInt32
    permission_type: WebViewPermissionType
    uri: typing.Optional[winrt.windows.foundation.Uri]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WebViewDeferredPermissionRequest: ...
    def allow(self) -> None: ...
    def deny(self) -> None: ...

class WebViewLongRunningScriptDetectedEventArgs(winrt.system.Object):
    stop_page_script_execution: winrt.system.Boolean
    execution_time: datetime.timedelta
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WebViewLongRunningScriptDetectedEventArgs: ...

class WebViewNavigationCompletedEventArgs(winrt.system.Object):
    is_success: winrt.system.Boolean
    uri: typing.Optional[winrt.windows.foundation.Uri]
    web_error_status: winrt.windows.web.WebErrorStatus
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WebViewNavigationCompletedEventArgs: ...

class WebViewNavigationFailedEventArgs(winrt.system.Object):
    uri: typing.Optional[winrt.windows.foundation.Uri]
    web_error_status: winrt.windows.web.WebErrorStatus
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WebViewNavigationFailedEventArgs: ...

class WebViewNavigationStartingEventArgs(winrt.system.Object):
    cancel: winrt.system.Boolean
    uri: typing.Optional[winrt.windows.foundation.Uri]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WebViewNavigationStartingEventArgs: ...

class WebViewNewWindowRequestedEventArgs(winrt.system.Object):
    handled: winrt.system.Boolean
    referrer: typing.Optional[winrt.windows.foundation.Uri]
    uri: typing.Optional[winrt.windows.foundation.Uri]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WebViewNewWindowRequestedEventArgs: ...

class WebViewPermissionRequest(winrt.system.Object):
    id: winrt.system.UInt32
    permission_type: WebViewPermissionType
    state: WebViewPermissionState
    uri: typing.Optional[winrt.windows.foundation.Uri]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WebViewPermissionRequest: ...
    def allow(self) -> None: ...
    def defer(self) -> None: ...
    def deny(self) -> None: ...

class WebViewPermissionRequestedEventArgs(winrt.system.Object):
    permission_request: typing.Optional[WebViewPermissionRequest]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WebViewPermissionRequestedEventArgs: ...

class WebViewSeparateProcessLostEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WebViewSeparateProcessLostEventArgs: ...

class WebViewSettings(winrt.system.Object):
    is_java_script_enabled: winrt.system.Boolean
    is_indexed_d_b_enabled: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WebViewSettings: ...

class WebViewUnsupportedUriSchemeIdentifiedEventArgs(winrt.system.Object):
    handled: winrt.system.Boolean
    uri: typing.Optional[winrt.windows.foundation.Uri]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WebViewUnsupportedUriSchemeIdentifiedEventArgs: ...

class WebViewUnviewableContentIdentifiedEventArgs(winrt.system.Object):
    referrer: typing.Optional[winrt.windows.foundation.Uri]
    uri: typing.Optional[winrt.windows.foundation.Uri]
    media_type: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WebViewUnviewableContentIdentifiedEventArgs: ...

class WebViewWebResourceRequestedEventArgs(winrt.system.Object):
    response: typing.Optional[winrt.windows.web.http.HttpResponseMessage]
    request: typing.Optional[winrt.windows.web.http.HttpRequestMessage]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WebViewWebResourceRequestedEventArgs: ...
    def get_deferral(self) -> typing.Optional[winrt.windows.foundation.Deferral]: ...

class WrapGrid(winrt.system.Object):
    vertical_children_alignment: winrt.windows.ui.xaml.VerticalAlignment
    orientation: Orientation
    maximum_rows_or_columns: winrt.system.Int32
    item_width: winrt.system.Double
    item_height: winrt.system.Double
    horizontal_children_alignment: winrt.windows.ui.xaml.HorizontalAlignment
    horizontal_children_alignment_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    item_height_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    item_width_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    maximum_rows_or_columns_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    orientation_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    vertical_children_alignment_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WrapGrid: ...
    def __new__(cls: typing.Type[WrapGrid]) -> WrapGrid:...

class ICommandBarElement(winrt.system.Object):
    is_compact: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ICommandBarElement: ...

class ICommandBarElement2(winrt.system.Object):
    dynamic_overflow_order: winrt.system.Int32
    is_in_overflow: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ICommandBarElement2: ...

class IInsertionPanel(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IInsertionPanel: ...
    def get_insertion_indexes(self, position: winrt.windows.foundation.Point, /) -> typing.Tuple[winrt.system.Int32, winrt.system.Int32]: ...

class IItemContainerMapping(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IItemContainerMapping: ...
    def container_from_index(self, index: winrt.system.Int32, /) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    def container_from_item(self, item: typing.Optional[winrt.system.Object], /) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    def index_from_container(self, container: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> winrt.system.Int32: ...
    def item_from_container(self, container: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> typing.Optional[winrt.system.Object]: ...

class INavigate(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> INavigate: ...
    def navigate(self, source_page_type: winrt.windows.ui.xaml.interop.TypeName, /) -> winrt.system.Boolean: ...

class IScrollAnchorProvider(winrt.system.Object):
    current_anchor: typing.Optional[winrt.windows.ui.xaml.UIElement]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IScrollAnchorProvider: ...
    def register_anchor_candidate(self, element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> None: ...
    def unregister_anchor_candidate(self, element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> None: ...

class ISemanticZoomInformation(winrt.system.Object):
    is_active_view: winrt.system.Boolean
    is_zoomed_in_view: winrt.system.Boolean
    semantic_zoom_owner: typing.Optional[SemanticZoom]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ISemanticZoomInformation: ...
    def complete_view_change(self) -> None: ...
    def complete_view_change_from(self, source: typing.Optional[SemanticZoomLocation], destination: typing.Optional[SemanticZoomLocation], /) -> None: ...
    def complete_view_change_to(self, source: typing.Optional[SemanticZoomLocation], destination: typing.Optional[SemanticZoomLocation], /) -> None: ...
    def initialize_view_change(self) -> None: ...
    def make_visible(self, item: typing.Optional[SemanticZoomLocation], /) -> None: ...
    def start_view_change_from(self, source: typing.Optional[SemanticZoomLocation], destination: typing.Optional[SemanticZoomLocation], /) -> None: ...
    def start_view_change_to(self, source: typing.Optional[SemanticZoomLocation], destination: typing.Optional[SemanticZoomLocation], /) -> None: ...

BackClickEventHandler = typing.Callable[[typing.Optional[winrt.system.Object], typing.Optional[BackClickEventArgs]], None]

CalendarViewDayItemChangingEventHandler = typing.Callable[[typing.Optional[CalendarView], typing.Optional[CalendarViewDayItemChangingEventArgs]], None]

CleanUpVirtualizedItemEventHandler = typing.Callable[[typing.Optional[winrt.system.Object], typing.Optional[CleanUpVirtualizedItemEventArgs]], None]

ContextMenuOpeningEventHandler = typing.Callable[[typing.Optional[winrt.system.Object], typing.Optional[ContextMenuEventArgs]], None]

DragItemsStartingEventHandler = typing.Callable[[typing.Optional[winrt.system.Object], typing.Optional[DragItemsStartingEventArgs]], None]

HubSectionHeaderClickEventHandler = typing.Callable[[typing.Optional[winrt.system.Object], typing.Optional[HubSectionHeaderClickEventArgs]], None]

ItemClickEventHandler = typing.Callable[[typing.Optional[winrt.system.Object], typing.Optional[ItemClickEventArgs]], None]

ListViewItemToKeyHandler = typing.Callable[[typing.Optional[winrt.system.Object]], str]

ListViewKeyToItemHandler = typing.Callable[[str], winrt.windows.foundation.IAsyncOperation[winrt.system.Object]]

NotifyEventHandler = typing.Callable[[typing.Optional[winrt.system.Object], typing.Optional[NotifyEventArgs]], None]

SectionsInViewChangedEventHandler = typing.Callable[[typing.Optional[winrt.system.Object], typing.Optional[SectionsInViewChangedEventArgs]], None]

SelectionChangedEventHandler = typing.Callable[[typing.Optional[winrt.system.Object], typing.Optional[SelectionChangedEventArgs]], None]

SemanticZoomViewChangedEventHandler = typing.Callable[[typing.Optional[winrt.system.Object], typing.Optional[SemanticZoomViewChangedEventArgs]], None]

TextChangedEventHandler = typing.Callable[[typing.Optional[winrt.system.Object], typing.Optional[TextChangedEventArgs]], None]

TextControlPasteEventHandler = typing.Callable[[typing.Optional[winrt.system.Object], typing.Optional[TextControlPasteEventArgs]], None]

WebViewNavigationFailedEventHandler = typing.Callable[[typing.Optional[winrt.system.Object], typing.Optional[WebViewNavigationFailedEventArgs]], None]

