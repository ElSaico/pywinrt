# WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

import datetime
import sys
import types
import typing
import uuid

import winrt.system
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.foundation.numerics
import winrt.windows.graphics.directx
import winrt.windows.ui.composition

from . import SceneAlphaMode, SceneAttributeSemantic, SceneComponentType, SceneWrappingMode

Self = typing.TypeVar('Self')

class SceneBoundingBox(winrt.system.Object):
    center: winrt.windows.foundation.numerics.Vector3
    extents: winrt.windows.foundation.numerics.Vector3
    max: winrt.windows.foundation.numerics.Vector3
    min: winrt.windows.foundation.numerics.Vector3
    size: winrt.windows.foundation.numerics.Vector3
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SceneBoundingBox: ...

class SceneComponent(winrt.system.Object):
    component_type: SceneComponentType
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SceneComponent: ...

class SceneComponentCollection(winrt.system.Object, typing.MutableSequence[SceneComponent]):
    size: winrt.system.UInt32
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> SceneComponent: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[SceneComponent]: ...
    def insert(self, index: int, value: SceneComponent) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: SceneComponent) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[SceneComponent]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SceneComponentCollection: ...
    def append(self, value: typing.Optional[SceneComponent], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[SceneComponent]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[SceneComponent]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[SceneComponent], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[SceneComponent]]: ...
    def index_of(self, value: typing.Optional[SceneComponent], /) -> typing.Tuple[winrt.system.Boolean, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[SceneComponent], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[SceneComponent], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[SceneComponent], /) -> None: ...

class SceneMaterial(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SceneMaterial: ...

class SceneMaterialInput(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SceneMaterialInput: ...

class SceneMesh(winrt.system.Object):
    primitive_topology: winrt.windows.graphics.directx.DirectXPrimitiveTopology
    bounds: typing.Optional[SceneBoundingBox]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SceneMesh: ...
    @staticmethod
    def create(compositor: typing.Optional[winrt.windows.ui.composition.Compositor], /) -> typing.Optional[SceneMesh]: ...
    def fill_mesh_attribute(self, semantic: SceneAttributeSemantic, format: winrt.windows.graphics.directx.DirectXPixelFormat, memory: typing.Optional[winrt.windows.foundation.MemoryBuffer], /) -> None: ...

class SceneMeshMaterialAttributeMap(winrt.system.Object, typing.MutableMapping[str, SceneAttributeSemantic]):
    size: winrt.system.UInt32
    def __len__(self) -> int: ...
    def __iter__(self) -> typing.Iterator[str]: ...
    def __contains__(self, key: object) -> bool:...
    def __setitem__(self, key: str, value: SceneAttributeSemantic) -> None: ...
    def __getitem__(self, key: str) -> SceneAttributeSemantic: ...
    def __delitem__(self, key: str) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SceneMeshMaterialAttributeMap: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[winrt.windows.foundation.collections.IKeyValuePair[str, SceneAttributeSemantic]]]: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IMapView[str, SceneAttributeSemantic]]: ...
    def has_key(self, key: str, /) -> winrt.system.Boolean: ...
    def insert(self, key: str, value: SceneAttributeSemantic, /) -> winrt.system.Boolean: ...
    def lookup(self, key: str, /) -> SceneAttributeSemantic: ...
    def remove(self, key: str, /) -> None: ...

class SceneMeshRendererComponent(winrt.system.Object):
    mesh: typing.Optional[SceneMesh]
    material: typing.Optional[SceneMaterial]
    u_v_mappings: typing.Optional[SceneMeshMaterialAttributeMap]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SceneMeshRendererComponent: ...
    @staticmethod
    def create(compositor: typing.Optional[winrt.windows.ui.composition.Compositor], /) -> typing.Optional[SceneMeshRendererComponent]: ...

class SceneMetallicRoughnessMaterial(winrt.system.Object):
    roughness_factor: winrt.system.Single
    metallic_roughness_input: typing.Optional[SceneMaterialInput]
    metallic_factor: winrt.system.Single
    base_color_input: typing.Optional[SceneMaterialInput]
    base_color_factor: winrt.windows.foundation.numerics.Vector4
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SceneMetallicRoughnessMaterial: ...
    @staticmethod
    def create(compositor: typing.Optional[winrt.windows.ui.composition.Compositor], /) -> typing.Optional[SceneMetallicRoughnessMaterial]: ...

class SceneModelTransform(winrt.system.Object):
    translation: winrt.windows.foundation.numerics.Vector3
    scale: winrt.windows.foundation.numerics.Vector3
    rotation_axis: winrt.windows.foundation.numerics.Vector3
    rotation_angle_in_degrees: winrt.system.Single
    rotation_angle: winrt.system.Single
    orientation: winrt.windows.foundation.numerics.Quaternion
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SceneModelTransform: ...

class SceneNode(winrt.system.Object):
    children: typing.Optional[SceneNodeCollection]
    components: typing.Optional[SceneComponentCollection]
    parent: typing.Optional[SceneNode]
    transform: typing.Optional[SceneModelTransform]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SceneNode: ...
    @staticmethod
    def create(compositor: typing.Optional[winrt.windows.ui.composition.Compositor], /) -> typing.Optional[SceneNode]: ...
    def find_first_component_of_type(self, value: SceneComponentType, /) -> typing.Optional[SceneComponent]: ...

class SceneNodeCollection(winrt.system.Object, typing.MutableSequence[SceneNode]):
    size: winrt.system.UInt32
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> SceneNode: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[SceneNode]: ...
    def insert(self, index: int, value: SceneNode) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: SceneNode) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[SceneNode]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SceneNodeCollection: ...
    def append(self, value: typing.Optional[SceneNode], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[SceneNode]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[SceneNode]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[SceneNode], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[SceneNode]]: ...
    def index_of(self, value: typing.Optional[SceneNode], /) -> typing.Tuple[winrt.system.Boolean, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[SceneNode], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[SceneNode], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[SceneNode], /) -> None: ...

class SceneObject(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SceneObject: ...

class ScenePbrMaterial(winrt.system.Object):
    occlusion_strength: winrt.system.Single
    occlusion_input: typing.Optional[SceneMaterialInput]
    normal_scale: winrt.system.Single
    normal_input: typing.Optional[SceneMaterialInput]
    is_double_sided: winrt.system.Boolean
    emissive_input: typing.Optional[SceneMaterialInput]
    emissive_factor: winrt.windows.foundation.numerics.Vector3
    alpha_mode: SceneAlphaMode
    alpha_cutoff: winrt.system.Single
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ScenePbrMaterial: ...

class SceneRendererComponent(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SceneRendererComponent: ...

class SceneSurfaceMaterialInput(winrt.system.Object):
    wrapping_v_mode: SceneWrappingMode
    wrapping_u_mode: SceneWrappingMode
    surface: typing.Optional[winrt.windows.ui.composition.ICompositionSurface]
    bitmap_interpolation_mode: winrt.windows.ui.composition.CompositionBitmapInterpolationMode
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SceneSurfaceMaterialInput: ...
    @staticmethod
    def create(compositor: typing.Optional[winrt.windows.ui.composition.Compositor], /) -> typing.Optional[SceneSurfaceMaterialInput]: ...

class SceneVisual(winrt.system.Object):
    root: typing.Optional[SceneNode]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SceneVisual: ...
    @staticmethod
    def create(compositor: typing.Optional[winrt.windows.ui.composition.Compositor], /) -> typing.Optional[SceneVisual]: ...

