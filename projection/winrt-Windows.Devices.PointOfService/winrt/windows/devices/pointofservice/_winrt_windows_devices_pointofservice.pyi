# WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

import datetime
import sys
import types
import typing
import uuid

import winrt.system
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.graphics.imaging
import winrt.windows.storage
import winrt.windows.storage.streams

from . import BarcodeScannerStatus, BarcodeSymbologyDecodeLengthKind, CashDrawerStatusKind, LineDisplayCursorType, LineDisplayDescriptorState, LineDisplayHorizontalAlignment, LineDisplayMarqueeFormat, LineDisplayPowerStatus, LineDisplayScrollDirection, LineDisplayTextAttribute, LineDisplayTextAttributeGranularity, LineDisplayVerticalAlignment, MagneticStripeReaderAuthenticationLevel, MagneticStripeReaderAuthenticationProtocol, MagneticStripeReaderErrorReportingType, MagneticStripeReaderStatus, MagneticStripeReaderTrackErrorType, MagneticStripeReaderTrackIds, PosConnectionTypes, PosPrinterAlignment, PosPrinterBarcodeTextPosition, PosPrinterCartridgeSensors, PosPrinterColorCapabilities, PosPrinterColorCartridge, PosPrinterLineDirection, PosPrinterLineStyle, PosPrinterMapMode, PosPrinterMarkFeedCapabilities, PosPrinterMarkFeedKind, PosPrinterPrintSide, PosPrinterRotation, PosPrinterRuledLineCapabilities, PosPrinterStatusKind, UnifiedPosErrorReason, UnifiedPosErrorSeverity, UnifiedPosHealthCheckLevel, UnifiedPosPowerReportingType

Self = typing.TypeVar('Self')

class SizeUInt32:
    width: winrt.system.UInt32
    height: winrt.system.UInt32
    def __new__(cls: typing.Type[SizeUInt32], width: winrt.system.UInt32, height: winrt.system.UInt32) -> SizeUInt32: ...

class BarcodeScanner(winrt.system.Object):
    capabilities: typing.Optional[BarcodeScannerCapabilities]
    device_id: str
    video_device_id: str
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BarcodeScanner: ...
    def check_health_async(self, level: UnifiedPosHealthCheckLevel, /) -> winrt.windows.foundation.IAsyncOperation[str]: ...
    def claim_scanner_async(self) -> winrt.windows.foundation.IAsyncOperation[ClaimedBarcodeScanner]: ...
    def close(self) -> None: ...
    @staticmethod
    def from_id_async(device_id: str, /) -> winrt.windows.foundation.IAsyncOperation[BarcodeScanner]: ...
    @staticmethod
    def get_default_async() -> winrt.windows.foundation.IAsyncOperation[BarcodeScanner]: ...
    @typing.overload
    @staticmethod
    def get_device_selector() -> str: ...
    @typing.overload
    @staticmethod
    def get_device_selector(connection_types: PosConnectionTypes, /) -> str: ...
    def get_supported_profiles(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[str]]: ...
    def get_supported_symbologies_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]: ...
    def is_profile_supported(self, profile: str, /) -> bool: ...
    def is_symbology_supported_async(self, barcode_symbology: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def retrieve_statistics_async(self, statistics_categories: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.streams.IBuffer]: ...
    def add_status_updated(self, handler: winrt.windows.foundation.TypedEventHandler[BarcodeScanner, BarcodeScannerStatusUpdatedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_status_updated(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class BarcodeScannerCapabilities(winrt.system.Object):
    is_image_preview_supported: bool
    is_statistics_reporting_supported: bool
    is_statistics_updating_supported: bool
    power_reporting_type: UnifiedPosPowerReportingType
    is_software_trigger_supported: bool
    is_video_preview_supported: bool
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BarcodeScannerCapabilities: ...

class BarcodeScannerDataReceivedEventArgs(winrt.system.Object):
    report: typing.Optional[BarcodeScannerReport]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BarcodeScannerDataReceivedEventArgs: ...

class BarcodeScannerErrorOccurredEventArgs(winrt.system.Object):
    error_data: typing.Optional[UnifiedPosErrorData]
    is_retriable: bool
    partial_input_data: typing.Optional[BarcodeScannerReport]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BarcodeScannerErrorOccurredEventArgs: ...

class BarcodeScannerImagePreviewReceivedEventArgs(winrt.system.Object):
    preview: typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamWithContentType]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BarcodeScannerImagePreviewReceivedEventArgs: ...

class BarcodeScannerReport(winrt.system.Object):
    scan_data: typing.Optional[winrt.windows.storage.streams.IBuffer]
    scan_data_label: typing.Optional[winrt.windows.storage.streams.IBuffer]
    scan_data_type: winrt.system.UInt32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BarcodeScannerReport: ...
    def __new__(cls: typing.Type[BarcodeScannerReport], scan_data_type: winrt.system.UInt32, scan_data: typing.Optional[winrt.windows.storage.streams.IBuffer], scan_data_label: typing.Optional[winrt.windows.storage.streams.IBuffer]) -> BarcodeScannerReport:...

class BarcodeScannerStatusUpdatedEventArgs(winrt.system.Object):
    extended_status: winrt.system.UInt32
    status: BarcodeScannerStatus
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BarcodeScannerStatusUpdatedEventArgs: ...

class BarcodeSymbologies(winrt.system.Object):
    code11: typing.ClassVar[winrt.system.UInt32]
    aus_post: typing.ClassVar[winrt.system.UInt32]
    aztec: typing.ClassVar[winrt.system.UInt32]
    can_post: typing.ClassVar[winrt.system.UInt32]
    ccab: typing.ClassVar[winrt.system.UInt32]
    ccc: typing.ClassVar[winrt.system.UInt32]
    china_post: typing.ClassVar[winrt.system.UInt32]
    codabar: typing.ClassVar[winrt.system.UInt32]
    codablock128: typing.ClassVar[winrt.system.UInt32]
    codablock_a: typing.ClassVar[winrt.system.UInt32]
    codablock_f: typing.ClassVar[winrt.system.UInt32]
    dutch_kix: typing.ClassVar[winrt.system.UInt32]
    code128: typing.ClassVar[winrt.system.UInt32]
    code16k: typing.ClassVar[winrt.system.UInt32]
    code32: typing.ClassVar[winrt.system.UInt32]
    code39: typing.ClassVar[winrt.system.UInt32]
    code39_ex: typing.ClassVar[winrt.system.UInt32]
    code49: typing.ClassVar[winrt.system.UInt32]
    code93: typing.ClassVar[winrt.system.UInt32]
    code93_ex: typing.ClassVar[winrt.system.UInt32]
    data_code: typing.ClassVar[winrt.system.UInt32]
    data_matrix: typing.ClassVar[winrt.system.UInt32]
    us_post_net: typing.ClassVar[winrt.system.UInt32]
    ean13: typing.ClassVar[winrt.system.UInt32]
    ean13_add2: typing.ClassVar[winrt.system.UInt32]
    ean13_add5: typing.ClassVar[winrt.system.UInt32]
    ean8: typing.ClassVar[winrt.system.UInt32]
    ean8_add2: typing.ClassVar[winrt.system.UInt32]
    ean8_add5: typing.ClassVar[winrt.system.UInt32]
    ean99: typing.ClassVar[winrt.system.UInt32]
    ean99_add2: typing.ClassVar[winrt.system.UInt32]
    ean99_add5: typing.ClassVar[winrt.system.UInt32]
    eanv: typing.ClassVar[winrt.system.UInt32]
    eanv_add2: typing.ClassVar[winrt.system.UInt32]
    eanv_add5: typing.ClassVar[winrt.system.UInt32]
    extended_base: typing.ClassVar[winrt.system.UInt32]
    gs1128: typing.ClassVar[winrt.system.UInt32]
    gs1128_coupon: typing.ClassVar[winrt.system.UInt32]
    gs1_databar_type1: typing.ClassVar[winrt.system.UInt32]
    gs1_databar_type2: typing.ClassVar[winrt.system.UInt32]
    gs1_databar_type3: typing.ClassVar[winrt.system.UInt32]
    han_xin: typing.ClassVar[winrt.system.UInt32]
    info_mail: typing.ClassVar[winrt.system.UInt32]
    isbn: typing.ClassVar[winrt.system.UInt32]
    isbn_add5: typing.ClassVar[winrt.system.UInt32]
    isbt: typing.ClassVar[winrt.system.UInt32]
    ismn: typing.ClassVar[winrt.system.UInt32]
    ismn_add2: typing.ClassVar[winrt.system.UInt32]
    ismn_add5: typing.ClassVar[winrt.system.UInt32]
    issn: typing.ClassVar[winrt.system.UInt32]
    issn_add2: typing.ClassVar[winrt.system.UInt32]
    issn_add5: typing.ClassVar[winrt.system.UInt32]
    italian_post25: typing.ClassVar[winrt.system.UInt32]
    italian_post39: typing.ClassVar[winrt.system.UInt32]
    japan_post: typing.ClassVar[winrt.system.UInt32]
    korean_post: typing.ClassVar[winrt.system.UInt32]
    maxicode: typing.ClassVar[winrt.system.UInt32]
    micr: typing.ClassVar[winrt.system.UInt32]
    micro_pdf417: typing.ClassVar[winrt.system.UInt32]
    micro_qr: typing.ClassVar[winrt.system.UInt32]
    ms_tag: typing.ClassVar[winrt.system.UInt32]
    msi: typing.ClassVar[winrt.system.UInt32]
    ocr_a: typing.ClassVar[winrt.system.UInt32]
    ocr_b: typing.ClassVar[winrt.system.UInt32]
    pdf417: typing.ClassVar[winrt.system.UInt32]
    plessey: typing.ClassVar[winrt.system.UInt32]
    pzn: typing.ClassVar[winrt.system.UInt32]
    qr: typing.ClassVar[winrt.system.UInt32]
    sisac: typing.ClassVar[winrt.system.UInt32]
    sweden_post: typing.ClassVar[winrt.system.UInt32]
    telepen: typing.ClassVar[winrt.system.UInt32]
    tf_dis: typing.ClassVar[winrt.system.UInt32]
    tf_iata: typing.ClassVar[winrt.system.UInt32]
    tf_ind: typing.ClassVar[winrt.system.UInt32]
    tf_int: typing.ClassVar[winrt.system.UInt32]
    tf_mat: typing.ClassVar[winrt.system.UInt32]
    tf_std: typing.ClassVar[winrt.system.UInt32]
    tlc39: typing.ClassVar[winrt.system.UInt32]
    trioptic39: typing.ClassVar[winrt.system.UInt32]
    ucc_ean128: typing.ClassVar[winrt.system.UInt32]
    uk_post: typing.ClassVar[winrt.system.UInt32]
    unknown: typing.ClassVar[winrt.system.UInt32]
    upc_coupon: typing.ClassVar[winrt.system.UInt32]
    upca: typing.ClassVar[winrt.system.UInt32]
    upca_add2: typing.ClassVar[winrt.system.UInt32]
    upca_add5: typing.ClassVar[winrt.system.UInt32]
    upce: typing.ClassVar[winrt.system.UInt32]
    upce_add2: typing.ClassVar[winrt.system.UInt32]
    upce_add5: typing.ClassVar[winrt.system.UInt32]
    us4_state_fics: typing.ClassVar[winrt.system.UInt32]
    us_intelligent: typing.ClassVar[winrt.system.UInt32]
    us_intelligent_pkg: typing.ClassVar[winrt.system.UInt32]
    us_planet: typing.ClassVar[winrt.system.UInt32]
    gs1_d_w_code: typing.ClassVar[winrt.system.UInt32]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BarcodeSymbologies: ...
    @staticmethod
    def get_name(scan_data_type: winrt.system.UInt32, /) -> str: ...

class BarcodeSymbologyAttributes(winrt.system.Object):
    is_check_digit_validation_enabled: bool
    is_check_digit_transmission_enabled: bool
    decode_length_kind: BarcodeSymbologyDecodeLengthKind
    decode_length2: winrt.system.UInt32
    decode_length1: winrt.system.UInt32
    is_check_digit_transmission_supported: bool
    is_check_digit_validation_supported: bool
    is_decode_length_supported: bool
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BarcodeSymbologyAttributes: ...

class CashDrawer(winrt.system.Object):
    capabilities: typing.Optional[CashDrawerCapabilities]
    device_id: str
    drawer_event_source: typing.Optional[CashDrawerEventSource]
    is_drawer_open: bool
    status: typing.Optional[CashDrawerStatus]
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CashDrawer: ...
    def check_health_async(self, level: UnifiedPosHealthCheckLevel, /) -> winrt.windows.foundation.IAsyncOperation[str]: ...
    def claim_drawer_async(self) -> winrt.windows.foundation.IAsyncOperation[ClaimedCashDrawer]: ...
    def close(self) -> None: ...
    @staticmethod
    def from_id_async(device_id: str, /) -> winrt.windows.foundation.IAsyncOperation[CashDrawer]: ...
    @staticmethod
    def get_default_async() -> winrt.windows.foundation.IAsyncOperation[CashDrawer]: ...
    @typing.overload
    @staticmethod
    def get_device_selector() -> str: ...
    @typing.overload
    @staticmethod
    def get_device_selector(connection_types: PosConnectionTypes, /) -> str: ...
    def get_statistics_async(self, statistics_categories: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncOperation[str]: ...
    def add_status_updated(self, handler: winrt.windows.foundation.TypedEventHandler[CashDrawer, CashDrawerStatusUpdatedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_status_updated(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class CashDrawerCapabilities(winrt.system.Object):
    is_drawer_open_sensor_available: bool
    is_statistics_reporting_supported: bool
    is_statistics_updating_supported: bool
    is_status_multi_drawer_detect_supported: bool
    is_status_reporting_supported: bool
    power_reporting_type: UnifiedPosPowerReportingType
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CashDrawerCapabilities: ...

class CashDrawerCloseAlarm(winrt.system.Object):
    beep_frequency: winrt.system.UInt32
    beep_duration: datetime.timedelta
    beep_delay: datetime.timedelta
    alarm_timeout: datetime.timedelta
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CashDrawerCloseAlarm: ...
    def start_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def add_alarm_timeout_expired(self, handler: winrt.windows.foundation.TypedEventHandler[CashDrawerCloseAlarm, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_alarm_timeout_expired(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class CashDrawerClosedEventArgs(winrt.system.Object):
    cash_drawer: typing.Optional[CashDrawer]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CashDrawerClosedEventArgs: ...

class CashDrawerEventSource(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CashDrawerEventSource: ...
    def add_drawer_closed(self, handler: winrt.windows.foundation.TypedEventHandler[CashDrawerEventSource, CashDrawerClosedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_drawer_closed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_drawer_opened(self, handler: winrt.windows.foundation.TypedEventHandler[CashDrawerEventSource, CashDrawerOpenedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_drawer_opened(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class CashDrawerOpenedEventArgs(winrt.system.Object):
    cash_drawer: typing.Optional[CashDrawer]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CashDrawerOpenedEventArgs: ...

class CashDrawerStatus(winrt.system.Object):
    extended_status: winrt.system.UInt32
    status_kind: CashDrawerStatusKind
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CashDrawerStatus: ...

class CashDrawerStatusUpdatedEventArgs(winrt.system.Object):
    status: typing.Optional[CashDrawerStatus]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CashDrawerStatusUpdatedEventArgs: ...

class ClaimedBarcodeScanner(winrt.system.Object):
    is_disabled_on_data_received: bool
    is_decode_data_enabled: bool
    device_id: str
    is_enabled: bool
    is_video_preview_shown_on_enable: bool
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ClaimedBarcodeScanner: ...
    def close(self) -> None: ...
    def disable_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def enable_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def get_symbology_attributes_async(self, barcode_symbology: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[BarcodeSymbologyAttributes]: ...
    def hide_video_preview(self) -> None: ...
    def reset_statistics_async(self, statistics_categories: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncAction: ...
    def retain_device(self) -> None: ...
    def set_active_profile_async(self, profile: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    def set_active_symbologies_async(self, symbologies: typing.Iterable[winrt.system.UInt32], /) -> winrt.windows.foundation.IAsyncAction: ...
    def set_symbology_attributes_async(self, barcode_symbology: winrt.system.UInt32, attributes: typing.Optional[BarcodeSymbologyAttributes], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def show_video_preview_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def start_software_trigger_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def stop_software_trigger_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def update_statistics_async(self, statistics: typing.Iterable[winrt.windows.foundation.collections.IKeyValuePair[str, str]], /) -> winrt.windows.foundation.IAsyncAction: ...
    def add_data_received(self, handler: winrt.windows.foundation.TypedEventHandler[ClaimedBarcodeScanner, BarcodeScannerDataReceivedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_data_received(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_error_occurred(self, handler: winrt.windows.foundation.TypedEventHandler[ClaimedBarcodeScanner, BarcodeScannerErrorOccurredEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_error_occurred(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_image_preview_received(self, handler: winrt.windows.foundation.TypedEventHandler[ClaimedBarcodeScanner, BarcodeScannerImagePreviewReceivedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_image_preview_received(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_release_device_requested(self, handler: winrt.windows.foundation.EventHandler[ClaimedBarcodeScanner], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_release_device_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_trigger_pressed(self, handler: winrt.windows.foundation.EventHandler[ClaimedBarcodeScanner], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_trigger_pressed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_trigger_released(self, handler: winrt.windows.foundation.EventHandler[ClaimedBarcodeScanner], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_trigger_released(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_closed(self, handler: winrt.windows.foundation.TypedEventHandler[ClaimedBarcodeScanner, ClaimedBarcodeScannerClosedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_closed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class ClaimedBarcodeScannerClosedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ClaimedBarcodeScannerClosedEventArgs: ...

class ClaimedCashDrawer(winrt.system.Object):
    close_alarm: typing.Optional[CashDrawerCloseAlarm]
    device_id: str
    is_drawer_open: bool
    is_enabled: bool
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ClaimedCashDrawer: ...
    def close(self) -> None: ...
    def disable_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def enable_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def open_drawer_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def reset_statistics_async(self, statistics_categories: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def retain_device_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def update_statistics_async(self, statistics: typing.Iterable[winrt.windows.foundation.collections.IKeyValuePair[str, str]], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def add_release_device_requested(self, handler: winrt.windows.foundation.TypedEventHandler[ClaimedCashDrawer, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_release_device_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_closed(self, handler: winrt.windows.foundation.TypedEventHandler[ClaimedCashDrawer, ClaimedCashDrawerClosedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_closed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class ClaimedCashDrawerClosedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ClaimedCashDrawerClosedEventArgs: ...

class ClaimedJournalPrinter(winrt.system.Object):
    line_spacing: winrt.system.UInt32
    line_height: winrt.system.UInt32
    is_letter_quality: bool
    color_cartridge: PosPrinterColorCartridge
    characters_per_line: winrt.system.UInt32
    is_cartridge_empty: bool
    is_cartridge_removed: bool
    is_cover_open: bool
    is_head_cleaning: bool
    is_paper_empty: bool
    is_paper_near_end: bool
    is_ready_to_print: bool
    line_width: winrt.system.UInt32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ClaimedJournalPrinter: ...
    def create_job(self) -> typing.Optional[JournalPrintJob]: ...
    def validate_data(self, data: str, /) -> bool: ...

class ClaimedLineDisplay(winrt.system.Object):
    capabilities: typing.Optional[LineDisplayCapabilities]
    default_window: typing.Optional[LineDisplayWindow]
    device_control_description: str
    device_control_version: str
    device_id: str
    device_service_version: str
    physical_device_description: str
    physical_device_name: str
    custom_glyphs: typing.Optional[LineDisplayCustomGlyphs]
    max_bitmap_size_in_pixels: winrt.windows.foundation.Size
    supported_character_sets: typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Int32]]
    supported_screen_sizes_in_characters: typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.foundation.Size]]
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ClaimedLineDisplay: ...
    def check_health_async(self, level: UnifiedPosHealthCheckLevel, /) -> winrt.windows.foundation.IAsyncOperation[str]: ...
    def check_power_status_async(self) -> winrt.windows.foundation.IAsyncOperation[LineDisplayPowerStatus]: ...
    def close(self) -> None: ...
    @staticmethod
    def from_id_async(device_id: str, /) -> winrt.windows.foundation.IAsyncOperation[ClaimedLineDisplay]: ...
    def get_attributes(self) -> typing.Optional[LineDisplayAttributes]: ...
    @typing.overload
    @staticmethod
    def get_device_selector() -> str: ...
    @typing.overload
    @staticmethod
    def get_device_selector(connection_types: PosConnectionTypes, /) -> str: ...
    def get_statistics_async(self, statistics_categories: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncOperation[str]: ...
    def retain_device(self) -> None: ...
    def try_clear_descriptors_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def try_create_window_async(self, viewport: winrt.windows.foundation.Rect, window_size: winrt.windows.foundation.Size, /) -> winrt.windows.foundation.IAsyncOperation[LineDisplayWindow]: ...
    def try_set_descriptor_async(self, descriptor: winrt.system.UInt32, descriptor_state: LineDisplayDescriptorState, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @typing.overload
    def try_store_storage_file_bitmap_async(self, bitmap: typing.Optional[winrt.windows.storage.StorageFile], /) -> winrt.windows.foundation.IAsyncOperation[LineDisplayStoredBitmap]: ...
    @typing.overload
    def try_store_storage_file_bitmap_async(self, bitmap: typing.Optional[winrt.windows.storage.StorageFile], horizontal_alignment: LineDisplayHorizontalAlignment, vertical_alignment: LineDisplayVerticalAlignment, /) -> winrt.windows.foundation.IAsyncOperation[LineDisplayStoredBitmap]: ...
    @typing.overload
    def try_store_storage_file_bitmap_async(self, bitmap: typing.Optional[winrt.windows.storage.StorageFile], horizontal_alignment: LineDisplayHorizontalAlignment, vertical_alignment: LineDisplayVerticalAlignment, width_in_pixels: winrt.system.Int32, /) -> winrt.windows.foundation.IAsyncOperation[LineDisplayStoredBitmap]: ...
    def try_update_attributes_async(self, attributes: typing.Optional[LineDisplayAttributes], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def add_release_device_requested(self, handler: winrt.windows.foundation.TypedEventHandler[ClaimedLineDisplay, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_release_device_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_status_updated(self, handler: winrt.windows.foundation.TypedEventHandler[ClaimedLineDisplay, LineDisplayStatusUpdatedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_status_updated(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_closed(self, handler: winrt.windows.foundation.TypedEventHandler[ClaimedLineDisplay, ClaimedLineDisplayClosedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_closed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class ClaimedLineDisplayClosedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ClaimedLineDisplayClosedEventArgs: ...

class ClaimedMagneticStripeReader(winrt.system.Object):
    tracks_to_read: MagneticStripeReaderTrackIds
    is_transmit_sentinels_enabled: bool
    is_disabled_on_data_received: bool
    is_decode_data_enabled: bool
    data_encryption_algorithm: winrt.system.UInt32
    device_id: str
    is_device_authenticated: bool
    is_enabled: bool
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ClaimedMagneticStripeReader: ...
    def authenticate_device_async(self, response_token: winrt.system.Array[winrt.system.UInt8], /) -> winrt.windows.foundation.IAsyncAction: ...
    def close(self) -> None: ...
    def de_authenticate_device_async(self, response_token: winrt.system.Array[winrt.system.UInt8], /) -> winrt.windows.foundation.IAsyncAction: ...
    def disable_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def enable_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def reset_statistics_async(self, statistics_categories: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncAction: ...
    def retain_device(self) -> None: ...
    def retrieve_device_authentication_data_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.streams.IBuffer]: ...
    def set_error_reporting_type(self, value: MagneticStripeReaderErrorReportingType, /) -> None: ...
    def update_key_async(self, key: str, key_name: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    def update_statistics_async(self, statistics: typing.Iterable[winrt.windows.foundation.collections.IKeyValuePair[str, str]], /) -> winrt.windows.foundation.IAsyncAction: ...
    def add_aamva_card_data_received(self, handler: winrt.windows.foundation.TypedEventHandler[ClaimedMagneticStripeReader, MagneticStripeReaderAamvaCardDataReceivedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_aamva_card_data_received(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_bank_card_data_received(self, handler: winrt.windows.foundation.TypedEventHandler[ClaimedMagneticStripeReader, MagneticStripeReaderBankCardDataReceivedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_bank_card_data_received(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_error_occurred(self, handler: winrt.windows.foundation.TypedEventHandler[ClaimedMagneticStripeReader, MagneticStripeReaderErrorOccurredEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_error_occurred(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_release_device_requested(self, handler: winrt.windows.foundation.EventHandler[ClaimedMagneticStripeReader], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_release_device_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_vendor_specific_data_received(self, handler: winrt.windows.foundation.TypedEventHandler[ClaimedMagneticStripeReader, MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_vendor_specific_data_received(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_closed(self, handler: winrt.windows.foundation.TypedEventHandler[ClaimedMagneticStripeReader, ClaimedMagneticStripeReaderClosedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_closed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class ClaimedMagneticStripeReaderClosedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ClaimedMagneticStripeReaderClosedEventArgs: ...

class ClaimedPosPrinter(winrt.system.Object):
    map_mode: PosPrinterMapMode
    is_character_set_mapping_enabled: bool
    character_set: winrt.system.UInt32
    device_id: str
    is_cover_open: bool
    is_enabled: bool
    journal: typing.Optional[ClaimedJournalPrinter]
    receipt: typing.Optional[ClaimedReceiptPrinter]
    slip: typing.Optional[ClaimedSlipPrinter]
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ClaimedPosPrinter: ...
    def close(self) -> None: ...
    def disable_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def enable_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def reset_statistics_async(self, statistics_categories: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def retain_device_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def update_statistics_async(self, statistics: typing.Iterable[winrt.windows.foundation.collections.IKeyValuePair[str, str]], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def add_release_device_requested(self, handler: winrt.windows.foundation.TypedEventHandler[ClaimedPosPrinter, PosPrinterReleaseDeviceRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_release_device_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_closed(self, handler: winrt.windows.foundation.TypedEventHandler[ClaimedPosPrinter, ClaimedPosPrinterClosedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_closed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class ClaimedPosPrinterClosedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ClaimedPosPrinterClosedEventArgs: ...

class ClaimedReceiptPrinter(winrt.system.Object):
    lines_to_paper_cut: winrt.system.UInt32
    page_size: winrt.windows.foundation.Size
    print_area: winrt.windows.foundation.Rect
    sideways_max_chars: winrt.system.UInt32
    sideways_max_lines: winrt.system.UInt32
    line_spacing: winrt.system.UInt32
    line_height: winrt.system.UInt32
    is_letter_quality: bool
    color_cartridge: PosPrinterColorCartridge
    characters_per_line: winrt.system.UInt32
    is_cartridge_empty: bool
    is_cartridge_removed: bool
    is_cover_open: bool
    is_head_cleaning: bool
    is_paper_empty: bool
    is_paper_near_end: bool
    is_ready_to_print: bool
    line_width: winrt.system.UInt32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ClaimedReceiptPrinter: ...
    def create_job(self) -> typing.Optional[ReceiptPrintJob]: ...
    def validate_data(self, data: str, /) -> bool: ...

class ClaimedSlipPrinter(winrt.system.Object):
    lines_near_end_to_end: winrt.system.UInt32
    max_lines: winrt.system.UInt32
    page_size: winrt.windows.foundation.Size
    print_area: winrt.windows.foundation.Rect
    print_side: PosPrinterPrintSide
    sideways_max_chars: winrt.system.UInt32
    sideways_max_lines: winrt.system.UInt32
    line_spacing: winrt.system.UInt32
    line_height: winrt.system.UInt32
    is_letter_quality: bool
    color_cartridge: PosPrinterColorCartridge
    characters_per_line: winrt.system.UInt32
    is_cartridge_empty: bool
    is_cartridge_removed: bool
    is_cover_open: bool
    is_head_cleaning: bool
    is_paper_empty: bool
    is_paper_near_end: bool
    is_ready_to_print: bool
    line_width: winrt.system.UInt32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ClaimedSlipPrinter: ...
    def change_print_side(self, print_side: PosPrinterPrintSide, /) -> None: ...
    def close_jaws(self) -> None: ...
    def create_job(self) -> typing.Optional[SlipPrintJob]: ...
    def insert_slip_async(self, timeout: datetime.timedelta, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def open_jaws(self) -> None: ...
    def remove_slip_async(self, timeout: datetime.timedelta, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def validate_data(self, data: str, /) -> bool: ...

class JournalPrintJob(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> JournalPrintJob: ...
    def execute_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def feed_paper_by_line(self, line_count: winrt.system.Int32, /) -> None: ...
    def feed_paper_by_map_mode_unit(self, distance: winrt.system.Int32, /) -> None: ...
    @typing.overload
    def print(self, data: str, /) -> None: ...
    @typing.overload
    def print(self, data: str, print_options: typing.Optional[PosPrinterPrintOptions], /) -> None: ...
    @typing.overload
    def print_line(self) -> None: ...
    @typing.overload
    def print_line(self, data: str, /) -> None: ...

class JournalPrinterCapabilities(winrt.system.Object):
    cartridge_sensors: PosPrinterCartridgeSensors
    color_cartridge_capabilities: PosPrinterColorCapabilities
    is_bold_supported: bool
    is_double_high_double_wide_print_supported: bool
    is_double_high_print_supported: bool
    is_double_wide_print_supported: bool
    is_dual_color_supported: bool
    is_italic_supported: bool
    is_paper_empty_sensor_supported: bool
    is_paper_near_end_sensor_supported: bool
    is_printer_present: bool
    is_underline_supported: bool
    supported_characters_per_line: typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]
    is_reverse_paper_feed_by_line_supported: bool
    is_reverse_paper_feed_by_map_mode_unit_supported: bool
    is_reverse_video_supported: bool
    is_strikethrough_supported: bool
    is_subscript_supported: bool
    is_superscript_supported: bool
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> JournalPrinterCapabilities: ...

class LineDisplay(winrt.system.Object):
    capabilities: typing.Optional[LineDisplayCapabilities]
    device_control_description: str
    device_control_version: str
    device_id: str
    device_service_version: str
    physical_device_description: str
    physical_device_name: str
    statistics_category_selector: typing.ClassVar[typing.Optional[LineDisplayStatisticsCategorySelector]]
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LineDisplay: ...
    def check_power_status_async(self) -> winrt.windows.foundation.IAsyncOperation[LineDisplayPowerStatus]: ...
    def claim_async(self) -> winrt.windows.foundation.IAsyncOperation[ClaimedLineDisplay]: ...
    def close(self) -> None: ...
    @staticmethod
    def from_id_async(device_id: str, /) -> winrt.windows.foundation.IAsyncOperation[LineDisplay]: ...
    @staticmethod
    def get_default_async() -> winrt.windows.foundation.IAsyncOperation[LineDisplay]: ...
    @typing.overload
    @staticmethod
    def get_device_selector() -> str: ...
    @typing.overload
    @staticmethod
    def get_device_selector(connection_types: PosConnectionTypes, /) -> str: ...

class LineDisplayAttributes(winrt.system.Object):
    screen_size_in_characters: winrt.windows.foundation.Size
    is_power_notify_enabled: bool
    is_character_set_mapping_enabled: bool
    current_window: typing.Optional[LineDisplayWindow]
    character_set: winrt.system.Int32
    brightness: winrt.system.Int32
    blink_rate: datetime.timedelta
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LineDisplayAttributes: ...

class LineDisplayCapabilities(winrt.system.Object):
    can_blink: LineDisplayTextAttributeGranularity
    can_change_blink_rate: bool
    can_change_screen_size: bool
    can_display_bitmaps: bool
    can_display_custom_glyphs: bool
    can_map_character_sets: bool
    can_read_character_at_cursor: bool
    can_reverse: LineDisplayTextAttributeGranularity
    is_brightness_supported: bool
    is_cursor_supported: bool
    is_horizontal_marquee_supported: bool
    is_inter_character_wait_supported: bool
    is_statistics_reporting_supported: bool
    is_statistics_updating_supported: bool
    is_vertical_marquee_supported: bool
    power_reporting_type: UnifiedPosPowerReportingType
    supported_descriptors: winrt.system.UInt32
    supported_windows: winrt.system.UInt32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LineDisplayCapabilities: ...

class LineDisplayCursor(winrt.system.Object):
    can_customize: bool
    is_blink_supported: bool
    is_block_supported: bool
    is_half_block_supported: bool
    is_other_supported: bool
    is_reverse_supported: bool
    is_underline_supported: bool
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LineDisplayCursor: ...
    def get_attributes(self) -> typing.Optional[LineDisplayCursorAttributes]: ...
    def try_update_attributes_async(self, attributes: typing.Optional[LineDisplayCursorAttributes], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...

class LineDisplayCursorAttributes(winrt.system.Object):
    position: winrt.windows.foundation.Point
    is_blink_enabled: bool
    is_auto_advance_enabled: bool
    cursor_type: LineDisplayCursorType
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LineDisplayCursorAttributes: ...

class LineDisplayCustomGlyphs(winrt.system.Object):
    size_in_pixels: winrt.windows.foundation.Size
    supported_glyph_codes: typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LineDisplayCustomGlyphs: ...
    def try_redefine_async(self, glyph_code: winrt.system.UInt32, glyph_data: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...

class LineDisplayMarquee(winrt.system.Object):
    scroll_wait_interval: datetime.timedelta
    repeat_wait_interval: datetime.timedelta
    format: LineDisplayMarqueeFormat
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LineDisplayMarquee: ...
    def try_start_scrolling_async(self, direction: LineDisplayScrollDirection, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def try_stop_scrolling_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...

class LineDisplayStatisticsCategorySelector(winrt.system.Object):
    all_statistics: str
    manufacturer_statistics: str
    unified_pos_statistics: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LineDisplayStatisticsCategorySelector: ...

class LineDisplayStatusUpdatedEventArgs(winrt.system.Object):
    status: LineDisplayPowerStatus
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LineDisplayStatusUpdatedEventArgs: ...

class LineDisplayStoredBitmap(winrt.system.Object):
    escape_sequence: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LineDisplayStoredBitmap: ...
    def try_delete_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...

class LineDisplayWindow(winrt.system.Object):
    inter_character_wait_interval: datetime.timedelta
    size_in_characters: winrt.windows.foundation.Size
    cursor: typing.Optional[LineDisplayCursor]
    marquee: typing.Optional[LineDisplayMarquee]
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LineDisplayWindow: ...
    def close(self) -> None: ...
    def read_character_at_cursor_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.system.UInt32]: ...
    def try_clear_text_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @typing.overload
    def try_display_storage_file_bitmap_at_cursor_async(self, bitmap: typing.Optional[winrt.windows.storage.StorageFile], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @typing.overload
    def try_display_storage_file_bitmap_at_cursor_async(self, bitmap: typing.Optional[winrt.windows.storage.StorageFile], horizontal_alignment: LineDisplayHorizontalAlignment, vertical_alignment: LineDisplayVerticalAlignment, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @typing.overload
    def try_display_storage_file_bitmap_at_cursor_async(self, bitmap: typing.Optional[winrt.windows.storage.StorageFile], horizontal_alignment: LineDisplayHorizontalAlignment, vertical_alignment: LineDisplayVerticalAlignment, width_in_pixels: winrt.system.Int32, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @typing.overload
    def try_display_storage_file_bitmap_at_point_async(self, bitmap: typing.Optional[winrt.windows.storage.StorageFile], offset_in_pixels: winrt.windows.foundation.Point, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @typing.overload
    def try_display_storage_file_bitmap_at_point_async(self, bitmap: typing.Optional[winrt.windows.storage.StorageFile], offset_in_pixels: winrt.windows.foundation.Point, width_in_pixels: winrt.system.Int32, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def try_display_stored_bitmap_at_cursor_async(self, bitmap: typing.Optional[LineDisplayStoredBitmap], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @typing.overload
    def try_display_text_async(self, text: str, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @typing.overload
    def try_display_text_async(self, text: str, display_attribute: LineDisplayTextAttribute, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @typing.overload
    def try_display_text_async(self, text: str, display_attribute: LineDisplayTextAttribute, start_position: winrt.windows.foundation.Point, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def try_refresh_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def try_scroll_text_async(self, direction: LineDisplayScrollDirection, number_of_columns_or_rows: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...

class MagneticStripeReader(winrt.system.Object):
    capabilities: typing.Optional[MagneticStripeReaderCapabilities]
    device_authentication_protocol: MagneticStripeReaderAuthenticationProtocol
    device_id: str
    supported_card_types: winrt.system.UInt32
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MagneticStripeReader: ...
    def check_health_async(self, level: UnifiedPosHealthCheckLevel, /) -> winrt.windows.foundation.IAsyncOperation[str]: ...
    def claim_reader_async(self) -> winrt.windows.foundation.IAsyncOperation[ClaimedMagneticStripeReader]: ...
    def close(self) -> None: ...
    @staticmethod
    def from_id_async(device_id: str, /) -> winrt.windows.foundation.IAsyncOperation[MagneticStripeReader]: ...
    @staticmethod
    def get_default_async() -> winrt.windows.foundation.IAsyncOperation[MagneticStripeReader]: ...
    @typing.overload
    @staticmethod
    def get_device_selector() -> str: ...
    @typing.overload
    @staticmethod
    def get_device_selector(connection_types: PosConnectionTypes, /) -> str: ...
    def get_error_reporting_type(self) -> MagneticStripeReaderErrorReportingType: ...
    def retrieve_statistics_async(self, statistics_categories: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.streams.IBuffer]: ...
    def add_status_updated(self, handler: winrt.windows.foundation.TypedEventHandler[MagneticStripeReader, MagneticStripeReaderStatusUpdatedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_status_updated(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class MagneticStripeReaderAamvaCardDataReceivedEventArgs(winrt.system.Object):
    address: str
    birth_date: str
    city: str
    class_: str
    endorsements: str
    expiration_date: str
    eye_color: str
    first_name: str
    gender: str
    hair_color: str
    height: str
    license_number: str
    postal_code: str
    report: typing.Optional[MagneticStripeReaderReport]
    restrictions: str
    state: str
    suffix: str
    surname: str
    weight: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MagneticStripeReaderAamvaCardDataReceivedEventArgs: ...

class MagneticStripeReaderBankCardDataReceivedEventArgs(winrt.system.Object):
    account_number: str
    expiration_date: str
    first_name: str
    middle_initial: str
    report: typing.Optional[MagneticStripeReaderReport]
    service_code: str
    suffix: str
    surname: str
    title: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MagneticStripeReaderBankCardDataReceivedEventArgs: ...

class MagneticStripeReaderCapabilities(winrt.system.Object):
    authentication_level: MagneticStripeReaderAuthenticationLevel
    card_authentication: str
    is_iso_supported: bool
    is_jis_one_supported: bool
    is_jis_two_supported: bool
    is_statistics_reporting_supported: bool
    is_statistics_updating_supported: bool
    is_track_data_masking_supported: bool
    is_transmit_sentinels_supported: bool
    power_reporting_type: UnifiedPosPowerReportingType
    supported_encryption_algorithms: winrt.system.UInt32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MagneticStripeReaderCapabilities: ...

class MagneticStripeReaderCardTypes(winrt.system.Object):
    aamva: typing.ClassVar[winrt.system.UInt32]
    bank: typing.ClassVar[winrt.system.UInt32]
    extended_base: typing.ClassVar[winrt.system.UInt32]
    unknown: typing.ClassVar[winrt.system.UInt32]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MagneticStripeReaderCardTypes: ...

class MagneticStripeReaderEncryptionAlgorithms(winrt.system.Object):
    extended_base: typing.ClassVar[winrt.system.UInt32]
    none: typing.ClassVar[winrt.system.UInt32]
    triple_des_dukpt: typing.ClassVar[winrt.system.UInt32]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MagneticStripeReaderEncryptionAlgorithms: ...

class MagneticStripeReaderErrorOccurredEventArgs(winrt.system.Object):
    error_data: typing.Optional[UnifiedPosErrorData]
    partial_input_data: typing.Optional[MagneticStripeReaderReport]
    track1_status: MagneticStripeReaderTrackErrorType
    track2_status: MagneticStripeReaderTrackErrorType
    track3_status: MagneticStripeReaderTrackErrorType
    track4_status: MagneticStripeReaderTrackErrorType
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MagneticStripeReaderErrorOccurredEventArgs: ...

class MagneticStripeReaderReport(winrt.system.Object):
    additional_security_information: typing.Optional[winrt.windows.storage.streams.IBuffer]
    card_authentication_data: typing.Optional[winrt.windows.storage.streams.IBuffer]
    card_authentication_data_length: winrt.system.UInt32
    card_type: winrt.system.UInt32
    properties: typing.Optional[winrt.windows.foundation.collections.IMapView[str, str]]
    track1: typing.Optional[MagneticStripeReaderTrackData]
    track2: typing.Optional[MagneticStripeReaderTrackData]
    track3: typing.Optional[MagneticStripeReaderTrackData]
    track4: typing.Optional[MagneticStripeReaderTrackData]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MagneticStripeReaderReport: ...

class MagneticStripeReaderStatusUpdatedEventArgs(winrt.system.Object):
    extended_status: winrt.system.UInt32
    status: MagneticStripeReaderStatus
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MagneticStripeReaderStatusUpdatedEventArgs: ...

class MagneticStripeReaderTrackData(winrt.system.Object):
    data: typing.Optional[winrt.windows.storage.streams.IBuffer]
    discretionary_data: typing.Optional[winrt.windows.storage.streams.IBuffer]
    encrypted_data: typing.Optional[winrt.windows.storage.streams.IBuffer]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MagneticStripeReaderTrackData: ...

class MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs(winrt.system.Object):
    report: typing.Optional[MagneticStripeReaderReport]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs: ...

class PosPrinter(winrt.system.Object):
    capabilities: typing.Optional[PosPrinterCapabilities]
    device_id: str
    status: typing.Optional[PosPrinterStatus]
    supported_character_sets: typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]
    supported_type_faces: typing.Optional[winrt.windows.foundation.collections.IVectorView[str]]
    supported_barcode_symbologies: typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PosPrinter: ...
    def check_health_async(self, level: UnifiedPosHealthCheckLevel, /) -> winrt.windows.foundation.IAsyncOperation[str]: ...
    def claim_printer_async(self) -> winrt.windows.foundation.IAsyncOperation[ClaimedPosPrinter]: ...
    def close(self) -> None: ...
    @staticmethod
    def from_id_async(device_id: str, /) -> winrt.windows.foundation.IAsyncOperation[PosPrinter]: ...
    @staticmethod
    def get_default_async() -> winrt.windows.foundation.IAsyncOperation[PosPrinter]: ...
    @typing.overload
    @staticmethod
    def get_device_selector() -> str: ...
    @typing.overload
    @staticmethod
    def get_device_selector(connection_types: PosConnectionTypes, /) -> str: ...
    def get_font_property(self, typeface: str, /) -> typing.Optional[PosPrinterFontProperty]: ...
    def get_statistics_async(self, statistics_categories: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncOperation[str]: ...
    def add_status_updated(self, handler: winrt.windows.foundation.TypedEventHandler[PosPrinter, PosPrinterStatusUpdatedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_status_updated(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class PosPrinterCapabilities(winrt.system.Object):
    can_map_character_set: bool
    default_character_set: winrt.system.UInt32
    has_cover_sensor: bool
    is_statistics_reporting_supported: bool
    is_statistics_updating_supported: bool
    is_transaction_supported: bool
    journal: typing.Optional[JournalPrinterCapabilities]
    power_reporting_type: UnifiedPosPowerReportingType
    receipt: typing.Optional[ReceiptPrinterCapabilities]
    slip: typing.Optional[SlipPrinterCapabilities]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PosPrinterCapabilities: ...

class PosPrinterCharacterSetIds(winrt.system.Object):
    ansi: typing.ClassVar[winrt.system.UInt32]
    ascii: typing.ClassVar[winrt.system.UInt32]
    utf16_l_e: typing.ClassVar[winrt.system.UInt32]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PosPrinterCharacterSetIds: ...

class PosPrinterFontProperty(winrt.system.Object):
    character_sizes: typing.Optional[winrt.windows.foundation.collections.IVectorView[SizeUInt32]]
    is_scalable_to_any_size: bool
    type_face: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PosPrinterFontProperty: ...

class PosPrinterPrintOptions(winrt.system.Object):
    underline: bool
    type_face: str
    superscript: bool
    subscript: bool
    strikethrough: bool
    reverse_video: bool
    italic: bool
    double_wide: bool
    double_high: bool
    character_set: winrt.system.UInt32
    character_height: winrt.system.UInt32
    bold: bool
    alignment: PosPrinterAlignment
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PosPrinterPrintOptions: ...
    def __new__(cls: typing.Type[PosPrinterPrintOptions]) -> PosPrinterPrintOptions:...

class PosPrinterReleaseDeviceRequestedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PosPrinterReleaseDeviceRequestedEventArgs: ...

class PosPrinterStatus(winrt.system.Object):
    extended_status: winrt.system.UInt32
    status_kind: PosPrinterStatusKind
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PosPrinterStatus: ...

class PosPrinterStatusUpdatedEventArgs(winrt.system.Object):
    status: typing.Optional[PosPrinterStatus]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PosPrinterStatusUpdatedEventArgs: ...

class ReceiptPrintJob(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ReceiptPrintJob: ...
    @typing.overload
    def cut_paper(self) -> None: ...
    @typing.overload
    def cut_paper(self, percentage: winrt.system.Double, /) -> None: ...
    def draw_ruled_line(self, position_list: str, line_direction: PosPrinterLineDirection, line_width: winrt.system.UInt32, line_style: PosPrinterLineStyle, line_color: winrt.system.UInt32, /) -> None: ...
    def execute_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def feed_paper_by_line(self, line_count: winrt.system.Int32, /) -> None: ...
    def feed_paper_by_map_mode_unit(self, distance: winrt.system.Int32, /) -> None: ...
    def mark_feed(self, kind: PosPrinterMarkFeedKind, /) -> None: ...
    @typing.overload
    def print(self, data: str, /) -> None: ...
    @typing.overload
    def print(self, data: str, print_options: typing.Optional[PosPrinterPrintOptions], /) -> None: ...
    def print_barcode(self, data: str, symbology: winrt.system.UInt32, height: winrt.system.UInt32, width: winrt.system.UInt32, text_position: PosPrinterBarcodeTextPosition, alignment: PosPrinterAlignment, /) -> None: ...
    def print_barcode_custom_align(self, data: str, symbology: winrt.system.UInt32, height: winrt.system.UInt32, width: winrt.system.UInt32, text_position: PosPrinterBarcodeTextPosition, alignment_distance: winrt.system.UInt32, /) -> None: ...
    @typing.overload
    def print_bitmap(self, bitmap: typing.Optional[winrt.windows.graphics.imaging.BitmapFrame], alignment: PosPrinterAlignment, /) -> None: ...
    @typing.overload
    def print_bitmap(self, bitmap: typing.Optional[winrt.windows.graphics.imaging.BitmapFrame], alignment: PosPrinterAlignment, width: winrt.system.UInt32, /) -> None: ...
    @typing.overload
    def print_custom_aligned_bitmap(self, bitmap: typing.Optional[winrt.windows.graphics.imaging.BitmapFrame], alignment_distance: winrt.system.UInt32, /) -> None: ...
    @typing.overload
    def print_custom_aligned_bitmap(self, bitmap: typing.Optional[winrt.windows.graphics.imaging.BitmapFrame], alignment_distance: winrt.system.UInt32, width: winrt.system.UInt32, /) -> None: ...
    @typing.overload
    def print_line(self) -> None: ...
    @typing.overload
    def print_line(self, data: str, /) -> None: ...
    def print_saved_bitmap(self, bitmap_number: winrt.system.UInt32, /) -> None: ...
    def set_barcode_rotation(self, value: PosPrinterRotation, /) -> None: ...
    @typing.overload
    def set_bitmap(self, bitmap_number: winrt.system.UInt32, bitmap: typing.Optional[winrt.windows.graphics.imaging.BitmapFrame], alignment: PosPrinterAlignment, /) -> None: ...
    @typing.overload
    def set_bitmap(self, bitmap_number: winrt.system.UInt32, bitmap: typing.Optional[winrt.windows.graphics.imaging.BitmapFrame], alignment: PosPrinterAlignment, width: winrt.system.UInt32, /) -> None: ...
    @typing.overload
    def set_custom_aligned_bitmap(self, bitmap_number: winrt.system.UInt32, bitmap: typing.Optional[winrt.windows.graphics.imaging.BitmapFrame], alignment_distance: winrt.system.UInt32, /) -> None: ...
    @typing.overload
    def set_custom_aligned_bitmap(self, bitmap_number: winrt.system.UInt32, bitmap: typing.Optional[winrt.windows.graphics.imaging.BitmapFrame], alignment_distance: winrt.system.UInt32, width: winrt.system.UInt32, /) -> None: ...
    def set_print_area(self, value: winrt.windows.foundation.Rect, /) -> None: ...
    def set_print_rotation(self, value: PosPrinterRotation, include_bitmaps: bool, /) -> None: ...
    def stamp_paper(self) -> None: ...

class ReceiptPrinterCapabilities(winrt.system.Object):
    cartridge_sensors: PosPrinterCartridgeSensors
    color_cartridge_capabilities: PosPrinterColorCapabilities
    is_bold_supported: bool
    is_double_high_double_wide_print_supported: bool
    is_double_high_print_supported: bool
    is_double_wide_print_supported: bool
    is_dual_color_supported: bool
    is_italic_supported: bool
    is_paper_empty_sensor_supported: bool
    is_paper_near_end_sensor_supported: bool
    is_printer_present: bool
    is_underline_supported: bool
    supported_characters_per_line: typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]
    is180_rotation_supported: bool
    is_barcode_supported: bool
    is_bitmap_supported: bool
    is_left90_rotation_supported: bool
    is_print_area_supported: bool
    is_right90_rotation_supported: bool
    ruled_line_capabilities: PosPrinterRuledLineCapabilities
    supported_barcode_rotations: typing.Optional[winrt.windows.foundation.collections.IVectorView[PosPrinterRotation]]
    supported_bitmap_rotations: typing.Optional[winrt.windows.foundation.collections.IVectorView[PosPrinterRotation]]
    can_cut_paper: bool
    is_stamp_supported: bool
    mark_feed_capabilities: PosPrinterMarkFeedCapabilities
    is_reverse_paper_feed_by_line_supported: bool
    is_reverse_paper_feed_by_map_mode_unit_supported: bool
    is_reverse_video_supported: bool
    is_strikethrough_supported: bool
    is_subscript_supported: bool
    is_superscript_supported: bool
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ReceiptPrinterCapabilities: ...

class SlipPrintJob(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SlipPrintJob: ...
    def draw_ruled_line(self, position_list: str, line_direction: PosPrinterLineDirection, line_width: winrt.system.UInt32, line_style: PosPrinterLineStyle, line_color: winrt.system.UInt32, /) -> None: ...
    def execute_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def feed_paper_by_line(self, line_count: winrt.system.Int32, /) -> None: ...
    def feed_paper_by_map_mode_unit(self, distance: winrt.system.Int32, /) -> None: ...
    @typing.overload
    def print(self, data: str, /) -> None: ...
    @typing.overload
    def print(self, data: str, print_options: typing.Optional[PosPrinterPrintOptions], /) -> None: ...
    def print_barcode(self, data: str, symbology: winrt.system.UInt32, height: winrt.system.UInt32, width: winrt.system.UInt32, text_position: PosPrinterBarcodeTextPosition, alignment: PosPrinterAlignment, /) -> None: ...
    def print_barcode_custom_align(self, data: str, symbology: winrt.system.UInt32, height: winrt.system.UInt32, width: winrt.system.UInt32, text_position: PosPrinterBarcodeTextPosition, alignment_distance: winrt.system.UInt32, /) -> None: ...
    @typing.overload
    def print_bitmap(self, bitmap: typing.Optional[winrt.windows.graphics.imaging.BitmapFrame], alignment: PosPrinterAlignment, /) -> None: ...
    @typing.overload
    def print_bitmap(self, bitmap: typing.Optional[winrt.windows.graphics.imaging.BitmapFrame], alignment: PosPrinterAlignment, width: winrt.system.UInt32, /) -> None: ...
    @typing.overload
    def print_custom_aligned_bitmap(self, bitmap: typing.Optional[winrt.windows.graphics.imaging.BitmapFrame], alignment_distance: winrt.system.UInt32, /) -> None: ...
    @typing.overload
    def print_custom_aligned_bitmap(self, bitmap: typing.Optional[winrt.windows.graphics.imaging.BitmapFrame], alignment_distance: winrt.system.UInt32, width: winrt.system.UInt32, /) -> None: ...
    @typing.overload
    def print_line(self) -> None: ...
    @typing.overload
    def print_line(self, data: str, /) -> None: ...
    def print_saved_bitmap(self, bitmap_number: winrt.system.UInt32, /) -> None: ...
    def set_barcode_rotation(self, value: PosPrinterRotation, /) -> None: ...
    @typing.overload
    def set_bitmap(self, bitmap_number: winrt.system.UInt32, bitmap: typing.Optional[winrt.windows.graphics.imaging.BitmapFrame], alignment: PosPrinterAlignment, /) -> None: ...
    @typing.overload
    def set_bitmap(self, bitmap_number: winrt.system.UInt32, bitmap: typing.Optional[winrt.windows.graphics.imaging.BitmapFrame], alignment: PosPrinterAlignment, width: winrt.system.UInt32, /) -> None: ...
    @typing.overload
    def set_custom_aligned_bitmap(self, bitmap_number: winrt.system.UInt32, bitmap: typing.Optional[winrt.windows.graphics.imaging.BitmapFrame], alignment_distance: winrt.system.UInt32, /) -> None: ...
    @typing.overload
    def set_custom_aligned_bitmap(self, bitmap_number: winrt.system.UInt32, bitmap: typing.Optional[winrt.windows.graphics.imaging.BitmapFrame], alignment_distance: winrt.system.UInt32, width: winrt.system.UInt32, /) -> None: ...
    def set_print_area(self, value: winrt.windows.foundation.Rect, /) -> None: ...
    def set_print_rotation(self, value: PosPrinterRotation, include_bitmaps: bool, /) -> None: ...

class SlipPrinterCapabilities(winrt.system.Object):
    cartridge_sensors: PosPrinterCartridgeSensors
    color_cartridge_capabilities: PosPrinterColorCapabilities
    is_bold_supported: bool
    is_double_high_double_wide_print_supported: bool
    is_double_high_print_supported: bool
    is_double_wide_print_supported: bool
    is_dual_color_supported: bool
    is_italic_supported: bool
    is_paper_empty_sensor_supported: bool
    is_paper_near_end_sensor_supported: bool
    is_printer_present: bool
    is_underline_supported: bool
    supported_characters_per_line: typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]
    is180_rotation_supported: bool
    is_barcode_supported: bool
    is_bitmap_supported: bool
    is_left90_rotation_supported: bool
    is_print_area_supported: bool
    is_right90_rotation_supported: bool
    ruled_line_capabilities: PosPrinterRuledLineCapabilities
    supported_barcode_rotations: typing.Optional[winrt.windows.foundation.collections.IVectorView[PosPrinterRotation]]
    supported_bitmap_rotations: typing.Optional[winrt.windows.foundation.collections.IVectorView[PosPrinterRotation]]
    is_both_sides_printing_supported: bool
    is_full_length_supported: bool
    is_reverse_paper_feed_by_line_supported: bool
    is_reverse_paper_feed_by_map_mode_unit_supported: bool
    is_reverse_video_supported: bool
    is_strikethrough_supported: bool
    is_subscript_supported: bool
    is_superscript_supported: bool
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SlipPrinterCapabilities: ...

class UnifiedPosErrorData(winrt.system.Object):
    extended_reason: winrt.system.UInt32
    message: str
    reason: UnifiedPosErrorReason
    severity: UnifiedPosErrorSeverity
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UnifiedPosErrorData: ...
    def __new__(cls: typing.Type[UnifiedPosErrorData], message: str, severity: UnifiedPosErrorSeverity, reason: UnifiedPosErrorReason, extended_reason: winrt.system.UInt32) -> UnifiedPosErrorData:...

class ICashDrawerEventSourceEventArgs(winrt.system.Object):
    cash_drawer: typing.Optional[CashDrawer]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ICashDrawerEventSourceEventArgs: ...

class ICommonClaimedPosPrinterStation(winrt.system.Object):
    characters_per_line: winrt.system.UInt32
    color_cartridge: PosPrinterColorCartridge
    is_cartridge_empty: bool
    is_cartridge_removed: bool
    is_cover_open: bool
    is_head_cleaning: bool
    is_letter_quality: bool
    is_paper_empty: bool
    is_paper_near_end: bool
    is_ready_to_print: bool
    line_height: winrt.system.UInt32
    line_spacing: winrt.system.UInt32
    line_width: winrt.system.UInt32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ICommonClaimedPosPrinterStation: ...
    def validate_data(self, data: str, /) -> bool: ...

class ICommonPosPrintStationCapabilities(winrt.system.Object):
    cartridge_sensors: PosPrinterCartridgeSensors
    color_cartridge_capabilities: PosPrinterColorCapabilities
    is_bold_supported: bool
    is_double_high_double_wide_print_supported: bool
    is_double_high_print_supported: bool
    is_double_wide_print_supported: bool
    is_dual_color_supported: bool
    is_italic_supported: bool
    is_paper_empty_sensor_supported: bool
    is_paper_near_end_sensor_supported: bool
    is_printer_present: bool
    is_underline_supported: bool
    supported_characters_per_line: typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ICommonPosPrintStationCapabilities: ...

class ICommonReceiptSlipCapabilities(winrt.system.Object):
    is180_rotation_supported: bool
    is_barcode_supported: bool
    is_bitmap_supported: bool
    is_left90_rotation_supported: bool
    is_print_area_supported: bool
    is_right90_rotation_supported: bool
    ruled_line_capabilities: PosPrinterRuledLineCapabilities
    supported_barcode_rotations: typing.Optional[winrt.windows.foundation.collections.IVectorView[PosPrinterRotation]]
    supported_bitmap_rotations: typing.Optional[winrt.windows.foundation.collections.IVectorView[PosPrinterRotation]]
    cartridge_sensors: PosPrinterCartridgeSensors
    color_cartridge_capabilities: PosPrinterColorCapabilities
    is_bold_supported: bool
    is_double_high_double_wide_print_supported: bool
    is_double_high_print_supported: bool
    is_double_wide_print_supported: bool
    is_dual_color_supported: bool
    is_italic_supported: bool
    is_paper_empty_sensor_supported: bool
    is_paper_near_end_sensor_supported: bool
    is_printer_present: bool
    is_underline_supported: bool
    supported_characters_per_line: typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ICommonReceiptSlipCapabilities: ...

class IPosPrinterJob(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IPosPrinterJob: ...
    def execute_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def print(self, data: str, /) -> None: ...
    @typing.overload
    def print_line(self) -> None: ...
    @typing.overload
    def print_line(self, data: str, /) -> None: ...

class IReceiptOrSlipJob(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IReceiptOrSlipJob: ...
    def draw_ruled_line(self, position_list: str, line_direction: PosPrinterLineDirection, line_width: winrt.system.UInt32, line_style: PosPrinterLineStyle, line_color: winrt.system.UInt32, /) -> None: ...
    def execute_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def print(self, data: str, /) -> None: ...
    def print_barcode(self, data: str, symbology: winrt.system.UInt32, height: winrt.system.UInt32, width: winrt.system.UInt32, text_position: PosPrinterBarcodeTextPosition, alignment: PosPrinterAlignment, /) -> None: ...
    def print_barcode_custom_align(self, data: str, symbology: winrt.system.UInt32, height: winrt.system.UInt32, width: winrt.system.UInt32, text_position: PosPrinterBarcodeTextPosition, alignment_distance: winrt.system.UInt32, /) -> None: ...
    @typing.overload
    def print_bitmap(self, bitmap: typing.Optional[winrt.windows.graphics.imaging.BitmapFrame], alignment: PosPrinterAlignment, /) -> None: ...
    @typing.overload
    def print_bitmap(self, bitmap: typing.Optional[winrt.windows.graphics.imaging.BitmapFrame], alignment: PosPrinterAlignment, width: winrt.system.UInt32, /) -> None: ...
    @typing.overload
    def print_custom_aligned_bitmap(self, bitmap: typing.Optional[winrt.windows.graphics.imaging.BitmapFrame], alignment_distance: winrt.system.UInt32, /) -> None: ...
    @typing.overload
    def print_custom_aligned_bitmap(self, bitmap: typing.Optional[winrt.windows.graphics.imaging.BitmapFrame], alignment_distance: winrt.system.UInt32, width: winrt.system.UInt32, /) -> None: ...
    @typing.overload
    def print_line(self) -> None: ...
    @typing.overload
    def print_line(self, data: str, /) -> None: ...
    def print_saved_bitmap(self, bitmap_number: winrt.system.UInt32, /) -> None: ...
    def set_barcode_rotation(self, value: PosPrinterRotation, /) -> None: ...
    @typing.overload
    def set_bitmap(self, bitmap_number: winrt.system.UInt32, bitmap: typing.Optional[winrt.windows.graphics.imaging.BitmapFrame], alignment: PosPrinterAlignment, /) -> None: ...
    @typing.overload
    def set_bitmap(self, bitmap_number: winrt.system.UInt32, bitmap: typing.Optional[winrt.windows.graphics.imaging.BitmapFrame], alignment: PosPrinterAlignment, width: winrt.system.UInt32, /) -> None: ...
    @typing.overload
    def set_custom_aligned_bitmap(self, bitmap_number: winrt.system.UInt32, bitmap: typing.Optional[winrt.windows.graphics.imaging.BitmapFrame], alignment_distance: winrt.system.UInt32, /) -> None: ...
    @typing.overload
    def set_custom_aligned_bitmap(self, bitmap_number: winrt.system.UInt32, bitmap: typing.Optional[winrt.windows.graphics.imaging.BitmapFrame], alignment_distance: winrt.system.UInt32, width: winrt.system.UInt32, /) -> None: ...
    def set_print_area(self, value: winrt.windows.foundation.Rect, /) -> None: ...
    def set_print_rotation(self, value: PosPrinterRotation, include_bitmaps: bool, /) -> None: ...

