# WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt.system
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.graphics.imaging
import winrt.windows.storage
import winrt.windows.storage.streams

from . import BarcodeScannerStatus, BarcodeSymbologyDecodeLengthKind, CashDrawerStatusKind, LineDisplayCursorType, LineDisplayDescriptorState, LineDisplayHorizontalAlignment, LineDisplayMarqueeFormat, LineDisplayPowerStatus, LineDisplayScrollDirection, LineDisplayTextAttribute, LineDisplayTextAttributeGranularity, LineDisplayVerticalAlignment, MagneticStripeReaderAuthenticationLevel, MagneticStripeReaderAuthenticationProtocol, MagneticStripeReaderErrorReportingType, MagneticStripeReaderStatus, MagneticStripeReaderTrackErrorType, MagneticStripeReaderTrackIds, PosConnectionTypes, PosPrinterAlignment, PosPrinterBarcodeTextPosition, PosPrinterCartridgeSensors, PosPrinterColorCapabilities, PosPrinterColorCartridge, PosPrinterLineDirection, PosPrinterLineStyle, PosPrinterMapMode, PosPrinterMarkFeedCapabilities, PosPrinterMarkFeedKind, PosPrinterPrintSide, PosPrinterRotation, PosPrinterRuledLineCapabilities, PosPrinterStatusKind, UnifiedPosErrorReason, UnifiedPosErrorSeverity, UnifiedPosHealthCheckLevel, UnifiedPosPowerReportingType

Self = typing.TypeVar('Self')

class SizeUInt32:
    width: winrt.system.UInt32
    height: winrt.system.UInt32
    def __init__(self, width: winrt.system.UInt32, height: winrt.system.UInt32) -> None: ...

class BarcodeScanner(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BarcodeScanner: ...
    def check_health_async(self, level: UnifiedPosHealthCheckLevel, /) -> winrt.windows.foundation.IAsyncOperation[str]: ...
    def claim_scanner_async(self) -> winrt.windows.foundation.IAsyncOperation[ClaimedBarcodeScanner]: ...
    def close(self) -> None: ...
    @staticmethod
    def from_id_async(device_id: str, /) -> winrt.windows.foundation.IAsyncOperation[BarcodeScanner]: ...
    @staticmethod
    def get_default_async() -> winrt.windows.foundation.IAsyncOperation[BarcodeScanner]: ...
    @typing.overload
    @staticmethod
    def get_device_selector() -> str: ...
    @typing.overload
    @staticmethod
    def get_device_selector(connection_types: PosConnectionTypes, /) -> str: ...
    def get_supported_profiles(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[str]]: ...
    def get_supported_symbologies_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]: ...
    def is_profile_supported(self, profile: str, /) -> bool: ...
    def is_symbology_supported_async(self, barcode_symbology: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def retrieve_statistics_async(self, statistics_categories: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.streams.IBuffer]: ...
    def add_status_updated(self, handler: winrt.windows.foundation.TypedEventHandler[BarcodeScanner, BarcodeScannerStatusUpdatedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_status_updated(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def capabilities(self) -> typing.Optional[BarcodeScannerCapabilities]: ...
    @_property
    def device_id(self) -> str: ...
    @_property
    def video_device_id(self) -> str: ...

class BarcodeScannerCapabilities(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BarcodeScannerCapabilities: ...
    @_property
    def is_image_preview_supported(self) -> bool: ...
    @_property
    def is_statistics_reporting_supported(self) -> bool: ...
    @_property
    def is_statistics_updating_supported(self) -> bool: ...
    @_property
    def power_reporting_type(self) -> UnifiedPosPowerReportingType: ...
    @_property
    def is_software_trigger_supported(self) -> bool: ...
    @_property
    def is_video_preview_supported(self) -> bool: ...

class BarcodeScannerDataReceivedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BarcodeScannerDataReceivedEventArgs: ...
    @_property
    def report(self) -> typing.Optional[BarcodeScannerReport]: ...

class BarcodeScannerErrorOccurredEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BarcodeScannerErrorOccurredEventArgs: ...
    @_property
    def error_data(self) -> typing.Optional[UnifiedPosErrorData]: ...
    @_property
    def is_retriable(self) -> bool: ...
    @_property
    def partial_input_data(self) -> typing.Optional[BarcodeScannerReport]: ...

class BarcodeScannerImagePreviewReceivedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BarcodeScannerImagePreviewReceivedEventArgs: ...
    @_property
    def preview(self) -> typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamWithContentType]: ...

class BarcodeScannerReport(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BarcodeScannerReport: ...
    def __new__(cls: typing.Type[BarcodeScannerReport], scan_data_type: winrt.system.UInt32, scan_data: typing.Optional[winrt.windows.storage.streams.IBuffer], scan_data_label: typing.Optional[winrt.windows.storage.streams.IBuffer]) -> BarcodeScannerReport:...
    @_property
    def scan_data(self) -> typing.Optional[winrt.windows.storage.streams.IBuffer]: ...
    @_property
    def scan_data_label(self) -> typing.Optional[winrt.windows.storage.streams.IBuffer]: ...
    @_property
    def scan_data_type(self) -> winrt.system.UInt32: ...

class BarcodeScannerStatusUpdatedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BarcodeScannerStatusUpdatedEventArgs: ...
    @_property
    def extended_status(self) -> winrt.system.UInt32: ...
    @_property
    def status(self) -> BarcodeScannerStatus: ...

class BarcodeSymbologies(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BarcodeSymbologies: ...
    @staticmethod
    def get_name(scan_data_type: winrt.system.UInt32, /) -> str: ...
    code11: typing.ClassVar[winrt.system.UInt32]
    aus_post: typing.ClassVar[winrt.system.UInt32]
    aztec: typing.ClassVar[winrt.system.UInt32]
    can_post: typing.ClassVar[winrt.system.UInt32]
    ccab: typing.ClassVar[winrt.system.UInt32]
    ccc: typing.ClassVar[winrt.system.UInt32]
    china_post: typing.ClassVar[winrt.system.UInt32]
    codabar: typing.ClassVar[winrt.system.UInt32]
    codablock128: typing.ClassVar[winrt.system.UInt32]
    codablock_a: typing.ClassVar[winrt.system.UInt32]
    codablock_f: typing.ClassVar[winrt.system.UInt32]
    dutch_kix: typing.ClassVar[winrt.system.UInt32]
    code128: typing.ClassVar[winrt.system.UInt32]
    code16k: typing.ClassVar[winrt.system.UInt32]
    code32: typing.ClassVar[winrt.system.UInt32]
    code39: typing.ClassVar[winrt.system.UInt32]
    code39_ex: typing.ClassVar[winrt.system.UInt32]
    code49: typing.ClassVar[winrt.system.UInt32]
    code93: typing.ClassVar[winrt.system.UInt32]
    code93_ex: typing.ClassVar[winrt.system.UInt32]
    data_code: typing.ClassVar[winrt.system.UInt32]
    data_matrix: typing.ClassVar[winrt.system.UInt32]
    us_post_net: typing.ClassVar[winrt.system.UInt32]
    ean13: typing.ClassVar[winrt.system.UInt32]
    ean13_add2: typing.ClassVar[winrt.system.UInt32]
    ean13_add5: typing.ClassVar[winrt.system.UInt32]
    ean8: typing.ClassVar[winrt.system.UInt32]
    ean8_add2: typing.ClassVar[winrt.system.UInt32]
    ean8_add5: typing.ClassVar[winrt.system.UInt32]
    ean99: typing.ClassVar[winrt.system.UInt32]
    ean99_add2: typing.ClassVar[winrt.system.UInt32]
    ean99_add5: typing.ClassVar[winrt.system.UInt32]
    eanv: typing.ClassVar[winrt.system.UInt32]
    eanv_add2: typing.ClassVar[winrt.system.UInt32]
    eanv_add5: typing.ClassVar[winrt.system.UInt32]
    extended_base: typing.ClassVar[winrt.system.UInt32]
    gs1128: typing.ClassVar[winrt.system.UInt32]
    gs1128_coupon: typing.ClassVar[winrt.system.UInt32]
    gs1_databar_type1: typing.ClassVar[winrt.system.UInt32]
    gs1_databar_type2: typing.ClassVar[winrt.system.UInt32]
    gs1_databar_type3: typing.ClassVar[winrt.system.UInt32]
    han_xin: typing.ClassVar[winrt.system.UInt32]
    info_mail: typing.ClassVar[winrt.system.UInt32]
    isbn: typing.ClassVar[winrt.system.UInt32]
    isbn_add5: typing.ClassVar[winrt.system.UInt32]
    isbt: typing.ClassVar[winrt.system.UInt32]
    ismn: typing.ClassVar[winrt.system.UInt32]
    ismn_add2: typing.ClassVar[winrt.system.UInt32]
    ismn_add5: typing.ClassVar[winrt.system.UInt32]
    issn: typing.ClassVar[winrt.system.UInt32]
    issn_add2: typing.ClassVar[winrt.system.UInt32]
    issn_add5: typing.ClassVar[winrt.system.UInt32]
    italian_post25: typing.ClassVar[winrt.system.UInt32]
    italian_post39: typing.ClassVar[winrt.system.UInt32]
    japan_post: typing.ClassVar[winrt.system.UInt32]
    korean_post: typing.ClassVar[winrt.system.UInt32]
    maxicode: typing.ClassVar[winrt.system.UInt32]
    micr: typing.ClassVar[winrt.system.UInt32]
    micro_pdf417: typing.ClassVar[winrt.system.UInt32]
    micro_qr: typing.ClassVar[winrt.system.UInt32]
    ms_tag: typing.ClassVar[winrt.system.UInt32]
    msi: typing.ClassVar[winrt.system.UInt32]
    ocr_a: typing.ClassVar[winrt.system.UInt32]
    ocr_b: typing.ClassVar[winrt.system.UInt32]
    pdf417: typing.ClassVar[winrt.system.UInt32]
    plessey: typing.ClassVar[winrt.system.UInt32]
    pzn: typing.ClassVar[winrt.system.UInt32]
    qr: typing.ClassVar[winrt.system.UInt32]
    sisac: typing.ClassVar[winrt.system.UInt32]
    sweden_post: typing.ClassVar[winrt.system.UInt32]
    telepen: typing.ClassVar[winrt.system.UInt32]
    tf_dis: typing.ClassVar[winrt.system.UInt32]
    tf_iata: typing.ClassVar[winrt.system.UInt32]
    tf_ind: typing.ClassVar[winrt.system.UInt32]
    tf_int: typing.ClassVar[winrt.system.UInt32]
    tf_mat: typing.ClassVar[winrt.system.UInt32]
    tf_std: typing.ClassVar[winrt.system.UInt32]
    tlc39: typing.ClassVar[winrt.system.UInt32]
    trioptic39: typing.ClassVar[winrt.system.UInt32]
    ucc_ean128: typing.ClassVar[winrt.system.UInt32]
    uk_post: typing.ClassVar[winrt.system.UInt32]
    unknown: typing.ClassVar[winrt.system.UInt32]
    upc_coupon: typing.ClassVar[winrt.system.UInt32]
    upca: typing.ClassVar[winrt.system.UInt32]
    upca_add2: typing.ClassVar[winrt.system.UInt32]
    upca_add5: typing.ClassVar[winrt.system.UInt32]
    upce: typing.ClassVar[winrt.system.UInt32]
    upce_add2: typing.ClassVar[winrt.system.UInt32]
    upce_add5: typing.ClassVar[winrt.system.UInt32]
    us4_state_fics: typing.ClassVar[winrt.system.UInt32]
    us_intelligent: typing.ClassVar[winrt.system.UInt32]
    us_intelligent_pkg: typing.ClassVar[winrt.system.UInt32]
    us_planet: typing.ClassVar[winrt.system.UInt32]
    gs1_d_w_code: typing.ClassVar[winrt.system.UInt32]

class BarcodeSymbologyAttributes(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BarcodeSymbologyAttributes: ...
    @_property
    def is_check_digit_validation_enabled(self) -> bool: ...
    @is_check_digit_validation_enabled.setter
    def is_check_digit_validation_enabled(self, value: bool) -> None: ...
    @_property
    def is_check_digit_transmission_enabled(self) -> bool: ...
    @is_check_digit_transmission_enabled.setter
    def is_check_digit_transmission_enabled(self, value: bool) -> None: ...
    @_property
    def decode_length_kind(self) -> BarcodeSymbologyDecodeLengthKind: ...
    @decode_length_kind.setter
    def decode_length_kind(self, value: BarcodeSymbologyDecodeLengthKind) -> None: ...
    @_property
    def decode_length2(self) -> winrt.system.UInt32: ...
    @decode_length2.setter
    def decode_length2(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def decode_length1(self) -> winrt.system.UInt32: ...
    @decode_length1.setter
    def decode_length1(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def is_check_digit_transmission_supported(self) -> bool: ...
    @_property
    def is_check_digit_validation_supported(self) -> bool: ...
    @_property
    def is_decode_length_supported(self) -> bool: ...

class CashDrawer(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CashDrawer: ...
    def check_health_async(self, level: UnifiedPosHealthCheckLevel, /) -> winrt.windows.foundation.IAsyncOperation[str]: ...
    def claim_drawer_async(self) -> winrt.windows.foundation.IAsyncOperation[ClaimedCashDrawer]: ...
    def close(self) -> None: ...
    @staticmethod
    def from_id_async(device_id: str, /) -> winrt.windows.foundation.IAsyncOperation[CashDrawer]: ...
    @staticmethod
    def get_default_async() -> winrt.windows.foundation.IAsyncOperation[CashDrawer]: ...
    @typing.overload
    @staticmethod
    def get_device_selector() -> str: ...
    @typing.overload
    @staticmethod
    def get_device_selector(connection_types: PosConnectionTypes, /) -> str: ...
    def get_statistics_async(self, statistics_categories: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncOperation[str]: ...
    def add_status_updated(self, handler: winrt.windows.foundation.TypedEventHandler[CashDrawer, CashDrawerStatusUpdatedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_status_updated(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def capabilities(self) -> typing.Optional[CashDrawerCapabilities]: ...
    @_property
    def device_id(self) -> str: ...
    @_property
    def drawer_event_source(self) -> typing.Optional[CashDrawerEventSource]: ...
    @_property
    def is_drawer_open(self) -> bool: ...
    @_property
    def status(self) -> typing.Optional[CashDrawerStatus]: ...

class CashDrawerCapabilities(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CashDrawerCapabilities: ...
    @_property
    def is_drawer_open_sensor_available(self) -> bool: ...
    @_property
    def is_statistics_reporting_supported(self) -> bool: ...
    @_property
    def is_statistics_updating_supported(self) -> bool: ...
    @_property
    def is_status_multi_drawer_detect_supported(self) -> bool: ...
    @_property
    def is_status_reporting_supported(self) -> bool: ...
    @_property
    def power_reporting_type(self) -> UnifiedPosPowerReportingType: ...

class CashDrawerCloseAlarm(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CashDrawerCloseAlarm: ...
    def start_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def add_alarm_timeout_expired(self, handler: winrt.windows.foundation.TypedEventHandler[CashDrawerCloseAlarm, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_alarm_timeout_expired(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def beep_frequency(self) -> winrt.system.UInt32: ...
    @beep_frequency.setter
    def beep_frequency(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def beep_duration(self) -> datetime.timedelta: ...
    @beep_duration.setter
    def beep_duration(self, value: datetime.timedelta) -> None: ...
    @_property
    def beep_delay(self) -> datetime.timedelta: ...
    @beep_delay.setter
    def beep_delay(self, value: datetime.timedelta) -> None: ...
    @_property
    def alarm_timeout(self) -> datetime.timedelta: ...
    @alarm_timeout.setter
    def alarm_timeout(self, value: datetime.timedelta) -> None: ...

class CashDrawerClosedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CashDrawerClosedEventArgs: ...
    @_property
    def cash_drawer(self) -> typing.Optional[CashDrawer]: ...

class CashDrawerEventSource(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CashDrawerEventSource: ...
    def add_drawer_closed(self, handler: winrt.windows.foundation.TypedEventHandler[CashDrawerEventSource, CashDrawerClosedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_drawer_closed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_drawer_opened(self, handler: winrt.windows.foundation.TypedEventHandler[CashDrawerEventSource, CashDrawerOpenedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_drawer_opened(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class CashDrawerOpenedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CashDrawerOpenedEventArgs: ...
    @_property
    def cash_drawer(self) -> typing.Optional[CashDrawer]: ...

class CashDrawerStatus(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CashDrawerStatus: ...
    @_property
    def extended_status(self) -> winrt.system.UInt32: ...
    @_property
    def status_kind(self) -> CashDrawerStatusKind: ...

class CashDrawerStatusUpdatedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CashDrawerStatusUpdatedEventArgs: ...
    @_property
    def status(self) -> typing.Optional[CashDrawerStatus]: ...

class ClaimedBarcodeScanner(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ClaimedBarcodeScanner: ...
    def close(self) -> None: ...
    def disable_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def enable_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def get_symbology_attributes_async(self, barcode_symbology: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[BarcodeSymbologyAttributes]: ...
    def hide_video_preview(self) -> None: ...
    def reset_statistics_async(self, statistics_categories: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncAction: ...
    def retain_device(self) -> None: ...
    def set_active_profile_async(self, profile: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    def set_active_symbologies_async(self, symbologies: typing.Iterable[winrt.system.UInt32], /) -> winrt.windows.foundation.IAsyncAction: ...
    def set_symbology_attributes_async(self, barcode_symbology: winrt.system.UInt32, attributes: typing.Optional[BarcodeSymbologyAttributes], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def show_video_preview_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def start_software_trigger_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def stop_software_trigger_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def update_statistics_async(self, statistics: typing.Iterable[winrt.windows.foundation.collections.IKeyValuePair[str, str]], /) -> winrt.windows.foundation.IAsyncAction: ...
    def add_data_received(self, handler: winrt.windows.foundation.TypedEventHandler[ClaimedBarcodeScanner, BarcodeScannerDataReceivedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_data_received(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_error_occurred(self, handler: winrt.windows.foundation.TypedEventHandler[ClaimedBarcodeScanner, BarcodeScannerErrorOccurredEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_error_occurred(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_image_preview_received(self, handler: winrt.windows.foundation.TypedEventHandler[ClaimedBarcodeScanner, BarcodeScannerImagePreviewReceivedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_image_preview_received(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_release_device_requested(self, handler: winrt.windows.foundation.EventHandler[ClaimedBarcodeScanner], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_release_device_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_trigger_pressed(self, handler: winrt.windows.foundation.EventHandler[ClaimedBarcodeScanner], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_trigger_pressed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_trigger_released(self, handler: winrt.windows.foundation.EventHandler[ClaimedBarcodeScanner], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_trigger_released(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_closed(self, handler: winrt.windows.foundation.TypedEventHandler[ClaimedBarcodeScanner, ClaimedBarcodeScannerClosedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_closed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def is_disabled_on_data_received(self) -> bool: ...
    @is_disabled_on_data_received.setter
    def is_disabled_on_data_received(self, value: bool) -> None: ...
    @_property
    def is_decode_data_enabled(self) -> bool: ...
    @is_decode_data_enabled.setter
    def is_decode_data_enabled(self, value: bool) -> None: ...
    @_property
    def device_id(self) -> str: ...
    @_property
    def is_enabled(self) -> bool: ...
    @_property
    def is_video_preview_shown_on_enable(self) -> bool: ...
    @is_video_preview_shown_on_enable.setter
    def is_video_preview_shown_on_enable(self, value: bool) -> None: ...

class ClaimedBarcodeScannerClosedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ClaimedBarcodeScannerClosedEventArgs: ...

class ClaimedCashDrawer(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ClaimedCashDrawer: ...
    def close(self) -> None: ...
    def disable_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def enable_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def open_drawer_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def reset_statistics_async(self, statistics_categories: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def retain_device_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def update_statistics_async(self, statistics: typing.Iterable[winrt.windows.foundation.collections.IKeyValuePair[str, str]], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def add_release_device_requested(self, handler: winrt.windows.foundation.TypedEventHandler[ClaimedCashDrawer, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_release_device_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_closed(self, handler: winrt.windows.foundation.TypedEventHandler[ClaimedCashDrawer, ClaimedCashDrawerClosedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_closed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def close_alarm(self) -> typing.Optional[CashDrawerCloseAlarm]: ...
    @_property
    def device_id(self) -> str: ...
    @_property
    def is_drawer_open(self) -> bool: ...
    @_property
    def is_enabled(self) -> bool: ...

class ClaimedCashDrawerClosedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ClaimedCashDrawerClosedEventArgs: ...

class ClaimedJournalPrinter(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ClaimedJournalPrinter: ...
    def create_job(self) -> typing.Optional[JournalPrintJob]: ...
    def validate_data(self, data: str, /) -> bool: ...
    @_property
    def line_spacing(self) -> winrt.system.UInt32: ...
    @line_spacing.setter
    def line_spacing(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def line_height(self) -> winrt.system.UInt32: ...
    @line_height.setter
    def line_height(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def is_letter_quality(self) -> bool: ...
    @is_letter_quality.setter
    def is_letter_quality(self, value: bool) -> None: ...
    @_property
    def color_cartridge(self) -> PosPrinterColorCartridge: ...
    @color_cartridge.setter
    def color_cartridge(self, value: PosPrinterColorCartridge) -> None: ...
    @_property
    def characters_per_line(self) -> winrt.system.UInt32: ...
    @characters_per_line.setter
    def characters_per_line(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def is_cartridge_empty(self) -> bool: ...
    @_property
    def is_cartridge_removed(self) -> bool: ...
    @_property
    def is_cover_open(self) -> bool: ...
    @_property
    def is_head_cleaning(self) -> bool: ...
    @_property
    def is_paper_empty(self) -> bool: ...
    @_property
    def is_paper_near_end(self) -> bool: ...
    @_property
    def is_ready_to_print(self) -> bool: ...
    @_property
    def line_width(self) -> winrt.system.UInt32: ...

class ClaimedLineDisplay(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ClaimedLineDisplay: ...
    def check_health_async(self, level: UnifiedPosHealthCheckLevel, /) -> winrt.windows.foundation.IAsyncOperation[str]: ...
    def check_power_status_async(self) -> winrt.windows.foundation.IAsyncOperation[LineDisplayPowerStatus]: ...
    def close(self) -> None: ...
    @staticmethod
    def from_id_async(device_id: str, /) -> winrt.windows.foundation.IAsyncOperation[ClaimedLineDisplay]: ...
    def get_attributes(self) -> typing.Optional[LineDisplayAttributes]: ...
    @typing.overload
    @staticmethod
    def get_device_selector() -> str: ...
    @typing.overload
    @staticmethod
    def get_device_selector(connection_types: PosConnectionTypes, /) -> str: ...
    def get_statistics_async(self, statistics_categories: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncOperation[str]: ...
    def retain_device(self) -> None: ...
    def try_clear_descriptors_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def try_create_window_async(self, viewport: winrt.windows.foundation.Rect, window_size: winrt.windows.foundation.Size, /) -> winrt.windows.foundation.IAsyncOperation[LineDisplayWindow]: ...
    def try_set_descriptor_async(self, descriptor: winrt.system.UInt32, descriptor_state: LineDisplayDescriptorState, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @typing.overload
    def try_store_storage_file_bitmap_async(self, bitmap: typing.Optional[winrt.windows.storage.StorageFile], /) -> winrt.windows.foundation.IAsyncOperation[LineDisplayStoredBitmap]: ...
    @typing.overload
    def try_store_storage_file_bitmap_async(self, bitmap: typing.Optional[winrt.windows.storage.StorageFile], horizontal_alignment: LineDisplayHorizontalAlignment, vertical_alignment: LineDisplayVerticalAlignment, /) -> winrt.windows.foundation.IAsyncOperation[LineDisplayStoredBitmap]: ...
    @typing.overload
    def try_store_storage_file_bitmap_async(self, bitmap: typing.Optional[winrt.windows.storage.StorageFile], horizontal_alignment: LineDisplayHorizontalAlignment, vertical_alignment: LineDisplayVerticalAlignment, width_in_pixels: winrt.system.Int32, /) -> winrt.windows.foundation.IAsyncOperation[LineDisplayStoredBitmap]: ...
    def try_update_attributes_async(self, attributes: typing.Optional[LineDisplayAttributes], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def add_release_device_requested(self, handler: winrt.windows.foundation.TypedEventHandler[ClaimedLineDisplay, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_release_device_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_status_updated(self, handler: winrt.windows.foundation.TypedEventHandler[ClaimedLineDisplay, LineDisplayStatusUpdatedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_status_updated(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_closed(self, handler: winrt.windows.foundation.TypedEventHandler[ClaimedLineDisplay, ClaimedLineDisplayClosedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_closed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def capabilities(self) -> typing.Optional[LineDisplayCapabilities]: ...
    @_property
    def default_window(self) -> typing.Optional[LineDisplayWindow]: ...
    @_property
    def device_control_description(self) -> str: ...
    @_property
    def device_control_version(self) -> str: ...
    @_property
    def device_id(self) -> str: ...
    @_property
    def device_service_version(self) -> str: ...
    @_property
    def physical_device_description(self) -> str: ...
    @_property
    def physical_device_name(self) -> str: ...
    @_property
    def custom_glyphs(self) -> typing.Optional[LineDisplayCustomGlyphs]: ...
    @_property
    def max_bitmap_size_in_pixels(self) -> winrt.windows.foundation.Size: ...
    @_property
    def supported_character_sets(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Int32]]: ...
    @_property
    def supported_screen_sizes_in_characters(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.foundation.Size]]: ...

class ClaimedLineDisplayClosedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ClaimedLineDisplayClosedEventArgs: ...

class ClaimedMagneticStripeReader(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ClaimedMagneticStripeReader: ...
    def authenticate_device_async(self, response_token: winrt.system.Array[winrt.system.UInt8], /) -> winrt.windows.foundation.IAsyncAction: ...
    def close(self) -> None: ...
    def de_authenticate_device_async(self, response_token: winrt.system.Array[winrt.system.UInt8], /) -> winrt.windows.foundation.IAsyncAction: ...
    def disable_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def enable_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def reset_statistics_async(self, statistics_categories: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncAction: ...
    def retain_device(self) -> None: ...
    def retrieve_device_authentication_data_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.streams.IBuffer]: ...
    def set_error_reporting_type(self, value: MagneticStripeReaderErrorReportingType, /) -> None: ...
    def update_key_async(self, key: str, key_name: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    def update_statistics_async(self, statistics: typing.Iterable[winrt.windows.foundation.collections.IKeyValuePair[str, str]], /) -> winrt.windows.foundation.IAsyncAction: ...
    def add_aamva_card_data_received(self, handler: winrt.windows.foundation.TypedEventHandler[ClaimedMagneticStripeReader, MagneticStripeReaderAamvaCardDataReceivedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_aamva_card_data_received(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_bank_card_data_received(self, handler: winrt.windows.foundation.TypedEventHandler[ClaimedMagneticStripeReader, MagneticStripeReaderBankCardDataReceivedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_bank_card_data_received(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_error_occurred(self, handler: winrt.windows.foundation.TypedEventHandler[ClaimedMagneticStripeReader, MagneticStripeReaderErrorOccurredEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_error_occurred(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_release_device_requested(self, handler: winrt.windows.foundation.EventHandler[ClaimedMagneticStripeReader], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_release_device_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_vendor_specific_data_received(self, handler: winrt.windows.foundation.TypedEventHandler[ClaimedMagneticStripeReader, MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_vendor_specific_data_received(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_closed(self, handler: winrt.windows.foundation.TypedEventHandler[ClaimedMagneticStripeReader, ClaimedMagneticStripeReaderClosedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_closed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def tracks_to_read(self) -> MagneticStripeReaderTrackIds: ...
    @tracks_to_read.setter
    def tracks_to_read(self, value: MagneticStripeReaderTrackIds) -> None: ...
    @_property
    def is_transmit_sentinels_enabled(self) -> bool: ...
    @is_transmit_sentinels_enabled.setter
    def is_transmit_sentinels_enabled(self, value: bool) -> None: ...
    @_property
    def is_disabled_on_data_received(self) -> bool: ...
    @is_disabled_on_data_received.setter
    def is_disabled_on_data_received(self, value: bool) -> None: ...
    @_property
    def is_decode_data_enabled(self) -> bool: ...
    @is_decode_data_enabled.setter
    def is_decode_data_enabled(self, value: bool) -> None: ...
    @_property
    def data_encryption_algorithm(self) -> winrt.system.UInt32: ...
    @data_encryption_algorithm.setter
    def data_encryption_algorithm(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def device_id(self) -> str: ...
    @_property
    def is_device_authenticated(self) -> bool: ...
    @_property
    def is_enabled(self) -> bool: ...

class ClaimedMagneticStripeReaderClosedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ClaimedMagneticStripeReaderClosedEventArgs: ...

class ClaimedPosPrinter(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ClaimedPosPrinter: ...
    def close(self) -> None: ...
    def disable_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def enable_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def reset_statistics_async(self, statistics_categories: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def retain_device_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def update_statistics_async(self, statistics: typing.Iterable[winrt.windows.foundation.collections.IKeyValuePair[str, str]], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def add_release_device_requested(self, handler: winrt.windows.foundation.TypedEventHandler[ClaimedPosPrinter, PosPrinterReleaseDeviceRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_release_device_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_closed(self, handler: winrt.windows.foundation.TypedEventHandler[ClaimedPosPrinter, ClaimedPosPrinterClosedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_closed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def map_mode(self) -> PosPrinterMapMode: ...
    @map_mode.setter
    def map_mode(self, value: PosPrinterMapMode) -> None: ...
    @_property
    def is_character_set_mapping_enabled(self) -> bool: ...
    @is_character_set_mapping_enabled.setter
    def is_character_set_mapping_enabled(self, value: bool) -> None: ...
    @_property
    def character_set(self) -> winrt.system.UInt32: ...
    @character_set.setter
    def character_set(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def device_id(self) -> str: ...
    @_property
    def is_cover_open(self) -> bool: ...
    @_property
    def is_enabled(self) -> bool: ...
    @_property
    def journal(self) -> typing.Optional[ClaimedJournalPrinter]: ...
    @_property
    def receipt(self) -> typing.Optional[ClaimedReceiptPrinter]: ...
    @_property
    def slip(self) -> typing.Optional[ClaimedSlipPrinter]: ...

class ClaimedPosPrinterClosedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ClaimedPosPrinterClosedEventArgs: ...

class ClaimedReceiptPrinter(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ClaimedReceiptPrinter: ...
    def create_job(self) -> typing.Optional[ReceiptPrintJob]: ...
    def validate_data(self, data: str, /) -> bool: ...
    @_property
    def lines_to_paper_cut(self) -> winrt.system.UInt32: ...
    @_property
    def page_size(self) -> winrt.windows.foundation.Size: ...
    @_property
    def print_area(self) -> winrt.windows.foundation.Rect: ...
    @_property
    def sideways_max_chars(self) -> winrt.system.UInt32: ...
    @_property
    def sideways_max_lines(self) -> winrt.system.UInt32: ...
    @_property
    def line_spacing(self) -> winrt.system.UInt32: ...
    @line_spacing.setter
    def line_spacing(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def line_height(self) -> winrt.system.UInt32: ...
    @line_height.setter
    def line_height(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def is_letter_quality(self) -> bool: ...
    @is_letter_quality.setter
    def is_letter_quality(self, value: bool) -> None: ...
    @_property
    def color_cartridge(self) -> PosPrinterColorCartridge: ...
    @color_cartridge.setter
    def color_cartridge(self, value: PosPrinterColorCartridge) -> None: ...
    @_property
    def characters_per_line(self) -> winrt.system.UInt32: ...
    @characters_per_line.setter
    def characters_per_line(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def is_cartridge_empty(self) -> bool: ...
    @_property
    def is_cartridge_removed(self) -> bool: ...
    @_property
    def is_cover_open(self) -> bool: ...
    @_property
    def is_head_cleaning(self) -> bool: ...
    @_property
    def is_paper_empty(self) -> bool: ...
    @_property
    def is_paper_near_end(self) -> bool: ...
    @_property
    def is_ready_to_print(self) -> bool: ...
    @_property
    def line_width(self) -> winrt.system.UInt32: ...

class ClaimedSlipPrinter(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ClaimedSlipPrinter: ...
    def change_print_side(self, print_side: PosPrinterPrintSide, /) -> None: ...
    def close_jaws(self) -> None: ...
    def create_job(self) -> typing.Optional[SlipPrintJob]: ...
    def insert_slip_async(self, timeout: datetime.timedelta, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def open_jaws(self) -> None: ...
    def remove_slip_async(self, timeout: datetime.timedelta, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def validate_data(self, data: str, /) -> bool: ...
    @_property
    def lines_near_end_to_end(self) -> winrt.system.UInt32: ...
    @_property
    def max_lines(self) -> winrt.system.UInt32: ...
    @_property
    def page_size(self) -> winrt.windows.foundation.Size: ...
    @_property
    def print_area(self) -> winrt.windows.foundation.Rect: ...
    @_property
    def print_side(self) -> PosPrinterPrintSide: ...
    @_property
    def sideways_max_chars(self) -> winrt.system.UInt32: ...
    @_property
    def sideways_max_lines(self) -> winrt.system.UInt32: ...
    @_property
    def line_spacing(self) -> winrt.system.UInt32: ...
    @line_spacing.setter
    def line_spacing(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def line_height(self) -> winrt.system.UInt32: ...
    @line_height.setter
    def line_height(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def is_letter_quality(self) -> bool: ...
    @is_letter_quality.setter
    def is_letter_quality(self, value: bool) -> None: ...
    @_property
    def color_cartridge(self) -> PosPrinterColorCartridge: ...
    @color_cartridge.setter
    def color_cartridge(self, value: PosPrinterColorCartridge) -> None: ...
    @_property
    def characters_per_line(self) -> winrt.system.UInt32: ...
    @characters_per_line.setter
    def characters_per_line(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def is_cartridge_empty(self) -> bool: ...
    @_property
    def is_cartridge_removed(self) -> bool: ...
    @_property
    def is_cover_open(self) -> bool: ...
    @_property
    def is_head_cleaning(self) -> bool: ...
    @_property
    def is_paper_empty(self) -> bool: ...
    @_property
    def is_paper_near_end(self) -> bool: ...
    @_property
    def is_ready_to_print(self) -> bool: ...
    @_property
    def line_width(self) -> winrt.system.UInt32: ...

class JournalPrintJob(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> JournalPrintJob: ...
    def execute_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def feed_paper_by_line(self, line_count: winrt.system.Int32, /) -> None: ...
    def feed_paper_by_map_mode_unit(self, distance: winrt.system.Int32, /) -> None: ...
    @typing.overload
    def print(self, data: str, /) -> None: ...
    @typing.overload
    def print(self, data: str, print_options: typing.Optional[PosPrinterPrintOptions], /) -> None: ...
    @typing.overload
    def print_line(self) -> None: ...
    @typing.overload
    def print_line(self, data: str, /) -> None: ...

class JournalPrinterCapabilities(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> JournalPrinterCapabilities: ...
    @_property
    def cartridge_sensors(self) -> PosPrinterCartridgeSensors: ...
    @_property
    def color_cartridge_capabilities(self) -> PosPrinterColorCapabilities: ...
    @_property
    def is_bold_supported(self) -> bool: ...
    @_property
    def is_double_high_double_wide_print_supported(self) -> bool: ...
    @_property
    def is_double_high_print_supported(self) -> bool: ...
    @_property
    def is_double_wide_print_supported(self) -> bool: ...
    @_property
    def is_dual_color_supported(self) -> bool: ...
    @_property
    def is_italic_supported(self) -> bool: ...
    @_property
    def is_paper_empty_sensor_supported(self) -> bool: ...
    @_property
    def is_paper_near_end_sensor_supported(self) -> bool: ...
    @_property
    def is_printer_present(self) -> bool: ...
    @_property
    def is_underline_supported(self) -> bool: ...
    @_property
    def supported_characters_per_line(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]: ...
    @_property
    def is_reverse_paper_feed_by_line_supported(self) -> bool: ...
    @_property
    def is_reverse_paper_feed_by_map_mode_unit_supported(self) -> bool: ...
    @_property
    def is_reverse_video_supported(self) -> bool: ...
    @_property
    def is_strikethrough_supported(self) -> bool: ...
    @_property
    def is_subscript_supported(self) -> bool: ...
    @_property
    def is_superscript_supported(self) -> bool: ...

class LineDisplay(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LineDisplay: ...
    def check_power_status_async(self) -> winrt.windows.foundation.IAsyncOperation[LineDisplayPowerStatus]: ...
    def claim_async(self) -> winrt.windows.foundation.IAsyncOperation[ClaimedLineDisplay]: ...
    def close(self) -> None: ...
    @staticmethod
    def from_id_async(device_id: str, /) -> winrt.windows.foundation.IAsyncOperation[LineDisplay]: ...
    @staticmethod
    def get_default_async() -> winrt.windows.foundation.IAsyncOperation[LineDisplay]: ...
    @typing.overload
    @staticmethod
    def get_device_selector() -> str: ...
    @typing.overload
    @staticmethod
    def get_device_selector(connection_types: PosConnectionTypes, /) -> str: ...
    @_property
    def capabilities(self) -> typing.Optional[LineDisplayCapabilities]: ...
    @_property
    def device_control_description(self) -> str: ...
    @_property
    def device_control_version(self) -> str: ...
    @_property
    def device_id(self) -> str: ...
    @_property
    def device_service_version(self) -> str: ...
    @_property
    def physical_device_description(self) -> str: ...
    @_property
    def physical_device_name(self) -> str: ...
    statistics_category_selector: typing.ClassVar[typing.Optional[LineDisplayStatisticsCategorySelector]]

class LineDisplayAttributes(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LineDisplayAttributes: ...
    @_property
    def screen_size_in_characters(self) -> winrt.windows.foundation.Size: ...
    @screen_size_in_characters.setter
    def screen_size_in_characters(self, value: winrt.windows.foundation.Size) -> None: ...
    @_property
    def is_power_notify_enabled(self) -> bool: ...
    @is_power_notify_enabled.setter
    def is_power_notify_enabled(self, value: bool) -> None: ...
    @_property
    def is_character_set_mapping_enabled(self) -> bool: ...
    @is_character_set_mapping_enabled.setter
    def is_character_set_mapping_enabled(self, value: bool) -> None: ...
    @_property
    def current_window(self) -> typing.Optional[LineDisplayWindow]: ...
    @current_window.setter
    def current_window(self, value: typing.Optional[LineDisplayWindow]) -> None: ...
    @_property
    def character_set(self) -> winrt.system.Int32: ...
    @character_set.setter
    def character_set(self, value: winrt.system.Int32) -> None: ...
    @_property
    def brightness(self) -> winrt.system.Int32: ...
    @brightness.setter
    def brightness(self, value: winrt.system.Int32) -> None: ...
    @_property
    def blink_rate(self) -> datetime.timedelta: ...
    @blink_rate.setter
    def blink_rate(self, value: datetime.timedelta) -> None: ...

class LineDisplayCapabilities(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LineDisplayCapabilities: ...
    @_property
    def can_blink(self) -> LineDisplayTextAttributeGranularity: ...
    @_property
    def can_change_blink_rate(self) -> bool: ...
    @_property
    def can_change_screen_size(self) -> bool: ...
    @_property
    def can_display_bitmaps(self) -> bool: ...
    @_property
    def can_display_custom_glyphs(self) -> bool: ...
    @_property
    def can_map_character_sets(self) -> bool: ...
    @_property
    def can_read_character_at_cursor(self) -> bool: ...
    @_property
    def can_reverse(self) -> LineDisplayTextAttributeGranularity: ...
    @_property
    def is_brightness_supported(self) -> bool: ...
    @_property
    def is_cursor_supported(self) -> bool: ...
    @_property
    def is_horizontal_marquee_supported(self) -> bool: ...
    @_property
    def is_inter_character_wait_supported(self) -> bool: ...
    @_property
    def is_statistics_reporting_supported(self) -> bool: ...
    @_property
    def is_statistics_updating_supported(self) -> bool: ...
    @_property
    def is_vertical_marquee_supported(self) -> bool: ...
    @_property
    def power_reporting_type(self) -> UnifiedPosPowerReportingType: ...
    @_property
    def supported_descriptors(self) -> winrt.system.UInt32: ...
    @_property
    def supported_windows(self) -> winrt.system.UInt32: ...

class LineDisplayCursor(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LineDisplayCursor: ...
    def get_attributes(self) -> typing.Optional[LineDisplayCursorAttributes]: ...
    def try_update_attributes_async(self, attributes: typing.Optional[LineDisplayCursorAttributes], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @_property
    def can_customize(self) -> bool: ...
    @_property
    def is_blink_supported(self) -> bool: ...
    @_property
    def is_block_supported(self) -> bool: ...
    @_property
    def is_half_block_supported(self) -> bool: ...
    @_property
    def is_other_supported(self) -> bool: ...
    @_property
    def is_reverse_supported(self) -> bool: ...
    @_property
    def is_underline_supported(self) -> bool: ...

class LineDisplayCursorAttributes(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LineDisplayCursorAttributes: ...
    @_property
    def position(self) -> winrt.windows.foundation.Point: ...
    @position.setter
    def position(self, value: winrt.windows.foundation.Point) -> None: ...
    @_property
    def is_blink_enabled(self) -> bool: ...
    @is_blink_enabled.setter
    def is_blink_enabled(self, value: bool) -> None: ...
    @_property
    def is_auto_advance_enabled(self) -> bool: ...
    @is_auto_advance_enabled.setter
    def is_auto_advance_enabled(self, value: bool) -> None: ...
    @_property
    def cursor_type(self) -> LineDisplayCursorType: ...
    @cursor_type.setter
    def cursor_type(self, value: LineDisplayCursorType) -> None: ...

class LineDisplayCustomGlyphs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LineDisplayCustomGlyphs: ...
    def try_redefine_async(self, glyph_code: winrt.system.UInt32, glyph_data: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @_property
    def size_in_pixels(self) -> winrt.windows.foundation.Size: ...
    @_property
    def supported_glyph_codes(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]: ...

class LineDisplayMarquee(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LineDisplayMarquee: ...
    def try_start_scrolling_async(self, direction: LineDisplayScrollDirection, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def try_stop_scrolling_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @_property
    def scroll_wait_interval(self) -> datetime.timedelta: ...
    @scroll_wait_interval.setter
    def scroll_wait_interval(self, value: datetime.timedelta) -> None: ...
    @_property
    def repeat_wait_interval(self) -> datetime.timedelta: ...
    @repeat_wait_interval.setter
    def repeat_wait_interval(self, value: datetime.timedelta) -> None: ...
    @_property
    def format(self) -> LineDisplayMarqueeFormat: ...
    @format.setter
    def format(self, value: LineDisplayMarqueeFormat) -> None: ...

class LineDisplayStatisticsCategorySelector(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LineDisplayStatisticsCategorySelector: ...
    @_property
    def all_statistics(self) -> str: ...
    @_property
    def manufacturer_statistics(self) -> str: ...
    @_property
    def unified_pos_statistics(self) -> str: ...

class LineDisplayStatusUpdatedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LineDisplayStatusUpdatedEventArgs: ...
    @_property
    def status(self) -> LineDisplayPowerStatus: ...

class LineDisplayStoredBitmap(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LineDisplayStoredBitmap: ...
    def try_delete_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @_property
    def escape_sequence(self) -> str: ...

class LineDisplayWindow(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LineDisplayWindow: ...
    def close(self) -> None: ...
    def read_character_at_cursor_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.system.UInt32]: ...
    def try_clear_text_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @typing.overload
    def try_display_storage_file_bitmap_at_cursor_async(self, bitmap: typing.Optional[winrt.windows.storage.StorageFile], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @typing.overload
    def try_display_storage_file_bitmap_at_cursor_async(self, bitmap: typing.Optional[winrt.windows.storage.StorageFile], horizontal_alignment: LineDisplayHorizontalAlignment, vertical_alignment: LineDisplayVerticalAlignment, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @typing.overload
    def try_display_storage_file_bitmap_at_cursor_async(self, bitmap: typing.Optional[winrt.windows.storage.StorageFile], horizontal_alignment: LineDisplayHorizontalAlignment, vertical_alignment: LineDisplayVerticalAlignment, width_in_pixels: winrt.system.Int32, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @typing.overload
    def try_display_storage_file_bitmap_at_point_async(self, bitmap: typing.Optional[winrt.windows.storage.StorageFile], offset_in_pixels: winrt.windows.foundation.Point, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @typing.overload
    def try_display_storage_file_bitmap_at_point_async(self, bitmap: typing.Optional[winrt.windows.storage.StorageFile], offset_in_pixels: winrt.windows.foundation.Point, width_in_pixels: winrt.system.Int32, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def try_display_stored_bitmap_at_cursor_async(self, bitmap: typing.Optional[LineDisplayStoredBitmap], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @typing.overload
    def try_display_text_async(self, text: str, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @typing.overload
    def try_display_text_async(self, text: str, display_attribute: LineDisplayTextAttribute, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @typing.overload
    def try_display_text_async(self, text: str, display_attribute: LineDisplayTextAttribute, start_position: winrt.windows.foundation.Point, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def try_refresh_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def try_scroll_text_async(self, direction: LineDisplayScrollDirection, number_of_columns_or_rows: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @_property
    def inter_character_wait_interval(self) -> datetime.timedelta: ...
    @inter_character_wait_interval.setter
    def inter_character_wait_interval(self, value: datetime.timedelta) -> None: ...
    @_property
    def size_in_characters(self) -> winrt.windows.foundation.Size: ...
    @_property
    def cursor(self) -> typing.Optional[LineDisplayCursor]: ...
    @_property
    def marquee(self) -> typing.Optional[LineDisplayMarquee]: ...

class MagneticStripeReader(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MagneticStripeReader: ...
    def check_health_async(self, level: UnifiedPosHealthCheckLevel, /) -> winrt.windows.foundation.IAsyncOperation[str]: ...
    def claim_reader_async(self) -> winrt.windows.foundation.IAsyncOperation[ClaimedMagneticStripeReader]: ...
    def close(self) -> None: ...
    @staticmethod
    def from_id_async(device_id: str, /) -> winrt.windows.foundation.IAsyncOperation[MagneticStripeReader]: ...
    @staticmethod
    def get_default_async() -> winrt.windows.foundation.IAsyncOperation[MagneticStripeReader]: ...
    @typing.overload
    @staticmethod
    def get_device_selector() -> str: ...
    @typing.overload
    @staticmethod
    def get_device_selector(connection_types: PosConnectionTypes, /) -> str: ...
    def get_error_reporting_type(self) -> MagneticStripeReaderErrorReportingType: ...
    def retrieve_statistics_async(self, statistics_categories: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.streams.IBuffer]: ...
    def add_status_updated(self, handler: winrt.windows.foundation.TypedEventHandler[MagneticStripeReader, MagneticStripeReaderStatusUpdatedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_status_updated(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def capabilities(self) -> typing.Optional[MagneticStripeReaderCapabilities]: ...
    @_property
    def device_authentication_protocol(self) -> MagneticStripeReaderAuthenticationProtocol: ...
    @_property
    def device_id(self) -> str: ...
    @_property
    def supported_card_types(self) -> winrt.system.UInt32: ...

class MagneticStripeReaderAamvaCardDataReceivedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MagneticStripeReaderAamvaCardDataReceivedEventArgs: ...
    @_property
    def address(self) -> str: ...
    @_property
    def birth_date(self) -> str: ...
    @_property
    def city(self) -> str: ...
    @_property
    def class_(self) -> str: ...
    @_property
    def endorsements(self) -> str: ...
    @_property
    def expiration_date(self) -> str: ...
    @_property
    def eye_color(self) -> str: ...
    @_property
    def first_name(self) -> str: ...
    @_property
    def gender(self) -> str: ...
    @_property
    def hair_color(self) -> str: ...
    @_property
    def height(self) -> str: ...
    @_property
    def license_number(self) -> str: ...
    @_property
    def postal_code(self) -> str: ...
    @_property
    def report(self) -> typing.Optional[MagneticStripeReaderReport]: ...
    @_property
    def restrictions(self) -> str: ...
    @_property
    def state(self) -> str: ...
    @_property
    def suffix(self) -> str: ...
    @_property
    def surname(self) -> str: ...
    @_property
    def weight(self) -> str: ...

class MagneticStripeReaderBankCardDataReceivedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MagneticStripeReaderBankCardDataReceivedEventArgs: ...
    @_property
    def account_number(self) -> str: ...
    @_property
    def expiration_date(self) -> str: ...
    @_property
    def first_name(self) -> str: ...
    @_property
    def middle_initial(self) -> str: ...
    @_property
    def report(self) -> typing.Optional[MagneticStripeReaderReport]: ...
    @_property
    def service_code(self) -> str: ...
    @_property
    def suffix(self) -> str: ...
    @_property
    def surname(self) -> str: ...
    @_property
    def title(self) -> str: ...

class MagneticStripeReaderCapabilities(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MagneticStripeReaderCapabilities: ...
    @_property
    def authentication_level(self) -> MagneticStripeReaderAuthenticationLevel: ...
    @_property
    def card_authentication(self) -> str: ...
    @_property
    def is_iso_supported(self) -> bool: ...
    @_property
    def is_jis_one_supported(self) -> bool: ...
    @_property
    def is_jis_two_supported(self) -> bool: ...
    @_property
    def is_statistics_reporting_supported(self) -> bool: ...
    @_property
    def is_statistics_updating_supported(self) -> bool: ...
    @_property
    def is_track_data_masking_supported(self) -> bool: ...
    @_property
    def is_transmit_sentinels_supported(self) -> bool: ...
    @_property
    def power_reporting_type(self) -> UnifiedPosPowerReportingType: ...
    @_property
    def supported_encryption_algorithms(self) -> winrt.system.UInt32: ...

class MagneticStripeReaderCardTypes(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MagneticStripeReaderCardTypes: ...
    aamva: typing.ClassVar[winrt.system.UInt32]
    bank: typing.ClassVar[winrt.system.UInt32]
    extended_base: typing.ClassVar[winrt.system.UInt32]
    unknown: typing.ClassVar[winrt.system.UInt32]

class MagneticStripeReaderEncryptionAlgorithms(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MagneticStripeReaderEncryptionAlgorithms: ...
    extended_base: typing.ClassVar[winrt.system.UInt32]
    none: typing.ClassVar[winrt.system.UInt32]
    triple_des_dukpt: typing.ClassVar[winrt.system.UInt32]

class MagneticStripeReaderErrorOccurredEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MagneticStripeReaderErrorOccurredEventArgs: ...
    @_property
    def error_data(self) -> typing.Optional[UnifiedPosErrorData]: ...
    @_property
    def partial_input_data(self) -> typing.Optional[MagneticStripeReaderReport]: ...
    @_property
    def track1_status(self) -> MagneticStripeReaderTrackErrorType: ...
    @_property
    def track2_status(self) -> MagneticStripeReaderTrackErrorType: ...
    @_property
    def track3_status(self) -> MagneticStripeReaderTrackErrorType: ...
    @_property
    def track4_status(self) -> MagneticStripeReaderTrackErrorType: ...

class MagneticStripeReaderReport(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MagneticStripeReaderReport: ...
    @_property
    def additional_security_information(self) -> typing.Optional[winrt.windows.storage.streams.IBuffer]: ...
    @_property
    def card_authentication_data(self) -> typing.Optional[winrt.windows.storage.streams.IBuffer]: ...
    @_property
    def card_authentication_data_length(self) -> winrt.system.UInt32: ...
    @_property
    def card_type(self) -> winrt.system.UInt32: ...
    @_property
    def properties(self) -> typing.Optional[winrt.windows.foundation.collections.IMapView[str, str]]: ...
    @_property
    def track1(self) -> typing.Optional[MagneticStripeReaderTrackData]: ...
    @_property
    def track2(self) -> typing.Optional[MagneticStripeReaderTrackData]: ...
    @_property
    def track3(self) -> typing.Optional[MagneticStripeReaderTrackData]: ...
    @_property
    def track4(self) -> typing.Optional[MagneticStripeReaderTrackData]: ...

class MagneticStripeReaderStatusUpdatedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MagneticStripeReaderStatusUpdatedEventArgs: ...
    @_property
    def extended_status(self) -> winrt.system.UInt32: ...
    @_property
    def status(self) -> MagneticStripeReaderStatus: ...

class MagneticStripeReaderTrackData(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MagneticStripeReaderTrackData: ...
    @_property
    def data(self) -> typing.Optional[winrt.windows.storage.streams.IBuffer]: ...
    @_property
    def discretionary_data(self) -> typing.Optional[winrt.windows.storage.streams.IBuffer]: ...
    @_property
    def encrypted_data(self) -> typing.Optional[winrt.windows.storage.streams.IBuffer]: ...

class MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs: ...
    @_property
    def report(self) -> typing.Optional[MagneticStripeReaderReport]: ...

class PosPrinter(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PosPrinter: ...
    def check_health_async(self, level: UnifiedPosHealthCheckLevel, /) -> winrt.windows.foundation.IAsyncOperation[str]: ...
    def claim_printer_async(self) -> winrt.windows.foundation.IAsyncOperation[ClaimedPosPrinter]: ...
    def close(self) -> None: ...
    @staticmethod
    def from_id_async(device_id: str, /) -> winrt.windows.foundation.IAsyncOperation[PosPrinter]: ...
    @staticmethod
    def get_default_async() -> winrt.windows.foundation.IAsyncOperation[PosPrinter]: ...
    @typing.overload
    @staticmethod
    def get_device_selector() -> str: ...
    @typing.overload
    @staticmethod
    def get_device_selector(connection_types: PosConnectionTypes, /) -> str: ...
    def get_font_property(self, typeface: str, /) -> typing.Optional[PosPrinterFontProperty]: ...
    def get_statistics_async(self, statistics_categories: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncOperation[str]: ...
    def add_status_updated(self, handler: winrt.windows.foundation.TypedEventHandler[PosPrinter, PosPrinterStatusUpdatedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_status_updated(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def capabilities(self) -> typing.Optional[PosPrinterCapabilities]: ...
    @_property
    def device_id(self) -> str: ...
    @_property
    def status(self) -> typing.Optional[PosPrinterStatus]: ...
    @_property
    def supported_character_sets(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]: ...
    @_property
    def supported_type_faces(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[str]]: ...
    @_property
    def supported_barcode_symbologies(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]: ...

class PosPrinterCapabilities(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PosPrinterCapabilities: ...
    @_property
    def can_map_character_set(self) -> bool: ...
    @_property
    def default_character_set(self) -> winrt.system.UInt32: ...
    @_property
    def has_cover_sensor(self) -> bool: ...
    @_property
    def is_statistics_reporting_supported(self) -> bool: ...
    @_property
    def is_statistics_updating_supported(self) -> bool: ...
    @_property
    def is_transaction_supported(self) -> bool: ...
    @_property
    def journal(self) -> typing.Optional[JournalPrinterCapabilities]: ...
    @_property
    def power_reporting_type(self) -> UnifiedPosPowerReportingType: ...
    @_property
    def receipt(self) -> typing.Optional[ReceiptPrinterCapabilities]: ...
    @_property
    def slip(self) -> typing.Optional[SlipPrinterCapabilities]: ...

class PosPrinterCharacterSetIds(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PosPrinterCharacterSetIds: ...
    ansi: typing.ClassVar[winrt.system.UInt32]
    ascii: typing.ClassVar[winrt.system.UInt32]
    utf16_l_e: typing.ClassVar[winrt.system.UInt32]

class PosPrinterFontProperty(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PosPrinterFontProperty: ...
    @_property
    def character_sizes(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[SizeUInt32]]: ...
    @_property
    def is_scalable_to_any_size(self) -> bool: ...
    @_property
    def type_face(self) -> str: ...

class PosPrinterPrintOptions(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PosPrinterPrintOptions: ...
    def __new__(cls: typing.Type[PosPrinterPrintOptions]) -> PosPrinterPrintOptions:...
    @_property
    def underline(self) -> bool: ...
    @underline.setter
    def underline(self, value: bool) -> None: ...
    @_property
    def type_face(self) -> str: ...
    @type_face.setter
    def type_face(self, value: str) -> None: ...
    @_property
    def superscript(self) -> bool: ...
    @superscript.setter
    def superscript(self, value: bool) -> None: ...
    @_property
    def subscript(self) -> bool: ...
    @subscript.setter
    def subscript(self, value: bool) -> None: ...
    @_property
    def strikethrough(self) -> bool: ...
    @strikethrough.setter
    def strikethrough(self, value: bool) -> None: ...
    @_property
    def reverse_video(self) -> bool: ...
    @reverse_video.setter
    def reverse_video(self, value: bool) -> None: ...
    @_property
    def italic(self) -> bool: ...
    @italic.setter
    def italic(self, value: bool) -> None: ...
    @_property
    def double_wide(self) -> bool: ...
    @double_wide.setter
    def double_wide(self, value: bool) -> None: ...
    @_property
    def double_high(self) -> bool: ...
    @double_high.setter
    def double_high(self, value: bool) -> None: ...
    @_property
    def character_set(self) -> winrt.system.UInt32: ...
    @character_set.setter
    def character_set(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def character_height(self) -> winrt.system.UInt32: ...
    @character_height.setter
    def character_height(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def bold(self) -> bool: ...
    @bold.setter
    def bold(self, value: bool) -> None: ...
    @_property
    def alignment(self) -> PosPrinterAlignment: ...
    @alignment.setter
    def alignment(self, value: PosPrinterAlignment) -> None: ...

class PosPrinterReleaseDeviceRequestedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PosPrinterReleaseDeviceRequestedEventArgs: ...

class PosPrinterStatus(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PosPrinterStatus: ...
    @_property
    def extended_status(self) -> winrt.system.UInt32: ...
    @_property
    def status_kind(self) -> PosPrinterStatusKind: ...

class PosPrinterStatusUpdatedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PosPrinterStatusUpdatedEventArgs: ...
    @_property
    def status(self) -> typing.Optional[PosPrinterStatus]: ...

class ReceiptPrintJob(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ReceiptPrintJob: ...
    @typing.overload
    def cut_paper(self) -> None: ...
    @typing.overload
    def cut_paper(self, percentage: winrt.system.Double, /) -> None: ...
    def draw_ruled_line(self, position_list: str, line_direction: PosPrinterLineDirection, line_width: winrt.system.UInt32, line_style: PosPrinterLineStyle, line_color: winrt.system.UInt32, /) -> None: ...
    def execute_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def feed_paper_by_line(self, line_count: winrt.system.Int32, /) -> None: ...
    def feed_paper_by_map_mode_unit(self, distance: winrt.system.Int32, /) -> None: ...
    def mark_feed(self, kind: PosPrinterMarkFeedKind, /) -> None: ...
    @typing.overload
    def print(self, data: str, /) -> None: ...
    @typing.overload
    def print(self, data: str, print_options: typing.Optional[PosPrinterPrintOptions], /) -> None: ...
    def print_barcode(self, data: str, symbology: winrt.system.UInt32, height: winrt.system.UInt32, width: winrt.system.UInt32, text_position: PosPrinterBarcodeTextPosition, alignment: PosPrinterAlignment, /) -> None: ...
    def print_barcode_custom_align(self, data: str, symbology: winrt.system.UInt32, height: winrt.system.UInt32, width: winrt.system.UInt32, text_position: PosPrinterBarcodeTextPosition, alignment_distance: winrt.system.UInt32, /) -> None: ...
    @typing.overload
    def print_bitmap(self, bitmap: typing.Optional[winrt.windows.graphics.imaging.BitmapFrame], alignment: PosPrinterAlignment, /) -> None: ...
    @typing.overload
    def print_bitmap(self, bitmap: typing.Optional[winrt.windows.graphics.imaging.BitmapFrame], alignment: PosPrinterAlignment, width: winrt.system.UInt32, /) -> None: ...
    @typing.overload
    def print_custom_aligned_bitmap(self, bitmap: typing.Optional[winrt.windows.graphics.imaging.BitmapFrame], alignment_distance: winrt.system.UInt32, /) -> None: ...
    @typing.overload
    def print_custom_aligned_bitmap(self, bitmap: typing.Optional[winrt.windows.graphics.imaging.BitmapFrame], alignment_distance: winrt.system.UInt32, width: winrt.system.UInt32, /) -> None: ...
    @typing.overload
    def print_line(self) -> None: ...
    @typing.overload
    def print_line(self, data: str, /) -> None: ...
    def print_saved_bitmap(self, bitmap_number: winrt.system.UInt32, /) -> None: ...
    def set_barcode_rotation(self, value: PosPrinterRotation, /) -> None: ...
    @typing.overload
    def set_bitmap(self, bitmap_number: winrt.system.UInt32, bitmap: typing.Optional[winrt.windows.graphics.imaging.BitmapFrame], alignment: PosPrinterAlignment, /) -> None: ...
    @typing.overload
    def set_bitmap(self, bitmap_number: winrt.system.UInt32, bitmap: typing.Optional[winrt.windows.graphics.imaging.BitmapFrame], alignment: PosPrinterAlignment, width: winrt.system.UInt32, /) -> None: ...
    @typing.overload
    def set_custom_aligned_bitmap(self, bitmap_number: winrt.system.UInt32, bitmap: typing.Optional[winrt.windows.graphics.imaging.BitmapFrame], alignment_distance: winrt.system.UInt32, /) -> None: ...
    @typing.overload
    def set_custom_aligned_bitmap(self, bitmap_number: winrt.system.UInt32, bitmap: typing.Optional[winrt.windows.graphics.imaging.BitmapFrame], alignment_distance: winrt.system.UInt32, width: winrt.system.UInt32, /) -> None: ...
    def set_print_area(self, value: winrt.windows.foundation.Rect, /) -> None: ...
    def set_print_rotation(self, value: PosPrinterRotation, include_bitmaps: bool, /) -> None: ...
    def stamp_paper(self) -> None: ...

class ReceiptPrinterCapabilities(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ReceiptPrinterCapabilities: ...
    @_property
    def cartridge_sensors(self) -> PosPrinterCartridgeSensors: ...
    @_property
    def color_cartridge_capabilities(self) -> PosPrinterColorCapabilities: ...
    @_property
    def is_bold_supported(self) -> bool: ...
    @_property
    def is_double_high_double_wide_print_supported(self) -> bool: ...
    @_property
    def is_double_high_print_supported(self) -> bool: ...
    @_property
    def is_double_wide_print_supported(self) -> bool: ...
    @_property
    def is_dual_color_supported(self) -> bool: ...
    @_property
    def is_italic_supported(self) -> bool: ...
    @_property
    def is_paper_empty_sensor_supported(self) -> bool: ...
    @_property
    def is_paper_near_end_sensor_supported(self) -> bool: ...
    @_property
    def is_printer_present(self) -> bool: ...
    @_property
    def is_underline_supported(self) -> bool: ...
    @_property
    def supported_characters_per_line(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]: ...
    @_property
    def is180_rotation_supported(self) -> bool: ...
    @_property
    def is_barcode_supported(self) -> bool: ...
    @_property
    def is_bitmap_supported(self) -> bool: ...
    @_property
    def is_left90_rotation_supported(self) -> bool: ...
    @_property
    def is_print_area_supported(self) -> bool: ...
    @_property
    def is_right90_rotation_supported(self) -> bool: ...
    @_property
    def ruled_line_capabilities(self) -> PosPrinterRuledLineCapabilities: ...
    @_property
    def supported_barcode_rotations(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[PosPrinterRotation]]: ...
    @_property
    def supported_bitmap_rotations(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[PosPrinterRotation]]: ...
    @_property
    def can_cut_paper(self) -> bool: ...
    @_property
    def is_stamp_supported(self) -> bool: ...
    @_property
    def mark_feed_capabilities(self) -> PosPrinterMarkFeedCapabilities: ...
    @_property
    def is_reverse_paper_feed_by_line_supported(self) -> bool: ...
    @_property
    def is_reverse_paper_feed_by_map_mode_unit_supported(self) -> bool: ...
    @_property
    def is_reverse_video_supported(self) -> bool: ...
    @_property
    def is_strikethrough_supported(self) -> bool: ...
    @_property
    def is_subscript_supported(self) -> bool: ...
    @_property
    def is_superscript_supported(self) -> bool: ...

class SlipPrintJob(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SlipPrintJob: ...
    def draw_ruled_line(self, position_list: str, line_direction: PosPrinterLineDirection, line_width: winrt.system.UInt32, line_style: PosPrinterLineStyle, line_color: winrt.system.UInt32, /) -> None: ...
    def execute_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def feed_paper_by_line(self, line_count: winrt.system.Int32, /) -> None: ...
    def feed_paper_by_map_mode_unit(self, distance: winrt.system.Int32, /) -> None: ...
    @typing.overload
    def print(self, data: str, /) -> None: ...
    @typing.overload
    def print(self, data: str, print_options: typing.Optional[PosPrinterPrintOptions], /) -> None: ...
    def print_barcode(self, data: str, symbology: winrt.system.UInt32, height: winrt.system.UInt32, width: winrt.system.UInt32, text_position: PosPrinterBarcodeTextPosition, alignment: PosPrinterAlignment, /) -> None: ...
    def print_barcode_custom_align(self, data: str, symbology: winrt.system.UInt32, height: winrt.system.UInt32, width: winrt.system.UInt32, text_position: PosPrinterBarcodeTextPosition, alignment_distance: winrt.system.UInt32, /) -> None: ...
    @typing.overload
    def print_bitmap(self, bitmap: typing.Optional[winrt.windows.graphics.imaging.BitmapFrame], alignment: PosPrinterAlignment, /) -> None: ...
    @typing.overload
    def print_bitmap(self, bitmap: typing.Optional[winrt.windows.graphics.imaging.BitmapFrame], alignment: PosPrinterAlignment, width: winrt.system.UInt32, /) -> None: ...
    @typing.overload
    def print_custom_aligned_bitmap(self, bitmap: typing.Optional[winrt.windows.graphics.imaging.BitmapFrame], alignment_distance: winrt.system.UInt32, /) -> None: ...
    @typing.overload
    def print_custom_aligned_bitmap(self, bitmap: typing.Optional[winrt.windows.graphics.imaging.BitmapFrame], alignment_distance: winrt.system.UInt32, width: winrt.system.UInt32, /) -> None: ...
    @typing.overload
    def print_line(self) -> None: ...
    @typing.overload
    def print_line(self, data: str, /) -> None: ...
    def print_saved_bitmap(self, bitmap_number: winrt.system.UInt32, /) -> None: ...
    def set_barcode_rotation(self, value: PosPrinterRotation, /) -> None: ...
    @typing.overload
    def set_bitmap(self, bitmap_number: winrt.system.UInt32, bitmap: typing.Optional[winrt.windows.graphics.imaging.BitmapFrame], alignment: PosPrinterAlignment, /) -> None: ...
    @typing.overload
    def set_bitmap(self, bitmap_number: winrt.system.UInt32, bitmap: typing.Optional[winrt.windows.graphics.imaging.BitmapFrame], alignment: PosPrinterAlignment, width: winrt.system.UInt32, /) -> None: ...
    @typing.overload
    def set_custom_aligned_bitmap(self, bitmap_number: winrt.system.UInt32, bitmap: typing.Optional[winrt.windows.graphics.imaging.BitmapFrame], alignment_distance: winrt.system.UInt32, /) -> None: ...
    @typing.overload
    def set_custom_aligned_bitmap(self, bitmap_number: winrt.system.UInt32, bitmap: typing.Optional[winrt.windows.graphics.imaging.BitmapFrame], alignment_distance: winrt.system.UInt32, width: winrt.system.UInt32, /) -> None: ...
    def set_print_area(self, value: winrt.windows.foundation.Rect, /) -> None: ...
    def set_print_rotation(self, value: PosPrinterRotation, include_bitmaps: bool, /) -> None: ...

class SlipPrinterCapabilities(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SlipPrinterCapabilities: ...
    @_property
    def cartridge_sensors(self) -> PosPrinterCartridgeSensors: ...
    @_property
    def color_cartridge_capabilities(self) -> PosPrinterColorCapabilities: ...
    @_property
    def is_bold_supported(self) -> bool: ...
    @_property
    def is_double_high_double_wide_print_supported(self) -> bool: ...
    @_property
    def is_double_high_print_supported(self) -> bool: ...
    @_property
    def is_double_wide_print_supported(self) -> bool: ...
    @_property
    def is_dual_color_supported(self) -> bool: ...
    @_property
    def is_italic_supported(self) -> bool: ...
    @_property
    def is_paper_empty_sensor_supported(self) -> bool: ...
    @_property
    def is_paper_near_end_sensor_supported(self) -> bool: ...
    @_property
    def is_printer_present(self) -> bool: ...
    @_property
    def is_underline_supported(self) -> bool: ...
    @_property
    def supported_characters_per_line(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]: ...
    @_property
    def is180_rotation_supported(self) -> bool: ...
    @_property
    def is_barcode_supported(self) -> bool: ...
    @_property
    def is_bitmap_supported(self) -> bool: ...
    @_property
    def is_left90_rotation_supported(self) -> bool: ...
    @_property
    def is_print_area_supported(self) -> bool: ...
    @_property
    def is_right90_rotation_supported(self) -> bool: ...
    @_property
    def ruled_line_capabilities(self) -> PosPrinterRuledLineCapabilities: ...
    @_property
    def supported_barcode_rotations(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[PosPrinterRotation]]: ...
    @_property
    def supported_bitmap_rotations(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[PosPrinterRotation]]: ...
    @_property
    def is_both_sides_printing_supported(self) -> bool: ...
    @_property
    def is_full_length_supported(self) -> bool: ...
    @_property
    def is_reverse_paper_feed_by_line_supported(self) -> bool: ...
    @_property
    def is_reverse_paper_feed_by_map_mode_unit_supported(self) -> bool: ...
    @_property
    def is_reverse_video_supported(self) -> bool: ...
    @_property
    def is_strikethrough_supported(self) -> bool: ...
    @_property
    def is_subscript_supported(self) -> bool: ...
    @_property
    def is_superscript_supported(self) -> bool: ...

class UnifiedPosErrorData(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UnifiedPosErrorData: ...
    def __new__(cls: typing.Type[UnifiedPosErrorData], message: str, severity: UnifiedPosErrorSeverity, reason: UnifiedPosErrorReason, extended_reason: winrt.system.UInt32) -> UnifiedPosErrorData:...
    @_property
    def extended_reason(self) -> winrt.system.UInt32: ...
    @_property
    def message(self) -> str: ...
    @_property
    def reason(self) -> UnifiedPosErrorReason: ...
    @_property
    def severity(self) -> UnifiedPosErrorSeverity: ...

class ICashDrawerEventSourceEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ICashDrawerEventSourceEventArgs: ...
    @_property
    def cash_drawer(self) -> typing.Optional[CashDrawer]: ...

class ICommonClaimedPosPrinterStation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ICommonClaimedPosPrinterStation: ...
    def validate_data(self, data: str, /) -> bool: ...
    @_property
    def characters_per_line(self) -> winrt.system.UInt32: ...
    @characters_per_line.setter
    def characters_per_line(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def color_cartridge(self) -> PosPrinterColorCartridge: ...
    @color_cartridge.setter
    def color_cartridge(self, value: PosPrinterColorCartridge) -> None: ...
    @_property
    def is_cartridge_empty(self) -> bool: ...
    @_property
    def is_cartridge_removed(self) -> bool: ...
    @_property
    def is_cover_open(self) -> bool: ...
    @_property
    def is_head_cleaning(self) -> bool: ...
    @_property
    def is_letter_quality(self) -> bool: ...
    @is_letter_quality.setter
    def is_letter_quality(self, value: bool) -> None: ...
    @_property
    def is_paper_empty(self) -> bool: ...
    @_property
    def is_paper_near_end(self) -> bool: ...
    @_property
    def is_ready_to_print(self) -> bool: ...
    @_property
    def line_height(self) -> winrt.system.UInt32: ...
    @line_height.setter
    def line_height(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def line_spacing(self) -> winrt.system.UInt32: ...
    @line_spacing.setter
    def line_spacing(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def line_width(self) -> winrt.system.UInt32: ...

class ICommonPosPrintStationCapabilities(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ICommonPosPrintStationCapabilities: ...
    @_property
    def cartridge_sensors(self) -> PosPrinterCartridgeSensors: ...
    @_property
    def color_cartridge_capabilities(self) -> PosPrinterColorCapabilities: ...
    @_property
    def is_bold_supported(self) -> bool: ...
    @_property
    def is_double_high_double_wide_print_supported(self) -> bool: ...
    @_property
    def is_double_high_print_supported(self) -> bool: ...
    @_property
    def is_double_wide_print_supported(self) -> bool: ...
    @_property
    def is_dual_color_supported(self) -> bool: ...
    @_property
    def is_italic_supported(self) -> bool: ...
    @_property
    def is_paper_empty_sensor_supported(self) -> bool: ...
    @_property
    def is_paper_near_end_sensor_supported(self) -> bool: ...
    @_property
    def is_printer_present(self) -> bool: ...
    @_property
    def is_underline_supported(self) -> bool: ...
    @_property
    def supported_characters_per_line(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]: ...

class ICommonReceiptSlipCapabilities(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ICommonReceiptSlipCapabilities: ...
    @_property
    def is180_rotation_supported(self) -> bool: ...
    @_property
    def is_barcode_supported(self) -> bool: ...
    @_property
    def is_bitmap_supported(self) -> bool: ...
    @_property
    def is_left90_rotation_supported(self) -> bool: ...
    @_property
    def is_print_area_supported(self) -> bool: ...
    @_property
    def is_right90_rotation_supported(self) -> bool: ...
    @_property
    def ruled_line_capabilities(self) -> PosPrinterRuledLineCapabilities: ...
    @_property
    def supported_barcode_rotations(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[PosPrinterRotation]]: ...
    @_property
    def supported_bitmap_rotations(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[PosPrinterRotation]]: ...
    @_property
    def cartridge_sensors(self) -> PosPrinterCartridgeSensors: ...
    @_property
    def color_cartridge_capabilities(self) -> PosPrinterColorCapabilities: ...
    @_property
    def is_bold_supported(self) -> bool: ...
    @_property
    def is_double_high_double_wide_print_supported(self) -> bool: ...
    @_property
    def is_double_high_print_supported(self) -> bool: ...
    @_property
    def is_double_wide_print_supported(self) -> bool: ...
    @_property
    def is_dual_color_supported(self) -> bool: ...
    @_property
    def is_italic_supported(self) -> bool: ...
    @_property
    def is_paper_empty_sensor_supported(self) -> bool: ...
    @_property
    def is_paper_near_end_sensor_supported(self) -> bool: ...
    @_property
    def is_printer_present(self) -> bool: ...
    @_property
    def is_underline_supported(self) -> bool: ...
    @_property
    def supported_characters_per_line(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]: ...

class IPosPrinterJob(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IPosPrinterJob: ...
    def execute_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def print(self, data: str, /) -> None: ...
    @typing.overload
    def print_line(self) -> None: ...
    @typing.overload
    def print_line(self, data: str, /) -> None: ...

class IReceiptOrSlipJob(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IReceiptOrSlipJob: ...
    def draw_ruled_line(self, position_list: str, line_direction: PosPrinterLineDirection, line_width: winrt.system.UInt32, line_style: PosPrinterLineStyle, line_color: winrt.system.UInt32, /) -> None: ...
    def execute_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def print(self, data: str, /) -> None: ...
    def print_barcode(self, data: str, symbology: winrt.system.UInt32, height: winrt.system.UInt32, width: winrt.system.UInt32, text_position: PosPrinterBarcodeTextPosition, alignment: PosPrinterAlignment, /) -> None: ...
    def print_barcode_custom_align(self, data: str, symbology: winrt.system.UInt32, height: winrt.system.UInt32, width: winrt.system.UInt32, text_position: PosPrinterBarcodeTextPosition, alignment_distance: winrt.system.UInt32, /) -> None: ...
    @typing.overload
    def print_bitmap(self, bitmap: typing.Optional[winrt.windows.graphics.imaging.BitmapFrame], alignment: PosPrinterAlignment, /) -> None: ...
    @typing.overload
    def print_bitmap(self, bitmap: typing.Optional[winrt.windows.graphics.imaging.BitmapFrame], alignment: PosPrinterAlignment, width: winrt.system.UInt32, /) -> None: ...
    @typing.overload
    def print_custom_aligned_bitmap(self, bitmap: typing.Optional[winrt.windows.graphics.imaging.BitmapFrame], alignment_distance: winrt.system.UInt32, /) -> None: ...
    @typing.overload
    def print_custom_aligned_bitmap(self, bitmap: typing.Optional[winrt.windows.graphics.imaging.BitmapFrame], alignment_distance: winrt.system.UInt32, width: winrt.system.UInt32, /) -> None: ...
    @typing.overload
    def print_line(self) -> None: ...
    @typing.overload
    def print_line(self, data: str, /) -> None: ...
    def print_saved_bitmap(self, bitmap_number: winrt.system.UInt32, /) -> None: ...
    def set_barcode_rotation(self, value: PosPrinterRotation, /) -> None: ...
    @typing.overload
    def set_bitmap(self, bitmap_number: winrt.system.UInt32, bitmap: typing.Optional[winrt.windows.graphics.imaging.BitmapFrame], alignment: PosPrinterAlignment, /) -> None: ...
    @typing.overload
    def set_bitmap(self, bitmap_number: winrt.system.UInt32, bitmap: typing.Optional[winrt.windows.graphics.imaging.BitmapFrame], alignment: PosPrinterAlignment, width: winrt.system.UInt32, /) -> None: ...
    @typing.overload
    def set_custom_aligned_bitmap(self, bitmap_number: winrt.system.UInt32, bitmap: typing.Optional[winrt.windows.graphics.imaging.BitmapFrame], alignment_distance: winrt.system.UInt32, /) -> None: ...
    @typing.overload
    def set_custom_aligned_bitmap(self, bitmap_number: winrt.system.UInt32, bitmap: typing.Optional[winrt.windows.graphics.imaging.BitmapFrame], alignment_distance: winrt.system.UInt32, width: winrt.system.UInt32, /) -> None: ...
    def set_print_area(self, value: winrt.windows.foundation.Rect, /) -> None: ...
    def set_print_rotation(self, value: PosPrinterRotation, include_bitmaps: bool, /) -> None: ...

