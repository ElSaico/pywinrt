# WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

import datetime
import sys
import types
import typing
import uuid

import winrt.system
import winrt.windows.applicationmodel
import winrt.windows.data.xml.dom
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.system

from . import AdaptiveNotificationContentKind, BadgeTemplateType, NotificationKinds, NotificationMirroring, NotificationSetting, NotificationUpdateResult, PeriodicUpdateRecurrence, TileFlyoutTemplateType, TileTemplateType, ToastDismissalReason, ToastHistoryChangedType, ToastNotificationMode, ToastNotificationPriority, ToastTemplateType, UserNotificationChangedKind

Self = typing.TypeVar('Self')

class AdaptiveNotificationText(winrt.system.Object):
    hints: typing.Optional[winrt.windows.foundation.collections.IMap[str, str]]
    kind: AdaptiveNotificationContentKind
    text: str
    language: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AdaptiveNotificationText: ...
    def __new__(cls: typing.Type[AdaptiveNotificationText]) -> AdaptiveNotificationText:...

class BadgeNotification(winrt.system.Object):
    expiration_time: typing.Optional[typing.Optional[datetime.datetime]]
    content: typing.Optional[winrt.windows.data.xml.dom.XmlDocument]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BadgeNotification: ...
    def __new__(cls: typing.Type[BadgeNotification], content: typing.Optional[winrt.windows.data.xml.dom.XmlDocument]) -> BadgeNotification:...

class BadgeUpdateManager(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BadgeUpdateManager: ...
    @typing.overload
    @staticmethod
    def create_badge_updater_for_application() -> typing.Optional[BadgeUpdater]: ...
    @typing.overload
    @staticmethod
    def create_badge_updater_for_application(application_id: str, /) -> typing.Optional[BadgeUpdater]: ...
    @staticmethod
    def create_badge_updater_for_secondary_tile(tile_id: str, /) -> typing.Optional[BadgeUpdater]: ...
    @staticmethod
    def get_for_user(user: typing.Optional[winrt.windows.system.User], /) -> typing.Optional[BadgeUpdateManagerForUser]: ...
    @staticmethod
    def get_template_content(type: BadgeTemplateType, /) -> typing.Optional[winrt.windows.data.xml.dom.XmlDocument]: ...

class BadgeUpdateManagerForUser(winrt.system.Object):
    user: typing.Optional[winrt.windows.system.User]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BadgeUpdateManagerForUser: ...
    @typing.overload
    def create_badge_updater_for_application(self) -> typing.Optional[BadgeUpdater]: ...
    @typing.overload
    def create_badge_updater_for_application(self, application_id: str, /) -> typing.Optional[BadgeUpdater]: ...
    def create_badge_updater_for_secondary_tile(self, tile_id: str, /) -> typing.Optional[BadgeUpdater]: ...

class BadgeUpdater(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BadgeUpdater: ...
    def clear(self) -> None: ...
    @typing.overload
    def start_periodic_update(self, badge_content: typing.Optional[winrt.windows.foundation.Uri], requested_interval: PeriodicUpdateRecurrence, /) -> None: ...
    @typing.overload
    def start_periodic_update(self, badge_content: typing.Optional[winrt.windows.foundation.Uri], start_time: datetime.datetime, requested_interval: PeriodicUpdateRecurrence, /) -> None: ...
    def stop_periodic_update(self) -> None: ...
    def update(self, notification: typing.Optional[BadgeNotification], /) -> None: ...

class KnownAdaptiveNotificationHints(winrt.system.Object):
    align: typing.ClassVar[str]
    max_lines: typing.ClassVar[str]
    min_lines: typing.ClassVar[str]
    style: typing.ClassVar[str]
    text_stacking: typing.ClassVar[str]
    wrap: typing.ClassVar[str]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> KnownAdaptiveNotificationHints: ...

class KnownAdaptiveNotificationTextStyles(winrt.system.Object):
    base: typing.ClassVar[str]
    base_subtle: typing.ClassVar[str]
    body: typing.ClassVar[str]
    body_subtle: typing.ClassVar[str]
    caption: typing.ClassVar[str]
    caption_subtle: typing.ClassVar[str]
    header: typing.ClassVar[str]
    header_numeral: typing.ClassVar[str]
    header_numeral_subtle: typing.ClassVar[str]
    header_subtle: typing.ClassVar[str]
    subheader: typing.ClassVar[str]
    subheader_numeral: typing.ClassVar[str]
    subheader_numeral_subtle: typing.ClassVar[str]
    subheader_subtle: typing.ClassVar[str]
    subtitle: typing.ClassVar[str]
    subtitle_subtle: typing.ClassVar[str]
    title: typing.ClassVar[str]
    title_numeral: typing.ClassVar[str]
    title_subtle: typing.ClassVar[str]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> KnownAdaptiveNotificationTextStyles: ...

class KnownNotificationBindings(winrt.system.Object):
    toast_generic: typing.ClassVar[str]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> KnownNotificationBindings: ...

class Notification(winrt.system.Object):
    visual: typing.Optional[NotificationVisual]
    expiration_time: typing.Optional[typing.Optional[datetime.datetime]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Notification: ...
    def __new__(cls: typing.Type[Notification]) -> Notification:...

class NotificationBinding(winrt.system.Object):
    template: str
    language: str
    hints: typing.Optional[winrt.windows.foundation.collections.IMap[str, str]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NotificationBinding: ...
    def get_text_elements(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[AdaptiveNotificationText]]: ...

class NotificationData(winrt.system.Object):
    sequence_number: winrt.system.UInt32
    values: typing.Optional[winrt.windows.foundation.collections.IMap[str, str]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NotificationData: ...
    @typing.overload
    def __new__(cls: typing.Type[NotificationData], initial_values: typing.Iterable[winrt.windows.foundation.collections.IKeyValuePair[str, str]], sequence_number: winrt.system.UInt32) -> NotificationData:...
    @typing.overload
    def __new__(cls: typing.Type[NotificationData], initial_values: typing.Iterable[winrt.windows.foundation.collections.IKeyValuePair[str, str]]) -> NotificationData:...
    @typing.overload
    def __new__(cls: typing.Type[NotificationData]) -> NotificationData:...

class NotificationVisual(winrt.system.Object):
    language: str
    bindings: typing.Optional[winrt.windows.foundation.collections.IVector[NotificationBinding]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NotificationVisual: ...
    def get_binding(self, template_name: str, /) -> typing.Optional[NotificationBinding]: ...

class ScheduledTileNotification(winrt.system.Object):
    tag: str
    id: str
    expiration_time: typing.Optional[typing.Optional[datetime.datetime]]
    content: typing.Optional[winrt.windows.data.xml.dom.XmlDocument]
    delivery_time: datetime.datetime
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ScheduledTileNotification: ...
    def __new__(cls: typing.Type[ScheduledTileNotification], content: typing.Optional[winrt.windows.data.xml.dom.XmlDocument], delivery_time: datetime.datetime) -> ScheduledTileNotification:...

class ScheduledToastNotification(winrt.system.Object):
    id: str
    content: typing.Optional[winrt.windows.data.xml.dom.XmlDocument]
    delivery_time: datetime.datetime
    maximum_snooze_count: winrt.system.UInt32
    snooze_interval: typing.Optional[typing.Optional[datetime.timedelta]]
    tag: str
    suppress_popup: winrt.system.Boolean
    group: str
    remote_id: str
    notification_mirroring: NotificationMirroring
    expiration_time: typing.Optional[typing.Optional[datetime.datetime]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ScheduledToastNotification: ...
    @typing.overload
    def __new__(cls: typing.Type[ScheduledToastNotification], content: typing.Optional[winrt.windows.data.xml.dom.XmlDocument], delivery_time: datetime.datetime) -> ScheduledToastNotification:...
    @typing.overload
    def __new__(cls: typing.Type[ScheduledToastNotification], content: typing.Optional[winrt.windows.data.xml.dom.XmlDocument], delivery_time: datetime.datetime, snooze_interval: datetime.timedelta, maximum_snooze_count: winrt.system.UInt32) -> ScheduledToastNotification:...

class ScheduledToastNotificationShowingEventArgs(winrt.system.Object):
    cancel: winrt.system.Boolean
    scheduled_toast_notification: typing.Optional[ScheduledToastNotification]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ScheduledToastNotificationShowingEventArgs: ...
    def get_deferral(self) -> typing.Optional[winrt.windows.foundation.Deferral]: ...

class ShownTileNotification(winrt.system.Object):
    arguments: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ShownTileNotification: ...

class TileFlyoutNotification(winrt.system.Object):
    expiration_time: typing.Optional[typing.Optional[datetime.datetime]]
    content: typing.Optional[winrt.windows.data.xml.dom.XmlDocument]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TileFlyoutNotification: ...
    def __new__(cls: typing.Type[TileFlyoutNotification], content: typing.Optional[winrt.windows.data.xml.dom.XmlDocument]) -> TileFlyoutNotification:...

class TileFlyoutUpdateManager(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TileFlyoutUpdateManager: ...
    @typing.overload
    @staticmethod
    def create_tile_flyout_updater_for_application() -> typing.Optional[TileFlyoutUpdater]: ...
    @typing.overload
    @staticmethod
    def create_tile_flyout_updater_for_application(application_id: str, /) -> typing.Optional[TileFlyoutUpdater]: ...
    @staticmethod
    def create_tile_flyout_updater_for_secondary_tile(tile_id: str, /) -> typing.Optional[TileFlyoutUpdater]: ...
    @staticmethod
    def get_template_content(type: TileFlyoutTemplateType, /) -> typing.Optional[winrt.windows.data.xml.dom.XmlDocument]: ...

class TileFlyoutUpdater(winrt.system.Object):
    setting: NotificationSetting
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TileFlyoutUpdater: ...
    def clear(self) -> None: ...
    @typing.overload
    def start_periodic_update(self, tile_flyout_content: typing.Optional[winrt.windows.foundation.Uri], requested_interval: PeriodicUpdateRecurrence, /) -> None: ...
    @typing.overload
    def start_periodic_update(self, tile_flyout_content: typing.Optional[winrt.windows.foundation.Uri], start_time: datetime.datetime, requested_interval: PeriodicUpdateRecurrence, /) -> None: ...
    def stop_periodic_update(self) -> None: ...
    def update(self, notification: typing.Optional[TileFlyoutNotification], /) -> None: ...

class TileNotification(winrt.system.Object):
    tag: str
    expiration_time: typing.Optional[typing.Optional[datetime.datetime]]
    content: typing.Optional[winrt.windows.data.xml.dom.XmlDocument]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TileNotification: ...
    def __new__(cls: typing.Type[TileNotification], content: typing.Optional[winrt.windows.data.xml.dom.XmlDocument]) -> TileNotification:...

class TileUpdateManager(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TileUpdateManager: ...
    @typing.overload
    @staticmethod
    def create_tile_updater_for_application() -> typing.Optional[TileUpdater]: ...
    @typing.overload
    @staticmethod
    def create_tile_updater_for_application(application_id: str, /) -> typing.Optional[TileUpdater]: ...
    @staticmethod
    def create_tile_updater_for_secondary_tile(tile_id: str, /) -> typing.Optional[TileUpdater]: ...
    @staticmethod
    def get_for_user(user: typing.Optional[winrt.windows.system.User], /) -> typing.Optional[TileUpdateManagerForUser]: ...
    @staticmethod
    def get_template_content(type: TileTemplateType, /) -> typing.Optional[winrt.windows.data.xml.dom.XmlDocument]: ...

class TileUpdateManagerForUser(winrt.system.Object):
    user: typing.Optional[winrt.windows.system.User]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TileUpdateManagerForUser: ...
    def create_tile_updater_for_application(self, application_id: str, /) -> typing.Optional[TileUpdater]: ...
    def create_tile_updater_for_application_for_user(self) -> typing.Optional[TileUpdater]: ...
    def create_tile_updater_for_secondary_tile(self, tile_id: str, /) -> typing.Optional[TileUpdater]: ...

class TileUpdater(winrt.system.Object):
    setting: NotificationSetting
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TileUpdater: ...
    def add_to_schedule(self, scheduled_tile: typing.Optional[ScheduledTileNotification], /) -> None: ...
    def clear(self) -> None: ...
    def enable_notification_queue(self, enable: winrt.system.Boolean, /) -> None: ...
    def enable_notification_queue_for_square150x150(self, enable: winrt.system.Boolean, /) -> None: ...
    def enable_notification_queue_for_square310x310(self, enable: winrt.system.Boolean, /) -> None: ...
    def enable_notification_queue_for_wide310x150(self, enable: winrt.system.Boolean, /) -> None: ...
    def get_scheduled_tile_notifications(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[ScheduledTileNotification]]: ...
    def remove_from_schedule(self, scheduled_tile: typing.Optional[ScheduledTileNotification], /) -> None: ...
    @typing.overload
    def start_periodic_update(self, tile_content: typing.Optional[winrt.windows.foundation.Uri], requested_interval: PeriodicUpdateRecurrence, /) -> None: ...
    @typing.overload
    def start_periodic_update(self, tile_content: typing.Optional[winrt.windows.foundation.Uri], start_time: datetime.datetime, requested_interval: PeriodicUpdateRecurrence, /) -> None: ...
    @typing.overload
    def start_periodic_update_batch(self, tile_contents: typing.Iterable[winrt.windows.foundation.Uri], requested_interval: PeriodicUpdateRecurrence, /) -> None: ...
    @typing.overload
    def start_periodic_update_batch(self, tile_contents: typing.Iterable[winrt.windows.foundation.Uri], start_time: datetime.datetime, requested_interval: PeriodicUpdateRecurrence, /) -> None: ...
    def stop_periodic_update(self) -> None: ...
    def update(self, notification: typing.Optional[TileNotification], /) -> None: ...

class ToastActivatedEventArgs(winrt.system.Object):
    arguments: str
    user_input: typing.Optional[winrt.windows.foundation.collections.ValueSet]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ToastActivatedEventArgs: ...

class ToastCollection(winrt.system.Object):
    launch_args: str
    icon: typing.Optional[winrt.windows.foundation.Uri]
    display_name: str
    id: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ToastCollection: ...
    def __new__(cls: typing.Type[ToastCollection], collection_id: str, display_name: str, launch_args: str, icon_uri: typing.Optional[winrt.windows.foundation.Uri]) -> ToastCollection:...

class ToastCollectionManager(winrt.system.Object):
    app_id: str
    user: typing.Optional[winrt.windows.system.User]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ToastCollectionManager: ...
    def find_all_toast_collections_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[ToastCollection]]: ...
    def get_toast_collection_async(self, collection_id: str, /) -> winrt.windows.foundation.IAsyncOperation[ToastCollection]: ...
    def remove_all_toast_collections_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def remove_toast_collection_async(self, collection_id: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    def save_toast_collection_async(self, collection: typing.Optional[ToastCollection], /) -> winrt.windows.foundation.IAsyncAction: ...

class ToastDismissedEventArgs(winrt.system.Object):
    reason: ToastDismissalReason
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ToastDismissedEventArgs: ...

class ToastFailedEventArgs(winrt.system.Object):
    error_code: winrt.windows.foundation.HResult
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ToastFailedEventArgs: ...

class ToastNotification(winrt.system.Object):
    expiration_time: typing.Optional[typing.Optional[datetime.datetime]]
    content: typing.Optional[winrt.windows.data.xml.dom.XmlDocument]
    tag: str
    suppress_popup: winrt.system.Boolean
    group: str
    remote_id: str
    notification_mirroring: NotificationMirroring
    priority: ToastNotificationPriority
    data: typing.Optional[NotificationData]
    expires_on_reboot: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ToastNotification: ...
    def __new__(cls: typing.Type[ToastNotification], content: typing.Optional[winrt.windows.data.xml.dom.XmlDocument]) -> ToastNotification:...
    def add_activated(self, handler: winrt.windows.foundation.TypedEventHandler[ToastNotification, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_activated(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_dismissed(self, handler: winrt.windows.foundation.TypedEventHandler[ToastNotification, ToastDismissedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_dismissed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_failed(self, handler: winrt.windows.foundation.TypedEventHandler[ToastNotification, ToastFailedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_failed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class ToastNotificationActionTriggerDetail(winrt.system.Object):
    argument: str
    user_input: typing.Optional[winrt.windows.foundation.collections.ValueSet]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ToastNotificationActionTriggerDetail: ...

class ToastNotificationHistory(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ToastNotificationHistory: ...
    @typing.overload
    def clear(self) -> None: ...
    @typing.overload
    def clear(self, application_id: str, /) -> None: ...
    @typing.overload
    def get_history(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[ToastNotification]]: ...
    @typing.overload
    def get_history(self, application_id: str, /) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[ToastNotification]]: ...
    @typing.overload
    def remove(self, tag: str, /) -> None: ...
    @typing.overload
    def remove(self, tag: str, group: str, /) -> None: ...
    @typing.overload
    def remove(self, tag: str, group: str, application_id: str, /) -> None: ...
    @typing.overload
    def remove_group(self, group: str, /) -> None: ...
    @typing.overload
    def remove_group(self, group: str, application_id: str, /) -> None: ...

class ToastNotificationHistoryChangedTriggerDetail(winrt.system.Object):
    change_type: ToastHistoryChangedType
    collection_id: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ToastNotificationHistoryChangedTriggerDetail: ...

class ToastNotificationManager(winrt.system.Object):
    history: typing.ClassVar[typing.Optional[ToastNotificationHistory]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ToastNotificationManager: ...
    @staticmethod
    def configure_notification_mirroring(value: NotificationMirroring, /) -> None: ...
    @typing.overload
    @staticmethod
    def create_toast_notifier() -> typing.Optional[ToastNotifier]: ...
    @typing.overload
    @staticmethod
    def create_toast_notifier(application_id: str, /) -> typing.Optional[ToastNotifier]: ...
    @staticmethod
    def get_default() -> typing.Optional[ToastNotificationManagerForUser]: ...
    @staticmethod
    def get_for_user(user: typing.Optional[winrt.windows.system.User], /) -> typing.Optional[ToastNotificationManagerForUser]: ...
    @staticmethod
    def get_template_content(type: ToastTemplateType, /) -> typing.Optional[winrt.windows.data.xml.dom.XmlDocument]: ...

class ToastNotificationManagerForUser(winrt.system.Object):
    history: typing.Optional[ToastNotificationHistory]
    user: typing.Optional[winrt.windows.system.User]
    notification_mode: ToastNotificationMode
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ToastNotificationManagerForUser: ...
    @typing.overload
    def create_toast_notifier(self) -> typing.Optional[ToastNotifier]: ...
    @typing.overload
    def create_toast_notifier(self, application_id: str, /) -> typing.Optional[ToastNotifier]: ...
    def get_history_for_toast_collection_id_async(self, collection_id: str, /) -> winrt.windows.foundation.IAsyncOperation[ToastNotificationHistory]: ...
    @typing.overload
    def get_toast_collection_manager(self) -> typing.Optional[ToastCollectionManager]: ...
    @typing.overload
    def get_toast_collection_manager(self, app_id: str, /) -> typing.Optional[ToastCollectionManager]: ...
    def get_toast_notifier_for_toast_collection_id_async(self, collection_id: str, /) -> winrt.windows.foundation.IAsyncOperation[ToastNotifier]: ...
    def add_notification_mode_changed(self, handler: winrt.windows.foundation.TypedEventHandler[ToastNotificationManagerForUser, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_notification_mode_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class ToastNotifier(winrt.system.Object):
    setting: NotificationSetting
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ToastNotifier: ...
    def add_to_schedule(self, scheduled_toast: typing.Optional[ScheduledToastNotification], /) -> None: ...
    def get_scheduled_toast_notifications(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[ScheduledToastNotification]]: ...
    def hide(self, notification: typing.Optional[ToastNotification], /) -> None: ...
    def remove_from_schedule(self, scheduled_toast: typing.Optional[ScheduledToastNotification], /) -> None: ...
    def show(self, notification: typing.Optional[ToastNotification], /) -> None: ...
    @typing.overload
    def update(self, data: typing.Optional[NotificationData], tag: str, /) -> NotificationUpdateResult: ...
    @typing.overload
    def update(self, data: typing.Optional[NotificationData], tag: str, group: str, /) -> NotificationUpdateResult: ...
    def add_scheduled_toast_notification_showing(self, handler: winrt.windows.foundation.TypedEventHandler[ToastNotifier, ScheduledToastNotificationShowingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_scheduled_toast_notification_showing(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class UserNotification(winrt.system.Object):
    app_info: typing.Optional[winrt.windows.applicationmodel.AppInfo]
    creation_time: datetime.datetime
    id: winrt.system.UInt32
    notification: typing.Optional[Notification]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UserNotification: ...

class UserNotificationChangedEventArgs(winrt.system.Object):
    change_kind: UserNotificationChangedKind
    user_notification_id: winrt.system.UInt32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UserNotificationChangedEventArgs: ...

class IAdaptiveNotificationContent(winrt.system.Object):
    hints: typing.Optional[winrt.windows.foundation.collections.IMap[str, str]]
    kind: AdaptiveNotificationContentKind
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IAdaptiveNotificationContent: ...

