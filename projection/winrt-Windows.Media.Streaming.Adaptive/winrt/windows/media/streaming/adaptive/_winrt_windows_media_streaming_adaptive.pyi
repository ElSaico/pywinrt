# WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

import datetime
import sys
import types
import typing
import uuid as _uuid

import winrt.system
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.storage.streams
import winrt.windows.web.http

from . import AdaptiveMediaSourceCreationStatus, AdaptiveMediaSourceDiagnosticType, AdaptiveMediaSourceDownloadBitrateChangedReason, AdaptiveMediaSourceResourceType

Self = typing.TypeVar('Self')

class AdaptiveMediaSource(winrt.system.Object):
    initial_bitrate: winrt.system.UInt32
    inbound_bits_per_second_window: datetime.timedelta
    desired_max_bitrate: typing.Optional[typing.Optional[winrt.system.UInt32]]
    desired_live_offset: datetime.timedelta
    desired_min_bitrate: typing.Optional[typing.Optional[winrt.system.UInt32]]
    current_playback_bitrate: winrt.system.UInt32
    audio_only_playback: bool
    inbound_bits_per_second: winrt.system.UInt64
    available_bitrates: typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]
    current_download_bitrate: winrt.system.UInt32
    is_live: bool
    advanced_settings: typing.Optional[AdaptiveMediaSourceAdvancedSettings]
    desired_seekable_window_size: typing.Optional[typing.Optional[datetime.timedelta]]
    diagnostics: typing.Optional[AdaptiveMediaSourceDiagnostics]
    max_seekable_window_size: typing.Optional[typing.Optional[datetime.timedelta]]
    min_live_offset: typing.Optional[typing.Optional[datetime.timedelta]]
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AdaptiveMediaSource: ...
    def close(self) -> None: ...
    @typing.overload
    @staticmethod
    def create_from_stream_async(stream: typing.Optional[winrt.windows.storage.streams.IInputStream], uri: typing.Optional[winrt.windows.foundation.Uri], content_type: str, /) -> winrt.windows.foundation.IAsyncOperation[AdaptiveMediaSourceCreationResult]: ...
    @typing.overload
    @staticmethod
    def create_from_stream_async(stream: typing.Optional[winrt.windows.storage.streams.IInputStream], uri: typing.Optional[winrt.windows.foundation.Uri], content_type: str, http_client: typing.Optional[winrt.windows.web.http.HttpClient], /) -> winrt.windows.foundation.IAsyncOperation[AdaptiveMediaSourceCreationResult]: ...
    @typing.overload
    @staticmethod
    def create_from_uri_async(uri: typing.Optional[winrt.windows.foundation.Uri], /) -> winrt.windows.foundation.IAsyncOperation[AdaptiveMediaSourceCreationResult]: ...
    @typing.overload
    @staticmethod
    def create_from_uri_async(uri: typing.Optional[winrt.windows.foundation.Uri], http_client: typing.Optional[winrt.windows.web.http.HttpClient], /) -> winrt.windows.foundation.IAsyncOperation[AdaptiveMediaSourceCreationResult]: ...
    def get_correlated_times(self) -> typing.Optional[AdaptiveMediaSourceCorrelatedTimes]: ...
    @staticmethod
    def is_content_type_supported(content_type: str, /) -> bool: ...
    def add_download_bitrate_changed(self, handler: winrt.windows.foundation.TypedEventHandler[AdaptiveMediaSource, AdaptiveMediaSourceDownloadBitrateChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_download_bitrate_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_download_completed(self, handler: winrt.windows.foundation.TypedEventHandler[AdaptiveMediaSource, AdaptiveMediaSourceDownloadCompletedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_download_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_download_failed(self, handler: winrt.windows.foundation.TypedEventHandler[AdaptiveMediaSource, AdaptiveMediaSourceDownloadFailedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_download_failed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_download_requested(self, handler: winrt.windows.foundation.TypedEventHandler[AdaptiveMediaSource, AdaptiveMediaSourceDownloadRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_download_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_playback_bitrate_changed(self, handler: winrt.windows.foundation.TypedEventHandler[AdaptiveMediaSource, AdaptiveMediaSourcePlaybackBitrateChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_playback_bitrate_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class AdaptiveMediaSourceAdvancedSettings(winrt.system.Object):
    desired_bitrate_headroom_ratio: typing.Optional[typing.Optional[winrt.system.Double]]
    bitrate_downgrade_trigger_ratio: typing.Optional[typing.Optional[winrt.system.Double]]
    all_segments_independent: bool
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AdaptiveMediaSourceAdvancedSettings: ...

class AdaptiveMediaSourceCorrelatedTimes(winrt.system.Object):
    position: typing.Optional[typing.Optional[datetime.timedelta]]
    presentation_time_stamp: typing.Optional[typing.Optional[datetime.timedelta]]
    program_date_time: typing.Optional[typing.Optional[datetime.datetime]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AdaptiveMediaSourceCorrelatedTimes: ...

class AdaptiveMediaSourceCreationResult(winrt.system.Object):
    http_response_message: typing.Optional[winrt.windows.web.http.HttpResponseMessage]
    media_source: typing.Optional[AdaptiveMediaSource]
    status: AdaptiveMediaSourceCreationStatus
    extended_error: winrt.windows.foundation.HResult
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AdaptiveMediaSourceCreationResult: ...

class AdaptiveMediaSourceDiagnosticAvailableEventArgs(winrt.system.Object):
    bitrate: typing.Optional[typing.Optional[winrt.system.UInt32]]
    diagnostic_type: AdaptiveMediaSourceDiagnosticType
    position: typing.Optional[typing.Optional[datetime.timedelta]]
    request_id: typing.Optional[typing.Optional[winrt.system.Int32]]
    resource_byte_range_length: typing.Optional[typing.Optional[winrt.system.UInt64]]
    resource_byte_range_offset: typing.Optional[typing.Optional[winrt.system.UInt64]]
    resource_type: typing.Optional[typing.Optional[AdaptiveMediaSourceResourceType]]
    resource_uri: typing.Optional[winrt.windows.foundation.Uri]
    segment_id: typing.Optional[typing.Optional[winrt.system.UInt64]]
    extended_error: winrt.windows.foundation.HResult
    resource_content_type: str
    resource_duration: typing.Optional[typing.Optional[datetime.timedelta]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AdaptiveMediaSourceDiagnosticAvailableEventArgs: ...

class AdaptiveMediaSourceDiagnostics(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AdaptiveMediaSourceDiagnostics: ...
    def add_diagnostic_available(self, handler: winrt.windows.foundation.TypedEventHandler[AdaptiveMediaSourceDiagnostics, AdaptiveMediaSourceDiagnosticAvailableEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_diagnostic_available(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class AdaptiveMediaSourceDownloadBitrateChangedEventArgs(winrt.system.Object):
    new_value: winrt.system.UInt32
    old_value: winrt.system.UInt32
    reason: AdaptiveMediaSourceDownloadBitrateChangedReason
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AdaptiveMediaSourceDownloadBitrateChangedEventArgs: ...

class AdaptiveMediaSourceDownloadCompletedEventArgs(winrt.system.Object):
    http_response_message: typing.Optional[winrt.windows.web.http.HttpResponseMessage]
    resource_byte_range_length: typing.Optional[typing.Optional[winrt.system.UInt64]]
    resource_byte_range_offset: typing.Optional[typing.Optional[winrt.system.UInt64]]
    resource_type: AdaptiveMediaSourceResourceType
    resource_uri: typing.Optional[winrt.windows.foundation.Uri]
    position: typing.Optional[typing.Optional[datetime.timedelta]]
    request_id: winrt.system.Int32
    statistics: typing.Optional[AdaptiveMediaSourceDownloadStatistics]
    resource_content_type: str
    resource_duration: typing.Optional[typing.Optional[datetime.timedelta]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AdaptiveMediaSourceDownloadCompletedEventArgs: ...

class AdaptiveMediaSourceDownloadFailedEventArgs(winrt.system.Object):
    http_response_message: typing.Optional[winrt.windows.web.http.HttpResponseMessage]
    resource_byte_range_length: typing.Optional[typing.Optional[winrt.system.UInt64]]
    resource_byte_range_offset: typing.Optional[typing.Optional[winrt.system.UInt64]]
    resource_type: AdaptiveMediaSourceResourceType
    resource_uri: typing.Optional[winrt.windows.foundation.Uri]
    extended_error: winrt.windows.foundation.HResult
    position: typing.Optional[typing.Optional[datetime.timedelta]]
    request_id: winrt.system.Int32
    statistics: typing.Optional[AdaptiveMediaSourceDownloadStatistics]
    resource_content_type: str
    resource_duration: typing.Optional[typing.Optional[datetime.timedelta]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AdaptiveMediaSourceDownloadFailedEventArgs: ...

class AdaptiveMediaSourceDownloadRequestedDeferral(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AdaptiveMediaSourceDownloadRequestedDeferral: ...
    def complete(self) -> None: ...

class AdaptiveMediaSourceDownloadRequestedEventArgs(winrt.system.Object):
    resource_byte_range_length: typing.Optional[typing.Optional[winrt.system.UInt64]]
    resource_byte_range_offset: typing.Optional[typing.Optional[winrt.system.UInt64]]
    resource_type: AdaptiveMediaSourceResourceType
    resource_uri: typing.Optional[winrt.windows.foundation.Uri]
    result: typing.Optional[AdaptiveMediaSourceDownloadResult]
    position: typing.Optional[typing.Optional[datetime.timedelta]]
    request_id: winrt.system.Int32
    resource_content_type: str
    resource_duration: typing.Optional[typing.Optional[datetime.timedelta]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AdaptiveMediaSourceDownloadRequestedEventArgs: ...
    def get_deferral(self) -> typing.Optional[AdaptiveMediaSourceDownloadRequestedDeferral]: ...

class AdaptiveMediaSourceDownloadResult(winrt.system.Object):
    resource_uri: typing.Optional[winrt.windows.foundation.Uri]
    input_stream: typing.Optional[winrt.windows.storage.streams.IInputStream]
    extended_status: winrt.system.UInt32
    content_type: str
    buffer: typing.Optional[winrt.windows.storage.streams.IBuffer]
    resource_byte_range_offset: typing.Optional[typing.Optional[winrt.system.UInt64]]
    resource_byte_range_length: typing.Optional[typing.Optional[winrt.system.UInt64]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AdaptiveMediaSourceDownloadResult: ...

class AdaptiveMediaSourceDownloadStatistics(winrt.system.Object):
    content_bytes_received_count: winrt.system.UInt64
    time_to_first_byte_received: typing.Optional[typing.Optional[datetime.timedelta]]
    time_to_headers_received: typing.Optional[typing.Optional[datetime.timedelta]]
    time_to_last_byte_received: typing.Optional[typing.Optional[datetime.timedelta]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AdaptiveMediaSourceDownloadStatistics: ...

class AdaptiveMediaSourcePlaybackBitrateChangedEventArgs(winrt.system.Object):
    audio_only: bool
    new_value: winrt.system.UInt32
    old_value: winrt.system.UInt32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AdaptiveMediaSourcePlaybackBitrateChangedEventArgs: ...

