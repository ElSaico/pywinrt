# WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

import datetime
import sys
import types
import typing
import uuid as _uuid

import winrt.system
import winrt.windows.applicationmodel.activation
import winrt.windows.applicationmodel.core
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.storage
import winrt.windows.storage.streams
import winrt.windows.system

from . import AddResourcePackageOptions, AppExecutionContext, AppInstallerPolicySource, FullTrustLaunchResult, LimitedAccessFeatureStatus, PackageContentGroupState, PackageRelationship, PackageSignatureKind, PackageUpdateAvailability, StartupTaskState

Self = typing.TypeVar('Self')

class PackageInstallProgress:
    percent_complete: winrt.system.UInt32
    def __init__(self, percent_complete: winrt.system.UInt32) -> None: ...

class PackageVersion:
    major: winrt.system.UInt16
    minor: winrt.system.UInt16
    build: winrt.system.UInt16
    revision: winrt.system.UInt16
    def __init__(self, major: winrt.system.UInt16, minor: winrt.system.UInt16, build: winrt.system.UInt16, revision: winrt.system.UInt16) -> None: ...

class AppDisplayInfo(winrt.system.Object):
    description: str
    display_name: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppDisplayInfo: ...
    def get_logo(self, size: winrt.windows.foundation.Size, /) -> typing.Optional[winrt.windows.storage.streams.RandomAccessStreamReference]: ...

class AppInfo(winrt.system.Object):
    app_user_model_id: str
    display_info: typing.Optional[AppDisplayInfo]
    id: str
    package_family_name: str
    package: typing.Optional[Package]
    execution_context: AppExecutionContext
    supported_file_extensions: str
    current: typing.ClassVar[typing.Optional[AppInfo]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppInfo: ...
    @staticmethod
    def get_from_app_user_model_id(app_user_model_id: str, /) -> typing.Optional[AppInfo]: ...
    @staticmethod
    def get_from_app_user_model_id_for_user(user: typing.Optional[winrt.windows.system.User], app_user_model_id: str, /) -> typing.Optional[AppInfo]: ...

class AppInstallerInfo(winrt.system.Object):
    uri: typing.Optional[winrt.windows.foundation.Uri]
    automatic_background_task: bool
    dependency_package_uris: typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.foundation.Uri]]
    force_update_from_any_version: bool
    hours_between_update_checks: winrt.system.UInt32
    is_auto_repair_enabled: bool
    last_checked: datetime.datetime
    on_launch: bool
    optional_package_uris: typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.foundation.Uri]]
    paused_until: typing.Optional[typing.Optional[datetime.datetime]]
    policy_source: AppInstallerPolicySource
    repair_uris: typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.foundation.Uri]]
    show_prompt: bool
    update_blocks_activation: bool
    update_uris: typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.foundation.Uri]]
    version: PackageVersion
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppInstallerInfo: ...

class AppInstance(winrt.system.Object):
    is_current_instance: bool
    key: str
    recommended_instance: typing.ClassVar[typing.Optional[AppInstance]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppInstance: ...
    @staticmethod
    def find_or_register_instance_for_key(key: str, /) -> typing.Optional[AppInstance]: ...
    @staticmethod
    def get_activated_event_args() -> typing.Optional[winrt.windows.applicationmodel.activation.IActivatedEventArgs]: ...
    @staticmethod
    def get_instances() -> typing.Optional[winrt.windows.foundation.collections.IVector[AppInstance]]: ...
    def redirect_activation_to(self) -> None: ...
    @staticmethod
    def unregister() -> None: ...

class CameraApplicationManager(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CameraApplicationManager: ...
    @staticmethod
    def show_installed_applications_u_i() -> None: ...

class DesignMode(winrt.system.Object):
    design_mode_enabled: typing.ClassVar[bool]
    design_mode2_enabled: typing.ClassVar[bool]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DesignMode: ...

class EnteredBackgroundEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EnteredBackgroundEventArgs: ...
    def get_deferral(self) -> typing.Optional[winrt.windows.foundation.Deferral]: ...

class FindRelatedPackagesOptions(winrt.system.Object):
    relationship: PackageRelationship
    include_resources: bool
    include_optionals: bool
    include_host_runtimes: bool
    include_frameworks: bool
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FindRelatedPackagesOptions: ...
    def __new__(cls: typing.Type[FindRelatedPackagesOptions], relationship: PackageRelationship) -> FindRelatedPackagesOptions:...

class FullTrustProcessLaunchResult(winrt.system.Object):
    extended_error: winrt.windows.foundation.HResult
    launch_result: FullTrustLaunchResult
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FullTrustProcessLaunchResult: ...

class FullTrustProcessLauncher(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FullTrustProcessLauncher: ...
    @typing.overload
    @staticmethod
    def launch_full_trust_process_for_app_async(full_trust_package_relative_app_id: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    @staticmethod
    def launch_full_trust_process_for_app_async(full_trust_package_relative_app_id: str, parameter_group_id: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    @staticmethod
    def launch_full_trust_process_for_app_with_arguments_async(full_trust_package_relative_app_id: str, command_line: str, /) -> winrt.windows.foundation.IAsyncOperation[FullTrustProcessLaunchResult]: ...
    @typing.overload
    @staticmethod
    def launch_full_trust_process_for_current_app_async() -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    @staticmethod
    def launch_full_trust_process_for_current_app_async(parameter_group_id: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    @staticmethod
    def launch_full_trust_process_for_current_app_with_arguments_async(command_line: str, /) -> winrt.windows.foundation.IAsyncOperation[FullTrustProcessLaunchResult]: ...

class LeavingBackgroundEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LeavingBackgroundEventArgs: ...
    def get_deferral(self) -> typing.Optional[winrt.windows.foundation.Deferral]: ...

class LimitedAccessFeatureRequestResult(winrt.system.Object):
    estimated_removal_date: typing.Optional[typing.Optional[datetime.datetime]]
    feature_id: str
    status: LimitedAccessFeatureStatus
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LimitedAccessFeatureRequestResult: ...

class LimitedAccessFeatures(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LimitedAccessFeatures: ...
    @staticmethod
    def try_unlock_feature(feature_id: str, token: str, attestation: str, /) -> typing.Optional[LimitedAccessFeatureRequestResult]: ...

class Package(winrt.system.Object):
    dependencies: typing.Optional[winrt.windows.foundation.collections.IVectorView[Package]]
    id: typing.Optional[PackageId]
    installed_location: typing.Optional[winrt.windows.storage.StorageFolder]
    is_framework: bool
    description: str
    display_name: str
    is_bundle: bool
    is_development_mode: bool
    is_resource_package: bool
    logo: typing.Optional[winrt.windows.foundation.Uri]
    publisher_display_name: str
    installed_date: datetime.datetime
    status: typing.Optional[PackageStatus]
    is_optional: bool
    signature_kind: PackageSignatureKind
    effective_location: typing.Optional[winrt.windows.storage.StorageFolder]
    mutable_location: typing.Optional[winrt.windows.storage.StorageFolder]
    effective_external_location: typing.Optional[winrt.windows.storage.StorageFolder]
    effective_external_path: str
    effective_path: str
    installed_path: str
    is_stub: bool
    machine_external_location: typing.Optional[winrt.windows.storage.StorageFolder]
    machine_external_path: str
    mutable_path: str
    user_external_location: typing.Optional[winrt.windows.storage.StorageFolder]
    user_external_path: str
    source_uri_scheme_name: str
    install_date: datetime.datetime
    current: typing.ClassVar[typing.Optional[Package]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Package: ...
    def check_update_availability_async(self) -> winrt.windows.foundation.IAsyncOperation[PackageUpdateAvailabilityResult]: ...
    def find_related_packages(self, options: typing.Optional[FindRelatedPackagesOptions], /) -> typing.Optional[winrt.windows.foundation.collections.IVector[Package]]: ...
    def get_app_installer_info(self) -> typing.Optional[AppInstallerInfo]: ...
    def get_app_list_entries(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.applicationmodel.core.AppListEntry]]: ...
    def get_app_list_entries_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[winrt.windows.applicationmodel.core.AppListEntry]]: ...
    def get_content_group_async(self, name: str, /) -> winrt.windows.foundation.IAsyncOperation[PackageContentGroup]: ...
    def get_content_groups_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVector[PackageContentGroup]]: ...
    def get_logo_as_random_access_stream_reference(self, size: winrt.windows.foundation.Size, /) -> typing.Optional[winrt.windows.storage.streams.RandomAccessStreamReference]: ...
    def get_thumbnail_token(self) -> str: ...
    def launch(self, parameters: str, /) -> None: ...
    def set_in_use_async(self, in_use: bool, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @typing.overload
    def stage_content_groups_async(self, names: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVector[PackageContentGroup]]: ...
    @typing.overload
    def stage_content_groups_async(self, names: typing.Iterable[str], move_to_head_of_queue: bool, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVector[PackageContentGroup]]: ...
    def verify_content_integrity_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...

class PackageCatalog(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PackageCatalog: ...
    def add_optional_package_async(self, optional_package_family_name: str, /) -> winrt.windows.foundation.IAsyncOperation[PackageCatalogAddOptionalPackageResult]: ...
    def add_resource_package_async(self, resource_package_family_name: str, resource_i_d: str, options: AddResourcePackageOptions, /) -> winrt.windows.foundation.IAsyncOperationWithProgress[PackageCatalogAddResourcePackageResult, PackageInstallProgress]: ...
    @staticmethod
    def open_for_current_package() -> typing.Optional[PackageCatalog]: ...
    @staticmethod
    def open_for_current_user() -> typing.Optional[PackageCatalog]: ...
    @staticmethod
    def open_for_package(package: typing.Optional[Package], /) -> typing.Optional[PackageCatalog]: ...
    def remove_optional_packages_async(self, optional_package_family_names: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncOperation[PackageCatalogRemoveOptionalPackagesResult]: ...
    def remove_resource_packages_async(self, resource_packages: typing.Iterable[Package], /) -> winrt.windows.foundation.IAsyncOperation[PackageCatalogRemoveResourcePackagesResult]: ...
    def add_package_installing(self, handler: winrt.windows.foundation.TypedEventHandler[PackageCatalog, PackageInstallingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_package_installing(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_package_staging(self, handler: winrt.windows.foundation.TypedEventHandler[PackageCatalog, PackageStagingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_package_staging(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_package_status_changed(self, handler: winrt.windows.foundation.TypedEventHandler[PackageCatalog, PackageStatusChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_package_status_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_package_uninstalling(self, handler: winrt.windows.foundation.TypedEventHandler[PackageCatalog, PackageUninstallingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_package_uninstalling(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_package_updating(self, handler: winrt.windows.foundation.TypedEventHandler[PackageCatalog, PackageUpdatingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_package_updating(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_package_content_group_staging(self, handler: winrt.windows.foundation.TypedEventHandler[PackageCatalog, PackageContentGroupStagingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_package_content_group_staging(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class PackageCatalogAddOptionalPackageResult(winrt.system.Object):
    extended_error: winrt.windows.foundation.HResult
    package: typing.Optional[Package]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PackageCatalogAddOptionalPackageResult: ...

class PackageCatalogAddResourcePackageResult(winrt.system.Object):
    extended_error: winrt.windows.foundation.HResult
    is_complete: bool
    package: typing.Optional[Package]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PackageCatalogAddResourcePackageResult: ...

class PackageCatalogRemoveOptionalPackagesResult(winrt.system.Object):
    extended_error: winrt.windows.foundation.HResult
    packages_removed: typing.Optional[winrt.windows.foundation.collections.IVectorView[Package]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PackageCatalogRemoveOptionalPackagesResult: ...

class PackageCatalogRemoveResourcePackagesResult(winrt.system.Object):
    extended_error: winrt.windows.foundation.HResult
    packages_removed: typing.Optional[winrt.windows.foundation.collections.IVectorView[Package]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PackageCatalogRemoveResourcePackagesResult: ...

class PackageContentGroup(winrt.system.Object):
    is_required: bool
    name: str
    package: typing.Optional[Package]
    state: PackageContentGroupState
    required_group_name: typing.ClassVar[str]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PackageContentGroup: ...

class PackageContentGroupStagingEventArgs(winrt.system.Object):
    activity_id: _uuid.UUID
    content_group_name: str
    error_code: winrt.windows.foundation.HResult
    is_complete: bool
    is_content_group_required: bool
    package: typing.Optional[Package]
    progress: winrt.system.Double
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PackageContentGroupStagingEventArgs: ...

class PackageId(winrt.system.Object):
    architecture: winrt.windows.system.ProcessorArchitecture
    family_name: str
    full_name: str
    name: str
    publisher: str
    publisher_id: str
    resource_id: str
    version: PackageVersion
    author: str
    product_id: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PackageId: ...

class PackageInstallingEventArgs(winrt.system.Object):
    activity_id: _uuid.UUID
    error_code: winrt.windows.foundation.HResult
    is_complete: bool
    package: typing.Optional[Package]
    progress: winrt.system.Double
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PackageInstallingEventArgs: ...

class PackageStagingEventArgs(winrt.system.Object):
    activity_id: _uuid.UUID
    error_code: winrt.windows.foundation.HResult
    is_complete: bool
    package: typing.Optional[Package]
    progress: winrt.system.Double
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PackageStagingEventArgs: ...

class PackageStatus(winrt.system.Object):
    data_offline: bool
    dependency_issue: bool
    deployment_in_progress: bool
    disabled: bool
    license_issue: bool
    modified: bool
    needs_remediation: bool
    not_available: bool
    package_offline: bool
    servicing: bool
    tampered: bool
    is_partially_staged: bool
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PackageStatus: ...
    def verify_is_o_k(self) -> bool: ...

class PackageStatusChangedEventArgs(winrt.system.Object):
    package: typing.Optional[Package]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PackageStatusChangedEventArgs: ...

class PackageUninstallingEventArgs(winrt.system.Object):
    activity_id: _uuid.UUID
    error_code: winrt.windows.foundation.HResult
    is_complete: bool
    package: typing.Optional[Package]
    progress: winrt.system.Double
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PackageUninstallingEventArgs: ...

class PackageUpdateAvailabilityResult(winrt.system.Object):
    availability: PackageUpdateAvailability
    extended_error: winrt.windows.foundation.HResult
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PackageUpdateAvailabilityResult: ...

class PackageUpdatingEventArgs(winrt.system.Object):
    activity_id: _uuid.UUID
    error_code: winrt.windows.foundation.HResult
    is_complete: bool
    progress: winrt.system.Double
    source_package: typing.Optional[Package]
    target_package: typing.Optional[Package]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PackageUpdatingEventArgs: ...

class StartupTask(winrt.system.Object):
    state: StartupTaskState
    task_id: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StartupTask: ...
    def disable(self) -> None: ...
    @staticmethod
    def get_async(task_id: str, /) -> winrt.windows.foundation.IAsyncOperation[StartupTask]: ...
    @staticmethod
    def get_for_current_package_async() -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[StartupTask]]: ...
    def request_enable_async(self) -> winrt.windows.foundation.IAsyncOperation[StartupTaskState]: ...

class SuspendingDeferral(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SuspendingDeferral: ...
    def complete(self) -> None: ...

class SuspendingEventArgs(winrt.system.Object):
    suspending_operation: typing.Optional[SuspendingOperation]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SuspendingEventArgs: ...

class SuspendingOperation(winrt.system.Object):
    deadline: datetime.datetime
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SuspendingOperation: ...
    def get_deferral(self) -> typing.Optional[SuspendingDeferral]: ...

class IEnteredBackgroundEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IEnteredBackgroundEventArgs: ...
    def get_deferral(self) -> typing.Optional[winrt.windows.foundation.Deferral]: ...

class ILeavingBackgroundEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ILeavingBackgroundEventArgs: ...
    def get_deferral(self) -> typing.Optional[winrt.windows.foundation.Deferral]: ...

class IPackageCatalogStatics2(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IPackageCatalogStatics2: ...
    def open_for_package(self, package: typing.Optional[Package], /) -> typing.Optional[PackageCatalog]: ...

class ISuspendingDeferral(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ISuspendingDeferral: ...
    def complete(self) -> None: ...

class ISuspendingEventArgs(winrt.system.Object):
    suspending_operation: typing.Optional[SuspendingOperation]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ISuspendingEventArgs: ...

class ISuspendingOperation(winrt.system.Object):
    deadline: datetime.datetime
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ISuspendingOperation: ...
    def get_deferral(self) -> typing.Optional[SuspendingDeferral]: ...

