# WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

import datetime
import sys
import types
import typing
import uuid

import winrt.system
import winrt.windows.applicationmodel
import winrt.windows.foundation
import winrt.windows.foundation.collections

from . import AddPackageByAppInstallerOptions, DeploymentOptions, DeploymentProgressState, PackageInstallState, PackageState, PackageStatus, PackageStubPreference, PackageTypes, RemovalOptions, SharedPackageContainerCreationCollisionOptions, SharedPackageContainerOperationStatus, StubPackageOption

Self = typing.TypeVar('Self')

class DeploymentProgress:
    state: DeploymentProgressState
    percentage: winrt.system.UInt32
    def __new__(cls: typing.Type[DeploymentProgress], state: DeploymentProgressState, percentage: winrt.system.UInt32) -> DeploymentProgress: ...

class AddPackageOptions(winrt.system.Object):
    target_volume: typing.Optional[PackageVolume]
    stub_package_option: StubPackageOption
    stage_in_place: winrt.system.Boolean
    retain_files_on_failure: winrt.system.Boolean
    required_content_group_only: winrt.system.Boolean
    install_all_resources: winrt.system.Boolean
    force_update_from_any_version: winrt.system.Boolean
    force_target_app_shutdown: winrt.system.Boolean
    force_app_shutdown: winrt.system.Boolean
    external_location_uri: typing.Optional[winrt.windows.foundation.Uri]
    developer_mode: winrt.system.Boolean
    defer_registration_when_packages_are_in_use: winrt.system.Boolean
    allow_unsigned: winrt.system.Boolean
    dependency_package_uris: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.foundation.Uri]]
    optional_package_family_names: typing.Optional[winrt.windows.foundation.collections.IVector[str]]
    optional_package_uris: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.foundation.Uri]]
    related_package_uris: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.foundation.Uri]]
    limit_to_existing_packages: winrt.system.Boolean
    expected_digests: typing.Optional[winrt.windows.foundation.collections.IMap[winrt.windows.foundation.Uri, str]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AddPackageOptions: ...
    def __new__(cls: typing.Type[AddPackageOptions]) -> AddPackageOptions:...

class AppInstallerManager(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AppInstallerManager: ...
    def clear_auto_update_settings(self, package_family_name: str, /) -> None: ...
    @staticmethod
    def get_default() -> typing.Optional[AppInstallerManager]: ...
    @staticmethod
    def get_for_system() -> typing.Optional[AppInstallerManager]: ...
    def pause_auto_updates_until(self, package_family_name: str, date_time: datetime.datetime, /) -> None: ...
    def set_auto_update_settings(self, package_family_name: str, app_installer_info: typing.Optional[AutoUpdateSettingsOptions], /) -> None: ...

class AutoUpdateSettingsOptions(winrt.system.Object):
    version: winrt.windows.applicationmodel.PackageVersion
    update_blocks_activation: winrt.system.Boolean
    show_prompt: winrt.system.Boolean
    on_launch: winrt.system.Boolean
    is_auto_repair_enabled: winrt.system.Boolean
    hours_between_update_checks: winrt.system.UInt32
    force_update_from_any_version: winrt.system.Boolean
    automatic_background_task: winrt.system.Boolean
    app_installer_uri: typing.Optional[winrt.windows.foundation.Uri]
    dependency_package_uris: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.foundation.Uri]]
    optional_package_uris: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.foundation.Uri]]
    repair_uris: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.foundation.Uri]]
    update_uris: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.foundation.Uri]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AutoUpdateSettingsOptions: ...
    def __new__(cls: typing.Type[AutoUpdateSettingsOptions]) -> AutoUpdateSettingsOptions:...
    @staticmethod
    def create_from_app_installer_info(app_installer_info: typing.Optional[winrt.windows.applicationmodel.AppInstallerInfo], /) -> typing.Optional[AutoUpdateSettingsOptions]: ...

class CreateSharedPackageContainerOptions(winrt.system.Object):
    force_app_shutdown: winrt.system.Boolean
    create_collision_option: SharedPackageContainerCreationCollisionOptions
    members: typing.Optional[winrt.windows.foundation.collections.IVector[SharedPackageContainerMember]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CreateSharedPackageContainerOptions: ...
    def __new__(cls: typing.Type[CreateSharedPackageContainerOptions]) -> CreateSharedPackageContainerOptions:...

class CreateSharedPackageContainerResult(winrt.system.Object):
    container: typing.Optional[SharedPackageContainer]
    extended_error: winrt.windows.foundation.HResult
    status: SharedPackageContainerOperationStatus
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CreateSharedPackageContainerResult: ...

class DeleteSharedPackageContainerOptions(winrt.system.Object):
    force_app_shutdown: winrt.system.Boolean
    all_users: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DeleteSharedPackageContainerOptions: ...
    def __new__(cls: typing.Type[DeleteSharedPackageContainerOptions]) -> DeleteSharedPackageContainerOptions:...

class DeleteSharedPackageContainerResult(winrt.system.Object):
    extended_error: winrt.windows.foundation.HResult
    status: SharedPackageContainerOperationStatus
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DeleteSharedPackageContainerResult: ...

class DeploymentResult(winrt.system.Object):
    activity_id: uuid.UUID
    error_text: str
    extended_error_code: winrt.windows.foundation.HResult
    is_registered: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DeploymentResult: ...

class FindSharedPackageContainerOptions(winrt.system.Object):
    package_family_name: str
    name: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FindSharedPackageContainerOptions: ...
    def __new__(cls: typing.Type[FindSharedPackageContainerOptions]) -> FindSharedPackageContainerOptions:...

class PackageAllUserProvisioningOptions(winrt.system.Object):
    optional_package_family_names: typing.Optional[winrt.windows.foundation.collections.IVector[str]]
    projection_order_package_family_names: typing.Optional[winrt.windows.foundation.collections.IVector[str]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PackageAllUserProvisioningOptions: ...
    def __new__(cls: typing.Type[PackageAllUserProvisioningOptions]) -> PackageAllUserProvisioningOptions:...

class PackageManager(winrt.system.Object):
    debug_settings: typing.Optional[PackageManagerDebugSettings]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PackageManager: ...
    def __new__(cls: typing.Type[PackageManager]) -> PackageManager:...
    @typing.overload
    def add_package_async(self, package_uri: typing.Optional[winrt.windows.foundation.Uri], dependency_package_uris: typing.Iterable[winrt.windows.foundation.Uri], deployment_options: DeploymentOptions, /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def add_package_async(self, package_uri: typing.Optional[winrt.windows.foundation.Uri], dependency_package_uris: typing.Iterable[winrt.windows.foundation.Uri], deployment_options: DeploymentOptions, target_volume: typing.Optional[PackageVolume], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def add_package_async(self, package_uri: typing.Optional[winrt.windows.foundation.Uri], dependency_package_uris: typing.Iterable[winrt.windows.foundation.Uri], deployment_options: DeploymentOptions, target_volume: typing.Optional[PackageVolume], optional_package_family_names: typing.Iterable[str], external_package_uris: typing.Iterable[winrt.windows.foundation.Uri], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def add_package_async(self, package_uri: typing.Optional[winrt.windows.foundation.Uri], dependency_package_uris: typing.Iterable[winrt.windows.foundation.Uri], options: DeploymentOptions, target_volume: typing.Optional[PackageVolume], optional_package_family_names: typing.Iterable[str], package_uris_to_install: typing.Iterable[winrt.windows.foundation.Uri], related_package_uris: typing.Iterable[winrt.windows.foundation.Uri], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    def add_package_by_app_installer_file_async(self, app_installer_file_uri: typing.Optional[winrt.windows.foundation.Uri], options: AddPackageByAppInstallerOptions, target_volume: typing.Optional[PackageVolume], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    def add_package_by_uri_async(self, package_uri: typing.Optional[winrt.windows.foundation.Uri], options: typing.Optional[AddPackageOptions], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    def add_package_volume_async(self, package_store_path: str, /) -> winrt.windows.foundation.IAsyncOperation[PackageVolume]: ...
    def cleanup_package_for_user_async(self, package_name: str, user_security_id: str, /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    def clear_package_status(self, package_full_name: str, status: PackageStatus, /) -> None: ...
    def deprovision_package_for_all_users_async(self, package_family_name: str, /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    def find_package(self, package_full_name: str, /) -> typing.Optional[winrt.windows.applicationmodel.Package]: ...
    def find_package_for_user(self, user_security_id: str, package_full_name: str, /) -> typing.Optional[winrt.windows.applicationmodel.Package]: ...
    def find_package_volume(self, volume_name: str, /) -> typing.Optional[PackageVolume]: ...
    def find_package_volumes(self) -> typing.Optional[winrt.windows.foundation.collections.IIterable[PackageVolume]]: ...
    @typing.overload
    def find_packages(self) -> typing.Optional[winrt.windows.foundation.collections.IIterable[winrt.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages(self, package_family_name: str, /) -> typing.Optional[winrt.windows.foundation.collections.IIterable[winrt.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages(self, package_name: str, package_publisher: str, /) -> typing.Optional[winrt.windows.foundation.collections.IIterable[winrt.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_for_user(self, user_security_id: str, /) -> typing.Optional[winrt.windows.foundation.collections.IIterable[winrt.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_for_user(self, user_security_id: str, package_family_name: str, /) -> typing.Optional[winrt.windows.foundation.collections.IIterable[winrt.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_for_user(self, user_security_id: str, package_name: str, package_publisher: str, /) -> typing.Optional[winrt.windows.foundation.collections.IIterable[winrt.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_for_user_with_package_types(self, user_security_id: str, package_types: PackageTypes, /) -> typing.Optional[winrt.windows.foundation.collections.IIterable[winrt.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_for_user_with_package_types(self, user_security_id: str, package_family_name: str, package_types: PackageTypes, /) -> typing.Optional[winrt.windows.foundation.collections.IIterable[winrt.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_for_user_with_package_types(self, user_security_id: str, package_name: str, package_publisher: str, package_types: PackageTypes, /) -> typing.Optional[winrt.windows.foundation.collections.IIterable[winrt.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_with_package_types(self, package_types: PackageTypes, /) -> typing.Optional[winrt.windows.foundation.collections.IIterable[winrt.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_with_package_types(self, package_family_name: str, package_types: PackageTypes, /) -> typing.Optional[winrt.windows.foundation.collections.IIterable[winrt.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_with_package_types(self, package_name: str, package_publisher: str, package_types: PackageTypes, /) -> typing.Optional[winrt.windows.foundation.collections.IIterable[winrt.windows.applicationmodel.Package]]: ...
    def find_provisioned_packages(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.applicationmodel.Package]]: ...
    def find_users(self, package_full_name: str, /) -> typing.Optional[winrt.windows.foundation.collections.IIterable[PackageUserInformation]]: ...
    def get_default_package_volume(self) -> typing.Optional[PackageVolume]: ...
    def get_package_stub_preference(self, package_family_name: str, /) -> PackageStubPreference: ...
    def get_package_volumes_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[PackageVolume]]: ...
    def move_package_to_volume_async(self, package_full_name: str, deployment_options: DeploymentOptions, target_volume: typing.Optional[PackageVolume], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def provision_package_for_all_users_async(self, package_family_name: str, /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def provision_package_for_all_users_async(self, main_package_family_name: str, options: typing.Optional[PackageAllUserProvisioningOptions], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def register_package_async(self, manifest_uri: typing.Optional[winrt.windows.foundation.Uri], dependency_package_uris: typing.Iterable[winrt.windows.foundation.Uri], deployment_options: DeploymentOptions, /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def register_package_async(self, manifest_uri: typing.Optional[winrt.windows.foundation.Uri], dependency_package_uris: typing.Iterable[winrt.windows.foundation.Uri], deployment_options: DeploymentOptions, app_data_volume: typing.Optional[PackageVolume], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    def register_package_by_family_name_async(self, main_package_family_name: str, dependency_package_family_names: typing.Iterable[str], deployment_options: DeploymentOptions, app_data_volume: typing.Optional[PackageVolume], optional_package_family_names: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    def register_package_by_full_name_async(self, main_package_full_name: str, dependency_package_full_names: typing.Iterable[str], deployment_options: DeploymentOptions, /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    def register_package_by_uri_async(self, manifest_uri: typing.Optional[winrt.windows.foundation.Uri], options: typing.Optional[RegisterPackageOptions], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    def register_packages_by_full_name_async(self, package_full_names: typing.Iterable[str], options: typing.Optional[RegisterPackageOptions], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def remove_package_async(self, package_full_name: str, /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def remove_package_async(self, package_full_name: str, removal_options: RemovalOptions, /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    def remove_package_volume_async(self, volume: typing.Optional[PackageVolume], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def request_add_package_async(self, package_uri: typing.Optional[winrt.windows.foundation.Uri], dependency_package_uris: typing.Iterable[winrt.windows.foundation.Uri], deployment_options: DeploymentOptions, target_volume: typing.Optional[PackageVolume], optional_package_family_names: typing.Iterable[str], related_package_uris: typing.Iterable[winrt.windows.foundation.Uri], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def request_add_package_async(self, package_uri: typing.Optional[winrt.windows.foundation.Uri], dependency_package_uris: typing.Iterable[winrt.windows.foundation.Uri], deployment_options: DeploymentOptions, target_volume: typing.Optional[PackageVolume], optional_package_family_names: typing.Iterable[str], related_package_uris: typing.Iterable[winrt.windows.foundation.Uri], package_uris_to_install: typing.Iterable[winrt.windows.foundation.Uri], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    def request_add_package_by_app_installer_file_async(self, app_installer_file_uri: typing.Optional[winrt.windows.foundation.Uri], options: AddPackageByAppInstallerOptions, target_volume: typing.Optional[PackageVolume], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    def set_default_package_volume(self, volume: typing.Optional[PackageVolume], /) -> None: ...
    def set_package_state(self, package_full_name: str, package_state: PackageState, /) -> None: ...
    def set_package_status(self, package_full_name: str, status: PackageStatus, /) -> None: ...
    def set_package_stub_preference(self, package_family_name: str, use_stub: PackageStubPreference, /) -> None: ...
    def set_package_volume_offline_async(self, package_volume: typing.Optional[PackageVolume], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    def set_package_volume_online_async(self, package_volume: typing.Optional[PackageVolume], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def stage_package_async(self, package_uri: typing.Optional[winrt.windows.foundation.Uri], dependency_package_uris: typing.Iterable[winrt.windows.foundation.Uri], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def stage_package_async(self, package_uri: typing.Optional[winrt.windows.foundation.Uri], dependency_package_uris: typing.Iterable[winrt.windows.foundation.Uri], deployment_options: DeploymentOptions, /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def stage_package_async(self, package_uri: typing.Optional[winrt.windows.foundation.Uri], dependency_package_uris: typing.Iterable[winrt.windows.foundation.Uri], deployment_options: DeploymentOptions, target_volume: typing.Optional[PackageVolume], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def stage_package_async(self, package_uri: typing.Optional[winrt.windows.foundation.Uri], dependency_package_uris: typing.Iterable[winrt.windows.foundation.Uri], deployment_options: DeploymentOptions, target_volume: typing.Optional[PackageVolume], optional_package_family_names: typing.Iterable[str], external_package_uris: typing.Iterable[winrt.windows.foundation.Uri], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def stage_package_async(self, package_uri: typing.Optional[winrt.windows.foundation.Uri], dependency_package_uris: typing.Iterable[winrt.windows.foundation.Uri], options: DeploymentOptions, target_volume: typing.Optional[PackageVolume], optional_package_family_names: typing.Iterable[str], package_uris_to_install: typing.Iterable[winrt.windows.foundation.Uri], related_package_uris: typing.Iterable[winrt.windows.foundation.Uri], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    def stage_package_by_uri_async(self, package_uri: typing.Optional[winrt.windows.foundation.Uri], options: typing.Optional[StagePackageOptions], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def stage_user_data_async(self, package_full_name: str, /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    @typing.overload
    def stage_user_data_async(self, package_full_name: str, deployment_options: DeploymentOptions, /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...
    def update_package_async(self, package_uri: typing.Optional[winrt.windows.foundation.Uri], dependency_package_uris: typing.Iterable[winrt.windows.foundation.Uri], deployment_options: DeploymentOptions, /) -> winrt.windows.foundation.IAsyncOperationWithProgress[DeploymentResult, DeploymentProgress]: ...

class PackageManagerDebugSettings(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PackageManagerDebugSettings: ...
    @typing.overload
    def set_content_group_state_async(self, package: typing.Optional[winrt.windows.applicationmodel.Package], content_group_name: str, state: winrt.windows.applicationmodel.PackageContentGroupState, /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def set_content_group_state_async(self, package: typing.Optional[winrt.windows.applicationmodel.Package], content_group_name: str, state: winrt.windows.applicationmodel.PackageContentGroupState, completion_percentage: winrt.system.Double, /) -> winrt.windows.foundation.IAsyncAction: ...

class PackageUserInformation(winrt.system.Object):
    install_state: PackageInstallState
    user_security_id: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PackageUserInformation: ...

class PackageVolume(winrt.system.Object):
    is_offline: winrt.system.Boolean
    is_system_volume: winrt.system.Boolean
    mount_point: str
    name: str
    package_store_path: str
    supports_hard_links: winrt.system.Boolean
    is_appx_install_supported: winrt.system.Boolean
    is_full_trust_package_supported: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PackageVolume: ...
    def find_package(self, package_full_name: str, /) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.applicationmodel.Package]]: ...
    def find_package_for_user(self, user_security_id: str, package_full_name: str, /) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages(self, package_family_name: str, /) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages(self, package_name: str, package_publisher: str, /) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_for_user(self, user_security_id: str, /) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_for_user(self, user_security_id: str, package_family_name: str, /) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_for_user(self, user_security_id: str, package_name: str, package_publisher: str, /) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_for_user_with_package_types(self, user_security_id: str, package_types: PackageTypes, /) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_for_user_with_package_types(self, user_security_id: str, package_types: PackageTypes, package_family_name: str, /) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_for_user_with_package_types(self, user_security_id: str, package_types: PackageTypes, package_name: str, package_publisher: str, /) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_with_package_types(self, package_types: PackageTypes, /) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_with_package_types(self, package_types: PackageTypes, package_family_name: str, /) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.applicationmodel.Package]]: ...
    @typing.overload
    def find_packages_with_package_types(self, package_types: PackageTypes, package_name: str, package_publisher: str, /) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.applicationmodel.Package]]: ...
    def get_available_space_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.system.UInt64]: ...

class RegisterPackageOptions(winrt.system.Object):
    stage_in_place: winrt.system.Boolean
    install_all_resources: winrt.system.Boolean
    force_update_from_any_version: winrt.system.Boolean
    force_target_app_shutdown: winrt.system.Boolean
    force_app_shutdown: winrt.system.Boolean
    external_location_uri: typing.Optional[winrt.windows.foundation.Uri]
    developer_mode: winrt.system.Boolean
    defer_registration_when_packages_are_in_use: winrt.system.Boolean
    app_data_volume: typing.Optional[PackageVolume]
    allow_unsigned: winrt.system.Boolean
    dependency_package_uris: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.foundation.Uri]]
    optional_package_family_names: typing.Optional[winrt.windows.foundation.collections.IVector[str]]
    expected_digests: typing.Optional[winrt.windows.foundation.collections.IMap[winrt.windows.foundation.Uri, str]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RegisterPackageOptions: ...
    def __new__(cls: typing.Type[RegisterPackageOptions]) -> RegisterPackageOptions:...

class SharedPackageContainer(winrt.system.Object):
    id: str
    name: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SharedPackageContainer: ...
    def get_members(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[SharedPackageContainerMember]]: ...
    def remove_package_family(self, package_family_name: str, options: typing.Optional[UpdateSharedPackageContainerOptions], /) -> typing.Optional[UpdateSharedPackageContainerResult]: ...
    def reset_data(self) -> typing.Optional[UpdateSharedPackageContainerResult]: ...

class SharedPackageContainerManager(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SharedPackageContainerManager: ...
    def create_container(self, name: str, options: typing.Optional[CreateSharedPackageContainerOptions], /) -> typing.Optional[CreateSharedPackageContainerResult]: ...
    def delete_container(self, id: str, options: typing.Optional[DeleteSharedPackageContainerOptions], /) -> typing.Optional[DeleteSharedPackageContainerResult]: ...
    @typing.overload
    def find_containers(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[SharedPackageContainer]]: ...
    @typing.overload
    def find_containers(self, options: typing.Optional[FindSharedPackageContainerOptions], /) -> typing.Optional[winrt.windows.foundation.collections.IVector[SharedPackageContainer]]: ...
    def get_container(self, id: str, /) -> typing.Optional[SharedPackageContainer]: ...
    @staticmethod
    def get_default() -> typing.Optional[SharedPackageContainerManager]: ...
    @staticmethod
    def get_for_provisioning() -> typing.Optional[SharedPackageContainerManager]: ...
    @staticmethod
    def get_for_user(user_sid: str, /) -> typing.Optional[SharedPackageContainerManager]: ...

class SharedPackageContainerMember(winrt.system.Object):
    package_family_name: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SharedPackageContainerMember: ...
    def __new__(cls: typing.Type[SharedPackageContainerMember], package_family_name: str) -> SharedPackageContainerMember:...

class StagePackageOptions(winrt.system.Object):
    target_volume: typing.Optional[PackageVolume]
    stub_package_option: StubPackageOption
    stage_in_place: winrt.system.Boolean
    required_content_group_only: winrt.system.Boolean
    install_all_resources: winrt.system.Boolean
    force_update_from_any_version: winrt.system.Boolean
    external_location_uri: typing.Optional[winrt.windows.foundation.Uri]
    developer_mode: winrt.system.Boolean
    allow_unsigned: winrt.system.Boolean
    dependency_package_uris: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.foundation.Uri]]
    optional_package_family_names: typing.Optional[winrt.windows.foundation.collections.IVector[str]]
    optional_package_uris: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.foundation.Uri]]
    related_package_uris: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.foundation.Uri]]
    expected_digests: typing.Optional[winrt.windows.foundation.collections.IMap[winrt.windows.foundation.Uri, str]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StagePackageOptions: ...
    def __new__(cls: typing.Type[StagePackageOptions]) -> StagePackageOptions:...

class UpdateSharedPackageContainerOptions(winrt.system.Object):
    require_packages_present: winrt.system.Boolean
    force_app_shutdown: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UpdateSharedPackageContainerOptions: ...
    def __new__(cls: typing.Type[UpdateSharedPackageContainerOptions]) -> UpdateSharedPackageContainerOptions:...

class UpdateSharedPackageContainerResult(winrt.system.Object):
    extended_error: winrt.windows.foundation.HResult
    status: SharedPackageContainerOperationStatus
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UpdateSharedPackageContainerResult: ...

