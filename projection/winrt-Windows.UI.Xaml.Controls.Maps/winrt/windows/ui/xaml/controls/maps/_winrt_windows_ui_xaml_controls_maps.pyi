# WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt.system
import winrt.windows.devices.geolocation
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.foundation.numerics
import winrt.windows.services.maps
import winrt.windows.services.maps.localsearch
import winrt.windows.storage.streams
import winrt.windows.ui
import winrt.windows.ui.xaml

from . import MapAnimationKind, MapCameraChangeReason, MapColorScheme, MapElementCollisionBehavior, MapInteractionMode, MapLoadingStatus, MapModel3DShadingOption, MapPanInteractionMode, MapProjection, MapStyle, MapTileAnimationState, MapTileLayer, MapVisibleRegionKind, MapWatermarkMode

Self = typing.TypeVar('Self')

class MapZoomLevelRange:
    min: winrt.system.Double
    max: winrt.system.Double
    def __init__(self, min: winrt.system.Double, max: winrt.system.Double) -> None: ...

class CustomMapTileDataSource(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CustomMapTileDataSource: ...
    def __new__(cls: typing.Type[CustomMapTileDataSource]) -> CustomMapTileDataSource:...
    def add_bitmap_requested(self, handler: winrt.windows.foundation.TypedEventHandler[CustomMapTileDataSource, MapTileBitmapRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_bitmap_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class HttpMapTileDataSource(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HttpMapTileDataSource: ...
    @typing.overload
    def __new__(cls: typing.Type[HttpMapTileDataSource]) -> HttpMapTileDataSource:...
    @typing.overload
    def __new__(cls: typing.Type[HttpMapTileDataSource], uri_format_string: str) -> HttpMapTileDataSource:...
    def add_uri_requested(self, handler: winrt.windows.foundation.TypedEventHandler[HttpMapTileDataSource, MapTileUriRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_uri_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def uri_format_string(self) -> str: ...
    @uri_format_string.setter
    def uri_format_string(self, value: str) -> None: ...
    @_property
    def allow_caching(self) -> bool: ...
    @allow_caching.setter
    def allow_caching(self, value: bool) -> None: ...
    @_property
    def additional_request_headers(self) -> typing.Optional[winrt.windows.foundation.collections.IMap[str, str]]: ...

class LocalMapTileDataSource(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LocalMapTileDataSource: ...
    @typing.overload
    def __new__(cls: typing.Type[LocalMapTileDataSource]) -> LocalMapTileDataSource:...
    @typing.overload
    def __new__(cls: typing.Type[LocalMapTileDataSource], uri_format_string: str) -> LocalMapTileDataSource:...
    def add_uri_requested(self, handler: winrt.windows.foundation.TypedEventHandler[LocalMapTileDataSource, MapTileUriRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_uri_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def uri_format_string(self) -> str: ...
    @uri_format_string.setter
    def uri_format_string(self, value: str) -> None: ...

class MapActualCameraChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapActualCameraChangedEventArgs: ...
    def __new__(cls: typing.Type[MapActualCameraChangedEventArgs]) -> MapActualCameraChangedEventArgs:...
    @_property
    def camera(self) -> typing.Optional[MapCamera]: ...
    @_property
    def change_reason(self) -> MapCameraChangeReason: ...

class MapActualCameraChangingEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapActualCameraChangingEventArgs: ...
    def __new__(cls: typing.Type[MapActualCameraChangingEventArgs]) -> MapActualCameraChangingEventArgs:...
    @_property
    def camera(self) -> typing.Optional[MapCamera]: ...
    @_property
    def change_reason(self) -> MapCameraChangeReason: ...

class MapBillboard(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapBillboard: ...
    def __new__(cls: typing.Type[MapBillboard], camera: typing.Optional[MapCamera]) -> MapBillboard:...
    @_property
    def normalized_anchor_point(self) -> winrt.windows.foundation.Point: ...
    @normalized_anchor_point.setter
    def normalized_anchor_point(self, value: winrt.windows.foundation.Point) -> None: ...
    @_property
    def location(self) -> typing.Optional[winrt.windows.devices.geolocation.Geopoint]: ...
    @location.setter
    def location(self, value: typing.Optional[winrt.windows.devices.geolocation.Geopoint]) -> None: ...
    @_property
    def image(self) -> typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference]: ...
    @image.setter
    def image(self, value: typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference]) -> None: ...
    @_property
    def collision_behavior_desired(self) -> MapElementCollisionBehavior: ...
    @collision_behavior_desired.setter
    def collision_behavior_desired(self, value: MapElementCollisionBehavior) -> None: ...
    @_property
    def reference_camera(self) -> typing.Optional[MapCamera]: ...
    collision_behavior_desired_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    location_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    normalized_anchor_point_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class MapCamera(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapCamera: ...
    @typing.overload
    def __new__(cls: typing.Type[MapCamera], location: typing.Optional[winrt.windows.devices.geolocation.Geopoint]) -> MapCamera:...
    @typing.overload
    def __new__(cls: typing.Type[MapCamera], location: typing.Optional[winrt.windows.devices.geolocation.Geopoint], heading_in_degrees: winrt.system.Double) -> MapCamera:...
    @typing.overload
    def __new__(cls: typing.Type[MapCamera], location: typing.Optional[winrt.windows.devices.geolocation.Geopoint], heading_in_degrees: winrt.system.Double, pitch_in_degrees: winrt.system.Double) -> MapCamera:...
    @typing.overload
    def __new__(cls: typing.Type[MapCamera], location: typing.Optional[winrt.windows.devices.geolocation.Geopoint], heading_in_degrees: winrt.system.Double, pitch_in_degrees: winrt.system.Double, roll_in_degrees: winrt.system.Double, field_of_view_in_degrees: winrt.system.Double) -> MapCamera:...
    @_property
    def roll(self) -> winrt.system.Double: ...
    @roll.setter
    def roll(self, value: winrt.system.Double) -> None: ...
    @_property
    def pitch(self) -> winrt.system.Double: ...
    @pitch.setter
    def pitch(self, value: winrt.system.Double) -> None: ...
    @_property
    def location(self) -> typing.Optional[winrt.windows.devices.geolocation.Geopoint]: ...
    @location.setter
    def location(self, value: typing.Optional[winrt.windows.devices.geolocation.Geopoint]) -> None: ...
    @_property
    def heading(self) -> winrt.system.Double: ...
    @heading.setter
    def heading(self, value: winrt.system.Double) -> None: ...
    @_property
    def field_of_view(self) -> winrt.system.Double: ...
    @field_of_view.setter
    def field_of_view(self, value: winrt.system.Double) -> None: ...

class MapContextRequestedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapContextRequestedEventArgs: ...
    def __new__(cls: typing.Type[MapContextRequestedEventArgs]) -> MapContextRequestedEventArgs:...
    @_property
    def location(self) -> typing.Optional[winrt.windows.devices.geolocation.Geopoint]: ...
    @_property
    def map_elements(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[MapElement]]: ...
    @_property
    def position(self) -> winrt.windows.foundation.Point: ...

class MapControl(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapControl: ...
    def __new__(cls: typing.Type[MapControl]) -> MapControl:...
    @typing.overload
    def find_map_elements_at_offset(self, offset: winrt.windows.foundation.Point, /) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[MapElement]]: ...
    @typing.overload
    def find_map_elements_at_offset(self, offset: winrt.windows.foundation.Point, radius: winrt.system.Double, /) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[MapElement]]: ...
    @staticmethod
    def get_location(element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> typing.Optional[winrt.windows.devices.geolocation.Geopoint]: ...
    @typing.overload
    def get_location_from_offset(self, offset: winrt.windows.foundation.Point, /) -> typing.Optional[winrt.windows.devices.geolocation.Geopoint]: ...
    @typing.overload
    def get_location_from_offset(self, offset: winrt.windows.foundation.Point, desired_reference_system: winrt.windows.devices.geolocation.AltitudeReferenceSystem, /) -> typing.Optional[winrt.windows.devices.geolocation.Geopoint]: ...
    @staticmethod
    def get_normalized_anchor_point(element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> winrt.windows.foundation.Point: ...
    def get_offset_from_location(self, location: typing.Optional[winrt.windows.devices.geolocation.Geopoint], /) -> winrt.windows.foundation.Point: ...
    def get_visible_region(self, region: MapVisibleRegionKind, /) -> typing.Optional[winrt.windows.devices.geolocation.Geopath]: ...
    def is_location_in_view(self, location: typing.Optional[winrt.windows.devices.geolocation.Geopoint], /) -> bool: ...
    @staticmethod
    def set_location(element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], value: typing.Optional[winrt.windows.devices.geolocation.Geopoint], /) -> None: ...
    @staticmethod
    def set_normalized_anchor_point(element: typing.Optional[winrt.windows.ui.xaml.DependencyObject], value: winrt.windows.foundation.Point, /) -> None: ...
    def start_continuous_pan(self, horizontal_pixels_per_second: winrt.system.Double, vertical_pixels_per_second: winrt.system.Double, /) -> None: ...
    def start_continuous_rotate(self, rate_in_degrees_per_second: winrt.system.Double, /) -> None: ...
    def start_continuous_tilt(self, rate_in_degrees_per_second: winrt.system.Double, /) -> None: ...
    def start_continuous_zoom(self, rate_of_change_per_second: winrt.system.Double, /) -> None: ...
    def stop_continuous_pan(self) -> None: ...
    def stop_continuous_rotate(self) -> None: ...
    def stop_continuous_tilt(self) -> None: ...
    def stop_continuous_zoom(self) -> None: ...
    @typing.overload
    def try_get_location_from_offset(self, offset: winrt.windows.foundation.Point, /) -> typing.Tuple[bool, typing.Optional[winrt.windows.devices.geolocation.Geopoint]]: ...
    @typing.overload
    def try_get_location_from_offset(self, offset: winrt.windows.foundation.Point, desired_reference_system: winrt.windows.devices.geolocation.AltitudeReferenceSystem, /) -> typing.Tuple[bool, typing.Optional[winrt.windows.devices.geolocation.Geopoint]]: ...
    def try_pan_async(self, horizontal_pixels: winrt.system.Double, vertical_pixels: winrt.system.Double, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def try_pan_to_async(self, location: typing.Optional[winrt.windows.devices.geolocation.Geopoint], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def try_rotate_async(self, degrees: winrt.system.Double, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def try_rotate_to_async(self, angle_in_degrees: winrt.system.Double, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @typing.overload
    def try_set_scene_async(self, scene: typing.Optional[MapScene], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @typing.overload
    def try_set_scene_async(self, scene: typing.Optional[MapScene], animation_kind: MapAnimationKind, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @typing.overload
    def try_set_view_async(self, center: typing.Optional[winrt.windows.devices.geolocation.Geopoint], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @typing.overload
    def try_set_view_async(self, center: typing.Optional[winrt.windows.devices.geolocation.Geopoint], zoom_level: typing.Optional[winrt.system.Double], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @typing.overload
    def try_set_view_async(self, center: typing.Optional[winrt.windows.devices.geolocation.Geopoint], zoom_level: typing.Optional[winrt.system.Double], heading: typing.Optional[winrt.system.Double], desired_pitch: typing.Optional[winrt.system.Double], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @typing.overload
    def try_set_view_async(self, center: typing.Optional[winrt.windows.devices.geolocation.Geopoint], zoom_level: typing.Optional[winrt.system.Double], heading: typing.Optional[winrt.system.Double], desired_pitch: typing.Optional[winrt.system.Double], animation: MapAnimationKind, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def try_set_view_bounds_async(self, bounds: typing.Optional[winrt.windows.devices.geolocation.GeoboundingBox], margin: typing.Optional[winrt.windows.ui.xaml.Thickness], animation: MapAnimationKind, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def try_tilt_async(self, degrees: winrt.system.Double, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def try_tilt_to_async(self, angle_in_degrees: winrt.system.Double, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def try_zoom_in_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def try_zoom_out_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def try_zoom_to_async(self, zoom_level: winrt.system.Double, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def add_center_changed(self, handler: winrt.windows.foundation.TypedEventHandler[MapControl, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_center_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_heading_changed(self, handler: winrt.windows.foundation.TypedEventHandler[MapControl, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_heading_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_loading_status_changed(self, handler: winrt.windows.foundation.TypedEventHandler[MapControl, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_loading_status_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_map_double_tapped(self, handler: winrt.windows.foundation.TypedEventHandler[MapControl, MapInputEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_map_double_tapped(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_map_holding(self, handler: winrt.windows.foundation.TypedEventHandler[MapControl, MapInputEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_map_holding(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_map_tapped(self, handler: winrt.windows.foundation.TypedEventHandler[MapControl, MapInputEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_map_tapped(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_pitch_changed(self, handler: winrt.windows.foundation.TypedEventHandler[MapControl, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_pitch_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_transform_origin_changed(self, handler: winrt.windows.foundation.TypedEventHandler[MapControl, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_transform_origin_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_zoom_level_changed(self, handler: winrt.windows.foundation.TypedEventHandler[MapControl, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_zoom_level_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_actual_camera_changed(self, handler: winrt.windows.foundation.TypedEventHandler[MapControl, MapActualCameraChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_actual_camera_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_actual_camera_changing(self, handler: winrt.windows.foundation.TypedEventHandler[MapControl, MapActualCameraChangingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_actual_camera_changing(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_custom_experience_changed(self, handler: winrt.windows.foundation.TypedEventHandler[MapControl, MapCustomExperienceChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_custom_experience_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_map_element_click(self, handler: winrt.windows.foundation.TypedEventHandler[MapControl, MapElementClickEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_map_element_click(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_map_element_pointer_entered(self, handler: winrt.windows.foundation.TypedEventHandler[MapControl, MapElementPointerEnteredEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_map_element_pointer_entered(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_map_element_pointer_exited(self, handler: winrt.windows.foundation.TypedEventHandler[MapControl, MapElementPointerExitedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_map_element_pointer_exited(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_target_camera_changed(self, handler: winrt.windows.foundation.TypedEventHandler[MapControl, MapTargetCameraChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_target_camera_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_map_right_tapped(self, handler: winrt.windows.foundation.TypedEventHandler[MapControl, MapRightTappedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_map_right_tapped(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_map_context_requested(self, handler: winrt.windows.foundation.TypedEventHandler[MapControl, MapContextRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_map_context_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def zoom_level(self) -> winrt.system.Double: ...
    @zoom_level.setter
    def zoom_level(self, value: winrt.system.Double) -> None: ...
    @_property
    def watermark_mode(self) -> MapWatermarkMode: ...
    @watermark_mode.setter
    def watermark_mode(self, value: MapWatermarkMode) -> None: ...
    @_property
    def transform_origin(self) -> winrt.windows.foundation.Point: ...
    @transform_origin.setter
    def transform_origin(self, value: winrt.windows.foundation.Point) -> None: ...
    @_property
    def traffic_flow_visible(self) -> bool: ...
    @traffic_flow_visible.setter
    def traffic_flow_visible(self, value: bool) -> None: ...
    @_property
    def style(self) -> MapStyle: ...
    @style.setter
    def style(self, value: MapStyle) -> None: ...
    @_property
    def pedestrian_features_visible(self) -> bool: ...
    @pedestrian_features_visible.setter
    def pedestrian_features_visible(self, value: bool) -> None: ...
    @_property
    def map_service_token(self) -> str: ...
    @map_service_token.setter
    def map_service_token(self, value: str) -> None: ...
    @_property
    def center(self) -> typing.Optional[winrt.windows.devices.geolocation.Geopoint]: ...
    @center.setter
    def center(self, value: typing.Optional[winrt.windows.devices.geolocation.Geopoint]) -> None: ...
    @_property
    def heading(self) -> winrt.system.Double: ...
    @heading.setter
    def heading(self, value: winrt.system.Double) -> None: ...
    @_property
    def desired_pitch(self) -> winrt.system.Double: ...
    @desired_pitch.setter
    def desired_pitch(self, value: winrt.system.Double) -> None: ...
    @_property
    def color_scheme(self) -> MapColorScheme: ...
    @color_scheme.setter
    def color_scheme(self, value: MapColorScheme) -> None: ...
    @_property
    def landmarks_visible(self) -> bool: ...
    @landmarks_visible.setter
    def landmarks_visible(self, value: bool) -> None: ...
    @_property
    def children(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.ui.xaml.DependencyObject]]: ...
    @_property
    def loading_status(self) -> MapLoadingStatus: ...
    @_property
    def map_elements(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[MapElement]]: ...
    @_property
    def max_zoom_level(self) -> winrt.system.Double: ...
    @_property
    def min_zoom_level(self) -> winrt.system.Double: ...
    @_property
    def pitch(self) -> winrt.system.Double: ...
    @_property
    def routes(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[MapRouteView]]: ...
    @_property
    def tile_sources(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[MapTileSource]]: ...
    @_property
    def rotate_interaction_mode(self) -> MapInteractionMode: ...
    @rotate_interaction_mode.setter
    def rotate_interaction_mode(self, value: MapInteractionMode) -> None: ...
    @_property
    def zoom_interaction_mode(self) -> MapInteractionMode: ...
    @zoom_interaction_mode.setter
    def zoom_interaction_mode(self, value: MapInteractionMode) -> None: ...
    @_property
    def transit_features_visible(self) -> bool: ...
    @transit_features_visible.setter
    def transit_features_visible(self, value: bool) -> None: ...
    @_property
    def tilt_interaction_mode(self) -> MapInteractionMode: ...
    @tilt_interaction_mode.setter
    def tilt_interaction_mode(self, value: MapInteractionMode) -> None: ...
    @_property
    def scene(self) -> typing.Optional[MapScene]: ...
    @scene.setter
    def scene(self, value: typing.Optional[MapScene]) -> None: ...
    @_property
    def business_landmarks_visible(self) -> bool: ...
    @business_landmarks_visible.setter
    def business_landmarks_visible(self, value: bool) -> None: ...
    @_property
    def pan_interaction_mode(self) -> MapPanInteractionMode: ...
    @pan_interaction_mode.setter
    def pan_interaction_mode(self, value: MapPanInteractionMode) -> None: ...
    @_property
    def custom_experience(self) -> typing.Optional[MapCustomExperience]: ...
    @custom_experience.setter
    def custom_experience(self, value: typing.Optional[MapCustomExperience]) -> None: ...
    @_property
    def actual_camera(self) -> typing.Optional[MapCamera]: ...
    @_property
    def is3_d_supported(self) -> bool: ...
    @_property
    def is_streetside_supported(self) -> bool: ...
    @_property
    def target_camera(self) -> typing.Optional[MapCamera]: ...
    @_property
    def transit_features_enabled(self) -> bool: ...
    @transit_features_enabled.setter
    def transit_features_enabled(self, value: bool) -> None: ...
    @_property
    def business_landmarks_enabled(self) -> bool: ...
    @business_landmarks_enabled.setter
    def business_landmarks_enabled(self, value: bool) -> None: ...
    @_property
    def view_padding(self) -> winrt.windows.ui.xaml.Thickness: ...
    @view_padding.setter
    def view_padding(self, value: winrt.windows.ui.xaml.Thickness) -> None: ...
    @_property
    def style_sheet(self) -> typing.Optional[MapStyleSheet]: ...
    @style_sheet.setter
    def style_sheet(self, value: typing.Optional[MapStyleSheet]) -> None: ...
    @_property
    def map_projection(self) -> MapProjection: ...
    @map_projection.setter
    def map_projection(self, value: MapProjection) -> None: ...
    @_property
    def layers(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[MapLayer]]: ...
    @layers.setter
    def layers(self, value: typing.Optional[winrt.windows.foundation.collections.IVector[MapLayer]]) -> None: ...
    @_property
    def region(self) -> str: ...
    @region.setter
    def region(self, value: str) -> None: ...
    @_property
    def can_tilt_down(self) -> bool: ...
    @_property
    def can_tilt_up(self) -> bool: ...
    @_property
    def can_zoom_in(self) -> bool: ...
    @_property
    def can_zoom_out(self) -> bool: ...
    center_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    zoom_level_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    children_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    color_scheme_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    desired_pitch_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    heading_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    landmarks_visible_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    loading_status_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    location_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    map_elements_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    map_service_token_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    normalized_anchor_point_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    pedestrian_features_visible_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    pitch_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    routes_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    style_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    tile_sources_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    traffic_flow_visible_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    transform_origin_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    watermark_mode_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    business_landmarks_visible_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is3_d_supported_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_streetside_supported_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    pan_interaction_mode_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    rotate_interaction_mode_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    scene_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    tilt_interaction_mode_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    transit_features_visible_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    zoom_interaction_mode_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    business_landmarks_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    transit_features_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    map_projection_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    style_sheet_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    view_padding_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    layers_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    region_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    can_tilt_up_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    can_zoom_in_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    can_zoom_out_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    can_tilt_down_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class MapControlBusinessLandmarkClickEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapControlBusinessLandmarkClickEventArgs: ...
    def __new__(cls: typing.Type[MapControlBusinessLandmarkClickEventArgs]) -> MapControlBusinessLandmarkClickEventArgs:...
    @_property
    def local_locations(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.services.maps.localsearch.LocalLocation]]: ...

class MapControlBusinessLandmarkPointerEnteredEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapControlBusinessLandmarkPointerEnteredEventArgs: ...
    def __new__(cls: typing.Type[MapControlBusinessLandmarkPointerEnteredEventArgs]) -> MapControlBusinessLandmarkPointerEnteredEventArgs:...
    @_property
    def local_locations(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.services.maps.localsearch.LocalLocation]]: ...

class MapControlBusinessLandmarkPointerExitedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapControlBusinessLandmarkPointerExitedEventArgs: ...
    def __new__(cls: typing.Type[MapControlBusinessLandmarkPointerExitedEventArgs]) -> MapControlBusinessLandmarkPointerExitedEventArgs:...
    @_property
    def local_locations(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.services.maps.localsearch.LocalLocation]]: ...

class MapControlBusinessLandmarkRightTappedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapControlBusinessLandmarkRightTappedEventArgs: ...
    def __new__(cls: typing.Type[MapControlBusinessLandmarkRightTappedEventArgs]) -> MapControlBusinessLandmarkRightTappedEventArgs:...
    @_property
    def local_locations(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.services.maps.localsearch.LocalLocation]]: ...

class MapControlDataHelper(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapControlDataHelper: ...
    def __new__(cls: typing.Type[MapControlDataHelper], map: typing.Optional[MapControl]) -> MapControlDataHelper:...
    @staticmethod
    def create_map_control(raster_render_mode: bool, /) -> typing.Optional[MapControl]: ...
    def add_business_landmark_click(self, value: winrt.windows.foundation.TypedEventHandler[MapControl, MapControlBusinessLandmarkClickEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_business_landmark_click(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_business_landmark_right_tapped(self, value: winrt.windows.foundation.TypedEventHandler[MapControl, MapControlBusinessLandmarkRightTappedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_business_landmark_right_tapped(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_transit_feature_click(self, value: winrt.windows.foundation.TypedEventHandler[MapControl, MapControlTransitFeatureClickEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_transit_feature_click(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_transit_feature_right_tapped(self, value: winrt.windows.foundation.TypedEventHandler[MapControl, MapControlTransitFeatureRightTappedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_transit_feature_right_tapped(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_business_landmark_pointer_entered(self, value: winrt.windows.foundation.TypedEventHandler[MapControl, MapControlBusinessLandmarkPointerEnteredEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_business_landmark_pointer_entered(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_business_landmark_pointer_exited(self, value: winrt.windows.foundation.TypedEventHandler[MapControl, MapControlBusinessLandmarkPointerExitedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_business_landmark_pointer_exited(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_transit_feature_pointer_entered(self, value: winrt.windows.foundation.TypedEventHandler[MapControl, MapControlTransitFeaturePointerEnteredEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_transit_feature_pointer_entered(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_transit_feature_pointer_exited(self, value: winrt.windows.foundation.TypedEventHandler[MapControl, MapControlTransitFeaturePointerExitedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_transit_feature_pointer_exited(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class MapControlTransitFeatureClickEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapControlTransitFeatureClickEventArgs: ...
    def __new__(cls: typing.Type[MapControlTransitFeatureClickEventArgs]) -> MapControlTransitFeatureClickEventArgs:...
    @_property
    def display_name(self) -> str: ...
    @_property
    def location(self) -> typing.Optional[winrt.windows.devices.geolocation.Geopoint]: ...
    @_property
    def transit_properties(self) -> typing.Optional[winrt.windows.foundation.collections.IMapView[str, winrt.system.Object]]: ...

class MapControlTransitFeaturePointerEnteredEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapControlTransitFeaturePointerEnteredEventArgs: ...
    def __new__(cls: typing.Type[MapControlTransitFeaturePointerEnteredEventArgs]) -> MapControlTransitFeaturePointerEnteredEventArgs:...
    @_property
    def display_name(self) -> str: ...
    @_property
    def location(self) -> typing.Optional[winrt.windows.devices.geolocation.Geopoint]: ...
    @_property
    def transit_properties(self) -> typing.Optional[winrt.windows.foundation.collections.IMapView[str, winrt.system.Object]]: ...

class MapControlTransitFeaturePointerExitedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapControlTransitFeaturePointerExitedEventArgs: ...
    def __new__(cls: typing.Type[MapControlTransitFeaturePointerExitedEventArgs]) -> MapControlTransitFeaturePointerExitedEventArgs:...
    @_property
    def display_name(self) -> str: ...
    @_property
    def location(self) -> typing.Optional[winrt.windows.devices.geolocation.Geopoint]: ...
    @_property
    def transit_properties(self) -> typing.Optional[winrt.windows.foundation.collections.IMapView[str, winrt.system.Object]]: ...

class MapControlTransitFeatureRightTappedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapControlTransitFeatureRightTappedEventArgs: ...
    def __new__(cls: typing.Type[MapControlTransitFeatureRightTappedEventArgs]) -> MapControlTransitFeatureRightTappedEventArgs:...
    @_property
    def display_name(self) -> str: ...
    @_property
    def location(self) -> typing.Optional[winrt.windows.devices.geolocation.Geopoint]: ...
    @_property
    def transit_properties(self) -> typing.Optional[winrt.windows.foundation.collections.IMapView[str, winrt.system.Object]]: ...

class MapCustomExperience(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapCustomExperience: ...
    def __new__(cls: typing.Type[MapCustomExperience]) -> MapCustomExperience:...

class MapCustomExperienceChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapCustomExperienceChangedEventArgs: ...
    def __new__(cls: typing.Type[MapCustomExperienceChangedEventArgs]) -> MapCustomExperienceChangedEventArgs:...

class MapElement(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapElement: ...
    def __new__(cls: typing.Type[MapElement]) -> MapElement:...
    @_property
    def z_index(self) -> winrt.system.Int32: ...
    @z_index.setter
    def z_index(self, value: winrt.system.Int32) -> None: ...
    @_property
    def visible(self) -> bool: ...
    @visible.setter
    def visible(self, value: bool) -> None: ...
    @_property
    def map_tab_index(self) -> winrt.system.Int32: ...
    @map_tab_index.setter
    def map_tab_index(self, value: winrt.system.Int32) -> None: ...
    @_property
    def tag(self) -> typing.Optional[winrt.system.Object]: ...
    @tag.setter
    def tag(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def map_style_sheet_entry_state(self) -> str: ...
    @map_style_sheet_entry_state.setter
    def map_style_sheet_entry_state(self, value: str) -> None: ...
    @_property
    def map_style_sheet_entry(self) -> str: ...
    @map_style_sheet_entry.setter
    def map_style_sheet_entry(self, value: str) -> None: ...
    @_property
    def is_enabled(self) -> bool: ...
    @is_enabled.setter
    def is_enabled(self, value: bool) -> None: ...
    visible_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    z_index_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    map_tab_index_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    map_style_sheet_entry_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    map_style_sheet_entry_state_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    tag_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class MapElement3D(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapElement3D: ...
    def __new__(cls: typing.Type[MapElement3D]) -> MapElement3D:...
    @_property
    def scale(self) -> winrt.windows.foundation.numerics.Vector3: ...
    @scale.setter
    def scale(self, value: winrt.windows.foundation.numerics.Vector3) -> None: ...
    @_property
    def roll(self) -> winrt.system.Double: ...
    @roll.setter
    def roll(self, value: winrt.system.Double) -> None: ...
    @_property
    def pitch(self) -> winrt.system.Double: ...
    @pitch.setter
    def pitch(self, value: winrt.system.Double) -> None: ...
    @_property
    def model(self) -> typing.Optional[MapModel3D]: ...
    @model.setter
    def model(self, value: typing.Optional[MapModel3D]) -> None: ...
    @_property
    def location(self) -> typing.Optional[winrt.windows.devices.geolocation.Geopoint]: ...
    @location.setter
    def location(self, value: typing.Optional[winrt.windows.devices.geolocation.Geopoint]) -> None: ...
    @_property
    def heading(self) -> winrt.system.Double: ...
    @heading.setter
    def heading(self, value: winrt.system.Double) -> None: ...
    heading_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    location_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    pitch_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    roll_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    scale_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class MapElementClickEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapElementClickEventArgs: ...
    def __new__(cls: typing.Type[MapElementClickEventArgs]) -> MapElementClickEventArgs:...
    @_property
    def location(self) -> typing.Optional[winrt.windows.devices.geolocation.Geopoint]: ...
    @_property
    def map_elements(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[MapElement]]: ...
    @_property
    def position(self) -> winrt.windows.foundation.Point: ...

class MapElementPointerEnteredEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapElementPointerEnteredEventArgs: ...
    def __new__(cls: typing.Type[MapElementPointerEnteredEventArgs]) -> MapElementPointerEnteredEventArgs:...
    @_property
    def location(self) -> typing.Optional[winrt.windows.devices.geolocation.Geopoint]: ...
    @_property
    def map_element(self) -> typing.Optional[MapElement]: ...
    @_property
    def position(self) -> winrt.windows.foundation.Point: ...

class MapElementPointerExitedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapElementPointerExitedEventArgs: ...
    def __new__(cls: typing.Type[MapElementPointerExitedEventArgs]) -> MapElementPointerExitedEventArgs:...
    @_property
    def location(self) -> typing.Optional[winrt.windows.devices.geolocation.Geopoint]: ...
    @_property
    def map_element(self) -> typing.Optional[MapElement]: ...
    @_property
    def position(self) -> winrt.windows.foundation.Point: ...

class MapElementsLayer(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapElementsLayer: ...
    def __new__(cls: typing.Type[MapElementsLayer]) -> MapElementsLayer:...
    def add_map_context_requested(self, handler: winrt.windows.foundation.TypedEventHandler[MapElementsLayer, MapElementsLayerContextRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_map_context_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_map_element_click(self, handler: winrt.windows.foundation.TypedEventHandler[MapElementsLayer, MapElementsLayerClickEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_map_element_click(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_map_element_pointer_entered(self, handler: winrt.windows.foundation.TypedEventHandler[MapElementsLayer, MapElementsLayerPointerEnteredEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_map_element_pointer_entered(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_map_element_pointer_exited(self, handler: winrt.windows.foundation.TypedEventHandler[MapElementsLayer, MapElementsLayerPointerExitedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_map_element_pointer_exited(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def map_elements(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[MapElement]]: ...
    @map_elements.setter
    def map_elements(self, value: typing.Optional[winrt.windows.foundation.collections.IVector[MapElement]]) -> None: ...
    map_elements_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class MapElementsLayerClickEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapElementsLayerClickEventArgs: ...
    def __new__(cls: typing.Type[MapElementsLayerClickEventArgs]) -> MapElementsLayerClickEventArgs:...
    @_property
    def location(self) -> typing.Optional[winrt.windows.devices.geolocation.Geopoint]: ...
    @_property
    def map_elements(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[MapElement]]: ...
    @_property
    def position(self) -> winrt.windows.foundation.Point: ...

class MapElementsLayerContextRequestedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapElementsLayerContextRequestedEventArgs: ...
    def __new__(cls: typing.Type[MapElementsLayerContextRequestedEventArgs]) -> MapElementsLayerContextRequestedEventArgs:...
    @_property
    def location(self) -> typing.Optional[winrt.windows.devices.geolocation.Geopoint]: ...
    @_property
    def map_elements(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[MapElement]]: ...
    @_property
    def position(self) -> winrt.windows.foundation.Point: ...

class MapElementsLayerPointerEnteredEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapElementsLayerPointerEnteredEventArgs: ...
    def __new__(cls: typing.Type[MapElementsLayerPointerEnteredEventArgs]) -> MapElementsLayerPointerEnteredEventArgs:...
    @_property
    def location(self) -> typing.Optional[winrt.windows.devices.geolocation.Geopoint]: ...
    @_property
    def map_element(self) -> typing.Optional[MapElement]: ...
    @_property
    def position(self) -> winrt.windows.foundation.Point: ...

class MapElementsLayerPointerExitedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapElementsLayerPointerExitedEventArgs: ...
    def __new__(cls: typing.Type[MapElementsLayerPointerExitedEventArgs]) -> MapElementsLayerPointerExitedEventArgs:...
    @_property
    def location(self) -> typing.Optional[winrt.windows.devices.geolocation.Geopoint]: ...
    @_property
    def map_element(self) -> typing.Optional[MapElement]: ...
    @_property
    def position(self) -> winrt.windows.foundation.Point: ...

class MapIcon(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapIcon: ...
    def __new__(cls: typing.Type[MapIcon]) -> MapIcon:...
    @_property
    def title(self) -> str: ...
    @title.setter
    def title(self, value: str) -> None: ...
    @_property
    def normalized_anchor_point(self) -> winrt.windows.foundation.Point: ...
    @normalized_anchor_point.setter
    def normalized_anchor_point(self, value: winrt.windows.foundation.Point) -> None: ...
    @_property
    def location(self) -> typing.Optional[winrt.windows.devices.geolocation.Geopoint]: ...
    @location.setter
    def location(self, value: typing.Optional[winrt.windows.devices.geolocation.Geopoint]) -> None: ...
    @_property
    def image(self) -> typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference]: ...
    @image.setter
    def image(self, value: typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference]) -> None: ...
    @_property
    def collision_behavior_desired(self) -> MapElementCollisionBehavior: ...
    @collision_behavior_desired.setter
    def collision_behavior_desired(self, value: MapElementCollisionBehavior) -> None: ...
    location_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    normalized_anchor_point_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    title_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    collision_behavior_desired_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class MapInputEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapInputEventArgs: ...
    def __new__(cls: typing.Type[MapInputEventArgs]) -> MapInputEventArgs:...
    @_property
    def location(self) -> typing.Optional[winrt.windows.devices.geolocation.Geopoint]: ...
    @_property
    def position(self) -> winrt.windows.foundation.Point: ...

class MapItemsControl(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapItemsControl: ...
    def __new__(cls: typing.Type[MapItemsControl]) -> MapItemsControl:...
    @_property
    def items_source(self) -> typing.Optional[winrt.system.Object]: ...
    @items_source.setter
    def items_source(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def item_template(self) -> typing.Optional[winrt.windows.ui.xaml.DataTemplate]: ...
    @item_template.setter
    def item_template(self, value: typing.Optional[winrt.windows.ui.xaml.DataTemplate]) -> None: ...
    @_property
    def items(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.ui.xaml.DependencyObject]]: ...
    item_template_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    items_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    items_source_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class MapLayer(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapLayer: ...
    def __new__(cls: typing.Type[MapLayer]) -> MapLayer:...
    @_property
    def z_index(self) -> winrt.system.Int32: ...
    @z_index.setter
    def z_index(self, value: winrt.system.Int32) -> None: ...
    @_property
    def visible(self) -> bool: ...
    @visible.setter
    def visible(self, value: bool) -> None: ...
    @_property
    def map_tab_index(self) -> winrt.system.Int32: ...
    @map_tab_index.setter
    def map_tab_index(self, value: winrt.system.Int32) -> None: ...
    map_tab_index_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    visible_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    z_index_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class MapModel3D(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapModel3D: ...
    def __new__(cls: typing.Type[MapModel3D]) -> MapModel3D:...
    @typing.overload
    @staticmethod
    def create_from3_m_f_async(source: typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference], /) -> winrt.windows.foundation.IAsyncOperation[MapModel3D]: ...
    @typing.overload
    @staticmethod
    def create_from3_m_f_async(source: typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference], shading_option: MapModel3DShadingOption, /) -> winrt.windows.foundation.IAsyncOperation[MapModel3D]: ...

class MapPolygon(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapPolygon: ...
    def __new__(cls: typing.Type[MapPolygon]) -> MapPolygon:...
    @_property
    def stroke_thickness(self) -> winrt.system.Double: ...
    @stroke_thickness.setter
    def stroke_thickness(self, value: winrt.system.Double) -> None: ...
    @_property
    def stroke_dashed(self) -> bool: ...
    @stroke_dashed.setter
    def stroke_dashed(self, value: bool) -> None: ...
    @_property
    def stroke_color(self) -> winrt.windows.ui.Color: ...
    @stroke_color.setter
    def stroke_color(self, value: winrt.windows.ui.Color) -> None: ...
    @_property
    def path(self) -> typing.Optional[winrt.windows.devices.geolocation.Geopath]: ...
    @path.setter
    def path(self, value: typing.Optional[winrt.windows.devices.geolocation.Geopath]) -> None: ...
    @_property
    def fill_color(self) -> winrt.windows.ui.Color: ...
    @fill_color.setter
    def fill_color(self, value: winrt.windows.ui.Color) -> None: ...
    @_property
    def paths(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.devices.geolocation.Geopath]]: ...
    path_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    stroke_dashed_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    stroke_thickness_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class MapPolyline(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapPolyline: ...
    def __new__(cls: typing.Type[MapPolyline]) -> MapPolyline:...
    @_property
    def stroke_thickness(self) -> winrt.system.Double: ...
    @stroke_thickness.setter
    def stroke_thickness(self, value: winrt.system.Double) -> None: ...
    @_property
    def stroke_dashed(self) -> bool: ...
    @stroke_dashed.setter
    def stroke_dashed(self, value: bool) -> None: ...
    @_property
    def stroke_color(self) -> winrt.windows.ui.Color: ...
    @stroke_color.setter
    def stroke_color(self, value: winrt.windows.ui.Color) -> None: ...
    @_property
    def path(self) -> typing.Optional[winrt.windows.devices.geolocation.Geopath]: ...
    @path.setter
    def path(self, value: typing.Optional[winrt.windows.devices.geolocation.Geopath]) -> None: ...
    path_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    stroke_dashed_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class MapRightTappedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapRightTappedEventArgs: ...
    def __new__(cls: typing.Type[MapRightTappedEventArgs]) -> MapRightTappedEventArgs:...
    @_property
    def location(self) -> typing.Optional[winrt.windows.devices.geolocation.Geopoint]: ...
    @_property
    def position(self) -> winrt.windows.foundation.Point: ...

class MapRouteView(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapRouteView: ...
    def __new__(cls: typing.Type[MapRouteView], route: typing.Optional[winrt.windows.services.maps.MapRoute]) -> MapRouteView:...
    @_property
    def route_color(self) -> winrt.windows.ui.Color: ...
    @route_color.setter
    def route_color(self, value: winrt.windows.ui.Color) -> None: ...
    @_property
    def outline_color(self) -> winrt.windows.ui.Color: ...
    @outline_color.setter
    def outline_color(self, value: winrt.windows.ui.Color) -> None: ...
    @_property
    def route(self) -> typing.Optional[winrt.windows.services.maps.MapRoute]: ...

class MapScene(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapScene: ...
    @typing.overload
    @staticmethod
    def create_from_bounding_box(bounds: typing.Optional[winrt.windows.devices.geolocation.GeoboundingBox], /) -> typing.Optional[MapScene]: ...
    @typing.overload
    @staticmethod
    def create_from_bounding_box(bounds: typing.Optional[winrt.windows.devices.geolocation.GeoboundingBox], heading_in_degrees: winrt.system.Double, pitch_in_degrees: winrt.system.Double, /) -> typing.Optional[MapScene]: ...
    @staticmethod
    def create_from_camera(camera: typing.Optional[MapCamera], /) -> typing.Optional[MapScene]: ...
    @typing.overload
    @staticmethod
    def create_from_location(location: typing.Optional[winrt.windows.devices.geolocation.Geopoint], /) -> typing.Optional[MapScene]: ...
    @typing.overload
    @staticmethod
    def create_from_location(location: typing.Optional[winrt.windows.devices.geolocation.Geopoint], heading_in_degrees: winrt.system.Double, pitch_in_degrees: winrt.system.Double, /) -> typing.Optional[MapScene]: ...
    @typing.overload
    @staticmethod
    def create_from_location_and_radius(location: typing.Optional[winrt.windows.devices.geolocation.Geopoint], radius_in_meters: winrt.system.Double, /) -> typing.Optional[MapScene]: ...
    @typing.overload
    @staticmethod
    def create_from_location_and_radius(location: typing.Optional[winrt.windows.devices.geolocation.Geopoint], radius_in_meters: winrt.system.Double, heading_in_degrees: winrt.system.Double, pitch_in_degrees: winrt.system.Double, /) -> typing.Optional[MapScene]: ...
    @typing.overload
    @staticmethod
    def create_from_locations(locations: typing.Iterable[winrt.windows.devices.geolocation.Geopoint], /) -> typing.Optional[MapScene]: ...
    @typing.overload
    @staticmethod
    def create_from_locations(locations: typing.Iterable[winrt.windows.devices.geolocation.Geopoint], heading_in_degrees: winrt.system.Double, pitch_in_degrees: winrt.system.Double, /) -> typing.Optional[MapScene]: ...
    def add_target_camera_changed(self, handler: winrt.windows.foundation.TypedEventHandler[MapScene, MapTargetCameraChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_target_camera_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def target_camera(self) -> typing.Optional[MapCamera]: ...

class MapStyleSheet(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapStyleSheet: ...
    @staticmethod
    def aerial() -> typing.Optional[MapStyleSheet]: ...
    @staticmethod
    def aerial_with_overlay() -> typing.Optional[MapStyleSheet]: ...
    @staticmethod
    def combine(style_sheets: typing.Iterable[MapStyleSheet], /) -> typing.Optional[MapStyleSheet]: ...
    @staticmethod
    def parse_from_json(style_as_json: str, /) -> typing.Optional[MapStyleSheet]: ...
    @staticmethod
    def road_dark() -> typing.Optional[MapStyleSheet]: ...
    @staticmethod
    def road_high_contrast_dark() -> typing.Optional[MapStyleSheet]: ...
    @staticmethod
    def road_high_contrast_light() -> typing.Optional[MapStyleSheet]: ...
    @staticmethod
    def road_light() -> typing.Optional[MapStyleSheet]: ...
    @staticmethod
    def try_parse_from_json(style_as_json: str, /) -> typing.Tuple[bool, typing.Optional[MapStyleSheet]]: ...

class MapStyleSheetEntries(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapStyleSheetEntries: ...
    admin_district: typing.ClassVar[str]
    admin_district_capital: typing.ClassVar[str]
    airport: typing.ClassVar[str]
    area: typing.ClassVar[str]
    arterial_road: typing.ClassVar[str]
    building: typing.ClassVar[str]
    business: typing.ClassVar[str]
    capital: typing.ClassVar[str]
    cemetery: typing.ClassVar[str]
    continent: typing.ClassVar[str]
    controlled_access_highway: typing.ClassVar[str]
    country_region: typing.ClassVar[str]
    country_region_capital: typing.ClassVar[str]
    district: typing.ClassVar[str]
    driving_route: typing.ClassVar[str]
    education: typing.ClassVar[str]
    education_building: typing.ClassVar[str]
    food_point: typing.ClassVar[str]
    forest: typing.ClassVar[str]
    golf_course: typing.ClassVar[str]
    high_speed_ramp: typing.ClassVar[str]
    highway: typing.ClassVar[str]
    indigenous_peoples_reserve: typing.ClassVar[str]
    island: typing.ClassVar[str]
    major_road: typing.ClassVar[str]
    medical: typing.ClassVar[str]
    medical_building: typing.ClassVar[str]
    military: typing.ClassVar[str]
    natural_point: typing.ClassVar[str]
    nautical: typing.ClassVar[str]
    neighborhood: typing.ClassVar[str]
    park: typing.ClassVar[str]
    peak: typing.ClassVar[str]
    playing_field: typing.ClassVar[str]
    point: typing.ClassVar[str]
    point_of_interest: typing.ClassVar[str]
    political: typing.ClassVar[str]
    populated_place: typing.ClassVar[str]
    railway: typing.ClassVar[str]
    ramp: typing.ClassVar[str]
    reserve: typing.ClassVar[str]
    river: typing.ClassVar[str]
    road: typing.ClassVar[str]
    road_exit: typing.ClassVar[str]
    road_shield: typing.ClassVar[str]
    route_line: typing.ClassVar[str]
    runway: typing.ClassVar[str]
    sand: typing.ClassVar[str]
    shopping_center: typing.ClassVar[str]
    stadium: typing.ClassVar[str]
    street: typing.ClassVar[str]
    structure: typing.ClassVar[str]
    toll_road: typing.ClassVar[str]
    trail: typing.ClassVar[str]
    transit: typing.ClassVar[str]
    transit_building: typing.ClassVar[str]
    transportation: typing.ClassVar[str]
    unpaved_street: typing.ClassVar[str]
    vegetation: typing.ClassVar[str]
    volcanic_peak: typing.ClassVar[str]
    walking_route: typing.ClassVar[str]
    water: typing.ClassVar[str]
    water_point: typing.ClassVar[str]
    water_route: typing.ClassVar[str]

class MapStyleSheetEntryStates(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapStyleSheetEntryStates: ...
    disabled: typing.ClassVar[str]
    hover: typing.ClassVar[str]
    selected: typing.ClassVar[str]

class MapTargetCameraChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapTargetCameraChangedEventArgs: ...
    def __new__(cls: typing.Type[MapTargetCameraChangedEventArgs]) -> MapTargetCameraChangedEventArgs:...
    @_property
    def camera(self) -> typing.Optional[MapCamera]: ...
    @_property
    def change_reason(self) -> MapCameraChangeReason: ...

class MapTileBitmapRequest(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapTileBitmapRequest: ...
    def __new__(cls: typing.Type[MapTileBitmapRequest]) -> MapTileBitmapRequest:...
    def get_deferral(self) -> typing.Optional[MapTileBitmapRequestDeferral]: ...
    @_property
    def pixel_data(self) -> typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference]: ...
    @pixel_data.setter
    def pixel_data(self, value: typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference]) -> None: ...

class MapTileBitmapRequestDeferral(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapTileBitmapRequestDeferral: ...
    def __new__(cls: typing.Type[MapTileBitmapRequestDeferral]) -> MapTileBitmapRequestDeferral:...
    def complete(self) -> None: ...

class MapTileBitmapRequestedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapTileBitmapRequestedEventArgs: ...
    def __new__(cls: typing.Type[MapTileBitmapRequestedEventArgs]) -> MapTileBitmapRequestedEventArgs:...
    @_property
    def request(self) -> typing.Optional[MapTileBitmapRequest]: ...
    @_property
    def x(self) -> winrt.system.Int32: ...
    @_property
    def y(self) -> winrt.system.Int32: ...
    @_property
    def zoom_level(self) -> winrt.system.Int32: ...
    @_property
    def frame_index(self) -> winrt.system.Int32: ...

class MapTileDataSource(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapTileDataSource: ...
    def __new__(cls: typing.Type[MapTileDataSource]) -> MapTileDataSource:...

class MapTileSource(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapTileSource: ...
    @typing.overload
    def __new__(cls: typing.Type[MapTileSource]) -> MapTileSource:...
    @typing.overload
    def __new__(cls: typing.Type[MapTileSource], data_source: typing.Optional[MapTileDataSource]) -> MapTileSource:...
    @typing.overload
    def __new__(cls: typing.Type[MapTileSource], data_source: typing.Optional[MapTileDataSource], zoom_level_range: MapZoomLevelRange) -> MapTileSource:...
    @typing.overload
    def __new__(cls: typing.Type[MapTileSource], data_source: typing.Optional[MapTileDataSource], zoom_level_range: MapZoomLevelRange, bounds: typing.Optional[winrt.windows.devices.geolocation.GeoboundingBox]) -> MapTileSource:...
    @typing.overload
    def __new__(cls: typing.Type[MapTileSource], data_source: typing.Optional[MapTileDataSource], zoom_level_range: MapZoomLevelRange, bounds: typing.Optional[winrt.windows.devices.geolocation.GeoboundingBox], tile_size_in_pixels: winrt.system.Int32) -> MapTileSource:...
    def pause(self) -> None: ...
    def play(self) -> None: ...
    def stop(self) -> None: ...
    @_property
    def zoom_level_range(self) -> MapZoomLevelRange: ...
    @zoom_level_range.setter
    def zoom_level_range(self, value: MapZoomLevelRange) -> None: ...
    @_property
    def z_index(self) -> winrt.system.Int32: ...
    @z_index.setter
    def z_index(self, value: winrt.system.Int32) -> None: ...
    @_property
    def visible(self) -> bool: ...
    @visible.setter
    def visible(self, value: bool) -> None: ...
    @_property
    def tile_pixel_size(self) -> winrt.system.Int32: ...
    @tile_pixel_size.setter
    def tile_pixel_size(self, value: winrt.system.Int32) -> None: ...
    @_property
    def layer(self) -> MapTileLayer: ...
    @layer.setter
    def layer(self, value: MapTileLayer) -> None: ...
    @_property
    def is_transparency_enabled(self) -> bool: ...
    @is_transparency_enabled.setter
    def is_transparency_enabled(self, value: bool) -> None: ...
    @_property
    def is_retry_enabled(self) -> bool: ...
    @is_retry_enabled.setter
    def is_retry_enabled(self, value: bool) -> None: ...
    @_property
    def is_fading_enabled(self) -> bool: ...
    @is_fading_enabled.setter
    def is_fading_enabled(self, value: bool) -> None: ...
    @_property
    def data_source(self) -> typing.Optional[MapTileDataSource]: ...
    @data_source.setter
    def data_source(self, value: typing.Optional[MapTileDataSource]) -> None: ...
    @_property
    def bounds(self) -> typing.Optional[winrt.windows.devices.geolocation.GeoboundingBox]: ...
    @bounds.setter
    def bounds(self, value: typing.Optional[winrt.windows.devices.geolocation.GeoboundingBox]) -> None: ...
    @_property
    def allow_overstretch(self) -> bool: ...
    @allow_overstretch.setter
    def allow_overstretch(self, value: bool) -> None: ...
    @_property
    def frame_duration(self) -> datetime.timedelta: ...
    @frame_duration.setter
    def frame_duration(self, value: datetime.timedelta) -> None: ...
    @_property
    def frame_count(self) -> winrt.system.Int32: ...
    @frame_count.setter
    def frame_count(self, value: winrt.system.Int32) -> None: ...
    @_property
    def auto_play(self) -> bool: ...
    @auto_play.setter
    def auto_play(self, value: bool) -> None: ...
    @_property
    def animation_state(self) -> MapTileAnimationState: ...
    allow_overstretch_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    bounds_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    data_source_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_fading_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_retry_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_transparency_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    layer_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    tile_pixel_size_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    visible_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    z_index_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    zoom_level_range_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    animation_state_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    auto_play_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    frame_count_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    frame_duration_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class MapTileUriRequest(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapTileUriRequest: ...
    def __new__(cls: typing.Type[MapTileUriRequest]) -> MapTileUriRequest:...
    def get_deferral(self) -> typing.Optional[MapTileUriRequestDeferral]: ...
    @_property
    def uri(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    @uri.setter
    def uri(self, value: typing.Optional[winrt.windows.foundation.Uri]) -> None: ...

class MapTileUriRequestDeferral(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapTileUriRequestDeferral: ...
    def __new__(cls: typing.Type[MapTileUriRequestDeferral]) -> MapTileUriRequestDeferral:...
    def complete(self) -> None: ...

class MapTileUriRequestedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MapTileUriRequestedEventArgs: ...
    def __new__(cls: typing.Type[MapTileUriRequestedEventArgs]) -> MapTileUriRequestedEventArgs:...
    @_property
    def request(self) -> typing.Optional[MapTileUriRequest]: ...
    @_property
    def x(self) -> winrt.system.Int32: ...
    @_property
    def y(self) -> winrt.system.Int32: ...
    @_property
    def zoom_level(self) -> winrt.system.Int32: ...
    @_property
    def frame_index(self) -> winrt.system.Int32: ...

class StreetsideExperience(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StreetsideExperience: ...
    @typing.overload
    def __new__(cls: typing.Type[StreetsideExperience], panorama: typing.Optional[StreetsidePanorama]) -> StreetsideExperience:...
    @typing.overload
    def __new__(cls: typing.Type[StreetsideExperience], panorama: typing.Optional[StreetsidePanorama], heading_in_degrees: winrt.system.Double, pitch_in_degrees: winrt.system.Double, field_of_view_in_degrees: winrt.system.Double) -> StreetsideExperience:...
    @_property
    def zoom_buttons_visible(self) -> bool: ...
    @zoom_buttons_visible.setter
    def zoom_buttons_visible(self, value: bool) -> None: ...
    @_property
    def street_labels_visible(self) -> bool: ...
    @street_labels_visible.setter
    def street_labels_visible(self, value: bool) -> None: ...
    @_property
    def overview_map_visible(self) -> bool: ...
    @overview_map_visible.setter
    def overview_map_visible(self, value: bool) -> None: ...
    @_property
    def exit_button_visible(self) -> bool: ...
    @exit_button_visible.setter
    def exit_button_visible(self, value: bool) -> None: ...
    @_property
    def cursor_visible(self) -> bool: ...
    @cursor_visible.setter
    def cursor_visible(self, value: bool) -> None: ...
    @_property
    def address_text_visible(self) -> bool: ...
    @address_text_visible.setter
    def address_text_visible(self, value: bool) -> None: ...

class StreetsidePanorama(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StreetsidePanorama: ...
    @typing.overload
    @staticmethod
    def find_nearby_async(location: typing.Optional[winrt.windows.devices.geolocation.Geopoint], /) -> winrt.windows.foundation.IAsyncOperation[StreetsidePanorama]: ...
    @typing.overload
    @staticmethod
    def find_nearby_async(location: typing.Optional[winrt.windows.devices.geolocation.Geopoint], radius_in_meters: winrt.system.Double, /) -> winrt.windows.foundation.IAsyncOperation[StreetsidePanorama]: ...
    @_property
    def location(self) -> typing.Optional[winrt.windows.devices.geolocation.Geopoint]: ...

