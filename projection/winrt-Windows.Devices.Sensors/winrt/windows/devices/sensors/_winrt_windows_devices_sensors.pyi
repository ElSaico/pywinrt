# WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

import datetime
import sys
import types
import typing
import uuid

import winrt.system
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.graphics.display

from . import AccelerometerReadingType, ActivitySensorReadingConfidence, ActivityType, HumanEngagement, HumanPresence, MagnetometerAccuracy, PedometerStepKind, SensorOptimizationGoal, SensorReadingType, SensorType, SimpleOrientation

Self = typing.TypeVar('Self')

class Accelerometer(winrt.system.Object):
    report_interval: winrt.system.UInt32
    minimum_report_interval: winrt.system.UInt32
    reading_transform: winrt.windows.graphics.display.DisplayOrientations
    report_latency: winrt.system.UInt32
    max_batch_size: winrt.system.UInt32
    reading_type: AccelerometerReadingType
    report_threshold: typing.Optional[AccelerometerDataThreshold]
    device_id: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Accelerometer: ...
    @staticmethod
    def from_id_async(device_id: str, /) -> winrt.windows.foundation.IAsyncOperation[Accelerometer]: ...
    def get_current_reading(self) -> typing.Optional[AccelerometerReading]: ...
    @typing.overload
    @staticmethod
    def get_default() -> typing.Optional[Accelerometer]: ...
    @typing.overload
    @staticmethod
    def get_default(reading_type: AccelerometerReadingType, /) -> typing.Optional[Accelerometer]: ...
    @staticmethod
    def get_device_selector(reading_type: AccelerometerReadingType, /) -> str: ...
    def add_reading_changed(self, handler: winrt.windows.foundation.TypedEventHandler[Accelerometer, AccelerometerReadingChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_reading_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_shaken(self, handler: winrt.windows.foundation.TypedEventHandler[Accelerometer, AccelerometerShakenEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_shaken(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class AccelerometerDataThreshold(winrt.system.Object):
    z_axis_in_g_force: winrt.system.Double
    y_axis_in_g_force: winrt.system.Double
    x_axis_in_g_force: winrt.system.Double
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AccelerometerDataThreshold: ...

class AccelerometerReading(winrt.system.Object):
    acceleration_x: winrt.system.Double
    acceleration_y: winrt.system.Double
    acceleration_z: winrt.system.Double
    timestamp: datetime.datetime
    performance_count: typing.Optional[typing.Optional[datetime.timedelta]]
    properties: typing.Optional[winrt.windows.foundation.collections.IMapView[str, winrt.system.Object]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AccelerometerReading: ...

class AccelerometerReadingChangedEventArgs(winrt.system.Object):
    reading: typing.Optional[AccelerometerReading]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AccelerometerReadingChangedEventArgs: ...

class AccelerometerShakenEventArgs(winrt.system.Object):
    timestamp: datetime.datetime
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AccelerometerShakenEventArgs: ...

class ActivitySensor(winrt.system.Object):
    device_id: str
    minimum_report_interval: winrt.system.UInt32
    power_in_milliwatts: winrt.system.Double
    subscribed_activities: typing.Optional[winrt.windows.foundation.collections.IVector[ActivityType]]
    supported_activities: typing.Optional[winrt.windows.foundation.collections.IVectorView[ActivityType]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ActivitySensor: ...
    @staticmethod
    def from_id_async(device_id: str, /) -> winrt.windows.foundation.IAsyncOperation[ActivitySensor]: ...
    def get_current_reading_async(self) -> winrt.windows.foundation.IAsyncOperation[ActivitySensorReading]: ...
    @staticmethod
    def get_default_async() -> winrt.windows.foundation.IAsyncOperation[ActivitySensor]: ...
    @staticmethod
    def get_device_selector() -> str: ...
    @typing.overload
    @staticmethod
    def get_system_history_async(from_time: datetime.datetime, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[ActivitySensorReading]]: ...
    @typing.overload
    @staticmethod
    def get_system_history_async(from_time: datetime.datetime, duration: datetime.timedelta, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[ActivitySensorReading]]: ...
    def add_reading_changed(self, handler: winrt.windows.foundation.TypedEventHandler[ActivitySensor, ActivitySensorReadingChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_reading_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class ActivitySensorReading(winrt.system.Object):
    activity: ActivityType
    confidence: ActivitySensorReadingConfidence
    timestamp: datetime.datetime
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ActivitySensorReading: ...

class ActivitySensorReadingChangeReport(winrt.system.Object):
    reading: typing.Optional[ActivitySensorReading]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ActivitySensorReadingChangeReport: ...

class ActivitySensorReadingChangedEventArgs(winrt.system.Object):
    reading: typing.Optional[ActivitySensorReading]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ActivitySensorReadingChangedEventArgs: ...

class ActivitySensorTriggerDetails(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ActivitySensorTriggerDetails: ...
    def read_reports(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[ActivitySensorReadingChangeReport]]: ...

class AdaptiveDimmingOptions(winrt.system.Object):
    allow_when_external_display_connected: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AdaptiveDimmingOptions: ...

class Altimeter(winrt.system.Object):
    report_interval: winrt.system.UInt32
    device_id: str
    minimum_report_interval: winrt.system.UInt32
    report_latency: winrt.system.UInt32
    max_batch_size: winrt.system.UInt32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Altimeter: ...
    def get_current_reading(self) -> typing.Optional[AltimeterReading]: ...
    @staticmethod
    def get_default() -> typing.Optional[Altimeter]: ...
    def add_reading_changed(self, handler: winrt.windows.foundation.TypedEventHandler[Altimeter, AltimeterReadingChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_reading_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class AltimeterReading(winrt.system.Object):
    altitude_change_in_meters: winrt.system.Double
    timestamp: datetime.datetime
    performance_count: typing.Optional[typing.Optional[datetime.timedelta]]
    properties: typing.Optional[winrt.windows.foundation.collections.IMapView[str, winrt.system.Object]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AltimeterReading: ...

class AltimeterReadingChangedEventArgs(winrt.system.Object):
    reading: typing.Optional[AltimeterReading]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AltimeterReadingChangedEventArgs: ...

class Barometer(winrt.system.Object):
    report_interval: winrt.system.UInt32
    device_id: str
    minimum_report_interval: winrt.system.UInt32
    report_latency: winrt.system.UInt32
    max_batch_size: winrt.system.UInt32
    report_threshold: typing.Optional[BarometerDataThreshold]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Barometer: ...
    @staticmethod
    def from_id_async(device_id: str, /) -> winrt.windows.foundation.IAsyncOperation[Barometer]: ...
    def get_current_reading(self) -> typing.Optional[BarometerReading]: ...
    @staticmethod
    def get_default() -> typing.Optional[Barometer]: ...
    @staticmethod
    def get_device_selector() -> str: ...
    def add_reading_changed(self, handler: winrt.windows.foundation.TypedEventHandler[Barometer, BarometerReadingChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_reading_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class BarometerDataThreshold(winrt.system.Object):
    hectopascals: winrt.system.Double
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BarometerDataThreshold: ...

class BarometerReading(winrt.system.Object):
    station_pressure_in_hectopascals: winrt.system.Double
    timestamp: datetime.datetime
    performance_count: typing.Optional[typing.Optional[datetime.timedelta]]
    properties: typing.Optional[winrt.windows.foundation.collections.IMapView[str, winrt.system.Object]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BarometerReading: ...

class BarometerReadingChangedEventArgs(winrt.system.Object):
    reading: typing.Optional[BarometerReading]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BarometerReadingChangedEventArgs: ...

class Compass(winrt.system.Object):
    report_interval: winrt.system.UInt32
    minimum_report_interval: winrt.system.UInt32
    reading_transform: winrt.windows.graphics.display.DisplayOrientations
    report_latency: winrt.system.UInt32
    max_batch_size: winrt.system.UInt32
    report_threshold: typing.Optional[CompassDataThreshold]
    device_id: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Compass: ...
    @staticmethod
    def from_id_async(device_id: str, /) -> winrt.windows.foundation.IAsyncOperation[Compass]: ...
    def get_current_reading(self) -> typing.Optional[CompassReading]: ...
    @staticmethod
    def get_default() -> typing.Optional[Compass]: ...
    @staticmethod
    def get_device_selector() -> str: ...
    def add_reading_changed(self, handler: winrt.windows.foundation.TypedEventHandler[Compass, CompassReadingChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_reading_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class CompassDataThreshold(winrt.system.Object):
    degrees: winrt.system.Double
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompassDataThreshold: ...

class CompassReading(winrt.system.Object):
    heading_magnetic_north: winrt.system.Double
    heading_true_north: typing.Optional[typing.Optional[winrt.system.Double]]
    timestamp: datetime.datetime
    performance_count: typing.Optional[typing.Optional[datetime.timedelta]]
    properties: typing.Optional[winrt.windows.foundation.collections.IMapView[str, winrt.system.Object]]
    heading_accuracy: MagnetometerAccuracy
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompassReading: ...

class CompassReadingChangedEventArgs(winrt.system.Object):
    reading: typing.Optional[CompassReading]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompassReadingChangedEventArgs: ...

class Gyrometer(winrt.system.Object):
    report_interval: winrt.system.UInt32
    minimum_report_interval: winrt.system.UInt32
    reading_transform: winrt.windows.graphics.display.DisplayOrientations
    report_latency: winrt.system.UInt32
    max_batch_size: winrt.system.UInt32
    report_threshold: typing.Optional[GyrometerDataThreshold]
    device_id: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Gyrometer: ...
    @staticmethod
    def from_id_async(device_id: str, /) -> winrt.windows.foundation.IAsyncOperation[Gyrometer]: ...
    def get_current_reading(self) -> typing.Optional[GyrometerReading]: ...
    @staticmethod
    def get_default() -> typing.Optional[Gyrometer]: ...
    @staticmethod
    def get_device_selector() -> str: ...
    def add_reading_changed(self, handler: winrt.windows.foundation.TypedEventHandler[Gyrometer, GyrometerReadingChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_reading_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class GyrometerDataThreshold(winrt.system.Object):
    z_axis_in_degrees_per_second: winrt.system.Double
    y_axis_in_degrees_per_second: winrt.system.Double
    x_axis_in_degrees_per_second: winrt.system.Double
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GyrometerDataThreshold: ...

class GyrometerReading(winrt.system.Object):
    angular_velocity_x: winrt.system.Double
    angular_velocity_y: winrt.system.Double
    angular_velocity_z: winrt.system.Double
    timestamp: datetime.datetime
    performance_count: typing.Optional[typing.Optional[datetime.timedelta]]
    properties: typing.Optional[winrt.windows.foundation.collections.IMapView[str, winrt.system.Object]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GyrometerReading: ...

class GyrometerReadingChangedEventArgs(winrt.system.Object):
    reading: typing.Optional[GyrometerReading]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GyrometerReadingChangedEventArgs: ...

class HingeAngleReading(winrt.system.Object):
    angle_in_degrees: winrt.system.Double
    properties: typing.Optional[winrt.windows.foundation.collections.IMapView[str, winrt.system.Object]]
    timestamp: datetime.datetime
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HingeAngleReading: ...

class HingeAngleSensor(winrt.system.Object):
    report_threshold_in_degrees: winrt.system.Double
    device_id: str
    min_report_threshold_in_degrees: winrt.system.Double
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HingeAngleSensor: ...
    @staticmethod
    def from_id_async(device_id: str, /) -> winrt.windows.foundation.IAsyncOperation[HingeAngleSensor]: ...
    def get_current_reading_async(self) -> winrt.windows.foundation.IAsyncOperation[HingeAngleReading]: ...
    @staticmethod
    def get_default_async() -> winrt.windows.foundation.IAsyncOperation[HingeAngleSensor]: ...
    @staticmethod
    def get_device_selector() -> str: ...
    @staticmethod
    def get_related_to_adjacent_panels_async(first_panel_id: str, second_panel_id: str, /) -> winrt.windows.foundation.IAsyncOperation[HingeAngleSensor]: ...
    def add_reading_changed(self, handler: winrt.windows.foundation.TypedEventHandler[HingeAngleSensor, HingeAngleSensorReadingChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_reading_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class HingeAngleSensorReadingChangedEventArgs(winrt.system.Object):
    reading: typing.Optional[HingeAngleReading]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HingeAngleSensorReadingChangedEventArgs: ...

class HumanPresenceFeatures(winrt.system.Object):
    is_attention_aware_dimming_supported: winrt.system.Boolean
    is_lock_on_leave_supported: winrt.system.Boolean
    is_wake_on_approach_supported: winrt.system.Boolean
    sensor_id: str
    supported_wake_or_lock_distances_in_millimeters: typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]
    is_adaptive_dimming_supported: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HumanPresenceFeatures: ...

class HumanPresenceSensor(winrt.system.Object):
    device_id: str
    max_detectable_distance_in_millimeters: typing.Optional[typing.Optional[winrt.system.UInt32]]
    min_detectable_distance_in_millimeters: typing.Optional[typing.Optional[winrt.system.UInt32]]
    is_engagement_supported: winrt.system.Boolean
    is_presence_supported: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HumanPresenceSensor: ...
    @staticmethod
    def from_id(sensor_id: str, /) -> typing.Optional[HumanPresenceSensor]: ...
    @staticmethod
    def from_id_async(sensor_id: str, /) -> winrt.windows.foundation.IAsyncOperation[HumanPresenceSensor]: ...
    def get_current_reading(self) -> typing.Optional[HumanPresenceSensorReading]: ...
    @staticmethod
    def get_default() -> typing.Optional[HumanPresenceSensor]: ...
    @staticmethod
    def get_default_async() -> winrt.windows.foundation.IAsyncOperation[HumanPresenceSensor]: ...
    @staticmethod
    def get_device_selector() -> str: ...
    def add_reading_changed(self, handler: winrt.windows.foundation.TypedEventHandler[HumanPresenceSensor, HumanPresenceSensorReadingChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_reading_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class HumanPresenceSensorReading(winrt.system.Object):
    distance_in_millimeters: typing.Optional[typing.Optional[winrt.system.UInt32]]
    engagement: HumanEngagement
    presence: HumanPresence
    timestamp: datetime.datetime
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HumanPresenceSensorReading: ...

class HumanPresenceSensorReadingChangedEventArgs(winrt.system.Object):
    reading: typing.Optional[HumanPresenceSensorReading]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HumanPresenceSensorReadingChangedEventArgs: ...

class HumanPresenceSettings(winrt.system.Object):
    wake_on_approach_distance_in_millimeters: typing.Optional[typing.Optional[winrt.system.UInt32]]
    sensor_id: str
    lock_on_leave_timeout: datetime.timedelta
    lock_on_leave_distance_in_millimeters: typing.Optional[typing.Optional[winrt.system.UInt32]]
    is_wake_on_approach_enabled: winrt.system.Boolean
    is_lock_on_leave_enabled: winrt.system.Boolean
    is_attention_aware_dimming_enabled: winrt.system.Boolean
    is_adaptive_dimming_enabled: winrt.system.Boolean
    dimming_options: typing.Optional[AdaptiveDimmingOptions]
    lock_options: typing.Optional[LockOnLeaveOptions]
    wake_options: typing.Optional[WakeOnApproachOptions]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HumanPresenceSettings: ...
    @staticmethod
    def get_current_settings() -> typing.Optional[HumanPresenceSettings]: ...
    @staticmethod
    def get_current_settings_async() -> winrt.windows.foundation.IAsyncOperation[HumanPresenceSettings]: ...
    @staticmethod
    def get_supported_features_for_sensor_id(sensor_id: str, /) -> typing.Optional[HumanPresenceFeatures]: ...
    @staticmethod
    def get_supported_features_for_sensor_id_async(sensor_id: str, /) -> winrt.windows.foundation.IAsyncOperation[HumanPresenceFeatures]: ...
    @staticmethod
    def get_supported_lock_on_leave_timeouts() -> typing.Optional[winrt.windows.foundation.collections.IVectorView[datetime.timedelta]]: ...
    @staticmethod
    def update_settings(settings: typing.Optional[HumanPresenceSettings], /) -> None: ...
    @staticmethod
    def update_settings_async(settings: typing.Optional[HumanPresenceSettings], /) -> winrt.windows.foundation.IAsyncAction: ...
    @staticmethod
    def add_settings_changed(handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    @staticmethod
    def remove_settings_changed(token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class Inclinometer(winrt.system.Object):
    report_interval: winrt.system.UInt32
    minimum_report_interval: winrt.system.UInt32
    reading_transform: winrt.windows.graphics.display.DisplayOrientations
    reading_type: SensorReadingType
    report_latency: winrt.system.UInt32
    max_batch_size: winrt.system.UInt32
    report_threshold: typing.Optional[InclinometerDataThreshold]
    device_id: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Inclinometer: ...
    @staticmethod
    def from_id_async(device_id: str, /) -> winrt.windows.foundation.IAsyncOperation[Inclinometer]: ...
    def get_current_reading(self) -> typing.Optional[InclinometerReading]: ...
    @typing.overload
    @staticmethod
    def get_default() -> typing.Optional[Inclinometer]: ...
    @typing.overload
    @staticmethod
    def get_default(sensor_readingtype: SensorReadingType, /) -> typing.Optional[Inclinometer]: ...
    @staticmethod
    def get_default_for_relative_readings() -> typing.Optional[Inclinometer]: ...
    @staticmethod
    def get_device_selector(reading_type: SensorReadingType, /) -> str: ...
    def add_reading_changed(self, handler: winrt.windows.foundation.TypedEventHandler[Inclinometer, InclinometerReadingChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_reading_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class InclinometerDataThreshold(winrt.system.Object):
    yaw_in_degrees: winrt.system.Single
    roll_in_degrees: winrt.system.Single
    pitch_in_degrees: winrt.system.Single
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InclinometerDataThreshold: ...

class InclinometerReading(winrt.system.Object):
    pitch_degrees: winrt.system.Single
    roll_degrees: winrt.system.Single
    timestamp: datetime.datetime
    yaw_degrees: winrt.system.Single
    performance_count: typing.Optional[typing.Optional[datetime.timedelta]]
    properties: typing.Optional[winrt.windows.foundation.collections.IMapView[str, winrt.system.Object]]
    yaw_accuracy: MagnetometerAccuracy
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InclinometerReading: ...

class InclinometerReadingChangedEventArgs(winrt.system.Object):
    reading: typing.Optional[InclinometerReading]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InclinometerReadingChangedEventArgs: ...

class LightSensor(winrt.system.Object):
    report_interval: winrt.system.UInt32
    minimum_report_interval: winrt.system.UInt32
    report_latency: winrt.system.UInt32
    max_batch_size: winrt.system.UInt32
    report_threshold: typing.Optional[LightSensorDataThreshold]
    device_id: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LightSensor: ...
    @staticmethod
    def from_id_async(device_id: str, /) -> winrt.windows.foundation.IAsyncOperation[LightSensor]: ...
    def get_current_reading(self) -> typing.Optional[LightSensorReading]: ...
    @staticmethod
    def get_default() -> typing.Optional[LightSensor]: ...
    @staticmethod
    def get_device_selector() -> str: ...
    def add_reading_changed(self, handler: winrt.windows.foundation.TypedEventHandler[LightSensor, LightSensorReadingChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_reading_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class LightSensorDataThreshold(winrt.system.Object):
    lux_percentage: winrt.system.Single
    absolute_lux: winrt.system.Single
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LightSensorDataThreshold: ...

class LightSensorReading(winrt.system.Object):
    illuminance_in_lux: winrt.system.Single
    timestamp: datetime.datetime
    performance_count: typing.Optional[typing.Optional[datetime.timedelta]]
    properties: typing.Optional[winrt.windows.foundation.collections.IMapView[str, winrt.system.Object]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LightSensorReading: ...

class LightSensorReadingChangedEventArgs(winrt.system.Object):
    reading: typing.Optional[LightSensorReading]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LightSensorReadingChangedEventArgs: ...

class LockOnLeaveOptions(winrt.system.Object):
    allow_when_external_display_connected: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LockOnLeaveOptions: ...

class Magnetometer(winrt.system.Object):
    report_interval: winrt.system.UInt32
    minimum_report_interval: winrt.system.UInt32
    reading_transform: winrt.windows.graphics.display.DisplayOrientations
    report_latency: winrt.system.UInt32
    max_batch_size: winrt.system.UInt32
    report_threshold: typing.Optional[MagnetometerDataThreshold]
    device_id: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Magnetometer: ...
    @staticmethod
    def from_id_async(device_id: str, /) -> winrt.windows.foundation.IAsyncOperation[Magnetometer]: ...
    def get_current_reading(self) -> typing.Optional[MagnetometerReading]: ...
    @staticmethod
    def get_default() -> typing.Optional[Magnetometer]: ...
    @staticmethod
    def get_device_selector() -> str: ...
    def add_reading_changed(self, handler: winrt.windows.foundation.TypedEventHandler[Magnetometer, MagnetometerReadingChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_reading_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class MagnetometerDataThreshold(winrt.system.Object):
    z_axis_microteslas: winrt.system.Single
    y_axis_microteslas: winrt.system.Single
    x_axis_microteslas: winrt.system.Single
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MagnetometerDataThreshold: ...

class MagnetometerReading(winrt.system.Object):
    directional_accuracy: MagnetometerAccuracy
    magnetic_field_x: winrt.system.Single
    magnetic_field_y: winrt.system.Single
    magnetic_field_z: winrt.system.Single
    timestamp: datetime.datetime
    performance_count: typing.Optional[typing.Optional[datetime.timedelta]]
    properties: typing.Optional[winrt.windows.foundation.collections.IMapView[str, winrt.system.Object]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MagnetometerReading: ...

class MagnetometerReadingChangedEventArgs(winrt.system.Object):
    reading: typing.Optional[MagnetometerReading]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MagnetometerReadingChangedEventArgs: ...

class OrientationSensor(winrt.system.Object):
    report_interval: winrt.system.UInt32
    minimum_report_interval: winrt.system.UInt32
    reading_transform: winrt.windows.graphics.display.DisplayOrientations
    reading_type: SensorReadingType
    report_latency: winrt.system.UInt32
    max_batch_size: winrt.system.UInt32
    device_id: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> OrientationSensor: ...
    @staticmethod
    def from_id_async(device_id: str, /) -> winrt.windows.foundation.IAsyncOperation[OrientationSensor]: ...
    def get_current_reading(self) -> typing.Optional[OrientationSensorReading]: ...
    @typing.overload
    @staticmethod
    def get_default() -> typing.Optional[OrientationSensor]: ...
    @typing.overload
    @staticmethod
    def get_default(sensor_readingtype: SensorReadingType, /) -> typing.Optional[OrientationSensor]: ...
    @typing.overload
    @staticmethod
    def get_default(sensor_reading_type: SensorReadingType, optimization_goal: SensorOptimizationGoal, /) -> typing.Optional[OrientationSensor]: ...
    @staticmethod
    def get_default_for_relative_readings() -> typing.Optional[OrientationSensor]: ...
    @typing.overload
    @staticmethod
    def get_device_selector(reading_type: SensorReadingType, /) -> str: ...
    @typing.overload
    @staticmethod
    def get_device_selector(reading_type: SensorReadingType, optimization_goal: SensorOptimizationGoal, /) -> str: ...
    def add_reading_changed(self, handler: winrt.windows.foundation.TypedEventHandler[OrientationSensor, OrientationSensorReadingChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_reading_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class OrientationSensorReading(winrt.system.Object):
    quaternion: typing.Optional[SensorQuaternion]
    rotation_matrix: typing.Optional[SensorRotationMatrix]
    timestamp: datetime.datetime
    performance_count: typing.Optional[typing.Optional[datetime.timedelta]]
    properties: typing.Optional[winrt.windows.foundation.collections.IMapView[str, winrt.system.Object]]
    yaw_accuracy: MagnetometerAccuracy
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> OrientationSensorReading: ...

class OrientationSensorReadingChangedEventArgs(winrt.system.Object):
    reading: typing.Optional[OrientationSensorReading]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> OrientationSensorReadingChangedEventArgs: ...

class Pedometer(winrt.system.Object):
    report_interval: winrt.system.UInt32
    device_id: str
    minimum_report_interval: winrt.system.UInt32
    power_in_milliwatts: winrt.system.Double
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Pedometer: ...
    @staticmethod
    def from_id_async(device_id: str, /) -> winrt.windows.foundation.IAsyncOperation[Pedometer]: ...
    def get_current_readings(self) -> typing.Optional[winrt.windows.foundation.collections.IMapView[PedometerStepKind, PedometerReading]]: ...
    @staticmethod
    def get_default_async() -> winrt.windows.foundation.IAsyncOperation[Pedometer]: ...
    @staticmethod
    def get_device_selector() -> str: ...
    @staticmethod
    def get_readings_from_trigger_details(trigger_details: typing.Optional[SensorDataThresholdTriggerDetails], /) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[PedometerReading]]: ...
    @typing.overload
    @staticmethod
    def get_system_history_async(from_time: datetime.datetime, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[PedometerReading]]: ...
    @typing.overload
    @staticmethod
    def get_system_history_async(from_time: datetime.datetime, duration: datetime.timedelta, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[PedometerReading]]: ...
    def add_reading_changed(self, handler: winrt.windows.foundation.TypedEventHandler[Pedometer, PedometerReadingChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_reading_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class PedometerDataThreshold(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PedometerDataThreshold: ...
    def __new__(cls: typing.Type[PedometerDataThreshold], sensor: typing.Optional[Pedometer], step_goal: winrt.system.Int32) -> PedometerDataThreshold:...

class PedometerReading(winrt.system.Object):
    cumulative_steps: winrt.system.Int32
    cumulative_steps_duration: datetime.timedelta
    step_kind: PedometerStepKind
    timestamp: datetime.datetime
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PedometerReading: ...

class PedometerReadingChangedEventArgs(winrt.system.Object):
    reading: typing.Optional[PedometerReading]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PedometerReadingChangedEventArgs: ...

class ProximitySensor(winrt.system.Object):
    device_id: str
    max_distance_in_millimeters: typing.Optional[typing.Optional[winrt.system.UInt32]]
    min_distance_in_millimeters: typing.Optional[typing.Optional[winrt.system.UInt32]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProximitySensor: ...
    def create_display_on_off_controller(self) -> typing.Optional[ProximitySensorDisplayOnOffController]: ...
    @staticmethod
    def from_id(sensor_id: str, /) -> typing.Optional[ProximitySensor]: ...
    def get_current_reading(self) -> typing.Optional[ProximitySensorReading]: ...
    @staticmethod
    def get_device_selector() -> str: ...
    @staticmethod
    def get_readings_from_trigger_details(trigger_details: typing.Optional[SensorDataThresholdTriggerDetails], /) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[ProximitySensorReading]]: ...
    def add_reading_changed(self, handler: winrt.windows.foundation.TypedEventHandler[ProximitySensor, ProximitySensorReadingChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_reading_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class ProximitySensorDataThreshold(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProximitySensorDataThreshold: ...
    def __new__(cls: typing.Type[ProximitySensorDataThreshold], sensor: typing.Optional[ProximitySensor]) -> ProximitySensorDataThreshold:...

class ProximitySensorDisplayOnOffController(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProximitySensorDisplayOnOffController: ...
    def close(self) -> None: ...

class ProximitySensorReading(winrt.system.Object):
    distance_in_millimeters: typing.Optional[typing.Optional[winrt.system.UInt32]]
    is_detected: winrt.system.Boolean
    timestamp: datetime.datetime
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProximitySensorReading: ...

class ProximitySensorReadingChangedEventArgs(winrt.system.Object):
    reading: typing.Optional[ProximitySensorReading]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProximitySensorReadingChangedEventArgs: ...

class SensorDataThresholdTriggerDetails(winrt.system.Object):
    device_id: str
    sensor_type: SensorType
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SensorDataThresholdTriggerDetails: ...

class SensorQuaternion(winrt.system.Object):
    w: winrt.system.Single
    x: winrt.system.Single
    y: winrt.system.Single
    z: winrt.system.Single
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SensorQuaternion: ...

class SensorRotationMatrix(winrt.system.Object):
    m11: winrt.system.Single
    m12: winrt.system.Single
    m13: winrt.system.Single
    m21: winrt.system.Single
    m22: winrt.system.Single
    m23: winrt.system.Single
    m31: winrt.system.Single
    m32: winrt.system.Single
    m33: winrt.system.Single
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SensorRotationMatrix: ...

class SimpleOrientationSensor(winrt.system.Object):
    reading_transform: winrt.windows.graphics.display.DisplayOrientations
    device_id: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SimpleOrientationSensor: ...
    @staticmethod
    def from_id_async(device_id: str, /) -> winrt.windows.foundation.IAsyncOperation[SimpleOrientationSensor]: ...
    def get_current_orientation(self) -> SimpleOrientation: ...
    @staticmethod
    def get_default() -> typing.Optional[SimpleOrientationSensor]: ...
    @staticmethod
    def get_device_selector() -> str: ...
    def add_orientation_changed(self, handler: winrt.windows.foundation.TypedEventHandler[SimpleOrientationSensor, SimpleOrientationSensorOrientationChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_orientation_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class SimpleOrientationSensorOrientationChangedEventArgs(winrt.system.Object):
    orientation: SimpleOrientation
    timestamp: datetime.datetime
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SimpleOrientationSensorOrientationChangedEventArgs: ...

class WakeOnApproachOptions(winrt.system.Object):
    disable_when_battery_saver_on: winrt.system.Boolean
    allow_when_external_display_connected: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WakeOnApproachOptions: ...

class ISensorDataThreshold(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ISensorDataThreshold: ...

