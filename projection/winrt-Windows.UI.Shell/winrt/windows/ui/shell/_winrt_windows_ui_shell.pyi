# WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

import datetime
import sys
import types
import typing
import uuid

import winrt.system
import winrt.windows.applicationmodel.core
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.graphics.imaging
import winrt.windows.storage.streams
import winrt.windows.ui
import winrt.windows.ui.startscreen

from . import SecurityAppKind, SecurityAppState, SecurityAppSubstatus, ShareWindowCommand

Self = typing.TypeVar('Self')

class AdaptiveCardBuilder(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AdaptiveCardBuilder: ...
    @staticmethod
    def create_adaptive_card_from_json(value: str, /) -> typing.Optional[IAdaptiveCard]: ...

class FocusSession(winrt.system.Object):
    id: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FocusSession: ...
    def end(self) -> None: ...

class FocusSessionManager(winrt.system.Object):
    is_focus_active: bool
    is_supported: typing.ClassVar[bool]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FocusSessionManager: ...
    def deactivate_focus(self) -> None: ...
    @staticmethod
    def get_default() -> typing.Optional[FocusSessionManager]: ...
    def get_session(self, id: str, /) -> typing.Optional[FocusSession]: ...
    @typing.overload
    def try_start_focus_session(self) -> typing.Optional[FocusSession]: ...
    @typing.overload
    def try_start_focus_session(self, end_time: datetime.datetime, /) -> typing.Optional[FocusSession]: ...
    def add_is_focus_active_changed(self, handler: winrt.windows.foundation.TypedEventHandler[FocusSessionManager, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_is_focus_active_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class SecurityAppManager(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SecurityAppManager: ...
    def __new__(cls: typing.Type[SecurityAppManager]) -> SecurityAppManager:...
    def register(self, kind: SecurityAppKind, display_name: str, details_uri: typing.Optional[winrt.windows.foundation.Uri], register_per_user: bool, /) -> uuid.UUID: ...
    def unregister(self, kind: SecurityAppKind, guid_registration: uuid.UUID, /) -> None: ...
    def update_state(self, kind: SecurityAppKind, guid_registration: uuid.UUID, state: SecurityAppState, substatus: SecurityAppSubstatus, details_uri: typing.Optional[winrt.windows.foundation.Uri], /) -> None: ...

class ShareWindowCommandEventArgs(winrt.system.Object):
    command: ShareWindowCommand
    window_id: winrt.windows.ui.WindowId
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ShareWindowCommandEventArgs: ...

class ShareWindowCommandSource(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ShareWindowCommandSource: ...
    @staticmethod
    def get_for_current_view() -> typing.Optional[ShareWindowCommandSource]: ...
    def report_command_changed(self) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def add_command_invoked(self, handler: winrt.windows.foundation.TypedEventHandler[ShareWindowCommandSource, ShareWindowCommandEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_command_invoked(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_command_requested(self, handler: winrt.windows.foundation.TypedEventHandler[ShareWindowCommandSource, ShareWindowCommandEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_command_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class TaskbarManager(winrt.system.Object):
    is_pinning_allowed: bool
    is_supported: bool
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TaskbarManager: ...
    @staticmethod
    def get_default() -> typing.Optional[TaskbarManager]: ...
    def is_app_list_entry_pinned_async(self, app_list_entry: typing.Optional[winrt.windows.applicationmodel.core.AppListEntry], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def is_current_app_pinned_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def is_secondary_tile_pinned_async(self, tile_id: str, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def request_pin_app_list_entry_async(self, app_list_entry: typing.Optional[winrt.windows.applicationmodel.core.AppListEntry], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def request_pin_current_app_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def request_pin_secondary_tile_async(self, secondary_tile: typing.Optional[winrt.windows.ui.startscreen.SecondaryTile], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def try_unpin_secondary_tile_async(self, tile_id: str, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...

class WindowTab(winrt.system.Object):
    treat_as_secondary_tile_id: str
    title: str
    tag: typing.Optional[winrt.system.Object]
    icon: typing.Optional[WindowTabIcon]
    group: typing.Optional[WindowTabGroup]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WindowTab: ...
    def __new__(cls: typing.Type[WindowTab]) -> WindowTab:...
    def report_thumbnail_available(self) -> None: ...

class WindowTabCloseRequestedEventArgs(winrt.system.Object):
    tab: typing.Optional[WindowTab]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WindowTabCloseRequestedEventArgs: ...

class WindowTabCollection(winrt.system.Object, typing.MutableSequence[WindowTab]):
    size: winrt.system.UInt32
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> WindowTab: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[WindowTab]: ...
    def insert(self, index: int, value: WindowTab) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: WindowTab) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[WindowTab]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WindowTabCollection: ...
    def append(self, value: typing.Optional[WindowTab], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[WindowTab]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[WindowTab]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[WindowTab], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[WindowTab]]: ...
    def index_of(self, value: typing.Optional[WindowTab], /) -> typing.Tuple[bool, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[WindowTab], /) -> None: ...
    def move_tab(self, tab: typing.Optional[WindowTab], index: winrt.system.UInt32, /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[WindowTab], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[WindowTab], /) -> None: ...

class WindowTabGroup(winrt.system.Object):
    title: str
    icon: typing.Optional[WindowTabIcon]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WindowTabGroup: ...
    def __new__(cls: typing.Type[WindowTabGroup]) -> WindowTabGroup:...

class WindowTabIcon(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WindowTabIcon: ...
    @typing.overload
    @staticmethod
    def create_from_font_glyph(glyph: str, font_family: str, /) -> typing.Optional[WindowTabIcon]: ...
    @typing.overload
    @staticmethod
    def create_from_font_glyph(glyph: str, font_family: str, font_uri: typing.Optional[winrt.windows.foundation.Uri], /) -> typing.Optional[WindowTabIcon]: ...
    @staticmethod
    def create_from_image(image: typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference], /) -> typing.Optional[WindowTabIcon]: ...

class WindowTabManager(winrt.system.Object):
    tabs: typing.Optional[WindowTabCollection]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WindowTabManager: ...
    @staticmethod
    def get_for_window(id: winrt.windows.ui.WindowId, /) -> typing.Optional[WindowTabManager]: ...
    @staticmethod
    def is_supported() -> bool: ...
    @staticmethod
    def is_tab_tear_out_supported() -> bool: ...
    def set_active_tab(self, tab: typing.Optional[WindowTab], /) -> None: ...
    def add_tab_close_requested(self, handler: winrt.windows.foundation.TypedEventHandler[WindowTabManager, WindowTabCloseRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_tab_close_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_tab_switch_requested(self, handler: winrt.windows.foundation.TypedEventHandler[WindowTabManager, WindowTabSwitchRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_tab_switch_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_tab_tear_out_requested(self, handler: winrt.windows.foundation.TypedEventHandler[WindowTabManager, WindowTabTearOutRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_tab_tear_out_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_tab_thumbnail_requested(self, handler: winrt.windows.foundation.TypedEventHandler[WindowTabManager, WindowTabThumbnailRequestedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_tab_thumbnail_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class WindowTabSwitchRequestedEventArgs(winrt.system.Object):
    tab: typing.Optional[WindowTab]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WindowTabSwitchRequestedEventArgs: ...

class WindowTabTearOutRequestedEventArgs(winrt.system.Object):
    window_id: winrt.system.UInt64
    tab: typing.Optional[WindowTab]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WindowTabTearOutRequestedEventArgs: ...
    def get_deferral(self) -> typing.Optional[winrt.windows.foundation.Deferral]: ...

class WindowTabThumbnailRequestedEventArgs(winrt.system.Object):
    image: typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference]
    is_composited_on_window: bool
    requested_size: winrt.windows.graphics.imaging.BitmapSize
    tab: typing.Optional[WindowTab]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WindowTabThumbnailRequestedEventArgs: ...
    def get_deferral(self) -> typing.Optional[winrt.windows.foundation.Deferral]: ...

class IAdaptiveCard(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IAdaptiveCard: ...
    def to_json(self) -> str: ...

class IAdaptiveCardBuilderStatics(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IAdaptiveCardBuilderStatics: ...
    def create_adaptive_card_from_json(self, value: str, /) -> typing.Optional[IAdaptiveCard]: ...

