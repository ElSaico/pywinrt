# WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

import datetime
import sys
import types
import typing

import winrt.system
import winrt.windows.devices.enumeration
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.media.capture
import winrt.windows.media.devices.core
import winrt.windows.media.mediaproperties
import winrt.windows.storage.streams

from . import AdvancedPhotoMode, AudioDeviceRole, AutoFocusRange, CameraOcclusionKind, CameraStreamState, CaptureSceneMode, CaptureUse, ColorTemperaturePreset, DigitalWindowMode, FocusMode, FocusPreset, HdrVideoMode, InfraredTorchMode, IsoSpeedPreset, ManualFocusDistance, MediaCaptureFocusState, MediaCaptureOptimization, MediaCapturePauseBehavior, OpticalImageStabilizationMode, RegionOfInterestType, SendCommandStatus, TelephonyKey, VideoDeviceControllerGetDevicePropertyStatus, VideoDeviceControllerSetDevicePropertyStatus, VideoTemporalDenoisingMode, ZoomTransitionMode
from . import CallControlEventHandler, DialRequestedEventHandler, KeypadPressedEventHandler, RedialRequestedEventHandler

Self = typing.TypeVar('Self')

class AdvancedPhotoCaptureSettings(winrt.system.Object):
    mode: AdvancedPhotoMode
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AdvancedPhotoCaptureSettings: ...
    def __new__(cls: typing.Type[AdvancedPhotoCaptureSettings]) -> AdvancedPhotoCaptureSettings:...

class AdvancedPhotoControl(winrt.system.Object):
    mode: AdvancedPhotoMode
    supported: winrt.system.Boolean
    supported_modes: typing.Optional[winrt.windows.foundation.collections.IVectorView[AdvancedPhotoMode]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AdvancedPhotoControl: ...
    def configure(self, settings: typing.Optional[AdvancedPhotoCaptureSettings], /) -> None: ...

class AudioDeviceController(winrt.system.Object):
    volume_percent: winrt.system.Single
    muted: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AudioDeviceController: ...
    def get_available_media_stream_properties(self, media_stream_type: winrt.windows.media.capture.MediaStreamType, /) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.media.mediaproperties.IMediaEncodingProperties]]: ...
    def get_media_stream_properties(self, media_stream_type: winrt.windows.media.capture.MediaStreamType, /) -> typing.Optional[winrt.windows.media.mediaproperties.IMediaEncodingProperties]: ...
    def set_media_stream_properties_async(self, media_stream_type: winrt.windows.media.capture.MediaStreamType, media_encoding_properties: typing.Optional[winrt.windows.media.mediaproperties.IMediaEncodingProperties], /) -> winrt.windows.foundation.IAsyncAction: ...

class AudioDeviceModule(winrt.system.Object):
    class_id: str
    display_name: str
    instance_id: winrt.system.UInt32
    major_version: winrt.system.UInt32
    minor_version: winrt.system.UInt32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AudioDeviceModule: ...
    def send_command_async(self, command: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> winrt.windows.foundation.IAsyncOperation[ModuleCommandResult]: ...

class AudioDeviceModuleNotificationEventArgs(winrt.system.Object):
    module: typing.Optional[AudioDeviceModule]
    notification_data: typing.Optional[winrt.windows.storage.streams.IBuffer]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AudioDeviceModuleNotificationEventArgs: ...

class AudioDeviceModulesManager(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AudioDeviceModulesManager: ...
    def __new__(cls: typing.Type[AudioDeviceModulesManager], device_id: str) -> AudioDeviceModulesManager:...
    def find_all(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[AudioDeviceModule]]: ...
    def find_all_by_id(self, module_id: str, /) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[AudioDeviceModule]]: ...
    def add_module_notification_received(self, handler: winrt.windows.foundation.TypedEventHandler[AudioDeviceModulesManager, AudioDeviceModuleNotificationEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_module_notification_received(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class CallControl(winrt.system.Object):
    has_ringer: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CallControl: ...
    def end_call(self, call_token: winrt.system.UInt64, /) -> None: ...
    @staticmethod
    def from_id(device_id: str, /) -> typing.Optional[CallControl]: ...
    @staticmethod
    def get_default() -> typing.Optional[CallControl]: ...
    def indicate_active_call(self, call_token: winrt.system.UInt64, /) -> None: ...
    def indicate_new_incoming_call(self, enable_ringer: winrt.system.Boolean, caller_id: str, /) -> winrt.system.UInt64: ...
    def indicate_new_outgoing_call(self) -> winrt.system.UInt64: ...
    def add_answer_requested(self, handler: typing.Optional[CallControlEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_answer_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_audio_transfer_requested(self, handler: typing.Optional[CallControlEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_audio_transfer_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_dial_requested(self, handler: typing.Optional[DialRequestedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_dial_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_hang_up_requested(self, handler: typing.Optional[CallControlEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_hang_up_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_keypad_pressed(self, handler: typing.Optional[KeypadPressedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_keypad_pressed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_redial_requested(self, handler: typing.Optional[RedialRequestedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_redial_requested(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class CameraOcclusionInfo(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CameraOcclusionInfo: ...
    def get_state(self) -> typing.Optional[CameraOcclusionState]: ...
    def is_occlusion_kind_supported(self, occlusion_kind: CameraOcclusionKind, /) -> winrt.system.Boolean: ...
    def add_state_changed(self, handler: winrt.windows.foundation.TypedEventHandler[CameraOcclusionInfo, CameraOcclusionStateChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_state_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class CameraOcclusionState(winrt.system.Object):
    is_occluded: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CameraOcclusionState: ...
    def is_occlusion_kind(self, occlusion_kind: CameraOcclusionKind, /) -> winrt.system.Boolean: ...

class CameraOcclusionStateChangedEventArgs(winrt.system.Object):
    state: typing.Optional[CameraOcclusionState]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CameraOcclusionStateChangedEventArgs: ...

class DefaultAudioCaptureDeviceChangedEventArgs(winrt.system.Object):
    id: str
    role: AudioDeviceRole
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DefaultAudioCaptureDeviceChangedEventArgs: ...

class DefaultAudioRenderDeviceChangedEventArgs(winrt.system.Object):
    id: str
    role: AudioDeviceRole
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DefaultAudioRenderDeviceChangedEventArgs: ...

class DialRequestedEventArgs(winrt.system.Object):
    contact: typing.Optional[winrt.system.Object]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DialRequestedEventArgs: ...
    def handled(self) -> None: ...

class DigitalWindowBounds(winrt.system.Object):
    scale: winrt.system.Double
    normalized_origin_top: winrt.system.Double
    normalized_origin_left: winrt.system.Double
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DigitalWindowBounds: ...
    def __new__(cls: typing.Type[DigitalWindowBounds]) -> DigitalWindowBounds:...

class DigitalWindowCapability(winrt.system.Object):
    height: winrt.system.Int32
    max_scale_value: winrt.system.Double
    min_scale_value: winrt.system.Double
    min_scale_value_without_upsampling: winrt.system.Double
    normalized_field_of_view_limit: winrt.windows.foundation.Rect
    width: winrt.system.Int32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DigitalWindowCapability: ...

class DigitalWindowControl(winrt.system.Object):
    current_mode: DigitalWindowMode
    is_supported: winrt.system.Boolean
    supported_capabilities: typing.Optional[winrt.windows.foundation.collections.IVectorView[DigitalWindowCapability]]
    supported_modes: DigitalWindowMode
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DigitalWindowControl: ...
    @typing.overload
    def configure(self, digital_window_mode: DigitalWindowMode, /) -> None: ...
    @typing.overload
    def configure(self, digital_window_mode: DigitalWindowMode, digital_window_bounds: typing.Optional[DigitalWindowBounds], /) -> None: ...
    def get_bounds(self) -> typing.Optional[DigitalWindowBounds]: ...
    def get_capability_for_size(self, width: winrt.system.Int32, height: winrt.system.Int32, /) -> typing.Optional[DigitalWindowCapability]: ...

class ExposureCompensationControl(winrt.system.Object):
    max: winrt.system.Single
    min: winrt.system.Single
    step: winrt.system.Single
    supported: winrt.system.Boolean
    value: winrt.system.Single
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ExposureCompensationControl: ...
    def set_value_async(self, value: winrt.system.Single, /) -> winrt.windows.foundation.IAsyncAction: ...

class ExposureControl(winrt.system.Object):
    auto: winrt.system.Boolean
    max: datetime.timedelta
    min: datetime.timedelta
    step: datetime.timedelta
    supported: winrt.system.Boolean
    value: datetime.timedelta
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ExposureControl: ...
    def set_auto_async(self, value: winrt.system.Boolean, /) -> winrt.windows.foundation.IAsyncAction: ...
    def set_value_async(self, shutter_duration: datetime.timedelta, /) -> winrt.windows.foundation.IAsyncAction: ...

class ExposurePriorityVideoControl(winrt.system.Object):
    enabled: winrt.system.Boolean
    supported: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ExposurePriorityVideoControl: ...

class FlashControl(winrt.system.Object):
    red_eye_reduction: winrt.system.Boolean
    power_percent: winrt.system.Single
    enabled: winrt.system.Boolean
    auto: winrt.system.Boolean
    power_supported: winrt.system.Boolean
    red_eye_reduction_supported: winrt.system.Boolean
    supported: winrt.system.Boolean
    assistant_light_enabled: winrt.system.Boolean
    assistant_light_supported: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FlashControl: ...

class FocusControl(winrt.system.Object):
    max: winrt.system.UInt32
    min: winrt.system.UInt32
    preset: FocusPreset
    step: winrt.system.UInt32
    supported: winrt.system.Boolean
    supported_presets: typing.Optional[winrt.windows.foundation.collections.IVectorView[FocusPreset]]
    value: winrt.system.UInt32
    focus_changed_supported: winrt.system.Boolean
    focus_state: MediaCaptureFocusState
    mode: FocusMode
    supported_focus_distances: typing.Optional[winrt.windows.foundation.collections.IVectorView[ManualFocusDistance]]
    supported_focus_modes: typing.Optional[winrt.windows.foundation.collections.IVectorView[FocusMode]]
    supported_focus_ranges: typing.Optional[winrt.windows.foundation.collections.IVectorView[AutoFocusRange]]
    wait_for_focus_supported: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FocusControl: ...
    def configure(self, settings: typing.Optional[FocusSettings], /) -> None: ...
    def focus_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def lock_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def set_preset_async(self, preset: FocusPreset, /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def set_preset_async(self, preset: FocusPreset, complete_before_focus: winrt.system.Boolean, /) -> winrt.windows.foundation.IAsyncAction: ...
    def set_value_async(self, focus: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncAction: ...
    def unlock_async(self) -> winrt.windows.foundation.IAsyncAction: ...

class FocusSettings(winrt.system.Object):
    wait_for_focus: winrt.system.Boolean
    value: typing.Optional[typing.Optional[winrt.system.UInt32]]
    mode: FocusMode
    distance: typing.Optional[typing.Optional[ManualFocusDistance]]
    disable_driver_fallback: winrt.system.Boolean
    auto_focus_range: AutoFocusRange
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FocusSettings: ...
    def __new__(cls: typing.Type[FocusSettings]) -> FocusSettings:...

class HdrVideoControl(winrt.system.Object):
    mode: HdrVideoMode
    supported: winrt.system.Boolean
    supported_modes: typing.Optional[winrt.windows.foundation.collections.IVectorView[HdrVideoMode]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HdrVideoControl: ...

class InfraredTorchControl(winrt.system.Object):
    power: winrt.system.Int32
    current_mode: InfraredTorchMode
    is_supported: winrt.system.Boolean
    max_power: winrt.system.Int32
    min_power: winrt.system.Int32
    power_step: winrt.system.Int32
    supported_modes: typing.Optional[winrt.windows.foundation.collections.IVectorView[InfraredTorchMode]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InfraredTorchControl: ...

class IsoSpeedControl(winrt.system.Object):
    preset: IsoSpeedPreset
    supported: winrt.system.Boolean
    supported_presets: typing.Optional[winrt.windows.foundation.collections.IVectorView[IsoSpeedPreset]]
    auto: winrt.system.Boolean
    max: winrt.system.UInt32
    min: winrt.system.UInt32
    step: winrt.system.UInt32
    value: winrt.system.UInt32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IsoSpeedControl: ...
    def set_auto_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def set_preset_async(self, preset: IsoSpeedPreset, /) -> winrt.windows.foundation.IAsyncAction: ...
    def set_value_async(self, iso_speed: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncAction: ...

class KeypadPressedEventArgs(winrt.system.Object):
    telephony_key: TelephonyKey
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> KeypadPressedEventArgs: ...

class LowLagPhotoControl(winrt.system.Object):
    thumbnail_format: winrt.windows.media.mediaproperties.MediaThumbnailFormat
    thumbnail_enabled: winrt.system.Boolean
    desired_thumbnail_size: winrt.system.UInt32
    hardware_accelerated_thumbnail_supported: winrt.system.UInt32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LowLagPhotoControl: ...
    def get_current_frame_rate(self) -> typing.Optional[winrt.windows.media.mediaproperties.MediaRatio]: ...
    def get_highest_concurrent_frame_rate(self, capture_properties: typing.Optional[winrt.windows.media.mediaproperties.IMediaEncodingProperties], /) -> typing.Optional[winrt.windows.media.mediaproperties.MediaRatio]: ...

class LowLagPhotoSequenceControl(winrt.system.Object):
    thumbnail_format: winrt.windows.media.mediaproperties.MediaThumbnailFormat
    thumbnail_enabled: winrt.system.Boolean
    photos_per_second_limit: winrt.system.Single
    past_photo_limit: winrt.system.UInt32
    desired_thumbnail_size: winrt.system.UInt32
    hardware_accelerated_thumbnail_supported: winrt.system.UInt32
    max_past_photos: winrt.system.UInt32
    max_photos_per_second: winrt.system.Single
    supported: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LowLagPhotoSequenceControl: ...
    def get_current_frame_rate(self) -> typing.Optional[winrt.windows.media.mediaproperties.MediaRatio]: ...
    def get_highest_concurrent_frame_rate(self, capture_properties: typing.Optional[winrt.windows.media.mediaproperties.IMediaEncodingProperties], /) -> typing.Optional[winrt.windows.media.mediaproperties.MediaRatio]: ...

class MediaDevice(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaDevice: ...
    @staticmethod
    def get_audio_capture_selector() -> str: ...
    @staticmethod
    def get_audio_render_selector() -> str: ...
    @staticmethod
    def get_default_audio_capture_id(role: AudioDeviceRole, /) -> str: ...
    @staticmethod
    def get_default_audio_render_id(role: AudioDeviceRole, /) -> str: ...
    @staticmethod
    def get_video_capture_selector() -> str: ...
    @staticmethod
    def add_default_audio_capture_device_changed(handler: winrt.windows.foundation.TypedEventHandler[winrt.system.Object, DefaultAudioCaptureDeviceChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    @staticmethod
    def remove_default_audio_capture_device_changed(cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @staticmethod
    def add_default_audio_render_device_changed(handler: winrt.windows.foundation.TypedEventHandler[winrt.system.Object, DefaultAudioRenderDeviceChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    @staticmethod
    def remove_default_audio_render_device_changed(cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class MediaDeviceControl(winrt.system.Object):
    capabilities: typing.Optional[MediaDeviceControlCapabilities]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaDeviceControl: ...
    def try_get_auto(self) -> typing.Tuple[winrt.system.Boolean, winrt.system.Boolean]: ...
    def try_get_value(self) -> typing.Tuple[winrt.system.Boolean, winrt.system.Double]: ...
    def try_set_auto(self, value: winrt.system.Boolean, /) -> winrt.system.Boolean: ...
    def try_set_value(self, value: winrt.system.Double, /) -> winrt.system.Boolean: ...

class MediaDeviceControlCapabilities(winrt.system.Object):
    auto_mode_supported: winrt.system.Boolean
    default: winrt.system.Double
    max: winrt.system.Double
    min: winrt.system.Double
    step: winrt.system.Double
    supported: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaDeviceControlCapabilities: ...

class ModuleCommandResult(winrt.system.Object):
    result: typing.Optional[winrt.windows.storage.streams.IBuffer]
    status: SendCommandStatus
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ModuleCommandResult: ...

class OpticalImageStabilizationControl(winrt.system.Object):
    mode: OpticalImageStabilizationMode
    supported: winrt.system.Boolean
    supported_modes: typing.Optional[winrt.windows.foundation.collections.IVectorView[OpticalImageStabilizationMode]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> OpticalImageStabilizationControl: ...

class PanelBasedOptimizationControl(winrt.system.Object):
    panel: winrt.windows.devices.enumeration.Panel
    is_supported: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PanelBasedOptimizationControl: ...

class PhotoConfirmationControl(winrt.system.Object):
    pixel_format: winrt.windows.media.mediaproperties.MediaPixelFormat
    enabled: winrt.system.Boolean
    supported: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PhotoConfirmationControl: ...

class RedialRequestedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RedialRequestedEventArgs: ...
    def handled(self) -> None: ...

class RegionOfInterest(winrt.system.Object):
    bounds: winrt.windows.foundation.Rect
    auto_white_balance_enabled: winrt.system.Boolean
    auto_focus_enabled: winrt.system.Boolean
    auto_exposure_enabled: winrt.system.Boolean
    weight: winrt.system.UInt32
    type: RegionOfInterestType
    bounds_normalized: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RegionOfInterest: ...
    def __new__(cls: typing.Type[RegionOfInterest]) -> RegionOfInterest:...

class RegionsOfInterestControl(winrt.system.Object):
    auto_exposure_supported: winrt.system.Boolean
    auto_focus_supported: winrt.system.Boolean
    auto_white_balance_supported: winrt.system.Boolean
    max_regions: winrt.system.UInt32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RegionsOfInterestControl: ...
    def clear_regions_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def set_regions_async(self, regions: typing.Iterable[RegionOfInterest], /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def set_regions_async(self, regions: typing.Iterable[RegionOfInterest], lock_values: winrt.system.Boolean, /) -> winrt.windows.foundation.IAsyncAction: ...

class SceneModeControl(winrt.system.Object):
    supported_modes: typing.Optional[winrt.windows.foundation.collections.IVectorView[CaptureSceneMode]]
    value: CaptureSceneMode
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SceneModeControl: ...
    def set_value_async(self, scene_mode: CaptureSceneMode, /) -> winrt.windows.foundation.IAsyncAction: ...

class TorchControl(winrt.system.Object):
    power_percent: winrt.system.Single
    enabled: winrt.system.Boolean
    power_supported: winrt.system.Boolean
    supported: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TorchControl: ...

class VideoDeviceController(winrt.system.Object):
    camera_occlusion_info: typing.Optional[CameraOcclusionInfo]
    primary_use: CaptureUse
    focus_control: typing.Optional[FocusControl]
    iso_speed_control: typing.Optional[IsoSpeedControl]
    low_lag_photo: typing.Optional[LowLagPhotoControl]
    white_balance_control: typing.Optional[WhiteBalanceControl]
    torch_control: typing.Optional[TorchControl]
    scene_mode_control: typing.Optional[SceneModeControl]
    regions_of_interest_control: typing.Optional[RegionsOfInterestControl]
    flash_control: typing.Optional[FlashControl]
    low_lag_photo_sequence: typing.Optional[LowLagPhotoSequenceControl]
    exposure_compensation_control: typing.Optional[ExposureCompensationControl]
    exposure_control: typing.Optional[ExposureControl]
    zoom_control: typing.Optional[ZoomControl]
    photo_confirmation_control: typing.Optional[PhotoConfirmationControl]
    variable_photo_sequence_controller: typing.Optional[winrt.windows.media.devices.core.VariablePhotoSequenceController]
    desired_optimization: MediaCaptureOptimization
    advanced_photo_control: typing.Optional[AdvancedPhotoControl]
    exposure_priority_video_control: typing.Optional[ExposurePriorityVideoControl]
    hdr_video_control: typing.Optional[HdrVideoControl]
    optical_image_stabilization_control: typing.Optional[OpticalImageStabilizationControl]
    id: str
    video_temporal_denoising_control: typing.Optional[VideoTemporalDenoisingControl]
    infrared_torch_control: typing.Optional[InfraredTorchControl]
    panel_based_optimization_control: typing.Optional[PanelBasedOptimizationControl]
    digital_window_control: typing.Optional[DigitalWindowControl]
    zoom: typing.Optional[MediaDeviceControl]
    contrast: typing.Optional[MediaDeviceControl]
    backlight_compensation: typing.Optional[MediaDeviceControl]
    white_balance: typing.Optional[MediaDeviceControl]
    brightness: typing.Optional[MediaDeviceControl]
    exposure: typing.Optional[MediaDeviceControl]
    tilt: typing.Optional[MediaDeviceControl]
    roll: typing.Optional[MediaDeviceControl]
    hue: typing.Optional[MediaDeviceControl]
    pan: typing.Optional[MediaDeviceControl]
    focus: typing.Optional[MediaDeviceControl]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VideoDeviceController: ...
    def get_available_media_stream_properties(self, media_stream_type: winrt.windows.media.capture.MediaStreamType, /) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.media.mediaproperties.IMediaEncodingProperties]]: ...
    def get_device_property(self, property_id: str, /) -> typing.Optional[winrt.system.Object]: ...
    def get_device_property_by_extended_id(self, extended_property_id: winrt.system.Array[winrt.system.UInt8], max_property_value_size: typing.Optional[winrt.system.UInt32], /) -> typing.Optional[VideoDeviceControllerGetDevicePropertyResult]: ...
    def get_device_property_by_id(self, property_id: str, max_property_value_size: typing.Optional[winrt.system.UInt32], /) -> typing.Optional[VideoDeviceControllerGetDevicePropertyResult]: ...
    def get_media_stream_properties(self, media_stream_type: winrt.windows.media.capture.MediaStreamType, /) -> typing.Optional[winrt.windows.media.mediaproperties.IMediaEncodingProperties]: ...
    def set_device_property(self, property_id: str, property_value: typing.Optional[winrt.system.Object], /) -> None: ...
    def set_device_property_by_extended_id(self, extended_property_id: winrt.system.Array[winrt.system.UInt8], property_value: winrt.system.Array[winrt.system.UInt8], /) -> VideoDeviceControllerSetDevicePropertyStatus: ...
    def set_device_property_by_id(self, property_id: str, property_value: typing.Optional[winrt.system.Object], /) -> VideoDeviceControllerSetDevicePropertyStatus: ...
    def set_media_stream_properties_async(self, media_stream_type: winrt.windows.media.capture.MediaStreamType, media_encoding_properties: typing.Optional[winrt.windows.media.mediaproperties.IMediaEncodingProperties], /) -> winrt.windows.foundation.IAsyncAction: ...
    def try_acquire_exclusive_control(self, device_id: str, mode: winrt.windows.media.capture.MediaCaptureDeviceExclusiveControlReleaseMode, /) -> winrt.system.Boolean: ...
    def try_get_powerline_frequency(self) -> typing.Tuple[winrt.system.Boolean, winrt.windows.media.capture.PowerlineFrequency]: ...
    def try_set_powerline_frequency(self, value: winrt.windows.media.capture.PowerlineFrequency, /) -> winrt.system.Boolean: ...

class VideoDeviceControllerGetDevicePropertyResult(winrt.system.Object):
    status: VideoDeviceControllerGetDevicePropertyStatus
    value: typing.Optional[winrt.system.Object]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VideoDeviceControllerGetDevicePropertyResult: ...

class VideoTemporalDenoisingControl(winrt.system.Object):
    mode: VideoTemporalDenoisingMode
    supported: winrt.system.Boolean
    supported_modes: typing.Optional[winrt.windows.foundation.collections.IVectorView[VideoTemporalDenoisingMode]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VideoTemporalDenoisingControl: ...

class WhiteBalanceControl(winrt.system.Object):
    max: winrt.system.UInt32
    min: winrt.system.UInt32
    preset: ColorTemperaturePreset
    step: winrt.system.UInt32
    supported: winrt.system.Boolean
    value: winrt.system.UInt32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WhiteBalanceControl: ...
    def set_preset_async(self, preset: ColorTemperaturePreset, /) -> winrt.windows.foundation.IAsyncAction: ...
    def set_value_async(self, temperature: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncAction: ...

class ZoomControl(winrt.system.Object):
    value: winrt.system.Single
    max: winrt.system.Single
    min: winrt.system.Single
    step: winrt.system.Single
    supported: winrt.system.Boolean
    mode: ZoomTransitionMode
    supported_modes: typing.Optional[winrt.windows.foundation.collections.IVectorView[ZoomTransitionMode]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ZoomControl: ...
    def configure(self, settings: typing.Optional[ZoomSettings], /) -> None: ...

class ZoomSettings(winrt.system.Object):
    value: winrt.system.Single
    mode: ZoomTransitionMode
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ZoomSettings: ...
    def __new__(cls: typing.Type[ZoomSettings]) -> ZoomSettings:...

class IDefaultAudioDeviceChangedEventArgs(winrt.system.Object):
    id: str
    role: AudioDeviceRole
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IDefaultAudioDeviceChangedEventArgs: ...

class IMediaDeviceController(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IMediaDeviceController: ...
    def get_available_media_stream_properties(self, media_stream_type: winrt.windows.media.capture.MediaStreamType, /) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.media.mediaproperties.IMediaEncodingProperties]]: ...
    def get_media_stream_properties(self, media_stream_type: winrt.windows.media.capture.MediaStreamType, /) -> typing.Optional[winrt.windows.media.mediaproperties.IMediaEncodingProperties]: ...
    def set_media_stream_properties_async(self, media_stream_type: winrt.windows.media.capture.MediaStreamType, media_encoding_properties: typing.Optional[winrt.windows.media.mediaproperties.IMediaEncodingProperties], /) -> winrt.windows.foundation.IAsyncAction: ...

