# WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

import datetime
import sys
import types
import typing
import uuid

import winrt.system
import winrt.windows.applicationmodel.activation
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.networking
import winrt.windows.networking.sockets
import winrt.windows.security.credentials
import winrt.windows.security.cryptography.certificates
import winrt.windows.storage.streams
import winrt.windows.system

from . import VpnAppIdType, VpnAuthenticationMethod, VpnChannelActivityEventType, VpnChannelRequestCredentialsOptions, VpnCredentialType, VpnDataPathType, VpnDomainNameType, VpnIPProtocol, VpnManagementConnectionStatus, VpnManagementErrorStatus, VpnNativeProtocolType, VpnPacketBufferStatus, VpnRoutingPolicyType

Self = typing.TypeVar('Self')

class VpnAppId(winrt.system.Object):
    value: str
    type: VpnAppIdType
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnAppId: ...
    def __new__(cls: typing.Type[VpnAppId], type: VpnAppIdType, value: str) -> VpnAppId:...

class VpnChannel(winrt.system.Object):
    plug_in_context: typing.Optional[winrt.system.Object]
    configuration: typing.Optional[VpnChannelConfiguration]
    id: winrt.system.UInt32
    system_health: typing.Optional[VpnSystemHealth]
    current_request_transport_context: typing.Optional[winrt.system.Object]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnChannel: ...
    def activate_foreground(self, package_relative_app_id: str, shared_context: typing.Optional[winrt.windows.foundation.collections.ValueSet], /) -> typing.Optional[winrt.windows.foundation.collections.ValueSet]: ...
    def add_and_associate_transport(self, transport: typing.Optional[winrt.system.Object], context: typing.Optional[winrt.system.Object], /) -> None: ...
    def append_vpn_receive_packet_buffer(self, decapsulated_packet_buffer: typing.Optional[VpnPacketBuffer], /) -> None: ...
    def append_vpn_send_packet_buffer(self, encapsulated_packet_buffer: typing.Optional[VpnPacketBuffer], /) -> None: ...
    def associate_transport(self, main_outer_tunnel_transport: typing.Optional[winrt.system.Object], optional_outer_tunnel_transport: typing.Optional[winrt.system.Object], /) -> None: ...
    def flush_vpn_receive_packet_buffers(self) -> None: ...
    def flush_vpn_send_packet_buffers(self) -> None: ...
    def get_slot_type_for_transport_context(self, context: typing.Optional[winrt.system.Object], /) -> winrt.windows.networking.sockets.ControlChannelTriggerStatus: ...
    def get_vpn_receive_packet_buffer(self) -> typing.Optional[VpnPacketBuffer]: ...
    def get_vpn_send_packet_buffer(self) -> typing.Optional[VpnPacketBuffer]: ...
    def log_diagnostic_message(self, message: str, /) -> None: ...
    @staticmethod
    def process_event_async(third_party_plug_in: typing.Optional[winrt.system.Object], event: typing.Optional[winrt.system.Object], /) -> None: ...
    def replace_and_associate_transport(self, transport: typing.Optional[winrt.system.Object], context: typing.Optional[winrt.system.Object], /) -> None: ...
    def request_credentials(self, cred_type: VpnCredentialType, is_retry: bool, is_single_sign_on_credential: bool, certificate: typing.Optional[winrt.windows.security.cryptography.certificates.Certificate], /) -> typing.Optional[VpnPickedCredential]: ...
    @typing.overload
    def request_credentials_async(self, cred_type: VpnCredentialType, /) -> winrt.windows.foundation.IAsyncOperation[VpnCredential]: ...
    @typing.overload
    def request_credentials_async(self, cred_type: VpnCredentialType, cred_options: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[VpnCredential]: ...
    @typing.overload
    def request_credentials_async(self, cred_type: VpnCredentialType, cred_options: winrt.system.UInt32, certificate: typing.Optional[winrt.windows.security.cryptography.certificates.Certificate], /) -> winrt.windows.foundation.IAsyncOperation[VpnCredential]: ...
    def request_custom_prompt(self, custom_prompt: winrt.windows.foundation.collections.IVectorView[IVpnCustomPrompt], /) -> None: ...
    def request_custom_prompt_async(self, custom_prompt_element: winrt.windows.foundation.collections.IVectorView[IVpnCustomPromptElement], /) -> winrt.windows.foundation.IAsyncAction: ...
    def request_vpn_packet_buffer(self, type: VpnDataPathType, /) -> typing.Optional[VpnPacketBuffer]: ...
    def set_allowed_ssl_tls_versions(self, tunnel_transport: typing.Optional[winrt.system.Object], use_tls12: bool, /) -> None: ...
    def set_error_message(self, message: str, /) -> None: ...
    def start(self, assigned_client_i_pv4list: winrt.windows.foundation.collections.IVectorView[winrt.windows.networking.HostName], assigned_client_i_pv6list: winrt.windows.foundation.collections.IVectorView[winrt.windows.networking.HostName], vpn_interface_id: typing.Optional[VpnInterfaceId], route_scope: typing.Optional[VpnRouteAssignment], namespace_scope: typing.Optional[VpnNamespaceAssignment], mtu_size: winrt.system.UInt32, max_frame_size: winrt.system.UInt32, optimize_for_low_cost_network: bool, main_outer_tunnel_transport: typing.Optional[winrt.system.Object], optional_outer_tunnel_transport: typing.Optional[winrt.system.Object], /) -> None: ...
    def start_existing_transports(self, assigned_client_i_pv4list: winrt.windows.foundation.collections.IVectorView[winrt.windows.networking.HostName], assigned_client_i_pv6list: winrt.windows.foundation.collections.IVectorView[winrt.windows.networking.HostName], vpn_interface_id: typing.Optional[VpnInterfaceId], assigned_routes: typing.Optional[VpnRouteAssignment], assigned_domain_name: typing.Optional[VpnDomainNameAssignment], mtu_size: winrt.system.UInt32, max_frame_size: winrt.system.UInt32, reserved: bool, /) -> None: ...
    def start_reconnecting_transport(self, transport: typing.Optional[winrt.system.Object], context: typing.Optional[winrt.system.Object], /) -> None: ...
    def start_with_main_transport(self, assigned_client_i_pv4list: winrt.windows.foundation.collections.IVectorView[winrt.windows.networking.HostName], assigned_client_i_pv6list: winrt.windows.foundation.collections.IVectorView[winrt.windows.networking.HostName], vpn_interface_id: typing.Optional[VpnInterfaceId], assigned_routes: typing.Optional[VpnRouteAssignment], assigned_domain_name: typing.Optional[VpnDomainNameAssignment], mtu_size: winrt.system.UInt32, max_frame_size: winrt.system.UInt32, reserved: bool, main_outer_tunnel_transport: typing.Optional[winrt.system.Object], /) -> None: ...
    @typing.overload
    def start_with_traffic_filter(self, assigned_client_ipv4_addresses: typing.Iterable[winrt.windows.networking.HostName], assigned_client_ipv6_addresses: typing.Iterable[winrt.windows.networking.HostName], vpninterface_id: typing.Optional[VpnInterfaceId], assigned_routes: typing.Optional[VpnRouteAssignment], assigned_namespace: typing.Optional[VpnDomainNameAssignment], mtu_size: winrt.system.UInt32, max_frame_size: winrt.system.UInt32, reserved: bool, transports: typing.Iterable[winrt.system.Object], assigned_traffic_filters: typing.Optional[VpnTrafficFilterAssignment], /) -> None: ...
    @typing.overload
    def start_with_traffic_filter(self, assigned_client_ipv4_list: winrt.windows.foundation.collections.IVectorView[winrt.windows.networking.HostName], assigned_client_ipv6_list: winrt.windows.foundation.collections.IVectorView[winrt.windows.networking.HostName], vpn_interface_id: typing.Optional[VpnInterfaceId], assigned_routes: typing.Optional[VpnRouteAssignment], assigned_namespace: typing.Optional[VpnDomainNameAssignment], mtu_size: winrt.system.UInt32, max_frame_size: winrt.system.UInt32, reserved: bool, main_outer_tunnel_transport: typing.Optional[winrt.system.Object], optional_outer_tunnel_transport: typing.Optional[winrt.system.Object], assigned_traffic_filters: typing.Optional[VpnTrafficFilterAssignment], /) -> None: ...
    def stop(self) -> None: ...
    def terminate_connection(self, message: str, /) -> None: ...
    def add_activity_change(self, handler: winrt.windows.foundation.TypedEventHandler[VpnChannel, VpnChannelActivityEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_activity_change(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_activity_state_change(self, handler: winrt.windows.foundation.TypedEventHandler[VpnChannel, VpnChannelActivityStateChangedArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_activity_state_change(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class VpnChannelActivityEventArgs(winrt.system.Object):
    type: VpnChannelActivityEventType
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnChannelActivityEventArgs: ...

class VpnChannelActivityStateChangedArgs(winrt.system.Object):
    activity_state: VpnChannelActivityEventType
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnChannelActivityStateChangedArgs: ...

class VpnChannelConfiguration(winrt.system.Object):
    custom_field: str
    server_host_name_list: typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.networking.HostName]]
    server_service_name: str
    server_uris: typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.foundation.Uri]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnChannelConfiguration: ...

class VpnCredential(winrt.system.Object):
    additional_pin: str
    certificate_credential: typing.Optional[winrt.windows.security.cryptography.certificates.Certificate]
    old_password_credential: typing.Optional[winrt.windows.security.credentials.PasswordCredential]
    passkey_credential: typing.Optional[winrt.windows.security.credentials.PasswordCredential]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnCredential: ...

class VpnCustomCheckBox(winrt.system.Object):
    initial_check_state: bool
    checked: bool
    label: str
    compulsory: bool
    bordered: bool
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnCustomCheckBox: ...
    def __new__(cls: typing.Type[VpnCustomCheckBox]) -> VpnCustomCheckBox:...

class VpnCustomComboBox(winrt.system.Object):
    options_text: typing.Optional[winrt.windows.foundation.collections.IVectorView[str]]
    selected: winrt.system.UInt32
    label: str
    compulsory: bool
    bordered: bool
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnCustomComboBox: ...
    def __new__(cls: typing.Type[VpnCustomComboBox]) -> VpnCustomComboBox:...

class VpnCustomEditBox(winrt.system.Object):
    no_echo: bool
    default_text: str
    text: str
    label: str
    compulsory: bool
    bordered: bool
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnCustomEditBox: ...
    def __new__(cls: typing.Type[VpnCustomEditBox]) -> VpnCustomEditBox:...

class VpnCustomErrorBox(winrt.system.Object):
    label: str
    compulsory: bool
    bordered: bool
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnCustomErrorBox: ...
    def __new__(cls: typing.Type[VpnCustomErrorBox]) -> VpnCustomErrorBox:...

class VpnCustomPromptBooleanInput(winrt.system.Object):
    initial_value: bool
    value: bool
    emphasized: bool
    display_name: str
    compulsory: bool
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnCustomPromptBooleanInput: ...
    def __new__(cls: typing.Type[VpnCustomPromptBooleanInput]) -> VpnCustomPromptBooleanInput:...

class VpnCustomPromptOptionSelector(winrt.system.Object):
    emphasized: bool
    display_name: str
    compulsory: bool
    options: typing.Optional[winrt.windows.foundation.collections.IVector[str]]
    selected_index: winrt.system.UInt32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnCustomPromptOptionSelector: ...
    def __new__(cls: typing.Type[VpnCustomPromptOptionSelector]) -> VpnCustomPromptOptionSelector:...

class VpnCustomPromptText(winrt.system.Object):
    emphasized: bool
    display_name: str
    compulsory: bool
    text: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnCustomPromptText: ...
    def __new__(cls: typing.Type[VpnCustomPromptText]) -> VpnCustomPromptText:...

class VpnCustomPromptTextInput(winrt.system.Object):
    emphasized: bool
    display_name: str
    compulsory: bool
    placeholder_text: str
    is_text_hidden: bool
    text: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnCustomPromptTextInput: ...
    def __new__(cls: typing.Type[VpnCustomPromptTextInput]) -> VpnCustomPromptTextInput:...

class VpnCustomTextBox(winrt.system.Object):
    label: str
    compulsory: bool
    bordered: bool
    display_text: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnCustomTextBox: ...
    def __new__(cls: typing.Type[VpnCustomTextBox]) -> VpnCustomTextBox:...

class VpnDomainNameAssignment(winrt.system.Object):
    proxy_auto_configuration_uri: typing.Optional[winrt.windows.foundation.Uri]
    domain_name_list: typing.Optional[winrt.windows.foundation.collections.IVector[VpnDomainNameInfo]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnDomainNameAssignment: ...
    def __new__(cls: typing.Type[VpnDomainNameAssignment]) -> VpnDomainNameAssignment:...

class VpnDomainNameInfo(winrt.system.Object):
    domain_name_type: VpnDomainNameType
    domain_name: typing.Optional[winrt.windows.networking.HostName]
    dns_servers: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.networking.HostName]]
    web_proxy_servers: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.networking.HostName]]
    web_proxy_uris: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.foundation.Uri]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnDomainNameInfo: ...
    def __new__(cls: typing.Type[VpnDomainNameInfo], name: str, name_type: VpnDomainNameType, dns_server_list: typing.Iterable[winrt.windows.networking.HostName], proxy_server_list: typing.Iterable[winrt.windows.networking.HostName]) -> VpnDomainNameInfo:...

class VpnForegroundActivatedEventArgs(winrt.system.Object):
    kind: winrt.windows.applicationmodel.activation.ActivationKind
    previous_execution_state: winrt.windows.applicationmodel.activation.ApplicationExecutionState
    splash_screen: typing.Optional[winrt.windows.applicationmodel.activation.SplashScreen]
    user: typing.Optional[winrt.windows.system.User]
    activation_operation: typing.Optional[VpnForegroundActivationOperation]
    profile_name: str
    shared_context: typing.Optional[winrt.windows.foundation.collections.ValueSet]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnForegroundActivatedEventArgs: ...

class VpnForegroundActivationOperation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnForegroundActivationOperation: ...
    def complete(self, result: typing.Optional[winrt.windows.foundation.collections.ValueSet], /) -> None: ...

class VpnInterfaceId(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnInterfaceId: ...
    def __new__(cls: typing.Type[VpnInterfaceId], address: winrt.system.Array[winrt.system.UInt8]) -> VpnInterfaceId:...
    def get_address_info(self) -> winrt.system.Array[winrt.system.UInt8]: ...

class VpnManagementAgent(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnManagementAgent: ...
    def __new__(cls: typing.Type[VpnManagementAgent]) -> VpnManagementAgent:...
    def add_profile_from_object_async(self, profile: typing.Optional[IVpnProfile], /) -> winrt.windows.foundation.IAsyncOperation[VpnManagementErrorStatus]: ...
    def add_profile_from_xml_async(self, xml: str, /) -> winrt.windows.foundation.IAsyncOperation[VpnManagementErrorStatus]: ...
    def connect_profile_async(self, profile: typing.Optional[IVpnProfile], /) -> winrt.windows.foundation.IAsyncOperation[VpnManagementErrorStatus]: ...
    def connect_profile_with_password_credential_async(self, profile: typing.Optional[IVpnProfile], password_credential: typing.Optional[winrt.windows.security.credentials.PasswordCredential], /) -> winrt.windows.foundation.IAsyncOperation[VpnManagementErrorStatus]: ...
    def delete_profile_async(self, profile: typing.Optional[IVpnProfile], /) -> winrt.windows.foundation.IAsyncOperation[VpnManagementErrorStatus]: ...
    def disconnect_profile_async(self, profile: typing.Optional[IVpnProfile], /) -> winrt.windows.foundation.IAsyncOperation[VpnManagementErrorStatus]: ...
    def get_profiles_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[IVpnProfile]]: ...
    def update_profile_from_object_async(self, profile: typing.Optional[IVpnProfile], /) -> winrt.windows.foundation.IAsyncOperation[VpnManagementErrorStatus]: ...
    def update_profile_from_xml_async(self, xml: str, /) -> winrt.windows.foundation.IAsyncOperation[VpnManagementErrorStatus]: ...

class VpnNamespaceAssignment(winrt.system.Object):
    proxy_auto_config_uri: typing.Optional[winrt.windows.foundation.Uri]
    namespace_list: typing.Optional[winrt.windows.foundation.collections.IVector[VpnNamespaceInfo]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnNamespaceAssignment: ...
    def __new__(cls: typing.Type[VpnNamespaceAssignment]) -> VpnNamespaceAssignment:...

class VpnNamespaceInfo(winrt.system.Object):
    web_proxy_servers: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.networking.HostName]]
    namespace: str
    dns_servers: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.networking.HostName]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnNamespaceInfo: ...
    def __new__(cls: typing.Type[VpnNamespaceInfo], name: str, dns_server_list: winrt.windows.foundation.collections.IVector[winrt.windows.networking.HostName], proxy_server_list: winrt.windows.foundation.collections.IVector[winrt.windows.networking.HostName]) -> VpnNamespaceInfo:...

class VpnNativeProfile(winrt.system.Object):
    user_authentication_method: VpnAuthenticationMethod
    tunnel_authentication_method: VpnAuthenticationMethod
    routing_policy_type: VpnRoutingPolicyType
    eap_configuration: str
    native_protocol_type: VpnNativeProtocolType
    servers: typing.Optional[winrt.windows.foundation.collections.IVector[str]]
    require_vpn_client_app_u_i: bool
    connection_status: VpnManagementConnectionStatus
    profile_name: str
    remember_credentials: bool
    always_on: bool
    routes: typing.Optional[winrt.windows.foundation.collections.IVector[VpnRoute]]
    app_triggers: typing.Optional[winrt.windows.foundation.collections.IVector[VpnAppId]]
    traffic_filters: typing.Optional[winrt.windows.foundation.collections.IVector[VpnTrafficFilter]]
    domain_name_info_list: typing.Optional[winrt.windows.foundation.collections.IVector[VpnDomainNameInfo]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnNativeProfile: ...
    def __new__(cls: typing.Type[VpnNativeProfile]) -> VpnNativeProfile:...

class VpnPacketBuffer(winrt.system.Object):
    transport_affinity: winrt.system.UInt32
    status: VpnPacketBufferStatus
    buffer: typing.Optional[winrt.windows.storage.streams.Buffer]
    app_id: typing.Optional[VpnAppId]
    transport_context: typing.Optional[winrt.system.Object]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnPacketBuffer: ...
    def __new__(cls: typing.Type[VpnPacketBuffer], parent_buffer: typing.Optional[VpnPacketBuffer], offset: winrt.system.UInt32, length: winrt.system.UInt32) -> VpnPacketBuffer:...

class VpnPacketBufferList(winrt.system.Object):
    status: VpnPacketBufferStatus
    size: winrt.system.UInt32
    def __iter__(self) -> winrt.windows.foundation.collections.IIterator[VpnPacketBuffer]: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnPacketBufferList: ...
    def add_at_begin(self, next_vpn_packet_buffer: typing.Optional[VpnPacketBuffer], /) -> None: ...
    def append(self, next_vpn_packet_buffer: typing.Optional[VpnPacketBuffer], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[VpnPacketBuffer]]: ...
    def remove_at_begin(self) -> typing.Optional[VpnPacketBuffer]: ...
    def remove_at_end(self) -> typing.Optional[VpnPacketBuffer]: ...

class VpnPickedCredential(winrt.system.Object):
    additional_pin: str
    old_password_credential: typing.Optional[winrt.windows.security.credentials.PasswordCredential]
    passkey_credential: typing.Optional[winrt.windows.security.credentials.PasswordCredential]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnPickedCredential: ...

class VpnPlugInProfile(winrt.system.Object):
    vpn_plugin_package_family_name: str
    custom_configuration: str
    server_uris: typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.foundation.Uri]]
    require_vpn_client_app_u_i: bool
    connection_status: VpnManagementConnectionStatus
    profile_name: str
    remember_credentials: bool
    always_on: bool
    app_triggers: typing.Optional[winrt.windows.foundation.collections.IVector[VpnAppId]]
    domain_name_info_list: typing.Optional[winrt.windows.foundation.collections.IVector[VpnDomainNameInfo]]
    routes: typing.Optional[winrt.windows.foundation.collections.IVector[VpnRoute]]
    traffic_filters: typing.Optional[winrt.windows.foundation.collections.IVector[VpnTrafficFilter]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnPlugInProfile: ...
    def __new__(cls: typing.Type[VpnPlugInProfile]) -> VpnPlugInProfile:...

class VpnRoute(winrt.system.Object):
    prefix_size: winrt.system.UInt8
    address: typing.Optional[winrt.windows.networking.HostName]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnRoute: ...
    def __new__(cls: typing.Type[VpnRoute], address: typing.Optional[winrt.windows.networking.HostName], prefix_size: winrt.system.UInt8) -> VpnRoute:...

class VpnRouteAssignment(winrt.system.Object):
    ipv6_inclusion_routes: typing.Optional[winrt.windows.foundation.collections.IVector[VpnRoute]]
    ipv6_exclusion_routes: typing.Optional[winrt.windows.foundation.collections.IVector[VpnRoute]]
    ipv4_inclusion_routes: typing.Optional[winrt.windows.foundation.collections.IVector[VpnRoute]]
    ipv4_exclusion_routes: typing.Optional[winrt.windows.foundation.collections.IVector[VpnRoute]]
    exclude_local_subnets: bool
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnRouteAssignment: ...
    def __new__(cls: typing.Type[VpnRouteAssignment]) -> VpnRouteAssignment:...

class VpnSystemHealth(winrt.system.Object):
    statement_of_health: typing.Optional[winrt.windows.storage.streams.Buffer]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnSystemHealth: ...

class VpnTrafficFilter(winrt.system.Object):
    routing_policy_type: VpnRoutingPolicyType
    protocol: VpnIPProtocol
    app_id: typing.Optional[VpnAppId]
    app_claims: typing.Optional[winrt.windows.foundation.collections.IVector[str]]
    local_address_ranges: typing.Optional[winrt.windows.foundation.collections.IVector[str]]
    local_port_ranges: typing.Optional[winrt.windows.foundation.collections.IVector[str]]
    remote_address_ranges: typing.Optional[winrt.windows.foundation.collections.IVector[str]]
    remote_port_ranges: typing.Optional[winrt.windows.foundation.collections.IVector[str]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnTrafficFilter: ...
    def __new__(cls: typing.Type[VpnTrafficFilter], app_id: typing.Optional[VpnAppId]) -> VpnTrafficFilter:...

class VpnTrafficFilterAssignment(winrt.system.Object):
    allow_outbound: bool
    allow_inbound: bool
    traffic_filter_list: typing.Optional[winrt.windows.foundation.collections.IVector[VpnTrafficFilter]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VpnTrafficFilterAssignment: ...
    def __new__(cls: typing.Type[VpnTrafficFilterAssignment]) -> VpnTrafficFilterAssignment:...

class IVpnChannelStatics(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IVpnChannelStatics: ...
    def process_event_async(self, third_party_plug_in: typing.Optional[winrt.system.Object], event: typing.Optional[winrt.system.Object], /) -> None: ...

class IVpnCredential(winrt.system.Object):
    additional_pin: str
    certificate_credential: typing.Optional[winrt.windows.security.cryptography.certificates.Certificate]
    old_password_credential: typing.Optional[winrt.windows.security.credentials.PasswordCredential]
    passkey_credential: typing.Optional[winrt.windows.security.credentials.PasswordCredential]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IVpnCredential: ...

class IVpnCustomPrompt(winrt.system.Object):
    bordered: bool
    compulsory: bool
    label: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IVpnCustomPrompt: ...

class IVpnCustomPromptElement(winrt.system.Object):
    compulsory: bool
    display_name: str
    emphasized: bool
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IVpnCustomPromptElement: ...

class IVpnDomainNameInfoFactory(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IVpnDomainNameInfoFactory: ...
    def create_vpn_domain_name_info(self, name: str, name_type: VpnDomainNameType, dns_server_list: typing.Iterable[winrt.windows.networking.HostName], proxy_server_list: typing.Iterable[winrt.windows.networking.HostName], /) -> typing.Optional[VpnDomainNameInfo]: ...

class IVpnInterfaceIdFactory(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IVpnInterfaceIdFactory: ...
    def create_vpn_interface_id(self, address: winrt.system.Array[winrt.system.UInt8], /) -> typing.Optional[VpnInterfaceId]: ...

class IVpnNamespaceInfoFactory(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IVpnNamespaceInfoFactory: ...
    def create_vpn_namespace_info(self, name: str, dns_server_list: winrt.windows.foundation.collections.IVector[winrt.windows.networking.HostName], proxy_server_list: winrt.windows.foundation.collections.IVector[winrt.windows.networking.HostName], /) -> typing.Optional[VpnNamespaceInfo]: ...

class IVpnPacketBufferFactory(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IVpnPacketBufferFactory: ...
    def create_vpn_packet_buffer(self, parent_buffer: typing.Optional[VpnPacketBuffer], offset: winrt.system.UInt32, length: winrt.system.UInt32, /) -> typing.Optional[VpnPacketBuffer]: ...

class IVpnPlugIn(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IVpnPlugIn: ...
    def connect(self, channel: typing.Optional[VpnChannel], /) -> None: ...
    def decapsulate(self, channel: typing.Optional[VpnChannel], encap_buffer: typing.Optional[VpnPacketBuffer], decapsulated_packets: typing.Optional[VpnPacketBufferList], control_packets_to_send: typing.Optional[VpnPacketBufferList], /) -> None: ...
    def disconnect(self, channel: typing.Optional[VpnChannel], /) -> None: ...
    def encapsulate(self, channel: typing.Optional[VpnChannel], packets: typing.Optional[VpnPacketBufferList], encapulated_packets: typing.Optional[VpnPacketBufferList], /) -> None: ...
    def get_keep_alive_payload(self, channel: typing.Optional[VpnChannel], /) -> typing.Optional[VpnPacketBuffer]: ...

class IVpnProfile(winrt.system.Object):
    always_on: bool
    app_triggers: typing.Optional[winrt.windows.foundation.collections.IVector[VpnAppId]]
    domain_name_info_list: typing.Optional[winrt.windows.foundation.collections.IVector[VpnDomainNameInfo]]
    profile_name: str
    remember_credentials: bool
    routes: typing.Optional[winrt.windows.foundation.collections.IVector[VpnRoute]]
    traffic_filters: typing.Optional[winrt.windows.foundation.collections.IVector[VpnTrafficFilter]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IVpnProfile: ...

class IVpnRouteFactory(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IVpnRouteFactory: ...
    def create_vpn_route(self, address: typing.Optional[winrt.windows.networking.HostName], prefix_size: winrt.system.UInt8, /) -> typing.Optional[VpnRoute]: ...

