# WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

import enum
import datetime
import sys
import types
import typing

import winrt.system
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.media.audio
import winrt.windows.storage.streams

class ActivationSignalDetectionConfigurationCreationStatus(enum.IntEnum):
    SUCCESS = 0
    SIGNAL_ID_NOT_AVAILABLE = 1
    MODEL_ID_NOT_SUPPORTED = 2
    INVALID_SIGNAL_ID = 3
    INVALID_MODEL_ID = 4
    INVALID_DISPLAY_NAME = 5
    CONFIGURATION_ALREADY_EXISTS = 6
    CREATION_NOT_SUPPORTED = 7

class ActivationSignalDetectionConfigurationRemovalResult(enum.IntEnum):
    SUCCESS = 0
    NOT_FOUND = 1
    CURRENTLY_ENABLED = 2
    REMOVAL_NOT_SUPPORTED = 3

class ActivationSignalDetectionConfigurationSetModelDataResult(enum.IntEnum):
    SUCCESS = 0
    EMPTY_MODEL_DATA = 1
    UNSUPPORTED_FORMAT = 2
    CONFIGURATION_CURRENTLY_ENABLED = 3
    INVALID_DATA = 4
    SET_MODEL_DATA_NOT_SUPPORTED = 5
    CONFIGURATION_NOT_FOUND = 6
    UNKNOWN_ERROR = 7

class ActivationSignalDetectionConfigurationStateChangeResult(enum.IntEnum):
    SUCCESS = 0
    NO_MODEL_DATA = 1
    CONFIGURATION_NOT_FOUND = 2

class ActivationSignalDetectionTrainingDataFormat(enum.IntEnum):
    VOICE8K_HZ8_BIT_MONO = 0
    VOICE8K_HZ16_BIT_MONO = 1
    VOICE16K_HZ8_BIT_MONO = 2
    VOICE16K_HZ16_BIT_MONO = 3
    VOICE_O_E_M_DEFINED = 4
    AUDIO44K_HZ8_BIT_MONO = 5
    AUDIO44K_HZ16_BIT_MONO = 6
    AUDIO48K_HZ8_BIT_MONO = 7
    AUDIO48K_HZ16_BIT_MONO = 8
    AUDIO_O_E_M_DEFINED = 9
    OTHER_O_E_M_DEFINED = 10

class ActivationSignalDetectorKind(enum.IntEnum):
    AUDIO_PATTERN = 0
    AUDIO_IMPULSE = 1
    HARDWARE_EVENT = 2

class ActivationSignalDetectorPowerState(enum.IntEnum):
    HIGH_POWER = 0
    CONNECTED_LOW_POWER = 1
    DISCONNECTED_LOW_POWER = 2

class ConversationalAgentActivationKind(enum.IntEnum):
    VOICE_ACTIVATION_PREVIEW = 0
    FOREGROUND = 1

class ConversationalAgentActivationResult(enum.IntEnum):
    SUCCESS = 0
    AGENT_INACTIVE = 1
    SCREEN_NOT_AVAILABLE = 2
    AGENT_INTERRUPTED = 3

class ConversationalAgentSessionUpdateResponse(enum.IntEnum):
    SUCCESS = 0
    FAILED = 1

class ConversationalAgentState(enum.IntEnum):
    INACTIVE = 0
    DETECTING = 1
    LISTENING = 2
    WORKING = 3
    SPEAKING = 4
    LISTENING_AND_SPEAKING = 5

class ConversationalAgentSystemStateChangeType(enum.IntEnum):
    USER_AUTHENTICATION = 0
    SCREEN_AVAILABILITY = 1
    INDICATOR_LIGHT_AVAILABILITY = 2
    VOICE_ACTIVATION_AVAILABILITY = 3

class ConversationalAgentVoiceActivationPrerequisiteKind(enum.IntEnum):
    MICROPHONE_PERMISSION = 0
    KNOWN_AGENTS = 1
    AGENT_ALLOWED = 2
    APP_CAPABILITY = 3
    BACKGROUND_TASK_REGISTRATION = 4
    POLICY_PERMISSION = 5

class DetectionConfigurationAvailabilityChangeKind(enum.IntEnum):
    SYSTEM_RESOURCE_ACCESS = 0
    PERMISSION = 1
    LOCK_SCREEN_PERMISSION = 2

class DetectionConfigurationTrainingStatus(enum.IntEnum):
    SUCCESS = 0
    FORMAT_NOT_SUPPORTED = 1
    VOICE_TOO_QUIET = 2
    VOICE_TOO_LOUD = 3
    VOICE_TOO_FAST = 4
    VOICE_TOO_SLOW = 5
    VOICE_QUALITY_PROBLEM = 6
    TRAINING_SYSTEM_INTERNAL_ERROR = 7
    TRAINING_TIMED_OUT = 8
    CONFIGURATION_NOT_FOUND = 9

class SignalDetectorResourceKind(enum.IntEnum):
    PARALLEL_MODEL_SUPPORT = 0
    PARALLEL_MODEL_SUPPORT_FOR_AGENT = 1
    PARALLEL_SIGNAL_SUPPORT = 2
    PARALLEL_SIGNAL_SUPPORT_FOR_AGENT = 3
    DISPLAY_OFF_SUPPORT = 4
    PLUGGED_IN_POWER = 5
    DETECTOR = 6
    SUPPORTED_SLEEP_STATE = 7
    SUPPORTED_BATTERY_SAVER_STATE = 8
    SCREEN_AVAILABILITY = 9
    INPUT_HARDWARE = 10
    ACOUSTIC_ECHO_CANCELLATION = 11
    MODEL_ID_SUPPORT = 12
    DATA_CHANNEL = 13

Self = typing.TypeVar('Self')

class ActivationSignalDetectionConfiguration(winrt.system.Object):
    availability_info: typing.Optional[DetectionConfigurationAvailabilityInfo]
    display_name: str
    is_active: winrt.system.Boolean
    model_id: str
    signal_id: str
    training_data_format: ActivationSignalDetectionTrainingDataFormat
    training_steps_completed: winrt.system.UInt32
    training_steps_remaining: winrt.system.UInt32
    training_step_completion_max_allowed_time: winrt.system.UInt32
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ActivationSignalDetectionConfiguration: ...
    def apply_training_data(self, training_data_format: ActivationSignalDetectionTrainingDataFormat, training_data: typing.Optional[winrt.windows.storage.streams.IInputStream], /) -> DetectionConfigurationTrainingStatus: ...
    def apply_training_data_async(self, training_data_format: ActivationSignalDetectionTrainingDataFormat, training_data: typing.Optional[winrt.windows.storage.streams.IInputStream], /) -> winrt.windows.foundation.IAsyncOperation[DetectionConfigurationTrainingStatus]: ...
    def clear_model_data(self) -> None: ...
    def clear_model_data_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def clear_training_data(self) -> None: ...
    def clear_training_data_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def close(self) -> None: ...
    def get_model_data(self) -> typing.Optional[winrt.windows.storage.streams.IInputStream]: ...
    def get_model_data_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.streams.IInputStream]: ...
    def get_model_data_type(self) -> str: ...
    def get_model_data_type_async(self) -> winrt.windows.foundation.IAsyncOperation[str]: ...
    def set_enabled(self, value: winrt.system.Boolean, /) -> None: ...
    def set_enabled_async(self, value: winrt.system.Boolean, /) -> winrt.windows.foundation.IAsyncAction: ...
    def set_enabled_with_result(self, value: winrt.system.Boolean, /) -> ActivationSignalDetectionConfigurationStateChangeResult: ...
    def set_enabled_with_result_async(self, value: winrt.system.Boolean, /) -> winrt.windows.foundation.IAsyncOperation[ActivationSignalDetectionConfigurationStateChangeResult]: ...
    def set_model_data(self, data_type: str, data: typing.Optional[winrt.windows.storage.streams.IInputStream], /) -> None: ...
    def set_model_data_async(self, data_type: str, data: typing.Optional[winrt.windows.storage.streams.IInputStream], /) -> winrt.windows.foundation.IAsyncAction: ...
    def set_model_data_with_result(self, data_type: str, data: typing.Optional[winrt.windows.storage.streams.IInputStream], /) -> ActivationSignalDetectionConfigurationSetModelDataResult: ...
    def set_model_data_with_result_async(self, data_type: str, data: typing.Optional[winrt.windows.storage.streams.IInputStream], /) -> winrt.windows.foundation.IAsyncOperation[ActivationSignalDetectionConfigurationSetModelDataResult]: ...
    def add_availability_changed(self, handler: winrt.windows.foundation.TypedEventHandler[ActivationSignalDetectionConfiguration, DetectionConfigurationAvailabilityChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_availability_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class ActivationSignalDetectionConfigurationCreationResult(winrt.system.Object):
    configuration: typing.Optional[ActivationSignalDetectionConfiguration]
    status: ActivationSignalDetectionConfigurationCreationStatus
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ActivationSignalDetectionConfigurationCreationResult: ...

class ActivationSignalDetector(winrt.system.Object):
    can_create_configurations: winrt.system.Boolean
    kind: ActivationSignalDetectorKind
    provider_id: str
    supported_model_data_types: typing.Optional[winrt.windows.foundation.collections.IVectorView[str]]
    supported_power_states: typing.Optional[winrt.windows.foundation.collections.IVectorView[ActivationSignalDetectorPowerState]]
    supported_training_data_formats: typing.Optional[winrt.windows.foundation.collections.IVectorView[ActivationSignalDetectionTrainingDataFormat]]
    detector_id: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ActivationSignalDetector: ...
    def create_configuration(self, signal_id: str, model_id: str, display_name: str, /) -> None: ...
    def create_configuration_async(self, signal_id: str, model_id: str, display_name: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    def create_configuration_with_result(self, signal_id: str, model_id: str, display_name: str, /) -> typing.Optional[ActivationSignalDetectionConfigurationCreationResult]: ...
    def create_configuration_with_result_async(self, signal_id: str, model_id: str, display_name: str, /) -> winrt.windows.foundation.IAsyncOperation[ActivationSignalDetectionConfigurationCreationResult]: ...
    def get_available_model_ids_for_signal_id(self, signal_id: str, /) -> typing.Optional[winrt.windows.foundation.collections.IVector[str]]: ...
    def get_available_model_ids_for_signal_id_async(self, signal_id: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVector[str]]: ...
    def get_configuration(self, signal_id: str, model_id: str, /) -> typing.Optional[ActivationSignalDetectionConfiguration]: ...
    def get_configuration_async(self, signal_id: str, model_id: str, /) -> winrt.windows.foundation.IAsyncOperation[ActivationSignalDetectionConfiguration]: ...
    def get_configurations(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[ActivationSignalDetectionConfiguration]]: ...
    def get_configurations_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[ActivationSignalDetectionConfiguration]]: ...
    def get_supported_model_ids_for_signal_id(self, signal_id: str, /) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[str]]: ...
    def get_supported_model_ids_for_signal_id_async(self, signal_id: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[str]]: ...
    def remove_configuration(self, signal_id: str, model_id: str, /) -> None: ...
    def remove_configuration_async(self, signal_id: str, model_id: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    def remove_configuration_with_result(self, signal_id: str, model_id: str, /) -> ActivationSignalDetectionConfigurationRemovalResult: ...
    def remove_configuration_with_result_async(self, signal_id: str, model_id: str, /) -> winrt.windows.foundation.IAsyncOperation[ActivationSignalDetectionConfigurationRemovalResult]: ...

class ConversationalAgentDetectorManager(winrt.system.Object):
    default: typing.ClassVar[typing.Optional[ConversationalAgentDetectorManager]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ConversationalAgentDetectorManager: ...
    def get_activation_signal_detector_from_id(self, detector_id: str, /) -> typing.Optional[ActivationSignalDetector]: ...
    def get_activation_signal_detector_from_id_async(self, detector_id: str, /) -> winrt.windows.foundation.IAsyncOperation[ActivationSignalDetector]: ...
    def get_activation_signal_detectors(self, kind: ActivationSignalDetectorKind, /) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[ActivationSignalDetector]]: ...
    def get_activation_signal_detectors_async(self, kind: ActivationSignalDetectorKind, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[ActivationSignalDetector]]: ...
    def get_all_activation_signal_detectors(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[ActivationSignalDetector]]: ...
    def get_all_activation_signal_detectors_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[ActivationSignalDetector]]: ...

class ConversationalAgentSession(winrt.system.Object):
    agent_state: ConversationalAgentState
    is_indicator_light_available: winrt.system.Boolean
    is_interrupted: winrt.system.Boolean
    is_interruptible: winrt.system.Boolean
    is_screen_available: winrt.system.Boolean
    is_user_authenticated: winrt.system.Boolean
    is_voice_activation_available: winrt.system.Boolean
    signal: typing.Optional[ConversationalAgentSignal]
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ConversationalAgentSession: ...
    def close(self) -> None: ...
    def create_audio_device_input_node(self, graph: typing.Optional[winrt.windows.media.audio.AudioGraph], /) -> typing.Optional[winrt.windows.media.audio.AudioDeviceInputNode]: ...
    def create_audio_device_input_node_async(self, graph: typing.Optional[winrt.windows.media.audio.AudioGraph], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.media.audio.AudioDeviceInputNode]: ...
    def get_audio_capture_device_id(self) -> str: ...
    def get_audio_capture_device_id_async(self) -> winrt.windows.foundation.IAsyncOperation[str]: ...
    def get_audio_client(self) -> typing.Optional[winrt.system.Object]: ...
    def get_audio_client_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Object]: ...
    def get_audio_render_device_id(self) -> str: ...
    def get_audio_render_device_id_async(self) -> winrt.windows.foundation.IAsyncOperation[str]: ...
    @staticmethod
    def get_current_session_async() -> winrt.windows.foundation.IAsyncOperation[ConversationalAgentSession]: ...
    @staticmethod
    def get_current_session_sync() -> typing.Optional[ConversationalAgentSession]: ...
    def get_missing_prerequisites(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[ConversationalAgentVoiceActivationPrerequisiteKind]]: ...
    def get_missing_prerequisites_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[ConversationalAgentVoiceActivationPrerequisiteKind]]: ...
    def get_signal_model_id(self) -> winrt.system.UInt32: ...
    def get_signal_model_id_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.system.UInt32]: ...
    def get_supported_signal_model_ids(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]: ...
    def get_supported_signal_model_ids_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]: ...
    def request_activation(self, activation_kind: ConversationalAgentActivationKind, /) -> ConversationalAgentActivationResult: ...
    def request_activation_async(self, activation_kind: ConversationalAgentActivationKind, /) -> winrt.windows.foundation.IAsyncOperation[ConversationalAgentActivationResult]: ...
    def request_agent_state_change(self, state: ConversationalAgentState, /) -> ConversationalAgentSessionUpdateResponse: ...
    def request_agent_state_change_async(self, state: ConversationalAgentState, /) -> winrt.windows.foundation.IAsyncOperation[ConversationalAgentSessionUpdateResponse]: ...
    def request_foreground_activation(self) -> ConversationalAgentSessionUpdateResponse: ...
    def request_foreground_activation_async(self) -> winrt.windows.foundation.IAsyncOperation[ConversationalAgentSessionUpdateResponse]: ...
    def request_interruptible(self, interruptible: winrt.system.Boolean, /) -> ConversationalAgentSessionUpdateResponse: ...
    def request_interruptible_async(self, interruptible: winrt.system.Boolean, /) -> winrt.windows.foundation.IAsyncOperation[ConversationalAgentSessionUpdateResponse]: ...
    def set_signal_model_id(self, signal_model_id: winrt.system.UInt32, /) -> winrt.system.Boolean: ...
    def set_signal_model_id_async(self, signal_model_id: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...
    def set_support_lock_screen_activation(self, lock_screen_activation_supported: winrt.system.Boolean, /) -> None: ...
    def set_support_lock_screen_activation_async(self, lock_screen_activation_supported: winrt.system.Boolean, /) -> winrt.windows.foundation.IAsyncAction: ...
    def add_session_interrupted(self, handler: winrt.windows.foundation.TypedEventHandler[ConversationalAgentSession, ConversationalAgentSessionInterruptedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_session_interrupted(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_signal_detected(self, handler: winrt.windows.foundation.TypedEventHandler[ConversationalAgentSession, ConversationalAgentSignalDetectedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_signal_detected(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_system_state_changed(self, handler: winrt.windows.foundation.TypedEventHandler[ConversationalAgentSession, ConversationalAgentSystemStateChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_system_state_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class ConversationalAgentSessionInterruptedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ConversationalAgentSessionInterruptedEventArgs: ...

class ConversationalAgentSignal(winrt.system.Object):
    signal_start: datetime.timedelta
    signal_name: str
    signal_id: str
    signal_end: datetime.timedelta
    signal_context: typing.Optional[winrt.system.Object]
    is_signal_verification_required: winrt.system.Boolean
    detector_id: str
    detector_kind: ActivationSignalDetectorKind
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ConversationalAgentSignal: ...

class ConversationalAgentSignalDetectedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ConversationalAgentSignalDetectedEventArgs: ...

class ConversationalAgentSystemStateChangedEventArgs(winrt.system.Object):
    system_state_change_type: ConversationalAgentSystemStateChangeType
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ConversationalAgentSystemStateChangedEventArgs: ...

class DetectionConfigurationAvailabilityChangedEventArgs(winrt.system.Object):
    kind: DetectionConfigurationAvailabilityChangeKind
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DetectionConfigurationAvailabilityChangedEventArgs: ...

class DetectionConfigurationAvailabilityInfo(winrt.system.Object):
    has_lock_screen_permission: winrt.system.Boolean
    has_permission: winrt.system.Boolean
    has_system_resource_access: winrt.system.Boolean
    is_enabled: winrt.system.Boolean
    unavailable_system_resources: typing.Optional[winrt.windows.foundation.collections.IVectorView[SignalDetectorResourceKind]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DetectionConfigurationAvailabilityInfo: ...

