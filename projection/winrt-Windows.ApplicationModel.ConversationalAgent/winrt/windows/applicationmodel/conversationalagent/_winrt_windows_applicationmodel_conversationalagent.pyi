# WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

import datetime
import sys
import types
import typing
import uuid

import winrt.system
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.media.audio
import winrt.windows.storage.streams

from . import ActivationSignalDetectionConfigurationCreationStatus, ActivationSignalDetectionConfigurationRemovalResult, ActivationSignalDetectionConfigurationSetModelDataResult, ActivationSignalDetectionConfigurationStateChangeResult, ActivationSignalDetectionTrainingDataFormat, ActivationSignalDetectorKind, ActivationSignalDetectorPowerState, ConversationalAgentActivationKind, ConversationalAgentActivationResult, ConversationalAgentSessionUpdateResponse, ConversationalAgentState, ConversationalAgentSystemStateChangeType, ConversationalAgentVoiceActivationPrerequisiteKind, DetectionConfigurationAvailabilityChangeKind, DetectionConfigurationTrainingStatus, SignalDetectorResourceKind

Self = typing.TypeVar('Self')

class ActivationSignalDetectionConfiguration(winrt.system.Object):
    availability_info: typing.Optional[DetectionConfigurationAvailabilityInfo]
    display_name: str
    is_active: winrt.system.Boolean
    model_id: str
    signal_id: str
    training_data_format: ActivationSignalDetectionTrainingDataFormat
    training_steps_completed: winrt.system.UInt32
    training_steps_remaining: winrt.system.UInt32
    training_step_completion_max_allowed_time: winrt.system.UInt32
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ActivationSignalDetectionConfiguration: ...
    def apply_training_data(self, training_data_format: ActivationSignalDetectionTrainingDataFormat, training_data: typing.Optional[winrt.windows.storage.streams.IInputStream], /) -> DetectionConfigurationTrainingStatus: ...
    def apply_training_data_async(self, training_data_format: ActivationSignalDetectionTrainingDataFormat, training_data: typing.Optional[winrt.windows.storage.streams.IInputStream], /) -> winrt.windows.foundation.IAsyncOperation[DetectionConfigurationTrainingStatus]: ...
    def clear_model_data(self) -> None: ...
    def clear_model_data_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def clear_training_data(self) -> None: ...
    def clear_training_data_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def close(self) -> None: ...
    def get_model_data(self) -> typing.Optional[winrt.windows.storage.streams.IInputStream]: ...
    def get_model_data_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.streams.IInputStream]: ...
    def get_model_data_type(self) -> str: ...
    def get_model_data_type_async(self) -> winrt.windows.foundation.IAsyncOperation[str]: ...
    def set_enabled(self, value: winrt.system.Boolean, /) -> None: ...
    def set_enabled_async(self, value: winrt.system.Boolean, /) -> winrt.windows.foundation.IAsyncAction: ...
    def set_enabled_with_result(self, value: winrt.system.Boolean, /) -> ActivationSignalDetectionConfigurationStateChangeResult: ...
    def set_enabled_with_result_async(self, value: winrt.system.Boolean, /) -> winrt.windows.foundation.IAsyncOperation[ActivationSignalDetectionConfigurationStateChangeResult]: ...
    def set_model_data(self, data_type: str, data: typing.Optional[winrt.windows.storage.streams.IInputStream], /) -> None: ...
    def set_model_data_async(self, data_type: str, data: typing.Optional[winrt.windows.storage.streams.IInputStream], /) -> winrt.windows.foundation.IAsyncAction: ...
    def set_model_data_with_result(self, data_type: str, data: typing.Optional[winrt.windows.storage.streams.IInputStream], /) -> ActivationSignalDetectionConfigurationSetModelDataResult: ...
    def set_model_data_with_result_async(self, data_type: str, data: typing.Optional[winrt.windows.storage.streams.IInputStream], /) -> winrt.windows.foundation.IAsyncOperation[ActivationSignalDetectionConfigurationSetModelDataResult]: ...
    def add_availability_changed(self, handler: winrt.windows.foundation.TypedEventHandler[ActivationSignalDetectionConfiguration, DetectionConfigurationAvailabilityChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_availability_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class ActivationSignalDetectionConfigurationCreationResult(winrt.system.Object):
    configuration: typing.Optional[ActivationSignalDetectionConfiguration]
    status: ActivationSignalDetectionConfigurationCreationStatus
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ActivationSignalDetectionConfigurationCreationResult: ...

class ActivationSignalDetector(winrt.system.Object):
    can_create_configurations: winrt.system.Boolean
    kind: ActivationSignalDetectorKind
    provider_id: str
    supported_model_data_types: typing.Optional[winrt.windows.foundation.collections.IVectorView[str]]
    supported_power_states: typing.Optional[winrt.windows.foundation.collections.IVectorView[ActivationSignalDetectorPowerState]]
    supported_training_data_formats: typing.Optional[winrt.windows.foundation.collections.IVectorView[ActivationSignalDetectionTrainingDataFormat]]
    detector_id: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ActivationSignalDetector: ...
    def create_configuration(self, signal_id: str, model_id: str, display_name: str, /) -> None: ...
    def create_configuration_async(self, signal_id: str, model_id: str, display_name: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    def create_configuration_with_result(self, signal_id: str, model_id: str, display_name: str, /) -> typing.Optional[ActivationSignalDetectionConfigurationCreationResult]: ...
    def create_configuration_with_result_async(self, signal_id: str, model_id: str, display_name: str, /) -> winrt.windows.foundation.IAsyncOperation[ActivationSignalDetectionConfigurationCreationResult]: ...
    def get_available_model_ids_for_signal_id(self, signal_id: str, /) -> typing.Optional[winrt.windows.foundation.collections.IVector[str]]: ...
    def get_available_model_ids_for_signal_id_async(self, signal_id: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVector[str]]: ...
    def get_configuration(self, signal_id: str, model_id: str, /) -> typing.Optional[ActivationSignalDetectionConfiguration]: ...
    def get_configuration_async(self, signal_id: str, model_id: str, /) -> winrt.windows.foundation.IAsyncOperation[ActivationSignalDetectionConfiguration]: ...
    def get_configurations(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[ActivationSignalDetectionConfiguration]]: ...
    def get_configurations_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[ActivationSignalDetectionConfiguration]]: ...
    def get_supported_model_ids_for_signal_id(self, signal_id: str, /) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[str]]: ...
    def get_supported_model_ids_for_signal_id_async(self, signal_id: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[str]]: ...
    def remove_configuration(self, signal_id: str, model_id: str, /) -> None: ...
    def remove_configuration_async(self, signal_id: str, model_id: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    def remove_configuration_with_result(self, signal_id: str, model_id: str, /) -> ActivationSignalDetectionConfigurationRemovalResult: ...
    def remove_configuration_with_result_async(self, signal_id: str, model_id: str, /) -> winrt.windows.foundation.IAsyncOperation[ActivationSignalDetectionConfigurationRemovalResult]: ...

class ConversationalAgentDetectorManager(winrt.system.Object):
    default: typing.ClassVar[typing.Optional[ConversationalAgentDetectorManager]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ConversationalAgentDetectorManager: ...
    def get_activation_signal_detector_from_id(self, detector_id: str, /) -> typing.Optional[ActivationSignalDetector]: ...
    def get_activation_signal_detector_from_id_async(self, detector_id: str, /) -> winrt.windows.foundation.IAsyncOperation[ActivationSignalDetector]: ...
    def get_activation_signal_detectors(self, kind: ActivationSignalDetectorKind, /) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[ActivationSignalDetector]]: ...
    def get_activation_signal_detectors_async(self, kind: ActivationSignalDetectorKind, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[ActivationSignalDetector]]: ...
    def get_all_activation_signal_detectors(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[ActivationSignalDetector]]: ...
    def get_all_activation_signal_detectors_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[ActivationSignalDetector]]: ...

class ConversationalAgentSession(winrt.system.Object):
    agent_state: ConversationalAgentState
    is_indicator_light_available: winrt.system.Boolean
    is_interrupted: winrt.system.Boolean
    is_interruptible: winrt.system.Boolean
    is_screen_available: winrt.system.Boolean
    is_user_authenticated: winrt.system.Boolean
    is_voice_activation_available: winrt.system.Boolean
    signal: typing.Optional[ConversationalAgentSignal]
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ConversationalAgentSession: ...
    def close(self) -> None: ...
    def create_audio_device_input_node(self, graph: typing.Optional[winrt.windows.media.audio.AudioGraph], /) -> typing.Optional[winrt.windows.media.audio.AudioDeviceInputNode]: ...
    def create_audio_device_input_node_async(self, graph: typing.Optional[winrt.windows.media.audio.AudioGraph], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.media.audio.AudioDeviceInputNode]: ...
    def get_audio_capture_device_id(self) -> str: ...
    def get_audio_capture_device_id_async(self) -> winrt.windows.foundation.IAsyncOperation[str]: ...
    def get_audio_client(self) -> typing.Optional[winrt.system.Object]: ...
    def get_audio_client_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Object]: ...
    def get_audio_render_device_id(self) -> str: ...
    def get_audio_render_device_id_async(self) -> winrt.windows.foundation.IAsyncOperation[str]: ...
    @staticmethod
    def get_current_session_async() -> winrt.windows.foundation.IAsyncOperation[ConversationalAgentSession]: ...
    @staticmethod
    def get_current_session_sync() -> typing.Optional[ConversationalAgentSession]: ...
    def get_missing_prerequisites(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[ConversationalAgentVoiceActivationPrerequisiteKind]]: ...
    def get_missing_prerequisites_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[ConversationalAgentVoiceActivationPrerequisiteKind]]: ...
    def get_signal_model_id(self) -> winrt.system.UInt32: ...
    def get_signal_model_id_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.system.UInt32]: ...
    def get_supported_signal_model_ids(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]: ...
    def get_supported_signal_model_ids_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt32]]: ...
    def request_activation(self, activation_kind: ConversationalAgentActivationKind, /) -> ConversationalAgentActivationResult: ...
    def request_activation_async(self, activation_kind: ConversationalAgentActivationKind, /) -> winrt.windows.foundation.IAsyncOperation[ConversationalAgentActivationResult]: ...
    def request_agent_state_change(self, state: ConversationalAgentState, /) -> ConversationalAgentSessionUpdateResponse: ...
    def request_agent_state_change_async(self, state: ConversationalAgentState, /) -> winrt.windows.foundation.IAsyncOperation[ConversationalAgentSessionUpdateResponse]: ...
    def request_foreground_activation(self) -> ConversationalAgentSessionUpdateResponse: ...
    def request_foreground_activation_async(self) -> winrt.windows.foundation.IAsyncOperation[ConversationalAgentSessionUpdateResponse]: ...
    def request_interruptible(self, interruptible: winrt.system.Boolean, /) -> ConversationalAgentSessionUpdateResponse: ...
    def request_interruptible_async(self, interruptible: winrt.system.Boolean, /) -> winrt.windows.foundation.IAsyncOperation[ConversationalAgentSessionUpdateResponse]: ...
    def set_signal_model_id(self, signal_model_id: winrt.system.UInt32, /) -> winrt.system.Boolean: ...
    def set_signal_model_id_async(self, signal_model_id: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...
    def set_support_lock_screen_activation(self, lock_screen_activation_supported: winrt.system.Boolean, /) -> None: ...
    def set_support_lock_screen_activation_async(self, lock_screen_activation_supported: winrt.system.Boolean, /) -> winrt.windows.foundation.IAsyncAction: ...
    def add_session_interrupted(self, handler: winrt.windows.foundation.TypedEventHandler[ConversationalAgentSession, ConversationalAgentSessionInterruptedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_session_interrupted(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_signal_detected(self, handler: winrt.windows.foundation.TypedEventHandler[ConversationalAgentSession, ConversationalAgentSignalDetectedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_signal_detected(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_system_state_changed(self, handler: winrt.windows.foundation.TypedEventHandler[ConversationalAgentSession, ConversationalAgentSystemStateChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_system_state_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class ConversationalAgentSessionInterruptedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ConversationalAgentSessionInterruptedEventArgs: ...

class ConversationalAgentSignal(winrt.system.Object):
    signal_start: datetime.timedelta
    signal_name: str
    signal_id: str
    signal_end: datetime.timedelta
    signal_context: typing.Optional[winrt.system.Object]
    is_signal_verification_required: winrt.system.Boolean
    detector_id: str
    detector_kind: ActivationSignalDetectorKind
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ConversationalAgentSignal: ...

class ConversationalAgentSignalDetectedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ConversationalAgentSignalDetectedEventArgs: ...

class ConversationalAgentSystemStateChangedEventArgs(winrt.system.Object):
    system_state_change_type: ConversationalAgentSystemStateChangeType
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ConversationalAgentSystemStateChangedEventArgs: ...

class DetectionConfigurationAvailabilityChangedEventArgs(winrt.system.Object):
    kind: DetectionConfigurationAvailabilityChangeKind
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DetectionConfigurationAvailabilityChangedEventArgs: ...

class DetectionConfigurationAvailabilityInfo(winrt.system.Object):
    has_lock_screen_permission: winrt.system.Boolean
    has_permission: winrt.system.Boolean
    has_system_resource_access: winrt.system.Boolean
    is_enabled: winrt.system.Boolean
    unavailable_system_resources: typing.Optional[winrt.windows.foundation.collections.IVectorView[SignalDetectorResourceKind]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DetectionConfigurationAvailabilityInfo: ...

