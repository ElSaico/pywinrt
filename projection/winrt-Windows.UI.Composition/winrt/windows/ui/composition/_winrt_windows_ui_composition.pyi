# WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

import datetime
import sys
import types
import typing
import uuid

import winrt.system
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.foundation.numerics
import winrt.windows.graphics
import winrt.windows.graphics.directx
import winrt.windows.graphics.effects
import winrt.windows.system
import winrt.windows.ui
import winrt.windows.ui.core

from . import AnimationControllerProgressBehavior, AnimationDelayBehavior, AnimationDirection, AnimationIterationBehavior, AnimationPropertyAccessMode, AnimationStopBehavior, CompositionBackfaceVisibility, CompositionBatchTypes, CompositionBitmapInterpolationMode, CompositionBorderMode, CompositionColorSpace, CompositionCompositeMode, CompositionDropShadowSourcePolicy, CompositionEasingFunctionMode, CompositionEffectFactoryLoadStatus, CompositionGetValueStatus, CompositionGradientExtendMode, CompositionMappingMode, CompositionStretch, CompositionStrokeCap, CompositionStrokeLineJoin

Self = typing.TypeVar('Self')

class InkTrailPoint:
    point: winrt.windows.foundation.Point
    radius: winrt.system.Single
    def __new__(cls: typing.Type[InkTrailPoint], point: winrt.windows.foundation.Point, radius: winrt.system.Single) -> InkTrailPoint: ...

class AmbientLight(winrt.system.Object):
    color: winrt.windows.ui.Color
    intensity: winrt.system.Single
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AmbientLight: ...

class AnimationController(winrt.system.Object):
    progress_behavior: AnimationControllerProgressBehavior
    progress: winrt.system.Single
    playback_rate: winrt.system.Single
    max_playback_rate: typing.ClassVar[winrt.system.Single]
    min_playback_rate: typing.ClassVar[winrt.system.Single]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AnimationController: ...
    def pause(self) -> None: ...
    def resume(self) -> None: ...

class AnimationPropertyInfo(winrt.system.Object):
    access_mode: AnimationPropertyAccessMode
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AnimationPropertyInfo: ...
    def get_resolved_composition_object(self) -> typing.Optional[CompositionObject]: ...
    def get_resolved_composition_object_property(self) -> str: ...

class BackEasingFunction(winrt.system.Object):
    amplitude: winrt.system.Single
    mode: CompositionEasingFunctionMode
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BackEasingFunction: ...

class BooleanKeyFrameAnimation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BooleanKeyFrameAnimation: ...
    def insert_key_frame(self, normalized_progress_key: winrt.system.Single, value: winrt.system.Boolean, /) -> None: ...

class BounceEasingFunction(winrt.system.Object):
    bounces: winrt.system.Int32
    bounciness: winrt.system.Single
    mode: CompositionEasingFunctionMode
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BounceEasingFunction: ...

class BounceScalarNaturalMotionAnimation(winrt.system.Object):
    restitution: winrt.system.Single
    acceleration: winrt.system.Single
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BounceScalarNaturalMotionAnimation: ...

class BounceVector2NaturalMotionAnimation(winrt.system.Object):
    restitution: winrt.system.Single
    acceleration: winrt.system.Single
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BounceVector2NaturalMotionAnimation: ...

class BounceVector3NaturalMotionAnimation(winrt.system.Object):
    restitution: winrt.system.Single
    acceleration: winrt.system.Single
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BounceVector3NaturalMotionAnimation: ...

class CircleEasingFunction(winrt.system.Object):
    mode: CompositionEasingFunctionMode
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CircleEasingFunction: ...

class ColorKeyFrameAnimation(winrt.system.Object):
    interpolation_color_space: CompositionColorSpace
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ColorKeyFrameAnimation: ...
    @typing.overload
    def insert_key_frame(self, normalized_progress_key: winrt.system.Single, value: winrt.windows.ui.Color, /) -> None: ...
    @typing.overload
    def insert_key_frame(self, normalized_progress_key: winrt.system.Single, value: winrt.windows.ui.Color, easing_function: typing.Optional[CompositionEasingFunction], /) -> None: ...

class CompositionAnimation(winrt.system.Object):
    target: str
    initial_value_expressions: typing.Optional[InitialValueExpressionCollection]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionAnimation: ...
    def clear_all_parameters(self) -> None: ...
    def clear_parameter(self, key: str, /) -> None: ...
    def set_boolean_parameter(self, key: str, value: winrt.system.Boolean, /) -> None: ...
    def set_color_parameter(self, key: str, value: winrt.windows.ui.Color, /) -> None: ...
    def set_expression_reference_parameter(self, parameter_name: str, source: typing.Optional[IAnimationObject], /) -> None: ...
    def set_matrix3x2_parameter(self, key: str, value: winrt.windows.foundation.numerics.Matrix3x2, /) -> None: ...
    def set_matrix4x4_parameter(self, key: str, value: winrt.windows.foundation.numerics.Matrix4x4, /) -> None: ...
    def set_quaternion_parameter(self, key: str, value: winrt.windows.foundation.numerics.Quaternion, /) -> None: ...
    def set_reference_parameter(self, key: str, composition_object: typing.Optional[CompositionObject], /) -> None: ...
    def set_scalar_parameter(self, key: str, value: winrt.system.Single, /) -> None: ...
    def set_vector2_parameter(self, key: str, value: winrt.windows.foundation.numerics.Vector2, /) -> None: ...
    def set_vector3_parameter(self, key: str, value: winrt.windows.foundation.numerics.Vector3, /) -> None: ...
    def set_vector4_parameter(self, key: str, value: winrt.windows.foundation.numerics.Vector4, /) -> None: ...

class CompositionAnimationGroup(winrt.system.Object):
    count: winrt.system.Int32
    def __iter__(self) -> winrt.windows.foundation.collections.IIterator[CompositionAnimation]: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionAnimationGroup: ...
    def add(self, value: typing.Optional[CompositionAnimation], /) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[CompositionAnimation]]: ...
    def remove(self, value: typing.Optional[CompositionAnimation], /) -> None: ...
    def remove_all(self) -> None: ...

class CompositionBackdropBrush(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionBackdropBrush: ...

class CompositionBatchCompletedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionBatchCompletedEventArgs: ...

class CompositionBrush(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionBrush: ...

class CompositionCapabilities(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionCapabilities: ...
    def are_effects_fast(self) -> winrt.system.Boolean: ...
    def are_effects_supported(self) -> winrt.system.Boolean: ...
    @staticmethod
    def get_for_current_view() -> typing.Optional[CompositionCapabilities]: ...
    def add_changed(self, handler: winrt.windows.foundation.TypedEventHandler[CompositionCapabilities, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class CompositionClip(winrt.system.Object):
    transform_matrix: winrt.windows.foundation.numerics.Matrix3x2
    scale: winrt.windows.foundation.numerics.Vector2
    rotation_angle_in_degrees: winrt.system.Single
    rotation_angle: winrt.system.Single
    offset: winrt.windows.foundation.numerics.Vector2
    center_point: winrt.windows.foundation.numerics.Vector2
    anchor_point: winrt.windows.foundation.numerics.Vector2
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionClip: ...

class CompositionColorBrush(winrt.system.Object):
    color: winrt.windows.ui.Color
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionColorBrush: ...

class CompositionColorGradientStop(winrt.system.Object):
    offset: winrt.system.Single
    color: winrt.windows.ui.Color
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionColorGradientStop: ...

class CompositionColorGradientStopCollection(winrt.system.Object, typing.MutableSequence[CompositionColorGradientStop]):
    size: winrt.system.UInt32
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> CompositionColorGradientStop: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[CompositionColorGradientStop]: ...
    def insert(self, index: int, value: CompositionColorGradientStop) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: CompositionColorGradientStop) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[CompositionColorGradientStop]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionColorGradientStopCollection: ...
    def append(self, value: typing.Optional[CompositionColorGradientStop], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[CompositionColorGradientStop]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[CompositionColorGradientStop]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[CompositionColorGradientStop], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[CompositionColorGradientStop]]: ...
    def index_of(self, value: typing.Optional[CompositionColorGradientStop], /) -> typing.Tuple[winrt.system.Boolean, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[CompositionColorGradientStop], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[CompositionColorGradientStop], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[CompositionColorGradientStop], /) -> None: ...

class CompositionCommitBatch(winrt.system.Object):
    is_active: winrt.system.Boolean
    is_ended: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionCommitBatch: ...
    def add_completed(self, handler: winrt.windows.foundation.TypedEventHandler[winrt.system.Object, CompositionBatchCompletedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class CompositionContainerShape(winrt.system.Object):
    shapes: typing.Optional[CompositionShapeCollection]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionContainerShape: ...

class CompositionDrawingSurface(winrt.system.Object):
    alpha_mode: winrt.windows.graphics.directx.DirectXAlphaMode
    pixel_format: winrt.windows.graphics.directx.DirectXPixelFormat
    size: winrt.windows.foundation.Size
    size_int32: winrt.windows.graphics.SizeInt32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionDrawingSurface: ...
    def resize(self, size_pixels: winrt.windows.graphics.SizeInt32, /) -> None: ...
    @typing.overload
    def scroll(self, offset: winrt.windows.graphics.PointInt32, /) -> None: ...
    @typing.overload
    def scroll(self, offset: winrt.windows.graphics.PointInt32, scroll_rect: winrt.windows.graphics.RectInt32, /) -> None: ...
    @typing.overload
    def scroll_with_clip(self, offset: winrt.windows.graphics.PointInt32, clip_rect: winrt.windows.graphics.RectInt32, /) -> None: ...
    @typing.overload
    def scroll_with_clip(self, offset: winrt.windows.graphics.PointInt32, clip_rect: winrt.windows.graphics.RectInt32, scroll_rect: winrt.windows.graphics.RectInt32, /) -> None: ...

class CompositionEasingFunction(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionEasingFunction: ...
    @staticmethod
    def create_back_easing_function(owner: typing.Optional[Compositor], mode: CompositionEasingFunctionMode, amplitude: winrt.system.Single, /) -> typing.Optional[BackEasingFunction]: ...
    @staticmethod
    def create_bounce_easing_function(owner: typing.Optional[Compositor], mode: CompositionEasingFunctionMode, bounces: winrt.system.Int32, bounciness: winrt.system.Single, /) -> typing.Optional[BounceEasingFunction]: ...
    @staticmethod
    def create_circle_easing_function(owner: typing.Optional[Compositor], mode: CompositionEasingFunctionMode, /) -> typing.Optional[CircleEasingFunction]: ...
    @staticmethod
    def create_cubic_bezier_easing_function(owner: typing.Optional[Compositor], control_point1: winrt.windows.foundation.numerics.Vector2, control_point2: winrt.windows.foundation.numerics.Vector2, /) -> typing.Optional[CubicBezierEasingFunction]: ...
    @staticmethod
    def create_elastic_easing_function(owner: typing.Optional[Compositor], mode: CompositionEasingFunctionMode, oscillations: winrt.system.Int32, springiness: winrt.system.Single, /) -> typing.Optional[ElasticEasingFunction]: ...
    @staticmethod
    def create_exponential_easing_function(owner: typing.Optional[Compositor], mode: CompositionEasingFunctionMode, exponent: winrt.system.Single, /) -> typing.Optional[ExponentialEasingFunction]: ...
    @staticmethod
    def create_linear_easing_function(owner: typing.Optional[Compositor], /) -> typing.Optional[LinearEasingFunction]: ...
    @staticmethod
    def create_power_easing_function(owner: typing.Optional[Compositor], mode: CompositionEasingFunctionMode, power: winrt.system.Single, /) -> typing.Optional[PowerEasingFunction]: ...
    @staticmethod
    def create_sine_easing_function(owner: typing.Optional[Compositor], mode: CompositionEasingFunctionMode, /) -> typing.Optional[SineEasingFunction]: ...
    @typing.overload
    @staticmethod
    def create_step_easing_function(owner: typing.Optional[Compositor], /) -> typing.Optional[StepEasingFunction]: ...
    @typing.overload
    @staticmethod
    def create_step_easing_function(owner: typing.Optional[Compositor], step_count: winrt.system.Int32, /) -> typing.Optional[StepEasingFunction]: ...

class CompositionEffectBrush(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionEffectBrush: ...
    def get_source_parameter(self, name: str, /) -> typing.Optional[CompositionBrush]: ...
    def set_source_parameter(self, name: str, source: typing.Optional[CompositionBrush], /) -> None: ...

class CompositionEffectFactory(winrt.system.Object):
    extended_error: winrt.windows.foundation.HResult
    load_status: CompositionEffectFactoryLoadStatus
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionEffectFactory: ...
    def create_brush(self) -> typing.Optional[CompositionEffectBrush]: ...

class CompositionEffectSourceParameter(winrt.system.Object):
    name: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionEffectSourceParameter: ...
    def __new__(cls: typing.Type[CompositionEffectSourceParameter], name: str) -> CompositionEffectSourceParameter:...

class CompositionEllipseGeometry(winrt.system.Object):
    radius: winrt.windows.foundation.numerics.Vector2
    center: winrt.windows.foundation.numerics.Vector2
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionEllipseGeometry: ...

class CompositionGeometricClip(winrt.system.Object):
    view_box: typing.Optional[CompositionViewBox]
    geometry: typing.Optional[CompositionGeometry]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionGeometricClip: ...

class CompositionGeometry(winrt.system.Object):
    trim_start: winrt.system.Single
    trim_offset: winrt.system.Single
    trim_end: winrt.system.Single
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionGeometry: ...

class CompositionGradientBrush(winrt.system.Object):
    transform_matrix: winrt.windows.foundation.numerics.Matrix3x2
    scale: winrt.windows.foundation.numerics.Vector2
    rotation_angle_in_degrees: winrt.system.Single
    rotation_angle: winrt.system.Single
    offset: winrt.windows.foundation.numerics.Vector2
    interpolation_space: CompositionColorSpace
    extend_mode: CompositionGradientExtendMode
    center_point: winrt.windows.foundation.numerics.Vector2
    anchor_point: winrt.windows.foundation.numerics.Vector2
    color_stops: typing.Optional[CompositionColorGradientStopCollection]
    mapping_mode: CompositionMappingMode
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionGradientBrush: ...

class CompositionGraphicsDevice(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionGraphicsDevice: ...
    def capture_async(self, capture_visual: typing.Optional[Visual], size: winrt.windows.graphics.SizeInt32, pixel_format: winrt.windows.graphics.directx.DirectXPixelFormat, alpha_mode: winrt.windows.graphics.directx.DirectXAlphaMode, sdr_boost: winrt.system.Single, /) -> winrt.windows.foundation.IAsyncOperation[ICompositionSurface]: ...
    def create_drawing_surface(self, size_pixels: winrt.windows.foundation.Size, pixel_format: winrt.windows.graphics.directx.DirectXPixelFormat, alpha_mode: winrt.windows.graphics.directx.DirectXAlphaMode, /) -> typing.Optional[CompositionDrawingSurface]: ...
    def create_drawing_surface2(self, size_pixels: winrt.windows.graphics.SizeInt32, pixel_format: winrt.windows.graphics.directx.DirectXPixelFormat, alpha_mode: winrt.windows.graphics.directx.DirectXAlphaMode, /) -> typing.Optional[CompositionDrawingSurface]: ...
    def create_mipmap_surface(self, size_pixels: winrt.windows.graphics.SizeInt32, pixel_format: winrt.windows.graphics.directx.DirectXPixelFormat, alpha_mode: winrt.windows.graphics.directx.DirectXAlphaMode, /) -> typing.Optional[CompositionMipmapSurface]: ...
    def create_virtual_drawing_surface(self, size_pixels: winrt.windows.graphics.SizeInt32, pixel_format: winrt.windows.graphics.directx.DirectXPixelFormat, alpha_mode: winrt.windows.graphics.directx.DirectXAlphaMode, /) -> typing.Optional[CompositionVirtualDrawingSurface]: ...
    def trim(self) -> None: ...
    def add_rendering_device_replaced(self, handler: winrt.windows.foundation.TypedEventHandler[CompositionGraphicsDevice, RenderingDeviceReplacedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_rendering_device_replaced(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class CompositionLight(winrt.system.Object):
    targets: typing.Optional[VisualUnorderedCollection]
    exclusions_from_targets: typing.Optional[VisualUnorderedCollection]
    is_enabled: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionLight: ...

class CompositionLineGeometry(winrt.system.Object):
    start: winrt.windows.foundation.numerics.Vector2
    end: winrt.windows.foundation.numerics.Vector2
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionLineGeometry: ...

class CompositionLinearGradientBrush(winrt.system.Object):
    start_point: winrt.windows.foundation.numerics.Vector2
    end_point: winrt.windows.foundation.numerics.Vector2
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionLinearGradientBrush: ...

class CompositionMaskBrush(winrt.system.Object):
    source: typing.Optional[CompositionBrush]
    mask: typing.Optional[CompositionBrush]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionMaskBrush: ...

class CompositionMipmapSurface(winrt.system.Object):
    alpha_mode: winrt.windows.graphics.directx.DirectXAlphaMode
    level_count: winrt.system.UInt32
    pixel_format: winrt.windows.graphics.directx.DirectXPixelFormat
    size_int32: winrt.windows.graphics.SizeInt32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionMipmapSurface: ...
    def get_drawing_surface_for_level(self, level: winrt.system.UInt32, /) -> typing.Optional[CompositionDrawingSurface]: ...

class CompositionNineGridBrush(winrt.system.Object):
    top_inset_scale: winrt.system.Single
    top_inset: winrt.system.Single
    source: typing.Optional[CompositionBrush]
    right_inset_scale: winrt.system.Single
    right_inset: winrt.system.Single
    left_inset_scale: winrt.system.Single
    left_inset: winrt.system.Single
    is_center_hollow: winrt.system.Boolean
    bottom_inset_scale: winrt.system.Single
    bottom_inset: winrt.system.Single
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionNineGridBrush: ...
    @typing.overload
    def set_inset_scales(self, scale: winrt.system.Single, /) -> None: ...
    @typing.overload
    def set_inset_scales(self, left: winrt.system.Single, top: winrt.system.Single, right: winrt.system.Single, bottom: winrt.system.Single, /) -> None: ...
    @typing.overload
    def set_insets(self, inset: winrt.system.Single, /) -> None: ...
    @typing.overload
    def set_insets(self, left: winrt.system.Single, top: winrt.system.Single, right: winrt.system.Single, bottom: winrt.system.Single, /) -> None: ...

class CompositionObject(winrt.system.Object):
    compositor: typing.Optional[Compositor]
    dispatcher: typing.Optional[winrt.windows.ui.core.CoreDispatcher]
    properties: typing.Optional[CompositionPropertySet]
    implicit_animations: typing.Optional[ImplicitAnimationCollection]
    comment: str
    dispatcher_queue: typing.Optional[winrt.windows.system.DispatcherQueue]
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionObject: ...
    def close(self) -> None: ...
    def populate_property_info(self, property_name: str, property_info: typing.Optional[AnimationPropertyInfo], /) -> None: ...
    @typing.overload
    def start_animation(self, property_name: str, animation: typing.Optional[CompositionAnimation], /) -> None: ...
    @typing.overload
    def start_animation(self, property_name: str, animation: typing.Optional[CompositionAnimation], animation_controller: typing.Optional[AnimationController], /) -> None: ...
    def start_animation_group(self, value: typing.Optional[ICompositionAnimationBase], /) -> None: ...
    @staticmethod
    def start_animation_group_with_i_animation_object(target: typing.Optional[IAnimationObject], animation: typing.Optional[ICompositionAnimationBase], /) -> None: ...
    @staticmethod
    def start_animation_with_i_animation_object(target: typing.Optional[IAnimationObject], property_name: str, animation: typing.Optional[CompositionAnimation], /) -> None: ...
    def stop_animation(self, property_name: str, /) -> None: ...
    def stop_animation_group(self, value: typing.Optional[ICompositionAnimationBase], /) -> None: ...
    def try_get_animation_controller(self, property_name: str, /) -> typing.Optional[AnimationController]: ...

class CompositionPath(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionPath: ...
    def __new__(cls: typing.Type[CompositionPath], source: typing.Optional[winrt.windows.graphics.IGeometrySource2D]) -> CompositionPath:...

class CompositionPathGeometry(winrt.system.Object):
    path: typing.Optional[CompositionPath]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionPathGeometry: ...

class CompositionProjectedShadow(winrt.system.Object):
    min_blur_radius: winrt.system.Single
    max_blur_radius: winrt.system.Single
    light_source: typing.Optional[CompositionLight]
    blur_radius_multiplier: winrt.system.Single
    casters: typing.Optional[CompositionProjectedShadowCasterCollection]
    receivers: typing.Optional[CompositionProjectedShadowReceiverUnorderedCollection]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionProjectedShadow: ...

class CompositionProjectedShadowCaster(winrt.system.Object):
    casting_visual: typing.Optional[Visual]
    brush: typing.Optional[CompositionBrush]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionProjectedShadowCaster: ...

class CompositionProjectedShadowCasterCollection(winrt.system.Object):
    count: winrt.system.Int32
    max_respected_casters: typing.ClassVar[winrt.system.Int32]
    def __iter__(self) -> winrt.windows.foundation.collections.IIterator[CompositionProjectedShadowCaster]: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionProjectedShadowCasterCollection: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[CompositionProjectedShadowCaster]]: ...
    def insert_above(self, new_caster: typing.Optional[CompositionProjectedShadowCaster], reference: typing.Optional[CompositionProjectedShadowCaster], /) -> None: ...
    def insert_at_bottom(self, new_caster: typing.Optional[CompositionProjectedShadowCaster], /) -> None: ...
    def insert_at_top(self, new_caster: typing.Optional[CompositionProjectedShadowCaster], /) -> None: ...
    def insert_below(self, new_caster: typing.Optional[CompositionProjectedShadowCaster], reference: typing.Optional[CompositionProjectedShadowCaster], /) -> None: ...
    def remove(self, caster: typing.Optional[CompositionProjectedShadowCaster], /) -> None: ...
    def remove_all(self) -> None: ...

class CompositionProjectedShadowReceiver(winrt.system.Object):
    receiving_visual: typing.Optional[Visual]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionProjectedShadowReceiver: ...

class CompositionProjectedShadowReceiverUnorderedCollection(winrt.system.Object):
    count: winrt.system.Int32
    def __iter__(self) -> winrt.windows.foundation.collections.IIterator[CompositionProjectedShadowReceiver]: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionProjectedShadowReceiverUnorderedCollection: ...
    def add(self, value: typing.Optional[CompositionProjectedShadowReceiver], /) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[CompositionProjectedShadowReceiver]]: ...
    def remove(self, value: typing.Optional[CompositionProjectedShadowReceiver], /) -> None: ...
    def remove_all(self) -> None: ...

class CompositionPropertySet(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionPropertySet: ...
    def insert_boolean(self, property_name: str, value: winrt.system.Boolean, /) -> None: ...
    def insert_color(self, property_name: str, value: winrt.windows.ui.Color, /) -> None: ...
    def insert_matrix3x2(self, property_name: str, value: winrt.windows.foundation.numerics.Matrix3x2, /) -> None: ...
    def insert_matrix4x4(self, property_name: str, value: winrt.windows.foundation.numerics.Matrix4x4, /) -> None: ...
    def insert_quaternion(self, property_name: str, value: winrt.windows.foundation.numerics.Quaternion, /) -> None: ...
    def insert_scalar(self, property_name: str, value: winrt.system.Single, /) -> None: ...
    def insert_vector2(self, property_name: str, value: winrt.windows.foundation.numerics.Vector2, /) -> None: ...
    def insert_vector3(self, property_name: str, value: winrt.windows.foundation.numerics.Vector3, /) -> None: ...
    def insert_vector4(self, property_name: str, value: winrt.windows.foundation.numerics.Vector4, /) -> None: ...
    def try_get_boolean(self, property_name: str, /) -> typing.Tuple[CompositionGetValueStatus, winrt.system.Boolean]: ...
    def try_get_color(self, property_name: str, /) -> typing.Tuple[CompositionGetValueStatus, winrt.windows.ui.Color]: ...
    def try_get_matrix3x2(self, property_name: str, /) -> typing.Tuple[CompositionGetValueStatus, winrt.windows.foundation.numerics.Matrix3x2]: ...
    def try_get_matrix4x4(self, property_name: str, /) -> typing.Tuple[CompositionGetValueStatus, winrt.windows.foundation.numerics.Matrix4x4]: ...
    def try_get_quaternion(self, property_name: str, /) -> typing.Tuple[CompositionGetValueStatus, winrt.windows.foundation.numerics.Quaternion]: ...
    def try_get_scalar(self, property_name: str, /) -> typing.Tuple[CompositionGetValueStatus, winrt.system.Single]: ...
    def try_get_vector2(self, property_name: str, /) -> typing.Tuple[CompositionGetValueStatus, winrt.windows.foundation.numerics.Vector2]: ...
    def try_get_vector3(self, property_name: str, /) -> typing.Tuple[CompositionGetValueStatus, winrt.windows.foundation.numerics.Vector3]: ...
    def try_get_vector4(self, property_name: str, /) -> typing.Tuple[CompositionGetValueStatus, winrt.windows.foundation.numerics.Vector4]: ...

class CompositionRadialGradientBrush(winrt.system.Object):
    gradient_origin_offset: winrt.windows.foundation.numerics.Vector2
    ellipse_radius: winrt.windows.foundation.numerics.Vector2
    ellipse_center: winrt.windows.foundation.numerics.Vector2
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionRadialGradientBrush: ...

class CompositionRectangleGeometry(winrt.system.Object):
    size: winrt.windows.foundation.numerics.Vector2
    offset: winrt.windows.foundation.numerics.Vector2
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionRectangleGeometry: ...

class CompositionRoundedRectangleGeometry(winrt.system.Object):
    size: winrt.windows.foundation.numerics.Vector2
    offset: winrt.windows.foundation.numerics.Vector2
    corner_radius: winrt.windows.foundation.numerics.Vector2
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionRoundedRectangleGeometry: ...

class CompositionScopedBatch(winrt.system.Object):
    is_active: winrt.system.Boolean
    is_ended: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionScopedBatch: ...
    def end(self) -> None: ...
    def resume(self) -> None: ...
    def suspend(self) -> None: ...
    def add_completed(self, handler: winrt.windows.foundation.TypedEventHandler[winrt.system.Object, CompositionBatchCompletedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class CompositionShadow(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionShadow: ...

class CompositionShape(winrt.system.Object):
    transform_matrix: winrt.windows.foundation.numerics.Matrix3x2
    scale: winrt.windows.foundation.numerics.Vector2
    rotation_angle_in_degrees: winrt.system.Single
    rotation_angle: winrt.system.Single
    offset: winrt.windows.foundation.numerics.Vector2
    center_point: winrt.windows.foundation.numerics.Vector2
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionShape: ...

class CompositionShapeCollection(winrt.system.Object, typing.MutableSequence[CompositionShape]):
    size: winrt.system.UInt32
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> CompositionShape: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[CompositionShape]: ...
    def insert(self, index: int, value: CompositionShape) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: CompositionShape) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[CompositionShape]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionShapeCollection: ...
    def append(self, value: typing.Optional[CompositionShape], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[CompositionShape]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[CompositionShape]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[CompositionShape], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[CompositionShape]]: ...
    def index_of(self, value: typing.Optional[CompositionShape], /) -> typing.Tuple[winrt.system.Boolean, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[CompositionShape], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[CompositionShape], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[CompositionShape], /) -> None: ...

class CompositionSpriteShape(winrt.system.Object):
    stroke_thickness: winrt.system.Single
    stroke_start_cap: CompositionStrokeCap
    stroke_miter_limit: winrt.system.Single
    stroke_line_join: CompositionStrokeLineJoin
    stroke_end_cap: CompositionStrokeCap
    stroke_dash_offset: winrt.system.Single
    stroke_dash_cap: CompositionStrokeCap
    stroke_brush: typing.Optional[CompositionBrush]
    is_stroke_non_scaling: winrt.system.Boolean
    geometry: typing.Optional[CompositionGeometry]
    fill_brush: typing.Optional[CompositionBrush]
    stroke_dash_array: typing.Optional[CompositionStrokeDashArray]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionSpriteShape: ...

class CompositionStrokeDashArray(winrt.system.Object, typing.MutableSequence[winrt.system.Single]):
    size: winrt.system.UInt32
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> winrt.system.Single: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[winrt.system.Single]: ...
    def insert(self, index: int, value: winrt.system.Single) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: winrt.system.Single) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[winrt.system.Single]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionStrokeDashArray: ...
    def append(self, value: winrt.system.Single, /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[winrt.system.Single]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> winrt.system.Single: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[winrt.system.Single], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Single]]: ...
    def index_of(self, value: winrt.system.Single, /) -> typing.Tuple[winrt.system.Boolean, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: winrt.system.Single, /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[winrt.system.Single], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: winrt.system.Single, /) -> None: ...

class CompositionSurfaceBrush(winrt.system.Object):
    vertical_alignment_ratio: winrt.system.Single
    surface: typing.Optional[ICompositionSurface]
    stretch: CompositionStretch
    horizontal_alignment_ratio: winrt.system.Single
    bitmap_interpolation_mode: CompositionBitmapInterpolationMode
    transform_matrix: winrt.windows.foundation.numerics.Matrix3x2
    scale: winrt.windows.foundation.numerics.Vector2
    rotation_angle_in_degrees: winrt.system.Single
    rotation_angle: winrt.system.Single
    offset: winrt.windows.foundation.numerics.Vector2
    center_point: winrt.windows.foundation.numerics.Vector2
    anchor_point: winrt.windows.foundation.numerics.Vector2
    snap_to_pixels: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionSurfaceBrush: ...

class CompositionTarget(winrt.system.Object):
    root: typing.Optional[Visual]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionTarget: ...

class CompositionTransform(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionTransform: ...

class CompositionViewBox(winrt.system.Object):
    vertical_alignment_ratio: winrt.system.Single
    stretch: CompositionStretch
    size: winrt.windows.foundation.numerics.Vector2
    offset: winrt.windows.foundation.numerics.Vector2
    horizontal_alignment_ratio: winrt.system.Single
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionViewBox: ...

class CompositionVirtualDrawingSurface(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionVirtualDrawingSurface: ...
    def trim(self, rects: winrt.system.Array[winrt.windows.graphics.RectInt32], /) -> None: ...

class CompositionVisualSurface(winrt.system.Object):
    source_visual: typing.Optional[Visual]
    source_size: winrt.windows.foundation.numerics.Vector2
    source_offset: winrt.windows.foundation.numerics.Vector2
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionVisualSurface: ...

class Compositor(winrt.system.Object):
    global_playback_rate: winrt.system.Single
    comment: str
    dispatcher_queue: typing.Optional[winrt.windows.system.DispatcherQueue]
    max_global_playback_rate: typing.ClassVar[winrt.system.Single]
    min_global_playback_rate: typing.ClassVar[winrt.system.Single]
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Compositor: ...
    def __new__(cls: typing.Type[Compositor]) -> Compositor:...
    def close(self) -> None: ...
    def create_ambient_light(self) -> typing.Optional[AmbientLight]: ...
    def create_animation_controller(self) -> typing.Optional[AnimationController]: ...
    def create_animation_group(self) -> typing.Optional[CompositionAnimationGroup]: ...
    def create_animation_property_info(self) -> typing.Optional[AnimationPropertyInfo]: ...
    def create_backdrop_brush(self) -> typing.Optional[CompositionBackdropBrush]: ...
    def create_boolean_key_frame_animation(self) -> typing.Optional[BooleanKeyFrameAnimation]: ...
    def create_bounce_scalar_animation(self) -> typing.Optional[BounceScalarNaturalMotionAnimation]: ...
    def create_bounce_vector2_animation(self) -> typing.Optional[BounceVector2NaturalMotionAnimation]: ...
    def create_bounce_vector3_animation(self) -> typing.Optional[BounceVector3NaturalMotionAnimation]: ...
    @typing.overload
    def create_color_brush(self) -> typing.Optional[CompositionColorBrush]: ...
    @typing.overload
    def create_color_brush(self, color: winrt.windows.ui.Color, /) -> typing.Optional[CompositionColorBrush]: ...
    @typing.overload
    def create_color_gradient_stop(self) -> typing.Optional[CompositionColorGradientStop]: ...
    @typing.overload
    def create_color_gradient_stop(self, offset: winrt.system.Single, color: winrt.windows.ui.Color, /) -> typing.Optional[CompositionColorGradientStop]: ...
    def create_color_key_frame_animation(self) -> typing.Optional[ColorKeyFrameAnimation]: ...
    def create_container_shape(self) -> typing.Optional[CompositionContainerShape]: ...
    def create_container_visual(self) -> typing.Optional[ContainerVisual]: ...
    def create_cubic_bezier_easing_function(self, control_point1: winrt.windows.foundation.numerics.Vector2, control_point2: winrt.windows.foundation.numerics.Vector2, /) -> typing.Optional[CubicBezierEasingFunction]: ...
    def create_distant_light(self) -> typing.Optional[DistantLight]: ...
    def create_drop_shadow(self) -> typing.Optional[DropShadow]: ...
    @typing.overload
    def create_effect_factory(self, graphics_effect: typing.Optional[winrt.windows.graphics.effects.IGraphicsEffect], /) -> typing.Optional[CompositionEffectFactory]: ...
    @typing.overload
    def create_effect_factory(self, graphics_effect: typing.Optional[winrt.windows.graphics.effects.IGraphicsEffect], animatable_properties: typing.Iterable[str], /) -> typing.Optional[CompositionEffectFactory]: ...
    def create_ellipse_geometry(self) -> typing.Optional[CompositionEllipseGeometry]: ...
    @typing.overload
    def create_expression_animation(self) -> typing.Optional[ExpressionAnimation]: ...
    @typing.overload
    def create_expression_animation(self, expression: str, /) -> typing.Optional[ExpressionAnimation]: ...
    @typing.overload
    def create_geometric_clip(self) -> typing.Optional[CompositionGeometricClip]: ...
    @typing.overload
    def create_geometric_clip(self, geometry: typing.Optional[CompositionGeometry], /) -> typing.Optional[CompositionGeometricClip]: ...
    def create_host_backdrop_brush(self) -> typing.Optional[CompositionBackdropBrush]: ...
    def create_implicit_animation_collection(self) -> typing.Optional[ImplicitAnimationCollection]: ...
    @typing.overload
    def create_inset_clip(self) -> typing.Optional[InsetClip]: ...
    @typing.overload
    def create_inset_clip(self, left_inset: winrt.system.Single, top_inset: winrt.system.Single, right_inset: winrt.system.Single, bottom_inset: winrt.system.Single, /) -> typing.Optional[InsetClip]: ...
    def create_layer_visual(self) -> typing.Optional[LayerVisual]: ...
    def create_line_geometry(self) -> typing.Optional[CompositionLineGeometry]: ...
    def create_linear_easing_function(self) -> typing.Optional[LinearEasingFunction]: ...
    def create_linear_gradient_brush(self) -> typing.Optional[CompositionLinearGradientBrush]: ...
    def create_mask_brush(self) -> typing.Optional[CompositionMaskBrush]: ...
    def create_nine_grid_brush(self) -> typing.Optional[CompositionNineGridBrush]: ...
    @typing.overload
    def create_path_geometry(self) -> typing.Optional[CompositionPathGeometry]: ...
    @typing.overload
    def create_path_geometry(self, path: typing.Optional[CompositionPath], /) -> typing.Optional[CompositionPathGeometry]: ...
    def create_path_key_frame_animation(self) -> typing.Optional[PathKeyFrameAnimation]: ...
    def create_point_light(self) -> typing.Optional[PointLight]: ...
    def create_projected_shadow(self) -> typing.Optional[CompositionProjectedShadow]: ...
    def create_projected_shadow_caster(self) -> typing.Optional[CompositionProjectedShadowCaster]: ...
    def create_projected_shadow_receiver(self) -> typing.Optional[CompositionProjectedShadowReceiver]: ...
    def create_property_set(self) -> typing.Optional[CompositionPropertySet]: ...
    def create_quaternion_key_frame_animation(self) -> typing.Optional[QuaternionKeyFrameAnimation]: ...
    def create_radial_gradient_brush(self) -> typing.Optional[CompositionRadialGradientBrush]: ...
    @typing.overload
    def create_rectangle_clip(self) -> typing.Optional[RectangleClip]: ...
    @typing.overload
    def create_rectangle_clip(self, left: winrt.system.Single, top: winrt.system.Single, right: winrt.system.Single, bottom: winrt.system.Single, /) -> typing.Optional[RectangleClip]: ...
    @typing.overload
    def create_rectangle_clip(self, left: winrt.system.Single, top: winrt.system.Single, right: winrt.system.Single, bottom: winrt.system.Single, top_left_radius: winrt.windows.foundation.numerics.Vector2, top_right_radius: winrt.windows.foundation.numerics.Vector2, bottom_right_radius: winrt.windows.foundation.numerics.Vector2, bottom_left_radius: winrt.windows.foundation.numerics.Vector2, /) -> typing.Optional[RectangleClip]: ...
    def create_rectangle_geometry(self) -> typing.Optional[CompositionRectangleGeometry]: ...
    @typing.overload
    def create_redirect_visual(self) -> typing.Optional[RedirectVisual]: ...
    @typing.overload
    def create_redirect_visual(self, source: typing.Optional[Visual], /) -> typing.Optional[RedirectVisual]: ...
    def create_rounded_rectangle_geometry(self) -> typing.Optional[CompositionRoundedRectangleGeometry]: ...
    def create_scalar_key_frame_animation(self) -> typing.Optional[ScalarKeyFrameAnimation]: ...
    def create_scoped_batch(self, batch_type: CompositionBatchTypes, /) -> typing.Optional[CompositionScopedBatch]: ...
    def create_shape_visual(self) -> typing.Optional[ShapeVisual]: ...
    def create_spot_light(self) -> typing.Optional[SpotLight]: ...
    def create_spring_scalar_animation(self) -> typing.Optional[SpringScalarNaturalMotionAnimation]: ...
    def create_spring_vector2_animation(self) -> typing.Optional[SpringVector2NaturalMotionAnimation]: ...
    def create_spring_vector3_animation(self) -> typing.Optional[SpringVector3NaturalMotionAnimation]: ...
    @typing.overload
    def create_sprite_shape(self) -> typing.Optional[CompositionSpriteShape]: ...
    @typing.overload
    def create_sprite_shape(self, geometry: typing.Optional[CompositionGeometry], /) -> typing.Optional[CompositionSpriteShape]: ...
    def create_sprite_visual(self) -> typing.Optional[SpriteVisual]: ...
    @typing.overload
    def create_step_easing_function(self) -> typing.Optional[StepEasingFunction]: ...
    @typing.overload
    def create_step_easing_function(self, step_count: winrt.system.Int32, /) -> typing.Optional[StepEasingFunction]: ...
    @typing.overload
    def create_surface_brush(self) -> typing.Optional[CompositionSurfaceBrush]: ...
    @typing.overload
    def create_surface_brush(self, surface: typing.Optional[ICompositionSurface], /) -> typing.Optional[CompositionSurfaceBrush]: ...
    def create_target_for_current_view(self) -> typing.Optional[CompositionTarget]: ...
    def create_vector2_key_frame_animation(self) -> typing.Optional[Vector2KeyFrameAnimation]: ...
    def create_vector3_key_frame_animation(self) -> typing.Optional[Vector3KeyFrameAnimation]: ...
    def create_vector4_key_frame_animation(self) -> typing.Optional[Vector4KeyFrameAnimation]: ...
    def create_view_box(self) -> typing.Optional[CompositionViewBox]: ...
    def create_visual_surface(self) -> typing.Optional[CompositionVisualSurface]: ...
    def get_commit_batch(self, batch_type: CompositionBatchTypes, /) -> typing.Optional[CompositionCommitBatch]: ...
    def request_commit_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def try_create_blurred_wallpaper_backdrop_brush(self) -> typing.Optional[CompositionBackdropBrush]: ...

class ContainerVisual(winrt.system.Object):
    children: typing.Optional[VisualCollection]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ContainerVisual: ...

class CubicBezierEasingFunction(winrt.system.Object):
    control_point1: winrt.windows.foundation.numerics.Vector2
    control_point2: winrt.windows.foundation.numerics.Vector2
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CubicBezierEasingFunction: ...

class DelegatedInkTrailVisual(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DelegatedInkTrailVisual: ...
    def add_trail_points(self, ink_points: winrt.system.Array[InkTrailPoint], /) -> winrt.system.UInt32: ...
    def add_trail_points_with_prediction(self, ink_points: winrt.system.Array[InkTrailPoint], predicted_ink_points: winrt.system.Array[InkTrailPoint], /) -> winrt.system.UInt32: ...
    @staticmethod
    def create(compositor: typing.Optional[Compositor], /) -> typing.Optional[DelegatedInkTrailVisual]: ...
    @staticmethod
    def create_for_swap_chain(compositor: typing.Optional[Compositor], swap_chain: typing.Optional[ICompositionSurface], /) -> typing.Optional[DelegatedInkTrailVisual]: ...
    def remove_trail_points(self, generation_id: winrt.system.UInt32, /) -> None: ...
    def start_new_trail(self, color: winrt.windows.ui.Color, /) -> None: ...

class DistantLight(winrt.system.Object):
    direction: winrt.windows.foundation.numerics.Vector3
    coordinate_space: typing.Optional[Visual]
    color: winrt.windows.ui.Color
    intensity: winrt.system.Single
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DistantLight: ...

class DropShadow(winrt.system.Object):
    opacity: winrt.system.Single
    offset: winrt.windows.foundation.numerics.Vector3
    mask: typing.Optional[CompositionBrush]
    color: winrt.windows.ui.Color
    blur_radius: winrt.system.Single
    source_policy: CompositionDropShadowSourcePolicy
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DropShadow: ...

class ElasticEasingFunction(winrt.system.Object):
    mode: CompositionEasingFunctionMode
    oscillations: winrt.system.Int32
    springiness: winrt.system.Single
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ElasticEasingFunction: ...

class ExponentialEasingFunction(winrt.system.Object):
    exponent: winrt.system.Single
    mode: CompositionEasingFunctionMode
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ExponentialEasingFunction: ...

class ExpressionAnimation(winrt.system.Object):
    expression: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ExpressionAnimation: ...

class ImplicitAnimationCollection(winrt.system.Object, typing.MutableMapping[str, ICompositionAnimationBase]):
    size: winrt.system.UInt32
    def __len__(self) -> int: ...
    def __iter__(self) -> typing.Iterator[str]: ...
    def __contains__(self, key: object) -> bool:...
    def __setitem__(self, key: str, value: ICompositionAnimationBase) -> None: ...
    def __getitem__(self, key: str) -> ICompositionAnimationBase: ...
    def __delitem__(self, key: str) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ImplicitAnimationCollection: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[winrt.windows.foundation.collections.IKeyValuePair[str, ICompositionAnimationBase]]]: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IMapView[str, ICompositionAnimationBase]]: ...
    def has_key(self, key: str, /) -> winrt.system.Boolean: ...
    def insert(self, key: str, value: typing.Optional[ICompositionAnimationBase], /) -> winrt.system.Boolean: ...
    def lookup(self, key: str, /) -> typing.Optional[ICompositionAnimationBase]: ...
    def remove(self, key: str, /) -> None: ...

class InitialValueExpressionCollection(winrt.system.Object, typing.MutableMapping[str, str]):
    size: winrt.system.UInt32
    def __len__(self) -> int: ...
    def __iter__(self) -> typing.Iterator[str]: ...
    def __contains__(self, key: object) -> bool:...
    def __setitem__(self, key: str, value: str) -> None: ...
    def __getitem__(self, key: str) -> str: ...
    def __delitem__(self, key: str) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InitialValueExpressionCollection: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[winrt.windows.foundation.collections.IKeyValuePair[str, str]]]: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IMapView[str, str]]: ...
    def has_key(self, key: str, /) -> winrt.system.Boolean: ...
    def insert(self, key: str, value: str, /) -> winrt.system.Boolean: ...
    def lookup(self, key: str, /) -> str: ...
    def remove(self, key: str, /) -> None: ...

class InsetClip(winrt.system.Object):
    top_inset: winrt.system.Single
    right_inset: winrt.system.Single
    left_inset: winrt.system.Single
    bottom_inset: winrt.system.Single
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InsetClip: ...

class KeyFrameAnimation(winrt.system.Object):
    stop_behavior: AnimationStopBehavior
    iteration_count: winrt.system.Int32
    iteration_behavior: AnimationIterationBehavior
    duration: datetime.timedelta
    delay_time: datetime.timedelta
    key_frame_count: winrt.system.Int32
    direction: AnimationDirection
    delay_behavior: AnimationDelayBehavior
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> KeyFrameAnimation: ...
    @typing.overload
    def insert_expression_key_frame(self, normalized_progress_key: winrt.system.Single, value: str, /) -> None: ...
    @typing.overload
    def insert_expression_key_frame(self, normalized_progress_key: winrt.system.Single, value: str, easing_function: typing.Optional[CompositionEasingFunction], /) -> None: ...

class LayerVisual(winrt.system.Object):
    effect: typing.Optional[CompositionEffectBrush]
    shadow: typing.Optional[CompositionShadow]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LayerVisual: ...

class LinearEasingFunction(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LinearEasingFunction: ...

class NaturalMotionAnimation(winrt.system.Object):
    stop_behavior: AnimationStopBehavior
    delay_time: datetime.timedelta
    delay_behavior: AnimationDelayBehavior
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NaturalMotionAnimation: ...

class PathKeyFrameAnimation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PathKeyFrameAnimation: ...
    @typing.overload
    def insert_key_frame(self, normalized_progress_key: winrt.system.Single, path: typing.Optional[CompositionPath], /) -> None: ...
    @typing.overload
    def insert_key_frame(self, normalized_progress_key: winrt.system.Single, path: typing.Optional[CompositionPath], easing_function: typing.Optional[CompositionEasingFunction], /) -> None: ...

class PointLight(winrt.system.Object):
    quadratic_attenuation: winrt.system.Single
    offset: winrt.windows.foundation.numerics.Vector3
    linear_attenuation: winrt.system.Single
    coordinate_space: typing.Optional[Visual]
    constant_attenuation: winrt.system.Single
    color: winrt.windows.ui.Color
    intensity: winrt.system.Single
    min_attenuation_cutoff: winrt.system.Single
    max_attenuation_cutoff: winrt.system.Single
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PointLight: ...

class PowerEasingFunction(winrt.system.Object):
    mode: CompositionEasingFunctionMode
    power: winrt.system.Single
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PowerEasingFunction: ...

class QuaternionKeyFrameAnimation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> QuaternionKeyFrameAnimation: ...
    @typing.overload
    def insert_key_frame(self, normalized_progress_key: winrt.system.Single, value: winrt.windows.foundation.numerics.Quaternion, /) -> None: ...
    @typing.overload
    def insert_key_frame(self, normalized_progress_key: winrt.system.Single, value: winrt.windows.foundation.numerics.Quaternion, easing_function: typing.Optional[CompositionEasingFunction], /) -> None: ...

class RectangleClip(winrt.system.Object):
    top_right_radius: winrt.windows.foundation.numerics.Vector2
    top_left_radius: winrt.windows.foundation.numerics.Vector2
    top: winrt.system.Single
    right: winrt.system.Single
    left: winrt.system.Single
    bottom_right_radius: winrt.windows.foundation.numerics.Vector2
    bottom_left_radius: winrt.windows.foundation.numerics.Vector2
    bottom: winrt.system.Single
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RectangleClip: ...

class RedirectVisual(winrt.system.Object):
    source: typing.Optional[Visual]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RedirectVisual: ...

class RenderingDeviceReplacedEventArgs(winrt.system.Object):
    graphics_device: typing.Optional[CompositionGraphicsDevice]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RenderingDeviceReplacedEventArgs: ...

class ScalarKeyFrameAnimation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ScalarKeyFrameAnimation: ...
    @typing.overload
    def insert_key_frame(self, normalized_progress_key: winrt.system.Single, value: winrt.system.Single, /) -> None: ...
    @typing.overload
    def insert_key_frame(self, normalized_progress_key: winrt.system.Single, value: winrt.system.Single, easing_function: typing.Optional[CompositionEasingFunction], /) -> None: ...

class ScalarNaturalMotionAnimation(winrt.system.Object):
    initial_velocity: winrt.system.Single
    initial_value: typing.Optional[typing.Optional[winrt.system.Single]]
    final_value: typing.Optional[typing.Optional[winrt.system.Single]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ScalarNaturalMotionAnimation: ...

class ShapeVisual(winrt.system.Object):
    view_box: typing.Optional[CompositionViewBox]
    shapes: typing.Optional[CompositionShapeCollection]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ShapeVisual: ...

class SineEasingFunction(winrt.system.Object):
    mode: CompositionEasingFunctionMode
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SineEasingFunction: ...

class SpotLight(winrt.system.Object):
    quadratic_attenuation: winrt.system.Single
    outer_cone_color: winrt.windows.ui.Color
    outer_cone_angle_in_degrees: winrt.system.Single
    outer_cone_angle: winrt.system.Single
    offset: winrt.windows.foundation.numerics.Vector3
    linear_attenuation: winrt.system.Single
    inner_cone_color: winrt.windows.ui.Color
    inner_cone_angle_in_degrees: winrt.system.Single
    inner_cone_angle: winrt.system.Single
    direction: winrt.windows.foundation.numerics.Vector3
    coordinate_space: typing.Optional[Visual]
    constant_attenuation: winrt.system.Single
    outer_cone_intensity: winrt.system.Single
    inner_cone_intensity: winrt.system.Single
    min_attenuation_cutoff: winrt.system.Single
    max_attenuation_cutoff: winrt.system.Single
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpotLight: ...

class SpringScalarNaturalMotionAnimation(winrt.system.Object):
    period: datetime.timedelta
    damping_ratio: winrt.system.Single
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpringScalarNaturalMotionAnimation: ...

class SpringVector2NaturalMotionAnimation(winrt.system.Object):
    period: datetime.timedelta
    damping_ratio: winrt.system.Single
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpringVector2NaturalMotionAnimation: ...

class SpringVector3NaturalMotionAnimation(winrt.system.Object):
    period: datetime.timedelta
    damping_ratio: winrt.system.Single
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpringVector3NaturalMotionAnimation: ...

class SpriteVisual(winrt.system.Object):
    brush: typing.Optional[CompositionBrush]
    shadow: typing.Optional[CompositionShadow]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SpriteVisual: ...

class StepEasingFunction(winrt.system.Object):
    step_count: winrt.system.Int32
    is_initial_step_single_frame: winrt.system.Boolean
    is_final_step_single_frame: winrt.system.Boolean
    initial_step: winrt.system.Int32
    final_step: winrt.system.Int32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StepEasingFunction: ...

class Vector2KeyFrameAnimation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Vector2KeyFrameAnimation: ...
    @typing.overload
    def insert_key_frame(self, normalized_progress_key: winrt.system.Single, value: winrt.windows.foundation.numerics.Vector2, /) -> None: ...
    @typing.overload
    def insert_key_frame(self, normalized_progress_key: winrt.system.Single, value: winrt.windows.foundation.numerics.Vector2, easing_function: typing.Optional[CompositionEasingFunction], /) -> None: ...

class Vector2NaturalMotionAnimation(winrt.system.Object):
    initial_velocity: winrt.windows.foundation.numerics.Vector2
    initial_value: typing.Optional[typing.Optional[winrt.windows.foundation.numerics.Vector2]]
    final_value: typing.Optional[typing.Optional[winrt.windows.foundation.numerics.Vector2]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Vector2NaturalMotionAnimation: ...

class Vector3KeyFrameAnimation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Vector3KeyFrameAnimation: ...
    @typing.overload
    def insert_key_frame(self, normalized_progress_key: winrt.system.Single, value: winrt.windows.foundation.numerics.Vector3, /) -> None: ...
    @typing.overload
    def insert_key_frame(self, normalized_progress_key: winrt.system.Single, value: winrt.windows.foundation.numerics.Vector3, easing_function: typing.Optional[CompositionEasingFunction], /) -> None: ...

class Vector3NaturalMotionAnimation(winrt.system.Object):
    initial_velocity: winrt.windows.foundation.numerics.Vector3
    initial_value: typing.Optional[typing.Optional[winrt.windows.foundation.numerics.Vector3]]
    final_value: typing.Optional[typing.Optional[winrt.windows.foundation.numerics.Vector3]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Vector3NaturalMotionAnimation: ...

class Vector4KeyFrameAnimation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Vector4KeyFrameAnimation: ...
    @typing.overload
    def insert_key_frame(self, normalized_progress_key: winrt.system.Single, value: winrt.windows.foundation.numerics.Vector4, /) -> None: ...
    @typing.overload
    def insert_key_frame(self, normalized_progress_key: winrt.system.Single, value: winrt.windows.foundation.numerics.Vector4, easing_function: typing.Optional[CompositionEasingFunction], /) -> None: ...

class Visual(winrt.system.Object):
    transform_matrix: winrt.windows.foundation.numerics.Matrix4x4
    size: winrt.windows.foundation.numerics.Vector2
    scale: winrt.windows.foundation.numerics.Vector3
    rotation_axis: winrt.windows.foundation.numerics.Vector3
    rotation_angle_in_degrees: winrt.system.Single
    rotation_angle: winrt.system.Single
    orientation: winrt.windows.foundation.numerics.Quaternion
    opacity: winrt.system.Single
    offset: winrt.windows.foundation.numerics.Vector3
    is_visible: winrt.system.Boolean
    composite_mode: CompositionCompositeMode
    clip: typing.Optional[CompositionClip]
    center_point: winrt.windows.foundation.numerics.Vector3
    border_mode: CompositionBorderMode
    backface_visibility: CompositionBackfaceVisibility
    anchor_point: winrt.windows.foundation.numerics.Vector2
    parent: typing.Optional[ContainerVisual]
    relative_size_adjustment: winrt.windows.foundation.numerics.Vector2
    relative_offset_adjustment: winrt.windows.foundation.numerics.Vector3
    parent_for_transform: typing.Optional[Visual]
    is_hit_test_visible: winrt.system.Boolean
    is_pixel_snapping_enabled: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Visual: ...

class VisualCollection(winrt.system.Object):
    count: winrt.system.Int32
    def __iter__(self) -> winrt.windows.foundation.collections.IIterator[Visual]: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VisualCollection: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[Visual]]: ...
    def insert_above(self, new_child: typing.Optional[Visual], sibling: typing.Optional[Visual], /) -> None: ...
    def insert_at_bottom(self, new_child: typing.Optional[Visual], /) -> None: ...
    def insert_at_top(self, new_child: typing.Optional[Visual], /) -> None: ...
    def insert_below(self, new_child: typing.Optional[Visual], sibling: typing.Optional[Visual], /) -> None: ...
    def remove(self, child: typing.Optional[Visual], /) -> None: ...
    def remove_all(self) -> None: ...

class VisualUnorderedCollection(winrt.system.Object):
    count: winrt.system.Int32
    def __iter__(self) -> winrt.windows.foundation.collections.IIterator[Visual]: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VisualUnorderedCollection: ...
    def add(self, new_visual: typing.Optional[Visual], /) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[Visual]]: ...
    def remove(self, visual: typing.Optional[Visual], /) -> None: ...
    def remove_all(self) -> None: ...

class IAnimationObject(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IAnimationObject: ...
    def populate_property_info(self, property_name: str, property_info: typing.Optional[AnimationPropertyInfo], /) -> None: ...

class ICompositionAnimationBase(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ICompositionAnimationBase: ...

class ICompositionSupportsSystemBackdrop(winrt.system.Object):
    system_backdrop: typing.Optional[CompositionBrush]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ICompositionSupportsSystemBackdrop: ...

class ICompositionSurface(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ICompositionSurface: ...

class ICompositionSurfaceFacade(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ICompositionSurfaceFacade: ...
    def get_real_surface(self) -> typing.Optional[ICompositionSurface]: ...

class IVisualElement(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IVisualElement: ...

class IVisualElement2(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IVisualElement2: ...
    def get_visual_internal(self) -> typing.Optional[Visual]: ...

