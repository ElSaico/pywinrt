# WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

import datetime
import sys
import types
import typing
import uuid

import winrt.system
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.networking
import winrt.windows.storage.streams

from . import CellularApnAuthenticationType, ConnectionProfileDeleteStatus, DataUsageGranularity, DomainAuthenticationKind, DomainConnectivityLevel, NetworkAuthenticationType, NetworkConnectivityLevel, NetworkCostType, NetworkEncryptionType, NetworkTypes, RoamingStates, TriStates, WwanDataClass, WwanNetworkIPKind, WwanNetworkRegistrationState
from . import NetworkStatusChangedEventHandler

Self = typing.TypeVar('Self')

class NetworkUsageStates:
    roaming: TriStates
    shared: TriStates
    def __init__(self, roaming: TriStates, shared: TriStates) -> None: ...

class AttributedNetworkUsage(winrt.system.Object):
    attribution_id: str
    attribution_name: str
    attribution_thumbnail: typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference]
    bytes_received: winrt.system.UInt64
    bytes_sent: winrt.system.UInt64
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AttributedNetworkUsage: ...

class CellularApnContext(winrt.system.Object):
    user_name: str
    provider_id: str
    password: str
    is_compression_enabled: bool
    authentication_type: CellularApnAuthenticationType
    access_point_name: str
    profile_name: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CellularApnContext: ...
    def __new__(cls: typing.Type[CellularApnContext]) -> CellularApnContext:...

class ConnectionCost(winrt.system.Object):
    approaching_data_limit: bool
    network_cost_type: NetworkCostType
    over_data_limit: bool
    roaming: bool
    background_data_usage_restricted: bool
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ConnectionCost: ...

class ConnectionProfile(winrt.system.Object):
    network_adapter: typing.Optional[NetworkAdapter]
    network_security_settings: typing.Optional[NetworkSecuritySettings]
    profile_name: str
    is_wlan_connection_profile: bool
    is_wwan_connection_profile: bool
    service_provider_guid: typing.Optional[typing.Optional[uuid.UUID]]
    wlan_connection_profile_details: typing.Optional[WlanConnectionProfileDetails]
    wwan_connection_profile_details: typing.Optional[WwanConnectionProfileDetails]
    can_delete: bool
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ConnectionProfile: ...
    def get_attributed_network_usage_async(self, start_time: datetime.datetime, end_time: datetime.datetime, states: NetworkUsageStates, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[AttributedNetworkUsage]]: ...
    def get_connection_cost(self) -> typing.Optional[ConnectionCost]: ...
    def get_connectivity_intervals_async(self, start_time: datetime.datetime, end_time: datetime.datetime, states: NetworkUsageStates, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[ConnectivityInterval]]: ...
    def get_data_plan_status(self) -> typing.Optional[DataPlanStatus]: ...
    def get_domain_connectivity_level(self) -> DomainConnectivityLevel: ...
    @typing.overload
    def get_local_usage(self, start_time: datetime.datetime, end_time: datetime.datetime, /) -> typing.Optional[DataUsage]: ...
    @typing.overload
    def get_local_usage(self, start_time: datetime.datetime, end_time: datetime.datetime, states: RoamingStates, /) -> typing.Optional[DataUsage]: ...
    def get_network_connectivity_level(self) -> NetworkConnectivityLevel: ...
    def get_network_names(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[str]]: ...
    def get_network_usage_async(self, start_time: datetime.datetime, end_time: datetime.datetime, granularity: DataUsageGranularity, states: NetworkUsageStates, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[NetworkUsage]]: ...
    def get_provider_network_usage_async(self, start_time: datetime.datetime, end_time: datetime.datetime, states: NetworkUsageStates, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[ProviderNetworkUsage]]: ...
    def get_signal_bars(self) -> typing.Optional[typing.Optional[winrt.system.UInt8]]: ...
    def is_domain_authenticated_by(self, kind: DomainAuthenticationKind, /) -> bool: ...
    def try_delete_async(self) -> winrt.windows.foundation.IAsyncOperation[ConnectionProfileDeleteStatus]: ...

class ConnectionProfileFilter(winrt.system.Object):
    service_provider_guid: typing.Optional[typing.Optional[uuid.UUID]]
    network_cost_type: NetworkCostType
    is_wwan_connection_profile: bool
    is_wlan_connection_profile: bool
    is_connected: bool
    is_roaming: typing.Optional[typing.Optional[bool]]
    is_over_data_limit: typing.Optional[typing.Optional[bool]]
    is_background_data_usage_restricted: typing.Optional[typing.Optional[bool]]
    raw_data: typing.Optional[winrt.windows.storage.streams.IBuffer]
    purpose_guid: typing.Optional[typing.Optional[uuid.UUID]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ConnectionProfileFilter: ...
    def __new__(cls: typing.Type[ConnectionProfileFilter]) -> ConnectionProfileFilter:...

class ConnectionSession(winrt.system.Object):
    connection_profile: typing.Optional[ConnectionProfile]
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ConnectionSession: ...
    def close(self) -> None: ...

class ConnectivityInterval(winrt.system.Object):
    connection_duration: datetime.timedelta
    start_time: datetime.datetime
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ConnectivityInterval: ...

class ConnectivityManager(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ConnectivityManager: ...
    @staticmethod
    def acquire_connection_async(cellular_apn_context: typing.Optional[CellularApnContext], /) -> winrt.windows.foundation.IAsyncOperation[ConnectionSession]: ...
    @staticmethod
    def add_http_route_policy(route_policy: typing.Optional[RoutePolicy], /) -> None: ...
    @staticmethod
    def remove_http_route_policy(route_policy: typing.Optional[RoutePolicy], /) -> None: ...

class DataPlanStatus(winrt.system.Object):
    data_limit_in_megabytes: typing.Optional[typing.Optional[winrt.system.UInt32]]
    data_plan_usage: typing.Optional[DataPlanUsage]
    inbound_bits_per_second: typing.Optional[typing.Optional[winrt.system.UInt64]]
    max_transfer_size_in_megabytes: typing.Optional[typing.Optional[winrt.system.UInt32]]
    next_billing_cycle: typing.Optional[typing.Optional[datetime.datetime]]
    outbound_bits_per_second: typing.Optional[typing.Optional[winrt.system.UInt64]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DataPlanStatus: ...

class DataPlanUsage(winrt.system.Object):
    last_sync_time: datetime.datetime
    megabytes_used: winrt.system.UInt32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DataPlanUsage: ...

class DataUsage(winrt.system.Object):
    bytes_received: winrt.system.UInt64
    bytes_sent: winrt.system.UInt64
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DataUsage: ...

class IPInformation(winrt.system.Object):
    network_adapter: typing.Optional[NetworkAdapter]
    prefix_length: typing.Optional[typing.Optional[winrt.system.UInt8]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IPInformation: ...

class LanIdentifier(winrt.system.Object):
    infrastructure_id: typing.Optional[LanIdentifierData]
    network_adapter_id: uuid.UUID
    port_id: typing.Optional[LanIdentifierData]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LanIdentifier: ...

class LanIdentifierData(winrt.system.Object):
    type: winrt.system.UInt32
    value: typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.UInt8]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LanIdentifierData: ...

class NetworkAdapter(winrt.system.Object):
    iana_interface_type: winrt.system.UInt32
    inbound_max_bits_per_second: winrt.system.UInt64
    network_adapter_id: uuid.UUID
    network_item: typing.Optional[NetworkItem]
    outbound_max_bits_per_second: winrt.system.UInt64
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NetworkAdapter: ...
    def get_connected_profile_async(self) -> winrt.windows.foundation.IAsyncOperation[ConnectionProfile]: ...

class NetworkInformation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NetworkInformation: ...
    @staticmethod
    def find_connection_profiles_async(p_profile_filter: typing.Optional[ConnectionProfileFilter], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[ConnectionProfile]]: ...
    @staticmethod
    def get_connection_profiles() -> typing.Optional[winrt.windows.foundation.collections.IVectorView[ConnectionProfile]]: ...
    @staticmethod
    def get_host_names() -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.networking.HostName]]: ...
    @staticmethod
    def get_internet_connection_profile() -> typing.Optional[ConnectionProfile]: ...
    @staticmethod
    def get_lan_identifiers() -> typing.Optional[winrt.windows.foundation.collections.IVectorView[LanIdentifier]]: ...
    @staticmethod
    def get_proxy_configuration_async(uri: typing.Optional[winrt.windows.foundation.Uri], /) -> winrt.windows.foundation.IAsyncOperation[ProxyConfiguration]: ...
    @staticmethod
    def get_sorted_endpoint_pairs(destination_list: typing.Iterable[winrt.windows.networking.EndpointPair], sort_options: winrt.windows.networking.HostNameSortOptions, /) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.networking.EndpointPair]]: ...
    @staticmethod
    def add_network_status_changed(network_status_handler: typing.Optional[NetworkStatusChangedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    @staticmethod
    def remove_network_status_changed(event_cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class NetworkItem(winrt.system.Object):
    network_id: uuid.UUID
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NetworkItem: ...
    def get_network_types(self) -> NetworkTypes: ...

class NetworkSecuritySettings(winrt.system.Object):
    network_authentication_type: NetworkAuthenticationType
    network_encryption_type: NetworkEncryptionType
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NetworkSecuritySettings: ...

class NetworkStateChangeEventDetails(winrt.system.Object):
    has_new_connection_cost: bool
    has_new_domain_connectivity_level: bool
    has_new_host_name_list: bool
    has_new_internet_connection_profile: bool
    has_new_network_connectivity_level: bool
    has_new_wwan_registration_state: bool
    has_new_tethering_client_count: bool
    has_new_tethering_operational_state: bool
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NetworkStateChangeEventDetails: ...

class NetworkUsage(winrt.system.Object):
    bytes_received: winrt.system.UInt64
    bytes_sent: winrt.system.UInt64
    connection_duration: datetime.timedelta
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NetworkUsage: ...

class ProviderNetworkUsage(winrt.system.Object):
    bytes_received: winrt.system.UInt64
    bytes_sent: winrt.system.UInt64
    provider_id: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProviderNetworkUsage: ...

class ProxyConfiguration(winrt.system.Object):
    can_connect_directly: bool
    proxy_uris: typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.foundation.Uri]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProxyConfiguration: ...

class RoutePolicy(winrt.system.Object):
    connection_profile: typing.Optional[ConnectionProfile]
    host_name: typing.Optional[winrt.windows.networking.HostName]
    host_name_type: winrt.windows.networking.DomainNameType
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RoutePolicy: ...
    def __new__(cls: typing.Type[RoutePolicy], connection_profile: typing.Optional[ConnectionProfile], host_name: typing.Optional[winrt.windows.networking.HostName], type: winrt.windows.networking.DomainNameType) -> RoutePolicy:...

class WlanConnectionProfileDetails(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WlanConnectionProfileDetails: ...
    def get_connected_ssid(self) -> str: ...

class WwanConnectionProfileDetails(winrt.system.Object):
    access_point_name: str
    home_provider_id: str
    i_p_kind: WwanNetworkIPKind
    purpose_guids: typing.Optional[winrt.windows.foundation.collections.IVectorView[uuid.UUID]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WwanConnectionProfileDetails: ...
    def get_current_data_class(self) -> WwanDataClass: ...
    def get_network_registration_state(self) -> WwanNetworkRegistrationState: ...

