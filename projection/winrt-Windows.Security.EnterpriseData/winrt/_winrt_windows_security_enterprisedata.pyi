# WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt.system
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.networking
import winrt.windows.storage
import winrt.windows.storage.streams

from winrt.windows.security.enterprisedata import DataProtectionStatus, EnforcementLevel, FileProtectionStatus, ProtectedImportExportStatus, ProtectionPolicyAuditAction, ProtectionPolicyEvaluationResult, ProtectionPolicyRequestAccessBehavior

Self = typing.TypeVar('Self')

class BufferProtectUnprotectResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BufferProtectUnprotectResult: ...
    @_property
    def buffer(self) -> typing.Optional[winrt.windows.storage.streams.IBuffer]: ...
    @_property
    def protection_info(self) -> typing.Optional[DataProtectionInfo]: ...

class DataProtectionInfo(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DataProtectionInfo: ...
    @_property
    def identity(self) -> str: ...
    @_property
    def status(self) -> DataProtectionStatus: ...

class DataProtectionManager(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DataProtectionManager: ...
    @staticmethod
    def get_protection_info_async(protected_data: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> winrt.windows.foundation.IAsyncOperation[DataProtectionInfo]: ...
    @staticmethod
    def get_stream_protection_info_async(protected_stream: typing.Optional[winrt.windows.storage.streams.IInputStream], /) -> winrt.windows.foundation.IAsyncOperation[DataProtectionInfo]: ...
    @staticmethod
    def protect_async(data: typing.Optional[winrt.windows.storage.streams.IBuffer], identity: str, /) -> winrt.windows.foundation.IAsyncOperation[BufferProtectUnprotectResult]: ...
    @staticmethod
    def protect_stream_async(unprotected_stream: typing.Optional[winrt.windows.storage.streams.IInputStream], identity: str, protected_stream: typing.Optional[winrt.windows.storage.streams.IOutputStream], /) -> winrt.windows.foundation.IAsyncOperation[DataProtectionInfo]: ...
    @staticmethod
    def unprotect_async(data: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> winrt.windows.foundation.IAsyncOperation[BufferProtectUnprotectResult]: ...
    @staticmethod
    def unprotect_stream_async(protected_stream: typing.Optional[winrt.windows.storage.streams.IInputStream], unprotected_stream: typing.Optional[winrt.windows.storage.streams.IOutputStream], /) -> winrt.windows.foundation.IAsyncOperation[DataProtectionInfo]: ...

class FileProtectionInfo(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FileProtectionInfo: ...
    @_property
    def identity(self) -> str: ...
    @_property
    def is_roamable(self) -> bool: ...
    @_property
    def status(self) -> FileProtectionStatus: ...
    @_property
    def is_protect_while_open_supported(self) -> bool: ...

class FileProtectionManager(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FileProtectionManager: ...
    @staticmethod
    def copy_protection_async(source: typing.Optional[winrt.windows.storage.IStorageItem], target: typing.Optional[winrt.windows.storage.IStorageItem], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @staticmethod
    def create_protected_and_open_async(parent_folder: typing.Optional[winrt.windows.storage.IStorageFolder], desired_name: str, identity: str, collision_option: winrt.windows.storage.CreationCollisionOption, /) -> winrt.windows.foundation.IAsyncOperation[ProtectedFileCreateResult]: ...
    @staticmethod
    def get_protection_info_async(source: typing.Optional[winrt.windows.storage.IStorageItem], /) -> winrt.windows.foundation.IAsyncOperation[FileProtectionInfo]: ...
    @staticmethod
    def is_container_async(file: typing.Optional[winrt.windows.storage.IStorageFile], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @typing.overload
    @staticmethod
    def load_file_from_container_async(container_file: typing.Optional[winrt.windows.storage.IStorageFile], /) -> winrt.windows.foundation.IAsyncOperation[ProtectedContainerImportResult]: ...
    @typing.overload
    @staticmethod
    def load_file_from_container_async(container_file: typing.Optional[winrt.windows.storage.IStorageFile], target: typing.Optional[winrt.windows.storage.IStorageItem], /) -> winrt.windows.foundation.IAsyncOperation[ProtectedContainerImportResult]: ...
    @typing.overload
    @staticmethod
    def load_file_from_container_async(container_file: typing.Optional[winrt.windows.storage.IStorageFile], target: typing.Optional[winrt.windows.storage.IStorageItem], collision_option: winrt.windows.storage.NameCollisionOption, /) -> winrt.windows.foundation.IAsyncOperation[ProtectedContainerImportResult]: ...
    @staticmethod
    def protect_async(target: typing.Optional[winrt.windows.storage.IStorageItem], identity: str, /) -> winrt.windows.foundation.IAsyncOperation[FileProtectionInfo]: ...
    @typing.overload
    @staticmethod
    def save_file_as_container_async(protected_file: typing.Optional[winrt.windows.storage.IStorageFile], /) -> winrt.windows.foundation.IAsyncOperation[ProtectedContainerExportResult]: ...
    @typing.overload
    @staticmethod
    def save_file_as_container_async(protected_file: typing.Optional[winrt.windows.storage.IStorageFile], shared_with_identities: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncOperation[ProtectedContainerExportResult]: ...
    @typing.overload
    @staticmethod
    def unprotect_async(target: typing.Optional[winrt.windows.storage.IStorageItem], /) -> winrt.windows.foundation.IAsyncOperation[FileProtectionInfo]: ...
    @typing.overload
    @staticmethod
    def unprotect_async(target: typing.Optional[winrt.windows.storage.IStorageItem], options: typing.Optional[FileUnprotectOptions], /) -> winrt.windows.foundation.IAsyncOperation[FileProtectionInfo]: ...

class FileRevocationManager(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FileRevocationManager: ...
    @staticmethod
    def copy_protection_async(source_storage_item: typing.Optional[winrt.windows.storage.IStorageItem], target_storage_item: typing.Optional[winrt.windows.storage.IStorageItem], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @staticmethod
    def get_status_async(storage_item: typing.Optional[winrt.windows.storage.IStorageItem], /) -> winrt.windows.foundation.IAsyncOperation[FileProtectionStatus]: ...
    @staticmethod
    def protect_async(storage_item: typing.Optional[winrt.windows.storage.IStorageItem], enterprise_identity: str, /) -> winrt.windows.foundation.IAsyncOperation[FileProtectionStatus]: ...
    @staticmethod
    def revoke(enterprise_identity: str, /) -> None: ...

class FileUnprotectOptions(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FileUnprotectOptions: ...
    def __new__(cls: typing.Type[FileUnprotectOptions], audit: bool) -> FileUnprotectOptions:...
    @_property
    def audit(self) -> bool: ...
    @audit.setter
    def audit(self, value: bool) -> None: ...

class ProtectedAccessResumedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProtectedAccessResumedEventArgs: ...
    @_property
    def identities(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[str]]: ...

class ProtectedAccessSuspendingEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProtectedAccessSuspendingEventArgs: ...
    def get_deferral(self) -> typing.Optional[winrt.windows.foundation.Deferral]: ...
    @_property
    def deadline(self) -> datetime.datetime: ...
    @_property
    def identities(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[str]]: ...

class ProtectedContainerExportResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProtectedContainerExportResult: ...
    @_property
    def file(self) -> typing.Optional[winrt.windows.storage.StorageFile]: ...
    @_property
    def status(self) -> ProtectedImportExportStatus: ...

class ProtectedContainerImportResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProtectedContainerImportResult: ...
    @_property
    def file(self) -> typing.Optional[winrt.windows.storage.StorageFile]: ...
    @_property
    def status(self) -> ProtectedImportExportStatus: ...

class ProtectedContentRevokedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProtectedContentRevokedEventArgs: ...
    @_property
    def identities(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[str]]: ...

class ProtectedFileCreateResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProtectedFileCreateResult: ...
    @_property
    def file(self) -> typing.Optional[winrt.windows.storage.StorageFile]: ...
    @_property
    def protection_info(self) -> typing.Optional[FileProtectionInfo]: ...
    @_property
    def stream(self) -> typing.Optional[winrt.windows.storage.streams.IRandomAccessStream]: ...

class ProtectionPolicyAuditInfo(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProtectionPolicyAuditInfo: ...
    @typing.overload
    def __new__(cls: typing.Type[ProtectionPolicyAuditInfo], action: ProtectionPolicyAuditAction, data_description: str, source_description: str, target_description: str) -> ProtectionPolicyAuditInfo:...
    @typing.overload
    def __new__(cls: typing.Type[ProtectionPolicyAuditInfo], action: ProtectionPolicyAuditAction, data_description: str) -> ProtectionPolicyAuditInfo:...
    @_property
    def target_description(self) -> str: ...
    @target_description.setter
    def target_description(self, value: str) -> None: ...
    @_property
    def source_description(self) -> str: ...
    @source_description.setter
    def source_description(self, value: str) -> None: ...
    @_property
    def data_description(self) -> str: ...
    @data_description.setter
    def data_description(self, value: str) -> None: ...
    @_property
    def action(self) -> ProtectionPolicyAuditAction: ...
    @action.setter
    def action(self, value: ProtectionPolicyAuditAction) -> None: ...

class ProtectionPolicyManager(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProtectionPolicyManager: ...
    @staticmethod
    def check_access(source_identity: str, target_identity: str, /) -> ProtectionPolicyEvaluationResult: ...
    @staticmethod
    def check_access_for_app(source_identity: str, app_package_family_name: str, /) -> ProtectionPolicyEvaluationResult: ...
    @staticmethod
    def clear_process_u_i_policy() -> None: ...
    @staticmethod
    def create_current_thread_network_context(identity: str, /) -> typing.Optional[ThreadNetworkContext]: ...
    @staticmethod
    def get_enforcement_level(identity: str, /) -> EnforcementLevel: ...
    @staticmethod
    def get_for_current_view() -> typing.Optional[ProtectionPolicyManager]: ...
    @staticmethod
    def get_primary_managed_identity_for_identity(identity: str, /) -> str: ...
    @staticmethod
    def get_primary_managed_identity_for_network_endpoint_async(endpoint_host: typing.Optional[winrt.windows.networking.HostName], /) -> winrt.windows.foundation.IAsyncOperation[str]: ...
    @staticmethod
    def has_content_been_revoked_since(identity: str, since: datetime.datetime, /) -> bool: ...
    @staticmethod
    def is_file_protection_required_async(target: typing.Optional[winrt.windows.storage.IStorageItem], identity: str, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @staticmethod
    def is_file_protection_required_for_new_file_async(parent_folder: typing.Optional[winrt.windows.storage.IStorageFolder], identity: str, desired_name: str, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @staticmethod
    def is_identity_managed(identity: str, /) -> bool: ...
    @staticmethod
    def is_protection_under_lock_required(identity: str, /) -> bool: ...
    @staticmethod
    def is_roamable_protection_enabled(identity: str, /) -> bool: ...
    @staticmethod
    def is_user_decryption_allowed(identity: str, /) -> bool: ...
    @staticmethod
    def log_audit_event(source_identity: str, target_identity: str, audit_info: typing.Optional[ProtectionPolicyAuditInfo], /) -> None: ...
    @typing.overload
    @staticmethod
    def request_access_async(source_identity: str, target_identity: str, /) -> winrt.windows.foundation.IAsyncOperation[ProtectionPolicyEvaluationResult]: ...
    @typing.overload
    @staticmethod
    def request_access_async(source_identity: str, target_identity: str, audit_info: typing.Optional[ProtectionPolicyAuditInfo], /) -> winrt.windows.foundation.IAsyncOperation[ProtectionPolicyEvaluationResult]: ...
    @typing.overload
    @staticmethod
    def request_access_async(source_identity: str, target_identity: str, audit_info: typing.Optional[ProtectionPolicyAuditInfo], message_from_app: str, /) -> winrt.windows.foundation.IAsyncOperation[ProtectionPolicyEvaluationResult]: ...
    @typing.overload
    @staticmethod
    def request_access_async(source_identity: str, target_identity: str, audit_info: typing.Optional[ProtectionPolicyAuditInfo], message_from_app: str, behavior: ProtectionPolicyRequestAccessBehavior, /) -> winrt.windows.foundation.IAsyncOperation[ProtectionPolicyEvaluationResult]: ...
    @typing.overload
    @staticmethod
    def request_access_for_app_async(source_identity: str, app_package_family_name: str, /) -> winrt.windows.foundation.IAsyncOperation[ProtectionPolicyEvaluationResult]: ...
    @typing.overload
    @staticmethod
    def request_access_for_app_async(source_identity: str, app_package_family_name: str, audit_info: typing.Optional[ProtectionPolicyAuditInfo], /) -> winrt.windows.foundation.IAsyncOperation[ProtectionPolicyEvaluationResult]: ...
    @typing.overload
    @staticmethod
    def request_access_for_app_async(source_identity: str, app_package_family_name: str, audit_info: typing.Optional[ProtectionPolicyAuditInfo], message_from_app: str, /) -> winrt.windows.foundation.IAsyncOperation[ProtectionPolicyEvaluationResult]: ...
    @typing.overload
    @staticmethod
    def request_access_for_app_async(source_identity: str, app_package_family_name: str, audit_info: typing.Optional[ProtectionPolicyAuditInfo], message_from_app: str, behavior: ProtectionPolicyRequestAccessBehavior, /) -> winrt.windows.foundation.IAsyncOperation[ProtectionPolicyEvaluationResult]: ...
    @typing.overload
    @staticmethod
    def request_access_to_files_for_app_async(source_item_list: typing.Iterable[winrt.windows.storage.IStorageItem], app_package_family_name: str, audit_info: typing.Optional[ProtectionPolicyAuditInfo], /) -> winrt.windows.foundation.IAsyncOperation[ProtectionPolicyEvaluationResult]: ...
    @typing.overload
    @staticmethod
    def request_access_to_files_for_app_async(source_item_list: typing.Iterable[winrt.windows.storage.IStorageItem], app_package_family_name: str, audit_info: typing.Optional[ProtectionPolicyAuditInfo], message_from_app: str, behavior: ProtectionPolicyRequestAccessBehavior, /) -> winrt.windows.foundation.IAsyncOperation[ProtectionPolicyEvaluationResult]: ...
    @typing.overload
    @staticmethod
    def request_access_to_files_for_process_async(source_item_list: typing.Iterable[winrt.windows.storage.IStorageItem], process_id: winrt.system.UInt32, audit_info: typing.Optional[ProtectionPolicyAuditInfo], /) -> winrt.windows.foundation.IAsyncOperation[ProtectionPolicyEvaluationResult]: ...
    @typing.overload
    @staticmethod
    def request_access_to_files_for_process_async(source_item_list: typing.Iterable[winrt.windows.storage.IStorageItem], process_id: winrt.system.UInt32, audit_info: typing.Optional[ProtectionPolicyAuditInfo], message_from_app: str, behavior: ProtectionPolicyRequestAccessBehavior, /) -> winrt.windows.foundation.IAsyncOperation[ProtectionPolicyEvaluationResult]: ...
    @staticmethod
    def revoke_content(identity: str, /) -> None: ...
    @staticmethod
    def try_apply_process_u_i_policy(identity: str, /) -> bool: ...
    @staticmethod
    def add_policy_changed(handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    @staticmethod
    def remove_policy_changed(token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @staticmethod
    def add_protected_access_resumed(handler: winrt.windows.foundation.EventHandler[ProtectedAccessResumedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    @staticmethod
    def remove_protected_access_resumed(token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @staticmethod
    def add_protected_access_suspending(handler: winrt.windows.foundation.EventHandler[ProtectedAccessSuspendingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    @staticmethod
    def remove_protected_access_suspending(token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @staticmethod
    def add_protected_content_revoked(handler: winrt.windows.foundation.EventHandler[ProtectedContentRevokedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    @staticmethod
    def remove_protected_content_revoked(token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def identity(self) -> str: ...
    @identity.setter
    def identity(self, value: str) -> None: ...
    @_property
    def show_enterprise_indicator(self) -> bool: ...
    @show_enterprise_indicator.setter
    def show_enterprise_indicator(self, value: bool) -> None: ...
    is_protection_enabled: typing.ClassVar[bool]
    primary_managed_identity: typing.ClassVar[str]

class ThreadNetworkContext(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ThreadNetworkContext: ...
    def close(self) -> None: ...

