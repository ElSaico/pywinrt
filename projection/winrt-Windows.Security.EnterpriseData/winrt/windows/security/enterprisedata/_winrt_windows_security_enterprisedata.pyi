# WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

import datetime
import sys
import types
import typing
import uuid

import winrt.system
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.networking
import winrt.windows.storage
import winrt.windows.storage.streams

from . import DataProtectionStatus, EnforcementLevel, FileProtectionStatus, ProtectedImportExportStatus, ProtectionPolicyAuditAction, ProtectionPolicyEvaluationResult, ProtectionPolicyRequestAccessBehavior

Self = typing.TypeVar('Self')

class BufferProtectUnprotectResult(winrt.system.Object):
    buffer: typing.Optional[winrt.windows.storage.streams.IBuffer]
    protection_info: typing.Optional[DataProtectionInfo]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BufferProtectUnprotectResult: ...

class DataProtectionInfo(winrt.system.Object):
    identity: str
    status: DataProtectionStatus
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DataProtectionInfo: ...

class DataProtectionManager(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DataProtectionManager: ...
    @staticmethod
    def get_protection_info_async(protected_data: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> winrt.windows.foundation.IAsyncOperation[DataProtectionInfo]: ...
    @staticmethod
    def get_stream_protection_info_async(protected_stream: typing.Optional[winrt.windows.storage.streams.IInputStream], /) -> winrt.windows.foundation.IAsyncOperation[DataProtectionInfo]: ...
    @staticmethod
    def protect_async(data: typing.Optional[winrt.windows.storage.streams.IBuffer], identity: str, /) -> winrt.windows.foundation.IAsyncOperation[BufferProtectUnprotectResult]: ...
    @staticmethod
    def protect_stream_async(unprotected_stream: typing.Optional[winrt.windows.storage.streams.IInputStream], identity: str, protected_stream: typing.Optional[winrt.windows.storage.streams.IOutputStream], /) -> winrt.windows.foundation.IAsyncOperation[DataProtectionInfo]: ...
    @staticmethod
    def unprotect_async(data: typing.Optional[winrt.windows.storage.streams.IBuffer], /) -> winrt.windows.foundation.IAsyncOperation[BufferProtectUnprotectResult]: ...
    @staticmethod
    def unprotect_stream_async(protected_stream: typing.Optional[winrt.windows.storage.streams.IInputStream], unprotected_stream: typing.Optional[winrt.windows.storage.streams.IOutputStream], /) -> winrt.windows.foundation.IAsyncOperation[DataProtectionInfo]: ...

class FileProtectionInfo(winrt.system.Object):
    identity: str
    is_roamable: winrt.system.Boolean
    status: FileProtectionStatus
    is_protect_while_open_supported: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FileProtectionInfo: ...

class FileProtectionManager(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FileProtectionManager: ...
    @staticmethod
    def copy_protection_async(source: typing.Optional[winrt.windows.storage.IStorageItem], target: typing.Optional[winrt.windows.storage.IStorageItem], /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...
    @staticmethod
    def create_protected_and_open_async(parent_folder: typing.Optional[winrt.windows.storage.IStorageFolder], desired_name: str, identity: str, collision_option: winrt.windows.storage.CreationCollisionOption, /) -> winrt.windows.foundation.IAsyncOperation[ProtectedFileCreateResult]: ...
    @staticmethod
    def get_protection_info_async(source: typing.Optional[winrt.windows.storage.IStorageItem], /) -> winrt.windows.foundation.IAsyncOperation[FileProtectionInfo]: ...
    @staticmethod
    def is_container_async(file: typing.Optional[winrt.windows.storage.IStorageFile], /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...
    @typing.overload
    @staticmethod
    def load_file_from_container_async(container_file: typing.Optional[winrt.windows.storage.IStorageFile], /) -> winrt.windows.foundation.IAsyncOperation[ProtectedContainerImportResult]: ...
    @typing.overload
    @staticmethod
    def load_file_from_container_async(container_file: typing.Optional[winrt.windows.storage.IStorageFile], target: typing.Optional[winrt.windows.storage.IStorageItem], /) -> winrt.windows.foundation.IAsyncOperation[ProtectedContainerImportResult]: ...
    @typing.overload
    @staticmethod
    def load_file_from_container_async(container_file: typing.Optional[winrt.windows.storage.IStorageFile], target: typing.Optional[winrt.windows.storage.IStorageItem], collision_option: winrt.windows.storage.NameCollisionOption, /) -> winrt.windows.foundation.IAsyncOperation[ProtectedContainerImportResult]: ...
    @staticmethod
    def protect_async(target: typing.Optional[winrt.windows.storage.IStorageItem], identity: str, /) -> winrt.windows.foundation.IAsyncOperation[FileProtectionInfo]: ...
    @typing.overload
    @staticmethod
    def save_file_as_container_async(protected_file: typing.Optional[winrt.windows.storage.IStorageFile], /) -> winrt.windows.foundation.IAsyncOperation[ProtectedContainerExportResult]: ...
    @typing.overload
    @staticmethod
    def save_file_as_container_async(protected_file: typing.Optional[winrt.windows.storage.IStorageFile], shared_with_identities: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncOperation[ProtectedContainerExportResult]: ...
    @typing.overload
    @staticmethod
    def unprotect_async(target: typing.Optional[winrt.windows.storage.IStorageItem], /) -> winrt.windows.foundation.IAsyncOperation[FileProtectionInfo]: ...
    @typing.overload
    @staticmethod
    def unprotect_async(target: typing.Optional[winrt.windows.storage.IStorageItem], options: typing.Optional[FileUnprotectOptions], /) -> winrt.windows.foundation.IAsyncOperation[FileProtectionInfo]: ...

class FileRevocationManager(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FileRevocationManager: ...
    @staticmethod
    def copy_protection_async(source_storage_item: typing.Optional[winrt.windows.storage.IStorageItem], target_storage_item: typing.Optional[winrt.windows.storage.IStorageItem], /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...
    @staticmethod
    def get_status_async(storage_item: typing.Optional[winrt.windows.storage.IStorageItem], /) -> winrt.windows.foundation.IAsyncOperation[FileProtectionStatus]: ...
    @staticmethod
    def protect_async(storage_item: typing.Optional[winrt.windows.storage.IStorageItem], enterprise_identity: str, /) -> winrt.windows.foundation.IAsyncOperation[FileProtectionStatus]: ...
    @staticmethod
    def revoke(enterprise_identity: str, /) -> None: ...

class FileUnprotectOptions(winrt.system.Object):
    audit: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FileUnprotectOptions: ...
    def __new__(cls: typing.Type[FileUnprotectOptions], audit: winrt.system.Boolean) -> FileUnprotectOptions:...

class ProtectedAccessResumedEventArgs(winrt.system.Object):
    identities: typing.Optional[winrt.windows.foundation.collections.IVectorView[str]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProtectedAccessResumedEventArgs: ...

class ProtectedAccessSuspendingEventArgs(winrt.system.Object):
    deadline: datetime.datetime
    identities: typing.Optional[winrt.windows.foundation.collections.IVectorView[str]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProtectedAccessSuspendingEventArgs: ...
    def get_deferral(self) -> typing.Optional[winrt.windows.foundation.Deferral]: ...

class ProtectedContainerExportResult(winrt.system.Object):
    file: typing.Optional[winrt.windows.storage.StorageFile]
    status: ProtectedImportExportStatus
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProtectedContainerExportResult: ...

class ProtectedContainerImportResult(winrt.system.Object):
    file: typing.Optional[winrt.windows.storage.StorageFile]
    status: ProtectedImportExportStatus
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProtectedContainerImportResult: ...

class ProtectedContentRevokedEventArgs(winrt.system.Object):
    identities: typing.Optional[winrt.windows.foundation.collections.IVectorView[str]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProtectedContentRevokedEventArgs: ...

class ProtectedFileCreateResult(winrt.system.Object):
    file: typing.Optional[winrt.windows.storage.StorageFile]
    protection_info: typing.Optional[FileProtectionInfo]
    stream: typing.Optional[winrt.windows.storage.streams.IRandomAccessStream]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProtectedFileCreateResult: ...

class ProtectionPolicyAuditInfo(winrt.system.Object):
    target_description: str
    source_description: str
    data_description: str
    action: ProtectionPolicyAuditAction
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProtectionPolicyAuditInfo: ...
    @typing.overload
    def __new__(cls: typing.Type[ProtectionPolicyAuditInfo], action: ProtectionPolicyAuditAction, data_description: str, source_description: str, target_description: str) -> ProtectionPolicyAuditInfo:...
    @typing.overload
    def __new__(cls: typing.Type[ProtectionPolicyAuditInfo], action: ProtectionPolicyAuditAction, data_description: str) -> ProtectionPolicyAuditInfo:...

class ProtectionPolicyManager(winrt.system.Object):
    identity: str
    show_enterprise_indicator: winrt.system.Boolean
    is_protection_enabled: typing.ClassVar[winrt.system.Boolean]
    primary_managed_identity: typing.ClassVar[str]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProtectionPolicyManager: ...
    @staticmethod
    def check_access(source_identity: str, target_identity: str, /) -> ProtectionPolicyEvaluationResult: ...
    @staticmethod
    def check_access_for_app(source_identity: str, app_package_family_name: str, /) -> ProtectionPolicyEvaluationResult: ...
    @staticmethod
    def clear_process_u_i_policy() -> None: ...
    @staticmethod
    def create_current_thread_network_context(identity: str, /) -> typing.Optional[ThreadNetworkContext]: ...
    @staticmethod
    def get_enforcement_level(identity: str, /) -> EnforcementLevel: ...
    @staticmethod
    def get_for_current_view() -> typing.Optional[ProtectionPolicyManager]: ...
    @staticmethod
    def get_primary_managed_identity_for_identity(identity: str, /) -> str: ...
    @staticmethod
    def get_primary_managed_identity_for_network_endpoint_async(endpoint_host: typing.Optional[winrt.windows.networking.HostName], /) -> winrt.windows.foundation.IAsyncOperation[str]: ...
    @staticmethod
    def has_content_been_revoked_since(identity: str, since: datetime.datetime, /) -> winrt.system.Boolean: ...
    @staticmethod
    def is_file_protection_required_async(target: typing.Optional[winrt.windows.storage.IStorageItem], identity: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...
    @staticmethod
    def is_file_protection_required_for_new_file_async(parent_folder: typing.Optional[winrt.windows.storage.IStorageFolder], identity: str, desired_name: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Boolean]: ...
    @staticmethod
    def is_identity_managed(identity: str, /) -> winrt.system.Boolean: ...
    @staticmethod
    def is_protection_under_lock_required(identity: str, /) -> winrt.system.Boolean: ...
    @staticmethod
    def is_roamable_protection_enabled(identity: str, /) -> winrt.system.Boolean: ...
    @staticmethod
    def is_user_decryption_allowed(identity: str, /) -> winrt.system.Boolean: ...
    @staticmethod
    def log_audit_event(source_identity: str, target_identity: str, audit_info: typing.Optional[ProtectionPolicyAuditInfo], /) -> None: ...
    @typing.overload
    @staticmethod
    def request_access_async(source_identity: str, target_identity: str, /) -> winrt.windows.foundation.IAsyncOperation[ProtectionPolicyEvaluationResult]: ...
    @typing.overload
    @staticmethod
    def request_access_async(source_identity: str, target_identity: str, audit_info: typing.Optional[ProtectionPolicyAuditInfo], /) -> winrt.windows.foundation.IAsyncOperation[ProtectionPolicyEvaluationResult]: ...
    @typing.overload
    @staticmethod
    def request_access_async(source_identity: str, target_identity: str, audit_info: typing.Optional[ProtectionPolicyAuditInfo], message_from_app: str, /) -> winrt.windows.foundation.IAsyncOperation[ProtectionPolicyEvaluationResult]: ...
    @typing.overload
    @staticmethod
    def request_access_async(source_identity: str, target_identity: str, audit_info: typing.Optional[ProtectionPolicyAuditInfo], message_from_app: str, behavior: ProtectionPolicyRequestAccessBehavior, /) -> winrt.windows.foundation.IAsyncOperation[ProtectionPolicyEvaluationResult]: ...
    @typing.overload
    @staticmethod
    def request_access_for_app_async(source_identity: str, app_package_family_name: str, /) -> winrt.windows.foundation.IAsyncOperation[ProtectionPolicyEvaluationResult]: ...
    @typing.overload
    @staticmethod
    def request_access_for_app_async(source_identity: str, app_package_family_name: str, audit_info: typing.Optional[ProtectionPolicyAuditInfo], /) -> winrt.windows.foundation.IAsyncOperation[ProtectionPolicyEvaluationResult]: ...
    @typing.overload
    @staticmethod
    def request_access_for_app_async(source_identity: str, app_package_family_name: str, audit_info: typing.Optional[ProtectionPolicyAuditInfo], message_from_app: str, /) -> winrt.windows.foundation.IAsyncOperation[ProtectionPolicyEvaluationResult]: ...
    @typing.overload
    @staticmethod
    def request_access_for_app_async(source_identity: str, app_package_family_name: str, audit_info: typing.Optional[ProtectionPolicyAuditInfo], message_from_app: str, behavior: ProtectionPolicyRequestAccessBehavior, /) -> winrt.windows.foundation.IAsyncOperation[ProtectionPolicyEvaluationResult]: ...
    @typing.overload
    @staticmethod
    def request_access_to_files_for_app_async(source_item_list: typing.Iterable[winrt.windows.storage.IStorageItem], app_package_family_name: str, audit_info: typing.Optional[ProtectionPolicyAuditInfo], /) -> winrt.windows.foundation.IAsyncOperation[ProtectionPolicyEvaluationResult]: ...
    @typing.overload
    @staticmethod
    def request_access_to_files_for_app_async(source_item_list: typing.Iterable[winrt.windows.storage.IStorageItem], app_package_family_name: str, audit_info: typing.Optional[ProtectionPolicyAuditInfo], message_from_app: str, behavior: ProtectionPolicyRequestAccessBehavior, /) -> winrt.windows.foundation.IAsyncOperation[ProtectionPolicyEvaluationResult]: ...
    @typing.overload
    @staticmethod
    def request_access_to_files_for_process_async(source_item_list: typing.Iterable[winrt.windows.storage.IStorageItem], process_id: winrt.system.UInt32, audit_info: typing.Optional[ProtectionPolicyAuditInfo], /) -> winrt.windows.foundation.IAsyncOperation[ProtectionPolicyEvaluationResult]: ...
    @typing.overload
    @staticmethod
    def request_access_to_files_for_process_async(source_item_list: typing.Iterable[winrt.windows.storage.IStorageItem], process_id: winrt.system.UInt32, audit_info: typing.Optional[ProtectionPolicyAuditInfo], message_from_app: str, behavior: ProtectionPolicyRequestAccessBehavior, /) -> winrt.windows.foundation.IAsyncOperation[ProtectionPolicyEvaluationResult]: ...
    @staticmethod
    def revoke_content(identity: str, /) -> None: ...
    @staticmethod
    def try_apply_process_u_i_policy(identity: str, /) -> winrt.system.Boolean: ...
    @staticmethod
    def add_policy_changed(handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    @staticmethod
    def remove_policy_changed(token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @staticmethod
    def add_protected_access_resumed(handler: winrt.windows.foundation.EventHandler[ProtectedAccessResumedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    @staticmethod
    def remove_protected_access_resumed(token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @staticmethod
    def add_protected_access_suspending(handler: winrt.windows.foundation.EventHandler[ProtectedAccessSuspendingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    @staticmethod
    def remove_protected_access_suspending(token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @staticmethod
    def add_protected_content_revoked(handler: winrt.windows.foundation.EventHandler[ProtectedContentRevokedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    @staticmethod
    def remove_protected_content_revoked(token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class ThreadNetworkContext(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ThreadNetworkContext: ...
    def close(self) -> None: ...

