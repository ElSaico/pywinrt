# WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

import datetime
import sys
import types
import typing

import winrt.system
import winrt.windows.devices.haptics
import winrt.windows.devices.input
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.storage.streams
import winrt.windows.system
import winrt.windows.ui.core

from . import CrossSlidingState, DraggingState, EdgeGestureKind, GazeInputAccessStatus, GestureSettings, HoldingState, InputActivationState, PointerUpdateKind, RadialControllerMenuKnownIcon, RadialControllerSystemMenuItemKind

Self = typing.TypeVar('Self')

class CrossSlideThresholds:
    selection_start: winrt.system.Single
    speed_bump_start: winrt.system.Single
    speed_bump_end: winrt.system.Single
    rearrange_start: winrt.system.Single
    def __new__(cls: typing.Type[CrossSlideThresholds], selection_start: winrt.system.Single, speed_bump_start: winrt.system.Single, speed_bump_end: winrt.system.Single, rearrange_start: winrt.system.Single) -> CrossSlideThresholds: ...

class ManipulationDelta:
    translation: winrt.windows.foundation.Point
    scale: winrt.system.Single
    rotation: winrt.system.Single
    expansion: winrt.system.Single
    def __new__(cls: typing.Type[ManipulationDelta], translation: winrt.windows.foundation.Point, scale: winrt.system.Single, rotation: winrt.system.Single, expansion: winrt.system.Single) -> ManipulationDelta: ...

class ManipulationVelocities:
    linear: winrt.windows.foundation.Point
    angular: winrt.system.Single
    expansion: winrt.system.Single
    def __new__(cls: typing.Type[ManipulationVelocities], linear: winrt.windows.foundation.Point, angular: winrt.system.Single, expansion: winrt.system.Single) -> ManipulationVelocities: ...

class AttachableInputObject(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AttachableInputObject: ...
    def close(self) -> None: ...

class CrossSlidingEventArgs(winrt.system.Object):
    cross_sliding_state: CrossSlidingState
    pointer_device_type: winrt.windows.devices.input.PointerDeviceType
    position: winrt.windows.foundation.Point
    contact_count: winrt.system.UInt32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CrossSlidingEventArgs: ...

class DraggingEventArgs(winrt.system.Object):
    dragging_state: DraggingState
    pointer_device_type: winrt.windows.devices.input.PointerDeviceType
    position: winrt.windows.foundation.Point
    contact_count: winrt.system.UInt32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DraggingEventArgs: ...

class EdgeGesture(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EdgeGesture: ...
    @staticmethod
    def get_for_current_view() -> typing.Optional[EdgeGesture]: ...
    def add_canceled(self, handler: winrt.windows.foundation.TypedEventHandler[EdgeGesture, EdgeGestureEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_canceled(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_completed(self, handler: winrt.windows.foundation.TypedEventHandler[EdgeGesture, EdgeGestureEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_starting(self, handler: winrt.windows.foundation.TypedEventHandler[EdgeGesture, EdgeGestureEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_starting(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class EdgeGestureEventArgs(winrt.system.Object):
    kind: EdgeGestureKind
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EdgeGestureEventArgs: ...

class GestureRecognizer(winrt.system.Object):
    show_gesture_feedback: winrt.system.Boolean
    pivot_radius: winrt.system.Single
    pivot_center: winrt.windows.foundation.Point
    manipulation_exact: winrt.system.Boolean
    inertia_translation_displacement: winrt.system.Single
    inertia_translation_deceleration: winrt.system.Single
    inertia_rotation_deceleration: winrt.system.Single
    inertia_rotation_angle: winrt.system.Single
    inertia_expansion_deceleration: winrt.system.Single
    inertia_expansion: winrt.system.Single
    gesture_settings: GestureSettings
    cross_slide_thresholds: CrossSlideThresholds
    cross_slide_horizontally: winrt.system.Boolean
    cross_slide_exact: winrt.system.Boolean
    auto_process_inertia: winrt.system.Boolean
    is_active: winrt.system.Boolean
    is_inertial: winrt.system.Boolean
    mouse_wheel_parameters: typing.Optional[MouseWheelParameters]
    translation_min_contact_count: winrt.system.UInt32
    translation_max_contact_count: winrt.system.UInt32
    tap_min_contact_count: winrt.system.UInt32
    tap_max_contact_count: winrt.system.UInt32
    hold_start_delay: datetime.timedelta
    hold_radius: winrt.system.Single
    hold_min_contact_count: winrt.system.UInt32
    hold_max_contact_count: winrt.system.UInt32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GestureRecognizer: ...
    def __new__(cls: typing.Type[GestureRecognizer]) -> GestureRecognizer:...
    def can_be_double_tap(self, value: typing.Optional[PointerPoint], /) -> winrt.system.Boolean: ...
    def complete_gesture(self) -> None: ...
    def process_down_event(self, value: typing.Optional[PointerPoint], /) -> None: ...
    def process_inertia(self) -> None: ...
    def process_mouse_wheel_event(self, value: typing.Optional[PointerPoint], is_shift_key_down: winrt.system.Boolean, is_control_key_down: winrt.system.Boolean, /) -> None: ...
    def process_move_events(self, value: winrt.windows.foundation.collections.IVector[PointerPoint], /) -> None: ...
    def process_up_event(self, value: typing.Optional[PointerPoint], /) -> None: ...
    def add_cross_sliding(self, handler: winrt.windows.foundation.TypedEventHandler[GestureRecognizer, CrossSlidingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_cross_sliding(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_dragging(self, handler: winrt.windows.foundation.TypedEventHandler[GestureRecognizer, DraggingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_dragging(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_holding(self, handler: winrt.windows.foundation.TypedEventHandler[GestureRecognizer, HoldingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_holding(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_manipulation_completed(self, handler: winrt.windows.foundation.TypedEventHandler[GestureRecognizer, ManipulationCompletedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_manipulation_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_manipulation_inertia_starting(self, handler: winrt.windows.foundation.TypedEventHandler[GestureRecognizer, ManipulationInertiaStartingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_manipulation_inertia_starting(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_manipulation_started(self, handler: winrt.windows.foundation.TypedEventHandler[GestureRecognizer, ManipulationStartedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_manipulation_started(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_manipulation_updated(self, handler: winrt.windows.foundation.TypedEventHandler[GestureRecognizer, ManipulationUpdatedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_manipulation_updated(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_right_tapped(self, handler: winrt.windows.foundation.TypedEventHandler[GestureRecognizer, RightTappedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_right_tapped(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_tapped(self, handler: winrt.windows.foundation.TypedEventHandler[GestureRecognizer, TappedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_tapped(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class HoldingEventArgs(winrt.system.Object):
    holding_state: HoldingState
    pointer_device_type: winrt.windows.devices.input.PointerDeviceType
    position: winrt.windows.foundation.Point
    contact_count: winrt.system.UInt32
    current_contact_count: winrt.system.UInt32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HoldingEventArgs: ...

class InputActivationListener(winrt.system.Object):
    state: InputActivationState
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InputActivationListener: ...
    def add_input_activation_changed(self, handler: winrt.windows.foundation.TypedEventHandler[InputActivationListener, InputActivationListenerActivationChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_input_activation_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class InputActivationListenerActivationChangedEventArgs(winrt.system.Object):
    state: InputActivationState
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InputActivationListenerActivationChangedEventArgs: ...

class KeyboardDeliveryInterceptor(winrt.system.Object):
    is_interception_enabled_when_in_foreground: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> KeyboardDeliveryInterceptor: ...
    @staticmethod
    def get_for_current_view() -> typing.Optional[KeyboardDeliveryInterceptor]: ...
    def add_key_down(self, handler: winrt.windows.foundation.TypedEventHandler[KeyboardDeliveryInterceptor, winrt.windows.ui.core.KeyEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_key_down(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_key_up(self, handler: winrt.windows.foundation.TypedEventHandler[KeyboardDeliveryInterceptor, winrt.windows.ui.core.KeyEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_key_up(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class ManipulationCompletedEventArgs(winrt.system.Object):
    cumulative: ManipulationDelta
    pointer_device_type: winrt.windows.devices.input.PointerDeviceType
    position: winrt.windows.foundation.Point
    velocities: ManipulationVelocities
    contact_count: winrt.system.UInt32
    current_contact_count: winrt.system.UInt32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ManipulationCompletedEventArgs: ...

class ManipulationInertiaStartingEventArgs(winrt.system.Object):
    cumulative: ManipulationDelta
    delta: ManipulationDelta
    pointer_device_type: winrt.windows.devices.input.PointerDeviceType
    position: winrt.windows.foundation.Point
    velocities: ManipulationVelocities
    contact_count: winrt.system.UInt32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ManipulationInertiaStartingEventArgs: ...

class ManipulationStartedEventArgs(winrt.system.Object):
    cumulative: ManipulationDelta
    pointer_device_type: winrt.windows.devices.input.PointerDeviceType
    position: winrt.windows.foundation.Point
    contact_count: winrt.system.UInt32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ManipulationStartedEventArgs: ...

class ManipulationUpdatedEventArgs(winrt.system.Object):
    cumulative: ManipulationDelta
    delta: ManipulationDelta
    pointer_device_type: winrt.windows.devices.input.PointerDeviceType
    position: winrt.windows.foundation.Point
    velocities: ManipulationVelocities
    contact_count: winrt.system.UInt32
    current_contact_count: winrt.system.UInt32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ManipulationUpdatedEventArgs: ...

class MouseWheelParameters(winrt.system.Object):
    page_translation: winrt.windows.foundation.Point
    delta_scale: winrt.system.Single
    delta_rotation_angle: winrt.system.Single
    char_translation: winrt.windows.foundation.Point
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MouseWheelParameters: ...

class PointerPoint(winrt.system.Object):
    frame_id: winrt.system.UInt32
    is_in_contact: winrt.system.Boolean
    pointer_device: typing.Optional[winrt.windows.devices.input.PointerDevice]
    pointer_id: winrt.system.UInt32
    position: winrt.windows.foundation.Point
    properties: typing.Optional[PointerPointProperties]
    raw_position: winrt.windows.foundation.Point
    timestamp: winrt.system.UInt64
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PointerPoint: ...
    @typing.overload
    @staticmethod
    def get_current_point(pointer_id: winrt.system.UInt32, /) -> typing.Optional[PointerPoint]: ...
    @typing.overload
    @staticmethod
    def get_current_point(pointer_id: winrt.system.UInt32, transform: typing.Optional[IPointerPointTransform], /) -> typing.Optional[PointerPoint]: ...
    @typing.overload
    @staticmethod
    def get_intermediate_points(pointer_id: winrt.system.UInt32, /) -> typing.Optional[winrt.windows.foundation.collections.IVector[PointerPoint]]: ...
    @typing.overload
    @staticmethod
    def get_intermediate_points(pointer_id: winrt.system.UInt32, transform: typing.Optional[IPointerPointTransform], /) -> typing.Optional[winrt.windows.foundation.collections.IVector[PointerPoint]]: ...

class PointerPointProperties(winrt.system.Object):
    contact_rect: winrt.windows.foundation.Rect
    contact_rect_raw: winrt.windows.foundation.Rect
    is_barrel_button_pressed: winrt.system.Boolean
    is_canceled: winrt.system.Boolean
    is_eraser: winrt.system.Boolean
    is_horizontal_mouse_wheel: winrt.system.Boolean
    is_in_range: winrt.system.Boolean
    is_inverted: winrt.system.Boolean
    is_left_button_pressed: winrt.system.Boolean
    is_middle_button_pressed: winrt.system.Boolean
    is_primary: winrt.system.Boolean
    is_right_button_pressed: winrt.system.Boolean
    is_x_button1_pressed: winrt.system.Boolean
    is_x_button2_pressed: winrt.system.Boolean
    mouse_wheel_delta: winrt.system.Int32
    orientation: winrt.system.Single
    pointer_update_kind: PointerUpdateKind
    pressure: winrt.system.Single
    touch_confidence: winrt.system.Boolean
    twist: winrt.system.Single
    x_tilt: winrt.system.Single
    y_tilt: winrt.system.Single
    z_distance: typing.Optional[typing.Optional[winrt.system.Single]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PointerPointProperties: ...
    def get_usage_value(self, usage_page: winrt.system.UInt32, usage_id: winrt.system.UInt32, /) -> winrt.system.Int32: ...
    def has_usage(self, usage_page: winrt.system.UInt32, usage_id: winrt.system.UInt32, /) -> winrt.system.Boolean: ...

class PointerVisualizationSettings(winrt.system.Object):
    is_contact_feedback_enabled: winrt.system.Boolean
    is_barrel_button_feedback_enabled: winrt.system.Boolean
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PointerVisualizationSettings: ...
    @staticmethod
    def get_for_current_view() -> typing.Optional[PointerVisualizationSettings]: ...

class RadialController(winrt.system.Object):
    use_automatic_haptic_feedback: winrt.system.Boolean
    rotation_resolution_in_degrees: winrt.system.Double
    menu: typing.Optional[RadialControllerMenu]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RadialController: ...
    @staticmethod
    def create_for_current_view() -> typing.Optional[RadialController]: ...
    @staticmethod
    def is_supported() -> winrt.system.Boolean: ...
    def add_button_clicked(self, handler: winrt.windows.foundation.TypedEventHandler[RadialController, RadialControllerButtonClickedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_button_clicked(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_control_acquired(self, handler: winrt.windows.foundation.TypedEventHandler[RadialController, RadialControllerControlAcquiredEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_control_acquired(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_control_lost(self, handler: winrt.windows.foundation.TypedEventHandler[RadialController, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_control_lost(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_rotation_changed(self, handler: winrt.windows.foundation.TypedEventHandler[RadialController, RadialControllerRotationChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_rotation_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_screen_contact_continued(self, handler: winrt.windows.foundation.TypedEventHandler[RadialController, RadialControllerScreenContactContinuedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_screen_contact_continued(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_screen_contact_ended(self, handler: winrt.windows.foundation.TypedEventHandler[RadialController, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_screen_contact_ended(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_screen_contact_started(self, handler: winrt.windows.foundation.TypedEventHandler[RadialController, RadialControllerScreenContactStartedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_screen_contact_started(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_button_holding(self, handler: winrt.windows.foundation.TypedEventHandler[RadialController, RadialControllerButtonHoldingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_button_holding(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_button_pressed(self, handler: winrt.windows.foundation.TypedEventHandler[RadialController, RadialControllerButtonPressedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_button_pressed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_button_released(self, handler: winrt.windows.foundation.TypedEventHandler[RadialController, RadialControllerButtonReleasedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_button_released(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class RadialControllerButtonClickedEventArgs(winrt.system.Object):
    contact: typing.Optional[RadialControllerScreenContact]
    simple_haptics_controller: typing.Optional[winrt.windows.devices.haptics.SimpleHapticsController]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RadialControllerButtonClickedEventArgs: ...

class RadialControllerButtonHoldingEventArgs(winrt.system.Object):
    contact: typing.Optional[RadialControllerScreenContact]
    simple_haptics_controller: typing.Optional[winrt.windows.devices.haptics.SimpleHapticsController]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RadialControllerButtonHoldingEventArgs: ...

class RadialControllerButtonPressedEventArgs(winrt.system.Object):
    contact: typing.Optional[RadialControllerScreenContact]
    simple_haptics_controller: typing.Optional[winrt.windows.devices.haptics.SimpleHapticsController]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RadialControllerButtonPressedEventArgs: ...

class RadialControllerButtonReleasedEventArgs(winrt.system.Object):
    contact: typing.Optional[RadialControllerScreenContact]
    simple_haptics_controller: typing.Optional[winrt.windows.devices.haptics.SimpleHapticsController]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RadialControllerButtonReleasedEventArgs: ...

class RadialControllerConfiguration(winrt.system.Object):
    is_menu_suppressed: winrt.system.Boolean
    active_controller_when_menu_is_suppressed: typing.Optional[RadialController]
    is_app_controller_enabled: typing.ClassVar[winrt.system.Boolean]
    app_controller: typing.ClassVar[typing.Optional[RadialController]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RadialControllerConfiguration: ...
    @staticmethod
    def get_for_current_view() -> typing.Optional[RadialControllerConfiguration]: ...
    def reset_to_default_menu_items(self) -> None: ...
    def set_default_menu_items(self, buttons: typing.Iterable[RadialControllerSystemMenuItemKind], /) -> None: ...
    def try_select_default_menu_item(self, type: RadialControllerSystemMenuItemKind, /) -> winrt.system.Boolean: ...

class RadialControllerControlAcquiredEventArgs(winrt.system.Object):
    contact: typing.Optional[RadialControllerScreenContact]
    is_button_pressed: winrt.system.Boolean
    simple_haptics_controller: typing.Optional[winrt.windows.devices.haptics.SimpleHapticsController]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RadialControllerControlAcquiredEventArgs: ...

class RadialControllerMenu(winrt.system.Object):
    is_enabled: winrt.system.Boolean
    items: typing.Optional[winrt.windows.foundation.collections.IVector[RadialControllerMenuItem]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RadialControllerMenu: ...
    def get_selected_menu_item(self) -> typing.Optional[RadialControllerMenuItem]: ...
    def select_menu_item(self, menu_item: typing.Optional[RadialControllerMenuItem], /) -> None: ...
    def try_select_previously_selected_menu_item(self) -> winrt.system.Boolean: ...

class RadialControllerMenuItem(winrt.system.Object):
    tag: typing.Optional[winrt.system.Object]
    display_text: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RadialControllerMenuItem: ...
    @typing.overload
    @staticmethod
    def create_from_font_glyph(display_text: str, glyph: str, font_family: str, /) -> typing.Optional[RadialControllerMenuItem]: ...
    @typing.overload
    @staticmethod
    def create_from_font_glyph(display_text: str, glyph: str, font_family: str, font_uri: typing.Optional[winrt.windows.foundation.Uri], /) -> typing.Optional[RadialControllerMenuItem]: ...
    @staticmethod
    def create_from_icon(display_text: str, icon: typing.Optional[winrt.windows.storage.streams.RandomAccessStreamReference], /) -> typing.Optional[RadialControllerMenuItem]: ...
    @staticmethod
    def create_from_known_icon(display_text: str, value: RadialControllerMenuKnownIcon, /) -> typing.Optional[RadialControllerMenuItem]: ...
    def add_invoked(self, handler: winrt.windows.foundation.TypedEventHandler[RadialControllerMenuItem, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_invoked(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class RadialControllerRotationChangedEventArgs(winrt.system.Object):
    contact: typing.Optional[RadialControllerScreenContact]
    rotation_delta_in_degrees: winrt.system.Double
    is_button_pressed: winrt.system.Boolean
    simple_haptics_controller: typing.Optional[winrt.windows.devices.haptics.SimpleHapticsController]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RadialControllerRotationChangedEventArgs: ...

class RadialControllerScreenContact(winrt.system.Object):
    bounds: winrt.windows.foundation.Rect
    position: winrt.windows.foundation.Point
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RadialControllerScreenContact: ...

class RadialControllerScreenContactContinuedEventArgs(winrt.system.Object):
    contact: typing.Optional[RadialControllerScreenContact]
    is_button_pressed: winrt.system.Boolean
    simple_haptics_controller: typing.Optional[winrt.windows.devices.haptics.SimpleHapticsController]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RadialControllerScreenContactContinuedEventArgs: ...

class RadialControllerScreenContactEndedEventArgs(winrt.system.Object):
    is_button_pressed: winrt.system.Boolean
    simple_haptics_controller: typing.Optional[winrt.windows.devices.haptics.SimpleHapticsController]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RadialControllerScreenContactEndedEventArgs: ...

class RadialControllerScreenContactStartedEventArgs(winrt.system.Object):
    contact: typing.Optional[RadialControllerScreenContact]
    is_button_pressed: winrt.system.Boolean
    simple_haptics_controller: typing.Optional[winrt.windows.devices.haptics.SimpleHapticsController]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RadialControllerScreenContactStartedEventArgs: ...

class RightTappedEventArgs(winrt.system.Object):
    pointer_device_type: winrt.windows.devices.input.PointerDeviceType
    position: winrt.windows.foundation.Point
    contact_count: winrt.system.UInt32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RightTappedEventArgs: ...

class SystemButtonEventController(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SystemButtonEventController: ...
    @staticmethod
    def create_for_dispatcher_queue(queue: typing.Optional[winrt.windows.system.DispatcherQueue], /) -> typing.Optional[SystemButtonEventController]: ...
    def add_system_function_button_pressed(self, handler: winrt.windows.foundation.TypedEventHandler[SystemButtonEventController, SystemFunctionButtonEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_system_function_button_pressed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_system_function_button_released(self, handler: winrt.windows.foundation.TypedEventHandler[SystemButtonEventController, SystemFunctionButtonEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_system_function_button_released(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_system_function_lock_changed(self, handler: winrt.windows.foundation.TypedEventHandler[SystemButtonEventController, SystemFunctionLockChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_system_function_lock_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_system_function_lock_indicator_changed(self, handler: winrt.windows.foundation.TypedEventHandler[SystemButtonEventController, SystemFunctionLockIndicatorChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_system_function_lock_indicator_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class SystemFunctionButtonEventArgs(winrt.system.Object):
    handled: winrt.system.Boolean
    timestamp: winrt.system.UInt64
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SystemFunctionButtonEventArgs: ...

class SystemFunctionLockChangedEventArgs(winrt.system.Object):
    handled: winrt.system.Boolean
    is_locked: winrt.system.Boolean
    timestamp: winrt.system.UInt64
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SystemFunctionLockChangedEventArgs: ...

class SystemFunctionLockIndicatorChangedEventArgs(winrt.system.Object):
    handled: winrt.system.Boolean
    is_indicator_on: winrt.system.Boolean
    timestamp: winrt.system.UInt64
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SystemFunctionLockIndicatorChangedEventArgs: ...

class TappedEventArgs(winrt.system.Object):
    pointer_device_type: winrt.windows.devices.input.PointerDeviceType
    position: winrt.windows.foundation.Point
    tap_count: winrt.system.UInt32
    contact_count: winrt.system.UInt32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TappedEventArgs: ...

class IPointerPointTransform(winrt.system.Object):
    inverse: typing.Optional[IPointerPointTransform]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IPointerPointTransform: ...
    def transform_bounds(self, rect: winrt.windows.foundation.Rect, /) -> winrt.windows.foundation.Rect: ...
    def try_transform(self, in_point: winrt.windows.foundation.Point, /) -> typing.Tuple[winrt.system.Boolean, winrt.windows.foundation.Point]: ...

