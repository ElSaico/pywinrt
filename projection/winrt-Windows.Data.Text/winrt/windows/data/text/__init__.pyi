# WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

import enum
import datetime
import sys
import types
import typing

import winrt.system
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.ui.text.core

class AlternateNormalizationFormat(enum.IntEnum):
    NOT_NORMALIZED = 0
    NUMBER = 1
    CURRENCY = 3
    DATE = 4
    TIME = 5

class TextPredictionOptions(enum.IntFlag):
    NONE = 0
    PREDICTIONS = 0x1
    CORRECTIONS = 0x2

class UnicodeGeneralCategory(enum.IntEnum):
    UPPERCASE_LETTER = 0
    LOWERCASE_LETTER = 1
    TITLECASE_LETTER = 2
    MODIFIER_LETTER = 3
    OTHER_LETTER = 4
    NONSPACING_MARK = 5
    SPACING_COMBINING_MARK = 6
    ENCLOSING_MARK = 7
    DECIMAL_DIGIT_NUMBER = 8
    LETTER_NUMBER = 9
    OTHER_NUMBER = 10
    SPACE_SEPARATOR = 11
    LINE_SEPARATOR = 12
    PARAGRAPH_SEPARATOR = 13
    CONTROL = 14
    FORMAT = 15
    SURROGATE = 16
    PRIVATE_USE = 17
    CONNECTOR_PUNCTUATION = 18
    DASH_PUNCTUATION = 19
    OPEN_PUNCTUATION = 20
    CLOSE_PUNCTUATION = 21
    INITIAL_QUOTE_PUNCTUATION = 22
    FINAL_QUOTE_PUNCTUATION = 23
    OTHER_PUNCTUATION = 24
    MATH_SYMBOL = 25
    CURRENCY_SYMBOL = 26
    MODIFIER_SYMBOL = 27
    OTHER_SYMBOL = 28
    NOT_ASSIGNED = 29

class UnicodeNumericType(enum.IntEnum):
    NONE = 0
    DECIMAL = 1
    DIGIT = 2
    NUMERIC = 3

Self = typing.TypeVar('Self')

class TextSegment:
    start_position: winrt.system.UInt32
    length: winrt.system.UInt32
    def __new__(cls: typing.Type[TextSegment], start_position: winrt.system.UInt32, length: winrt.system.UInt32) -> TextSegment: ...

class AlternateWordForm(winrt.system.Object):
    alternate_text: str
    normalization_format: AlternateNormalizationFormat
    source_text_segment: TextSegment
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AlternateWordForm: ...

class SelectableWordSegment(winrt.system.Object):
    source_text_segment: TextSegment
    text: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SelectableWordSegment: ...

class SelectableWordsSegmenter(winrt.system.Object):
    resolved_language: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SelectableWordsSegmenter: ...
    def __new__(cls: typing.Type[SelectableWordsSegmenter], language: str) -> SelectableWordsSegmenter:...
    def get_token_at(self, text: str, start_index: winrt.system.UInt32, /) -> typing.Optional[SelectableWordSegment]: ...
    def get_tokens(self, text: str, /) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[SelectableWordSegment]]: ...
    def tokenize(self, text: str, start_index: winrt.system.UInt32, handler: typing.Optional[SelectableWordSegmentsTokenizingHandler], /) -> None: ...

class SemanticTextQuery(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SemanticTextQuery: ...
    @typing.overload
    def __new__(cls: typing.Type[SemanticTextQuery], aqs_filter: str) -> SemanticTextQuery:...
    @typing.overload
    def __new__(cls: typing.Type[SemanticTextQuery], aqs_filter: str, filter_language: str) -> SemanticTextQuery:...
    def find(self, content: str, /) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[TextSegment]]: ...
    def find_in_property(self, property_content: str, property_name: str, /) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[TextSegment]]: ...

class TextConversionGenerator(winrt.system.Object):
    language_available_but_not_installed: winrt.system.Boolean
    resolved_language: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TextConversionGenerator: ...
    def __new__(cls: typing.Type[TextConversionGenerator], language_tag: str) -> TextConversionGenerator:...
    @typing.overload
    def get_candidates_async(self, input: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[str]]: ...
    @typing.overload
    def get_candidates_async(self, input: str, max_candidates: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[str]]: ...

class TextPhoneme(winrt.system.Object):
    display_text: str
    reading_text: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TextPhoneme: ...

class TextPredictionGenerator(winrt.system.Object):
    language_available_but_not_installed: winrt.system.Boolean
    resolved_language: str
    input_scope: winrt.windows.ui.text.core.CoreTextInputScope
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TextPredictionGenerator: ...
    def __new__(cls: typing.Type[TextPredictionGenerator], language_tag: str) -> TextPredictionGenerator:...
    @typing.overload
    def get_candidates_async(self, input: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[str]]: ...
    @typing.overload
    def get_candidates_async(self, input: str, max_candidates: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[str]]: ...
    @typing.overload
    def get_candidates_async(self, input: str, max_candidates: winrt.system.UInt32, prediction_options: TextPredictionOptions, previous_strings: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[str]]: ...
    def get_next_word_candidates_async(self, max_candidates: winrt.system.UInt32, previous_strings: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[str]]: ...

class TextReverseConversionGenerator(winrt.system.Object):
    language_available_but_not_installed: winrt.system.Boolean
    resolved_language: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TextReverseConversionGenerator: ...
    def __new__(cls: typing.Type[TextReverseConversionGenerator], language_tag: str) -> TextReverseConversionGenerator:...
    def convert_back_async(self, input: str, /) -> winrt.windows.foundation.IAsyncOperation[str]: ...
    def get_phonemes_async(self, input: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[TextPhoneme]]: ...

class UnicodeCharacters(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> UnicodeCharacters: ...
    @staticmethod
    def get_codepoint_from_surrogate_pair(high_surrogate: winrt.system.UInt32, low_surrogate: winrt.system.UInt32, /) -> winrt.system.UInt32: ...
    @staticmethod
    def get_general_category(codepoint: winrt.system.UInt32, /) -> UnicodeGeneralCategory: ...
    @staticmethod
    def get_numeric_type(codepoint: winrt.system.UInt32, /) -> UnicodeNumericType: ...
    @staticmethod
    def get_surrogate_pair_from_codepoint(codepoint: winrt.system.UInt32, /) -> typing.Tuple[winrt.system.Char16, winrt.system.Char16]: ...
    @staticmethod
    def is_alphabetic(codepoint: winrt.system.UInt32, /) -> winrt.system.Boolean: ...
    @staticmethod
    def is_cased(codepoint: winrt.system.UInt32, /) -> winrt.system.Boolean: ...
    @staticmethod
    def is_grapheme_base(codepoint: winrt.system.UInt32, /) -> winrt.system.Boolean: ...
    @staticmethod
    def is_grapheme_extend(codepoint: winrt.system.UInt32, /) -> winrt.system.Boolean: ...
    @staticmethod
    def is_high_surrogate(codepoint: winrt.system.UInt32, /) -> winrt.system.Boolean: ...
    @staticmethod
    def is_id_continue(codepoint: winrt.system.UInt32, /) -> winrt.system.Boolean: ...
    @staticmethod
    def is_id_start(codepoint: winrt.system.UInt32, /) -> winrt.system.Boolean: ...
    @staticmethod
    def is_low_surrogate(codepoint: winrt.system.UInt32, /) -> winrt.system.Boolean: ...
    @staticmethod
    def is_lowercase(codepoint: winrt.system.UInt32, /) -> winrt.system.Boolean: ...
    @staticmethod
    def is_noncharacter(codepoint: winrt.system.UInt32, /) -> winrt.system.Boolean: ...
    @staticmethod
    def is_supplementary(codepoint: winrt.system.UInt32, /) -> winrt.system.Boolean: ...
    @staticmethod
    def is_uppercase(codepoint: winrt.system.UInt32, /) -> winrt.system.Boolean: ...
    @staticmethod
    def is_whitespace(codepoint: winrt.system.UInt32, /) -> winrt.system.Boolean: ...

class WordSegment(winrt.system.Object):
    alternate_forms: typing.Optional[winrt.windows.foundation.collections.IVectorView[AlternateWordForm]]
    source_text_segment: TextSegment
    text: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WordSegment: ...

class WordsSegmenter(winrt.system.Object):
    resolved_language: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WordsSegmenter: ...
    def __new__(cls: typing.Type[WordsSegmenter], language: str) -> WordsSegmenter:...
    def get_token_at(self, text: str, start_index: winrt.system.UInt32, /) -> typing.Optional[WordSegment]: ...
    def get_tokens(self, text: str, /) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[WordSegment]]: ...
    def tokenize(self, text: str, start_index: winrt.system.UInt32, handler: typing.Optional[WordSegmentsTokenizingHandler], /) -> None: ...

SelectableWordSegmentsTokenizingHandler = typing.Callable[[typing.Iterable[SelectableWordSegment], typing.Iterable[SelectableWordSegment]], None]

WordSegmentsTokenizingHandler = typing.Callable[[typing.Iterable[WordSegment], typing.Iterable[WordSegment]], None]

