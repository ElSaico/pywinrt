# WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt.system
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.ui
import winrt.windows.ui.composition
import winrt.windows.ui.xaml
import winrt.windows.ui.xaml.controls
import winrt.windows.ui.xaml.controls.primitives

from winrt.windows.ui.xaml.media.animation import ClockState, ConnectedAnimationComponent, EasingMode, FillBehavior, RepeatBehaviorType, SlideNavigationTransitionEffect

Self = typing.TypeVar('Self')

class KeyTime:
    time_span: datetime.timedelta
    def __init__(self, time_span: datetime.timedelta) -> None: ...

class RepeatBehavior:
    count: winrt.system.Double
    duration: datetime.timedelta
    type: RepeatBehaviorType
    def __init__(self, count: winrt.system.Double, duration: datetime.timedelta, type: RepeatBehaviorType) -> None: ...

class AddDeleteThemeTransition(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AddDeleteThemeTransition: ...
    def __new__(cls: typing.Type[AddDeleteThemeTransition]) -> AddDeleteThemeTransition:...

class BackEase(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BackEase: ...
    def __new__(cls: typing.Type[BackEase]) -> BackEase:...
    @_property
    def amplitude(self) -> winrt.system.Double: ...
    @amplitude.setter
    def amplitude(self, value: winrt.system.Double) -> None: ...
    amplitude_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class BasicConnectedAnimationConfiguration(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BasicConnectedAnimationConfiguration: ...
    def __new__(cls: typing.Type[BasicConnectedAnimationConfiguration]) -> BasicConnectedAnimationConfiguration:...

class BeginStoryboard(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BeginStoryboard: ...
    def __new__(cls: typing.Type[BeginStoryboard]) -> BeginStoryboard:...
    @_property
    def storyboard(self) -> typing.Optional[Storyboard]: ...
    @storyboard.setter
    def storyboard(self, value: typing.Optional[Storyboard]) -> None: ...
    storyboard_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class BounceEase(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BounceEase: ...
    def __new__(cls: typing.Type[BounceEase]) -> BounceEase:...
    @_property
    def bounciness(self) -> winrt.system.Double: ...
    @bounciness.setter
    def bounciness(self, value: winrt.system.Double) -> None: ...
    @_property
    def bounces(self) -> winrt.system.Int32: ...
    @bounces.setter
    def bounces(self, value: winrt.system.Int32) -> None: ...
    bounces_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    bounciness_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class CircleEase(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CircleEase: ...
    def __new__(cls: typing.Type[CircleEase]) -> CircleEase:...

class ColorAnimation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ColorAnimation: ...
    def __new__(cls: typing.Type[ColorAnimation]) -> ColorAnimation:...
    @_property
    def to(self) -> typing.Optional[typing.Optional[winrt.windows.ui.Color]]: ...
    @to.setter
    def to(self, value: typing.Optional[typing.Optional[winrt.windows.ui.Color]]) -> None: ...
    @_property
    def from_(self) -> typing.Optional[typing.Optional[winrt.windows.ui.Color]]: ...
    @from_.setter
    def from_(self, value: typing.Optional[typing.Optional[winrt.windows.ui.Color]]) -> None: ...
    @_property
    def enable_dependent_animation(self) -> bool: ...
    @enable_dependent_animation.setter
    def enable_dependent_animation(self, value: bool) -> None: ...
    @_property
    def easing_function(self) -> typing.Optional[EasingFunctionBase]: ...
    @easing_function.setter
    def easing_function(self, value: typing.Optional[EasingFunctionBase]) -> None: ...
    @_property
    def by(self) -> typing.Optional[typing.Optional[winrt.windows.ui.Color]]: ...
    @by.setter
    def by(self, value: typing.Optional[typing.Optional[winrt.windows.ui.Color]]) -> None: ...
    by_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    easing_function_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    enable_dependent_animation_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    from_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    to_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class ColorAnimationUsingKeyFrames(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ColorAnimationUsingKeyFrames: ...
    def __new__(cls: typing.Type[ColorAnimationUsingKeyFrames]) -> ColorAnimationUsingKeyFrames:...
    @_property
    def enable_dependent_animation(self) -> bool: ...
    @enable_dependent_animation.setter
    def enable_dependent_animation(self, value: bool) -> None: ...
    @_property
    def key_frames(self) -> typing.Optional[ColorKeyFrameCollection]: ...
    enable_dependent_animation_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class ColorKeyFrame(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ColorKeyFrame: ...
    @_property
    def value(self) -> winrt.windows.ui.Color: ...
    @value.setter
    def value(self, value: winrt.windows.ui.Color) -> None: ...
    @_property
    def key_time(self) -> KeyTime: ...
    @key_time.setter
    def key_time(self, value: KeyTime) -> None: ...
    key_time_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    value_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class ColorKeyFrameCollection(winrt.system.Object, typing.MutableSequence[ColorKeyFrame]):
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> ColorKeyFrame: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[ColorKeyFrame]: ...
    def insert(self, index: int, value: ColorKeyFrame) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: ColorKeyFrame) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[ColorKeyFrame]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ColorKeyFrameCollection: ...
    def __new__(cls: typing.Type[ColorKeyFrameCollection]) -> ColorKeyFrameCollection:...
    def append(self, value: typing.Optional[ColorKeyFrame], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[ColorKeyFrame]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[ColorKeyFrame]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[ColorKeyFrame], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[ColorKeyFrame]]: ...
    def index_of(self, value: typing.Optional[ColorKeyFrame], /) -> typing.Tuple[bool, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[ColorKeyFrame], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[ColorKeyFrame], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[ColorKeyFrame], /) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

class CommonNavigationTransitionInfo(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CommonNavigationTransitionInfo: ...
    def __new__(cls: typing.Type[CommonNavigationTransitionInfo]) -> CommonNavigationTransitionInfo:...
    @staticmethod
    def get_is_stagger_element(element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> bool: ...
    @staticmethod
    def set_is_stagger_element(element: typing.Optional[winrt.windows.ui.xaml.UIElement], value: bool, /) -> None: ...
    @_property
    def is_staggering_enabled(self) -> bool: ...
    @is_staggering_enabled.setter
    def is_staggering_enabled(self, value: bool) -> None: ...
    is_stagger_element_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_staggering_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class ConnectedAnimation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ConnectedAnimation: ...
    def cancel(self) -> None: ...
    def set_animation_component(self, component: ConnectedAnimationComponent, animation: typing.Optional[winrt.windows.ui.composition.ICompositionAnimationBase], /) -> None: ...
    @typing.overload
    def try_start(self, destination: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> bool: ...
    @typing.overload
    def try_start(self, destination: typing.Optional[winrt.windows.ui.xaml.UIElement], coordinated_elements: typing.Iterable[winrt.windows.ui.xaml.UIElement], /) -> bool: ...
    def add_completed(self, handler: winrt.windows.foundation.TypedEventHandler[ConnectedAnimation, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def is_scale_animation_enabled(self) -> bool: ...
    @is_scale_animation_enabled.setter
    def is_scale_animation_enabled(self, value: bool) -> None: ...
    @_property
    def configuration(self) -> typing.Optional[ConnectedAnimationConfiguration]: ...
    @configuration.setter
    def configuration(self, value: typing.Optional[ConnectedAnimationConfiguration]) -> None: ...

class ConnectedAnimationConfiguration(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ConnectedAnimationConfiguration: ...

class ConnectedAnimationService(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ConnectedAnimationService: ...
    def get_animation(self, key: str, /) -> typing.Optional[ConnectedAnimation]: ...
    @staticmethod
    def get_for_current_view() -> typing.Optional[ConnectedAnimationService]: ...
    def prepare_to_animate(self, key: str, source: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> typing.Optional[ConnectedAnimation]: ...
    @_property
    def default_easing_function(self) -> typing.Optional[winrt.windows.ui.composition.CompositionEasingFunction]: ...
    @default_easing_function.setter
    def default_easing_function(self, value: typing.Optional[winrt.windows.ui.composition.CompositionEasingFunction]) -> None: ...
    @_property
    def default_duration(self) -> datetime.timedelta: ...
    @default_duration.setter
    def default_duration(self, value: datetime.timedelta) -> None: ...

class ContentThemeTransition(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ContentThemeTransition: ...
    def __new__(cls: typing.Type[ContentThemeTransition]) -> ContentThemeTransition:...
    @_property
    def vertical_offset(self) -> winrt.system.Double: ...
    @vertical_offset.setter
    def vertical_offset(self, value: winrt.system.Double) -> None: ...
    @_property
    def horizontal_offset(self) -> winrt.system.Double: ...
    @horizontal_offset.setter
    def horizontal_offset(self, value: winrt.system.Double) -> None: ...
    horizontal_offset_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    vertical_offset_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class ContinuumNavigationTransitionInfo(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ContinuumNavigationTransitionInfo: ...
    def __new__(cls: typing.Type[ContinuumNavigationTransitionInfo]) -> ContinuumNavigationTransitionInfo:...
    @staticmethod
    def get_exit_element_container(element: typing.Optional[winrt.windows.ui.xaml.controls.ListViewBase], /) -> bool: ...
    @staticmethod
    def get_is_entrance_element(element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> bool: ...
    @staticmethod
    def get_is_exit_element(element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> bool: ...
    @staticmethod
    def set_exit_element_container(element: typing.Optional[winrt.windows.ui.xaml.controls.ListViewBase], value: bool, /) -> None: ...
    @staticmethod
    def set_is_entrance_element(element: typing.Optional[winrt.windows.ui.xaml.UIElement], value: bool, /) -> None: ...
    @staticmethod
    def set_is_exit_element(element: typing.Optional[winrt.windows.ui.xaml.UIElement], value: bool, /) -> None: ...
    @_property
    def exit_element(self) -> typing.Optional[winrt.windows.ui.xaml.UIElement]: ...
    @exit_element.setter
    def exit_element(self, value: typing.Optional[winrt.windows.ui.xaml.UIElement]) -> None: ...
    exit_element_container_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    exit_element_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_entrance_element_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_exit_element_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class CubicEase(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CubicEase: ...
    def __new__(cls: typing.Type[CubicEase]) -> CubicEase:...

class DirectConnectedAnimationConfiguration(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DirectConnectedAnimationConfiguration: ...
    def __new__(cls: typing.Type[DirectConnectedAnimationConfiguration]) -> DirectConnectedAnimationConfiguration:...

class DiscreteColorKeyFrame(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DiscreteColorKeyFrame: ...
    def __new__(cls: typing.Type[DiscreteColorKeyFrame]) -> DiscreteColorKeyFrame:...

class DiscreteDoubleKeyFrame(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DiscreteDoubleKeyFrame: ...
    def __new__(cls: typing.Type[DiscreteDoubleKeyFrame]) -> DiscreteDoubleKeyFrame:...

class DiscreteObjectKeyFrame(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DiscreteObjectKeyFrame: ...
    def __new__(cls: typing.Type[DiscreteObjectKeyFrame]) -> DiscreteObjectKeyFrame:...

class DiscretePointKeyFrame(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DiscretePointKeyFrame: ...
    def __new__(cls: typing.Type[DiscretePointKeyFrame]) -> DiscretePointKeyFrame:...

class DoubleAnimation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DoubleAnimation: ...
    def __new__(cls: typing.Type[DoubleAnimation]) -> DoubleAnimation:...
    @_property
    def to(self) -> typing.Optional[typing.Optional[winrt.system.Double]]: ...
    @to.setter
    def to(self, value: typing.Optional[typing.Optional[winrt.system.Double]]) -> None: ...
    @_property
    def from_(self) -> typing.Optional[typing.Optional[winrt.system.Double]]: ...
    @from_.setter
    def from_(self, value: typing.Optional[typing.Optional[winrt.system.Double]]) -> None: ...
    @_property
    def enable_dependent_animation(self) -> bool: ...
    @enable_dependent_animation.setter
    def enable_dependent_animation(self, value: bool) -> None: ...
    @_property
    def easing_function(self) -> typing.Optional[EasingFunctionBase]: ...
    @easing_function.setter
    def easing_function(self, value: typing.Optional[EasingFunctionBase]) -> None: ...
    @_property
    def by(self) -> typing.Optional[typing.Optional[winrt.system.Double]]: ...
    @by.setter
    def by(self, value: typing.Optional[typing.Optional[winrt.system.Double]]) -> None: ...
    by_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    easing_function_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    enable_dependent_animation_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    from_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    to_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class DoubleAnimationUsingKeyFrames(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DoubleAnimationUsingKeyFrames: ...
    def __new__(cls: typing.Type[DoubleAnimationUsingKeyFrames]) -> DoubleAnimationUsingKeyFrames:...
    @_property
    def enable_dependent_animation(self) -> bool: ...
    @enable_dependent_animation.setter
    def enable_dependent_animation(self, value: bool) -> None: ...
    @_property
    def key_frames(self) -> typing.Optional[DoubleKeyFrameCollection]: ...
    enable_dependent_animation_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class DoubleKeyFrame(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DoubleKeyFrame: ...
    @_property
    def value(self) -> winrt.system.Double: ...
    @value.setter
    def value(self, value: winrt.system.Double) -> None: ...
    @_property
    def key_time(self) -> KeyTime: ...
    @key_time.setter
    def key_time(self, value: KeyTime) -> None: ...
    key_time_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    value_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class DoubleKeyFrameCollection(winrt.system.Object, typing.MutableSequence[DoubleKeyFrame]):
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> DoubleKeyFrame: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[DoubleKeyFrame]: ...
    def insert(self, index: int, value: DoubleKeyFrame) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: DoubleKeyFrame) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[DoubleKeyFrame]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DoubleKeyFrameCollection: ...
    def __new__(cls: typing.Type[DoubleKeyFrameCollection]) -> DoubleKeyFrameCollection:...
    def append(self, value: typing.Optional[DoubleKeyFrame], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[DoubleKeyFrame]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[DoubleKeyFrame]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[DoubleKeyFrame], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[DoubleKeyFrame]]: ...
    def index_of(self, value: typing.Optional[DoubleKeyFrame], /) -> typing.Tuple[bool, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[DoubleKeyFrame], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[DoubleKeyFrame], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[DoubleKeyFrame], /) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

class DragItemThemeAnimation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DragItemThemeAnimation: ...
    def __new__(cls: typing.Type[DragItemThemeAnimation]) -> DragItemThemeAnimation:...
    @_property
    def target_name(self) -> str: ...
    @target_name.setter
    def target_name(self, value: str) -> None: ...
    target_name_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class DragOverThemeAnimation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DragOverThemeAnimation: ...
    def __new__(cls: typing.Type[DragOverThemeAnimation]) -> DragOverThemeAnimation:...
    @_property
    def to_offset(self) -> winrt.system.Double: ...
    @to_offset.setter
    def to_offset(self, value: winrt.system.Double) -> None: ...
    @_property
    def target_name(self) -> str: ...
    @target_name.setter
    def target_name(self, value: str) -> None: ...
    @_property
    def direction(self) -> winrt.windows.ui.xaml.controls.primitives.AnimationDirection: ...
    @direction.setter
    def direction(self, value: winrt.windows.ui.xaml.controls.primitives.AnimationDirection) -> None: ...
    direction_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    target_name_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    to_offset_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class DrillInNavigationTransitionInfo(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DrillInNavigationTransitionInfo: ...
    def __new__(cls: typing.Type[DrillInNavigationTransitionInfo]) -> DrillInNavigationTransitionInfo:...

class DrillInThemeAnimation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DrillInThemeAnimation: ...
    def __new__(cls: typing.Type[DrillInThemeAnimation]) -> DrillInThemeAnimation:...
    @_property
    def exit_target_name(self) -> str: ...
    @exit_target_name.setter
    def exit_target_name(self, value: str) -> None: ...
    @_property
    def exit_target(self) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    @exit_target.setter
    def exit_target(self, value: typing.Optional[winrt.windows.ui.xaml.DependencyObject]) -> None: ...
    @_property
    def entrance_target_name(self) -> str: ...
    @entrance_target_name.setter
    def entrance_target_name(self, value: str) -> None: ...
    @_property
    def entrance_target(self) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    @entrance_target.setter
    def entrance_target(self, value: typing.Optional[winrt.windows.ui.xaml.DependencyObject]) -> None: ...
    entrance_target_name_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    entrance_target_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    exit_target_name_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    exit_target_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class DrillOutThemeAnimation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DrillOutThemeAnimation: ...
    def __new__(cls: typing.Type[DrillOutThemeAnimation]) -> DrillOutThemeAnimation:...
    @_property
    def exit_target_name(self) -> str: ...
    @exit_target_name.setter
    def exit_target_name(self, value: str) -> None: ...
    @_property
    def exit_target(self) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    @exit_target.setter
    def exit_target(self, value: typing.Optional[winrt.windows.ui.xaml.DependencyObject]) -> None: ...
    @_property
    def entrance_target_name(self) -> str: ...
    @entrance_target_name.setter
    def entrance_target_name(self, value: str) -> None: ...
    @_property
    def entrance_target(self) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    @entrance_target.setter
    def entrance_target(self, value: typing.Optional[winrt.windows.ui.xaml.DependencyObject]) -> None: ...
    entrance_target_name_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    entrance_target_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    exit_target_name_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    exit_target_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class DropTargetItemThemeAnimation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DropTargetItemThemeAnimation: ...
    def __new__(cls: typing.Type[DropTargetItemThemeAnimation]) -> DropTargetItemThemeAnimation:...
    @_property
    def target_name(self) -> str: ...
    @target_name.setter
    def target_name(self, value: str) -> None: ...
    target_name_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class EasingColorKeyFrame(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EasingColorKeyFrame: ...
    def __new__(cls: typing.Type[EasingColorKeyFrame]) -> EasingColorKeyFrame:...
    @_property
    def easing_function(self) -> typing.Optional[EasingFunctionBase]: ...
    @easing_function.setter
    def easing_function(self, value: typing.Optional[EasingFunctionBase]) -> None: ...
    easing_function_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class EasingDoubleKeyFrame(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EasingDoubleKeyFrame: ...
    def __new__(cls: typing.Type[EasingDoubleKeyFrame]) -> EasingDoubleKeyFrame:...
    @_property
    def easing_function(self) -> typing.Optional[EasingFunctionBase]: ...
    @easing_function.setter
    def easing_function(self, value: typing.Optional[EasingFunctionBase]) -> None: ...
    easing_function_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class EasingFunctionBase(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EasingFunctionBase: ...
    def ease(self, normalized_time: winrt.system.Double, /) -> winrt.system.Double: ...
    @_property
    def easing_mode(self) -> EasingMode: ...
    @easing_mode.setter
    def easing_mode(self, value: EasingMode) -> None: ...
    easing_mode_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class EasingPointKeyFrame(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EasingPointKeyFrame: ...
    def __new__(cls: typing.Type[EasingPointKeyFrame]) -> EasingPointKeyFrame:...
    @_property
    def easing_function(self) -> typing.Optional[EasingFunctionBase]: ...
    @easing_function.setter
    def easing_function(self, value: typing.Optional[EasingFunctionBase]) -> None: ...
    easing_function_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class EdgeUIThemeTransition(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EdgeUIThemeTransition: ...
    def __new__(cls: typing.Type[EdgeUIThemeTransition]) -> EdgeUIThemeTransition:...
    @_property
    def edge(self) -> winrt.windows.ui.xaml.controls.primitives.EdgeTransitionLocation: ...
    @edge.setter
    def edge(self, value: winrt.windows.ui.xaml.controls.primitives.EdgeTransitionLocation) -> None: ...
    edge_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class ElasticEase(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ElasticEase: ...
    def __new__(cls: typing.Type[ElasticEase]) -> ElasticEase:...
    @_property
    def springiness(self) -> winrt.system.Double: ...
    @springiness.setter
    def springiness(self, value: winrt.system.Double) -> None: ...
    @_property
    def oscillations(self) -> winrt.system.Int32: ...
    @oscillations.setter
    def oscillations(self, value: winrt.system.Int32) -> None: ...
    oscillations_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    springiness_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class EntranceNavigationTransitionInfo(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EntranceNavigationTransitionInfo: ...
    def __new__(cls: typing.Type[EntranceNavigationTransitionInfo]) -> EntranceNavigationTransitionInfo:...
    @staticmethod
    def get_is_target_element(element: typing.Optional[winrt.windows.ui.xaml.UIElement], /) -> bool: ...
    @staticmethod
    def set_is_target_element(element: typing.Optional[winrt.windows.ui.xaml.UIElement], value: bool, /) -> None: ...
    is_target_element_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class EntranceThemeTransition(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EntranceThemeTransition: ...
    def __new__(cls: typing.Type[EntranceThemeTransition]) -> EntranceThemeTransition:...
    @_property
    def is_staggering_enabled(self) -> bool: ...
    @is_staggering_enabled.setter
    def is_staggering_enabled(self, value: bool) -> None: ...
    @_property
    def from_vertical_offset(self) -> winrt.system.Double: ...
    @from_vertical_offset.setter
    def from_vertical_offset(self, value: winrt.system.Double) -> None: ...
    @_property
    def from_horizontal_offset(self) -> winrt.system.Double: ...
    @from_horizontal_offset.setter
    def from_horizontal_offset(self, value: winrt.system.Double) -> None: ...
    from_horizontal_offset_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    from_vertical_offset_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    is_staggering_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class ExponentialEase(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ExponentialEase: ...
    def __new__(cls: typing.Type[ExponentialEase]) -> ExponentialEase:...
    @_property
    def exponent(self) -> winrt.system.Double: ...
    @exponent.setter
    def exponent(self, value: winrt.system.Double) -> None: ...
    exponent_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class FadeInThemeAnimation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FadeInThemeAnimation: ...
    def __new__(cls: typing.Type[FadeInThemeAnimation]) -> FadeInThemeAnimation:...
    @_property
    def target_name(self) -> str: ...
    @target_name.setter
    def target_name(self, value: str) -> None: ...
    target_name_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class FadeOutThemeAnimation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FadeOutThemeAnimation: ...
    def __new__(cls: typing.Type[FadeOutThemeAnimation]) -> FadeOutThemeAnimation:...
    @_property
    def target_name(self) -> str: ...
    @target_name.setter
    def target_name(self, value: str) -> None: ...
    target_name_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class GravityConnectedAnimationConfiguration(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GravityConnectedAnimationConfiguration: ...
    def __new__(cls: typing.Type[GravityConnectedAnimationConfiguration]) -> GravityConnectedAnimationConfiguration:...
    @_property
    def is_shadow_enabled(self) -> bool: ...
    @is_shadow_enabled.setter
    def is_shadow_enabled(self, value: bool) -> None: ...

class KeySpline(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> KeySpline: ...
    def __new__(cls: typing.Type[KeySpline]) -> KeySpline:...
    @_property
    def control_point2(self) -> winrt.windows.foundation.Point: ...
    @control_point2.setter
    def control_point2(self, value: winrt.windows.foundation.Point) -> None: ...
    @_property
    def control_point1(self) -> winrt.windows.foundation.Point: ...
    @control_point1.setter
    def control_point1(self, value: winrt.windows.foundation.Point) -> None: ...

class KeyTimeHelper(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> KeyTimeHelper: ...
    @staticmethod
    def from_time_span(time_span: datetime.timedelta, /) -> KeyTime: ...

class LinearColorKeyFrame(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LinearColorKeyFrame: ...
    def __new__(cls: typing.Type[LinearColorKeyFrame]) -> LinearColorKeyFrame:...

class LinearDoubleKeyFrame(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LinearDoubleKeyFrame: ...
    def __new__(cls: typing.Type[LinearDoubleKeyFrame]) -> LinearDoubleKeyFrame:...

class LinearPointKeyFrame(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LinearPointKeyFrame: ...
    def __new__(cls: typing.Type[LinearPointKeyFrame]) -> LinearPointKeyFrame:...

class NavigationThemeTransition(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NavigationThemeTransition: ...
    def __new__(cls: typing.Type[NavigationThemeTransition]) -> NavigationThemeTransition:...
    @_property
    def default_navigation_transition_info(self) -> typing.Optional[NavigationTransitionInfo]: ...
    @default_navigation_transition_info.setter
    def default_navigation_transition_info(self, value: typing.Optional[NavigationTransitionInfo]) -> None: ...
    default_navigation_transition_info_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class NavigationTransitionInfo(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NavigationTransitionInfo: ...
    def get_navigation_state_core(self) -> str: ...
    def set_navigation_state_core(self, navigation_state: str, /) -> None: ...

class ObjectAnimationUsingKeyFrames(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ObjectAnimationUsingKeyFrames: ...
    def __new__(cls: typing.Type[ObjectAnimationUsingKeyFrames]) -> ObjectAnimationUsingKeyFrames:...
    @_property
    def enable_dependent_animation(self) -> bool: ...
    @enable_dependent_animation.setter
    def enable_dependent_animation(self, value: bool) -> None: ...
    @_property
    def key_frames(self) -> typing.Optional[ObjectKeyFrameCollection]: ...
    enable_dependent_animation_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class ObjectKeyFrame(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ObjectKeyFrame: ...
    @_property
    def value(self) -> typing.Optional[winrt.system.Object]: ...
    @value.setter
    def value(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def key_time(self) -> KeyTime: ...
    @key_time.setter
    def key_time(self, value: KeyTime) -> None: ...
    key_time_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    value_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class ObjectKeyFrameCollection(winrt.system.Object, typing.MutableSequence[ObjectKeyFrame]):
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> ObjectKeyFrame: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[ObjectKeyFrame]: ...
    def insert(self, index: int, value: ObjectKeyFrame) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: ObjectKeyFrame) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[ObjectKeyFrame]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ObjectKeyFrameCollection: ...
    def __new__(cls: typing.Type[ObjectKeyFrameCollection]) -> ObjectKeyFrameCollection:...
    def append(self, value: typing.Optional[ObjectKeyFrame], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[ObjectKeyFrame]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[ObjectKeyFrame]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[ObjectKeyFrame], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[ObjectKeyFrame]]: ...
    def index_of(self, value: typing.Optional[ObjectKeyFrame], /) -> typing.Tuple[bool, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[ObjectKeyFrame], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[ObjectKeyFrame], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[ObjectKeyFrame], /) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

class PaneThemeTransition(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PaneThemeTransition: ...
    def __new__(cls: typing.Type[PaneThemeTransition]) -> PaneThemeTransition:...
    @_property
    def edge(self) -> winrt.windows.ui.xaml.controls.primitives.EdgeTransitionLocation: ...
    @edge.setter
    def edge(self, value: winrt.windows.ui.xaml.controls.primitives.EdgeTransitionLocation) -> None: ...
    edge_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class PointAnimation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PointAnimation: ...
    def __new__(cls: typing.Type[PointAnimation]) -> PointAnimation:...
    @_property
    def to(self) -> typing.Optional[typing.Optional[winrt.windows.foundation.Point]]: ...
    @to.setter
    def to(self, value: typing.Optional[typing.Optional[winrt.windows.foundation.Point]]) -> None: ...
    @_property
    def from_(self) -> typing.Optional[typing.Optional[winrt.windows.foundation.Point]]: ...
    @from_.setter
    def from_(self, value: typing.Optional[typing.Optional[winrt.windows.foundation.Point]]) -> None: ...
    @_property
    def enable_dependent_animation(self) -> bool: ...
    @enable_dependent_animation.setter
    def enable_dependent_animation(self, value: bool) -> None: ...
    @_property
    def easing_function(self) -> typing.Optional[EasingFunctionBase]: ...
    @easing_function.setter
    def easing_function(self, value: typing.Optional[EasingFunctionBase]) -> None: ...
    @_property
    def by(self) -> typing.Optional[typing.Optional[winrt.windows.foundation.Point]]: ...
    @by.setter
    def by(self, value: typing.Optional[typing.Optional[winrt.windows.foundation.Point]]) -> None: ...
    by_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    easing_function_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    enable_dependent_animation_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    from_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    to_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class PointAnimationUsingKeyFrames(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PointAnimationUsingKeyFrames: ...
    def __new__(cls: typing.Type[PointAnimationUsingKeyFrames]) -> PointAnimationUsingKeyFrames:...
    @_property
    def enable_dependent_animation(self) -> bool: ...
    @enable_dependent_animation.setter
    def enable_dependent_animation(self, value: bool) -> None: ...
    @_property
    def key_frames(self) -> typing.Optional[PointKeyFrameCollection]: ...
    enable_dependent_animation_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class PointKeyFrame(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PointKeyFrame: ...
    @_property
    def value(self) -> winrt.windows.foundation.Point: ...
    @value.setter
    def value(self, value: winrt.windows.foundation.Point) -> None: ...
    @_property
    def key_time(self) -> KeyTime: ...
    @key_time.setter
    def key_time(self, value: KeyTime) -> None: ...
    key_time_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    value_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class PointKeyFrameCollection(winrt.system.Object, typing.MutableSequence[PointKeyFrame]):
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> PointKeyFrame: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[PointKeyFrame]: ...
    def insert(self, index: int, value: PointKeyFrame) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: PointKeyFrame) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[PointKeyFrame]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PointKeyFrameCollection: ...
    def __new__(cls: typing.Type[PointKeyFrameCollection]) -> PointKeyFrameCollection:...
    def append(self, value: typing.Optional[PointKeyFrame], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[PointKeyFrame]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[PointKeyFrame]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[PointKeyFrame], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[PointKeyFrame]]: ...
    def index_of(self, value: typing.Optional[PointKeyFrame], /) -> typing.Tuple[bool, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[PointKeyFrame], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[PointKeyFrame], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[PointKeyFrame], /) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

class PointerDownThemeAnimation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PointerDownThemeAnimation: ...
    def __new__(cls: typing.Type[PointerDownThemeAnimation]) -> PointerDownThemeAnimation:...
    @_property
    def target_name(self) -> str: ...
    @target_name.setter
    def target_name(self, value: str) -> None: ...
    target_name_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class PointerUpThemeAnimation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PointerUpThemeAnimation: ...
    def __new__(cls: typing.Type[PointerUpThemeAnimation]) -> PointerUpThemeAnimation:...
    @_property
    def target_name(self) -> str: ...
    @target_name.setter
    def target_name(self, value: str) -> None: ...
    target_name_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class PopInThemeAnimation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PopInThemeAnimation: ...
    def __new__(cls: typing.Type[PopInThemeAnimation]) -> PopInThemeAnimation:...
    @_property
    def target_name(self) -> str: ...
    @target_name.setter
    def target_name(self, value: str) -> None: ...
    @_property
    def from_vertical_offset(self) -> winrt.system.Double: ...
    @from_vertical_offset.setter
    def from_vertical_offset(self, value: winrt.system.Double) -> None: ...
    @_property
    def from_horizontal_offset(self) -> winrt.system.Double: ...
    @from_horizontal_offset.setter
    def from_horizontal_offset(self, value: winrt.system.Double) -> None: ...
    from_horizontal_offset_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    from_vertical_offset_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    target_name_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class PopOutThemeAnimation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PopOutThemeAnimation: ...
    def __new__(cls: typing.Type[PopOutThemeAnimation]) -> PopOutThemeAnimation:...
    @_property
    def target_name(self) -> str: ...
    @target_name.setter
    def target_name(self, value: str) -> None: ...
    target_name_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class PopupThemeTransition(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PopupThemeTransition: ...
    def __new__(cls: typing.Type[PopupThemeTransition]) -> PopupThemeTransition:...
    @_property
    def from_vertical_offset(self) -> winrt.system.Double: ...
    @from_vertical_offset.setter
    def from_vertical_offset(self, value: winrt.system.Double) -> None: ...
    @_property
    def from_horizontal_offset(self) -> winrt.system.Double: ...
    @from_horizontal_offset.setter
    def from_horizontal_offset(self, value: winrt.system.Double) -> None: ...
    from_horizontal_offset_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    from_vertical_offset_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class PowerEase(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PowerEase: ...
    def __new__(cls: typing.Type[PowerEase]) -> PowerEase:...
    @_property
    def power(self) -> winrt.system.Double: ...
    @power.setter
    def power(self, value: winrt.system.Double) -> None: ...
    power_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class QuadraticEase(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> QuadraticEase: ...
    def __new__(cls: typing.Type[QuadraticEase]) -> QuadraticEase:...

class QuarticEase(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> QuarticEase: ...
    def __new__(cls: typing.Type[QuarticEase]) -> QuarticEase:...

class QuinticEase(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> QuinticEase: ...
    def __new__(cls: typing.Type[QuinticEase]) -> QuinticEase:...

class ReorderThemeTransition(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ReorderThemeTransition: ...
    def __new__(cls: typing.Type[ReorderThemeTransition]) -> ReorderThemeTransition:...

class RepeatBehaviorHelper(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RepeatBehaviorHelper: ...
    @staticmethod
    def equals(target: RepeatBehavior, value: RepeatBehavior, /) -> bool: ...
    @staticmethod
    def from_count(count: winrt.system.Double, /) -> RepeatBehavior: ...
    @staticmethod
    def from_duration(duration: datetime.timedelta, /) -> RepeatBehavior: ...
    @staticmethod
    def get_has_count(target: RepeatBehavior, /) -> bool: ...
    @staticmethod
    def get_has_duration(target: RepeatBehavior, /) -> bool: ...
    forever: typing.ClassVar[RepeatBehavior]

class RepositionThemeAnimation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RepositionThemeAnimation: ...
    def __new__(cls: typing.Type[RepositionThemeAnimation]) -> RepositionThemeAnimation:...
    @_property
    def target_name(self) -> str: ...
    @target_name.setter
    def target_name(self, value: str) -> None: ...
    @_property
    def from_vertical_offset(self) -> winrt.system.Double: ...
    @from_vertical_offset.setter
    def from_vertical_offset(self, value: winrt.system.Double) -> None: ...
    @_property
    def from_horizontal_offset(self) -> winrt.system.Double: ...
    @from_horizontal_offset.setter
    def from_horizontal_offset(self, value: winrt.system.Double) -> None: ...
    from_horizontal_offset_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    from_vertical_offset_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    target_name_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class RepositionThemeTransition(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RepositionThemeTransition: ...
    def __new__(cls: typing.Type[RepositionThemeTransition]) -> RepositionThemeTransition:...
    @_property
    def is_staggering_enabled(self) -> bool: ...
    @is_staggering_enabled.setter
    def is_staggering_enabled(self, value: bool) -> None: ...
    is_staggering_enabled_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class SineEase(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SineEase: ...
    def __new__(cls: typing.Type[SineEase]) -> SineEase:...

class SlideNavigationTransitionInfo(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SlideNavigationTransitionInfo: ...
    def __new__(cls: typing.Type[SlideNavigationTransitionInfo]) -> SlideNavigationTransitionInfo:...
    @_property
    def effect(self) -> SlideNavigationTransitionEffect: ...
    @effect.setter
    def effect(self, value: SlideNavigationTransitionEffect) -> None: ...
    effect_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class SplineColorKeyFrame(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SplineColorKeyFrame: ...
    def __new__(cls: typing.Type[SplineColorKeyFrame]) -> SplineColorKeyFrame:...
    @_property
    def key_spline(self) -> typing.Optional[KeySpline]: ...
    @key_spline.setter
    def key_spline(self, value: typing.Optional[KeySpline]) -> None: ...
    key_spline_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class SplineDoubleKeyFrame(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SplineDoubleKeyFrame: ...
    def __new__(cls: typing.Type[SplineDoubleKeyFrame]) -> SplineDoubleKeyFrame:...
    @_property
    def key_spline(self) -> typing.Optional[KeySpline]: ...
    @key_spline.setter
    def key_spline(self, value: typing.Optional[KeySpline]) -> None: ...
    key_spline_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class SplinePointKeyFrame(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SplinePointKeyFrame: ...
    def __new__(cls: typing.Type[SplinePointKeyFrame]) -> SplinePointKeyFrame:...
    @_property
    def key_spline(self) -> typing.Optional[KeySpline]: ...
    @key_spline.setter
    def key_spline(self, value: typing.Optional[KeySpline]) -> None: ...
    key_spline_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class SplitCloseThemeAnimation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SplitCloseThemeAnimation: ...
    def __new__(cls: typing.Type[SplitCloseThemeAnimation]) -> SplitCloseThemeAnimation:...
    @_property
    def opened_target_name(self) -> str: ...
    @opened_target_name.setter
    def opened_target_name(self, value: str) -> None: ...
    @_property
    def opened_target(self) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    @opened_target.setter
    def opened_target(self, value: typing.Optional[winrt.windows.ui.xaml.DependencyObject]) -> None: ...
    @_property
    def opened_length(self) -> winrt.system.Double: ...
    @opened_length.setter
    def opened_length(self, value: winrt.system.Double) -> None: ...
    @_property
    def offset_from_center(self) -> winrt.system.Double: ...
    @offset_from_center.setter
    def offset_from_center(self, value: winrt.system.Double) -> None: ...
    @_property
    def content_translation_offset(self) -> winrt.system.Double: ...
    @content_translation_offset.setter
    def content_translation_offset(self, value: winrt.system.Double) -> None: ...
    @_property
    def content_translation_direction(self) -> winrt.windows.ui.xaml.controls.primitives.AnimationDirection: ...
    @content_translation_direction.setter
    def content_translation_direction(self, value: winrt.windows.ui.xaml.controls.primitives.AnimationDirection) -> None: ...
    @_property
    def content_target_name(self) -> str: ...
    @content_target_name.setter
    def content_target_name(self, value: str) -> None: ...
    @_property
    def content_target(self) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    @content_target.setter
    def content_target(self, value: typing.Optional[winrt.windows.ui.xaml.DependencyObject]) -> None: ...
    @_property
    def closed_target_name(self) -> str: ...
    @closed_target_name.setter
    def closed_target_name(self, value: str) -> None: ...
    @_property
    def closed_target(self) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    @closed_target.setter
    def closed_target(self, value: typing.Optional[winrt.windows.ui.xaml.DependencyObject]) -> None: ...
    @_property
    def closed_length(self) -> winrt.system.Double: ...
    @closed_length.setter
    def closed_length(self, value: winrt.system.Double) -> None: ...
    closed_length_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    closed_target_name_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    closed_target_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    content_target_name_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    content_target_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    content_translation_direction_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    content_translation_offset_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    offset_from_center_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    opened_length_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    opened_target_name_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    opened_target_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class SplitOpenThemeAnimation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SplitOpenThemeAnimation: ...
    def __new__(cls: typing.Type[SplitOpenThemeAnimation]) -> SplitOpenThemeAnimation:...
    @_property
    def opened_target_name(self) -> str: ...
    @opened_target_name.setter
    def opened_target_name(self, value: str) -> None: ...
    @_property
    def opened_target(self) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    @opened_target.setter
    def opened_target(self, value: typing.Optional[winrt.windows.ui.xaml.DependencyObject]) -> None: ...
    @_property
    def opened_length(self) -> winrt.system.Double: ...
    @opened_length.setter
    def opened_length(self, value: winrt.system.Double) -> None: ...
    @_property
    def offset_from_center(self) -> winrt.system.Double: ...
    @offset_from_center.setter
    def offset_from_center(self, value: winrt.system.Double) -> None: ...
    @_property
    def content_translation_offset(self) -> winrt.system.Double: ...
    @content_translation_offset.setter
    def content_translation_offset(self, value: winrt.system.Double) -> None: ...
    @_property
    def content_translation_direction(self) -> winrt.windows.ui.xaml.controls.primitives.AnimationDirection: ...
    @content_translation_direction.setter
    def content_translation_direction(self, value: winrt.windows.ui.xaml.controls.primitives.AnimationDirection) -> None: ...
    @_property
    def content_target_name(self) -> str: ...
    @content_target_name.setter
    def content_target_name(self, value: str) -> None: ...
    @_property
    def content_target(self) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    @content_target.setter
    def content_target(self, value: typing.Optional[winrt.windows.ui.xaml.DependencyObject]) -> None: ...
    @_property
    def closed_target_name(self) -> str: ...
    @closed_target_name.setter
    def closed_target_name(self, value: str) -> None: ...
    @_property
    def closed_target(self) -> typing.Optional[winrt.windows.ui.xaml.DependencyObject]: ...
    @closed_target.setter
    def closed_target(self, value: typing.Optional[winrt.windows.ui.xaml.DependencyObject]) -> None: ...
    @_property
    def closed_length(self) -> winrt.system.Double: ...
    @closed_length.setter
    def closed_length(self, value: winrt.system.Double) -> None: ...
    closed_length_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    closed_target_name_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    closed_target_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    content_target_name_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    content_target_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    content_translation_direction_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    content_translation_offset_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    offset_from_center_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    opened_length_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    opened_target_name_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    opened_target_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class Storyboard(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Storyboard: ...
    def __new__(cls: typing.Type[Storyboard]) -> Storyboard:...
    def begin(self) -> None: ...
    def get_current_state(self) -> ClockState: ...
    def get_current_time(self) -> datetime.timedelta: ...
    @staticmethod
    def get_target_name(element: typing.Optional[Timeline], /) -> str: ...
    @staticmethod
    def get_target_property(element: typing.Optional[Timeline], /) -> str: ...
    def pause(self) -> None: ...
    def resume(self) -> None: ...
    def seek(self, offset: datetime.timedelta, /) -> None: ...
    def seek_aligned_to_last_tick(self, offset: datetime.timedelta, /) -> None: ...
    @staticmethod
    def set_target(timeline: typing.Optional[Timeline], target: typing.Optional[winrt.windows.ui.xaml.DependencyObject], /) -> None: ...
    @staticmethod
    def set_target_name(element: typing.Optional[Timeline], name: str, /) -> None: ...
    @staticmethod
    def set_target_property(element: typing.Optional[Timeline], path: str, /) -> None: ...
    def skip_to_fill(self) -> None: ...
    def stop(self) -> None: ...
    @_property
    def children(self) -> typing.Optional[TimelineCollection]: ...
    target_name_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    target_property_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class SuppressNavigationTransitionInfo(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SuppressNavigationTransitionInfo: ...
    def __new__(cls: typing.Type[SuppressNavigationTransitionInfo]) -> SuppressNavigationTransitionInfo:...

class SwipeBackThemeAnimation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SwipeBackThemeAnimation: ...
    def __new__(cls: typing.Type[SwipeBackThemeAnimation]) -> SwipeBackThemeAnimation:...
    @_property
    def target_name(self) -> str: ...
    @target_name.setter
    def target_name(self, value: str) -> None: ...
    @_property
    def from_vertical_offset(self) -> winrt.system.Double: ...
    @from_vertical_offset.setter
    def from_vertical_offset(self, value: winrt.system.Double) -> None: ...
    @_property
    def from_horizontal_offset(self) -> winrt.system.Double: ...
    @from_horizontal_offset.setter
    def from_horizontal_offset(self, value: winrt.system.Double) -> None: ...
    from_horizontal_offset_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    from_vertical_offset_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    target_name_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class SwipeHintThemeAnimation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SwipeHintThemeAnimation: ...
    def __new__(cls: typing.Type[SwipeHintThemeAnimation]) -> SwipeHintThemeAnimation:...
    @_property
    def to_vertical_offset(self) -> winrt.system.Double: ...
    @to_vertical_offset.setter
    def to_vertical_offset(self, value: winrt.system.Double) -> None: ...
    @_property
    def to_horizontal_offset(self) -> winrt.system.Double: ...
    @to_horizontal_offset.setter
    def to_horizontal_offset(self, value: winrt.system.Double) -> None: ...
    @_property
    def target_name(self) -> str: ...
    @target_name.setter
    def target_name(self, value: str) -> None: ...
    target_name_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    to_horizontal_offset_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    to_vertical_offset_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class Timeline(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Timeline: ...
    def add_completed(self, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def speed_ratio(self) -> winrt.system.Double: ...
    @speed_ratio.setter
    def speed_ratio(self, value: winrt.system.Double) -> None: ...
    @_property
    def repeat_behavior(self) -> RepeatBehavior: ...
    @repeat_behavior.setter
    def repeat_behavior(self, value: RepeatBehavior) -> None: ...
    @_property
    def fill_behavior(self) -> FillBehavior: ...
    @fill_behavior.setter
    def fill_behavior(self, value: FillBehavior) -> None: ...
    @_property
    def duration(self) -> winrt.windows.ui.xaml.Duration: ...
    @duration.setter
    def duration(self, value: winrt.windows.ui.xaml.Duration) -> None: ...
    @_property
    def begin_time(self) -> typing.Optional[typing.Optional[datetime.timedelta]]: ...
    @begin_time.setter
    def begin_time(self, value: typing.Optional[typing.Optional[datetime.timedelta]]) -> None: ...
    @_property
    def auto_reverse(self) -> bool: ...
    @auto_reverse.setter
    def auto_reverse(self, value: bool) -> None: ...
    allow_dependent_animations: typing.ClassVar[bool]
    auto_reverse_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    begin_time_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    duration_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    fill_behavior_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    repeat_behavior_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]
    speed_ratio_property: typing.ClassVar[typing.Optional[winrt.windows.ui.xaml.DependencyProperty]]

class TimelineCollection(winrt.system.Object, typing.MutableSequence[Timeline]):
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> Timeline: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[Timeline]: ...
    def insert(self, index: int, value: Timeline) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: Timeline) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[Timeline]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TimelineCollection: ...
    def __new__(cls: typing.Type[TimelineCollection]) -> TimelineCollection:...
    def append(self, value: typing.Optional[Timeline], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[Timeline]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[Timeline]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[Timeline], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[Timeline]]: ...
    def index_of(self, value: typing.Optional[Timeline], /) -> typing.Tuple[bool, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[Timeline], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[Timeline], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[Timeline], /) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

class Transition(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Transition: ...

class TransitionCollection(winrt.system.Object, typing.MutableSequence[Transition]):
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> Transition: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[Transition]: ...
    def insert(self, index: int, value: Transition) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: Transition) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[Transition]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TransitionCollection: ...
    def __new__(cls: typing.Type[TransitionCollection]) -> TransitionCollection:...
    def append(self, value: typing.Optional[Transition], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[Transition]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[Transition]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[Transition], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[Transition]]: ...
    def index_of(self, value: typing.Optional[Transition], /) -> typing.Tuple[bool, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[Transition], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[Transition], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[Transition], /) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

