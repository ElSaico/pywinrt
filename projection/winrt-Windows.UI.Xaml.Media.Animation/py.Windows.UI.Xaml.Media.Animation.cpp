// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "pybase.h"
#include "py.Windows.UI.Xaml.Media.Animation.h"


namespace py::cpp::Windows::UI::Xaml::Media::Animation
{
    // ----- AddDeleteThemeTransition class --------------------
    static constexpr const char* const type_name_AddDeleteThemeTransition = "AddDeleteThemeTransition";

    static PyObject* _new_AddDeleteThemeTransition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::AddDeleteThemeTransition instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AddDeleteThemeTransition(py::wrapper::Windows::UI::Xaml::Media::Animation::AddDeleteThemeTransition* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_AddDeleteThemeTransition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::AddDeleteThemeTransition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AddDeleteThemeTransition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::AddDeleteThemeTransition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AddDeleteThemeTransition[] = {
        { "_assign_array_", _assign_array_AddDeleteThemeTransition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AddDeleteThemeTransition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AddDeleteThemeTransition[] = {
        { }
    };

    static PyType_Slot _type_slots_AddDeleteThemeTransition[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AddDeleteThemeTransition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AddDeleteThemeTransition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AddDeleteThemeTransition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AddDeleteThemeTransition) },
        { },
    };

    static PyType_Spec type_spec_AddDeleteThemeTransition =
    {
        "_winrt_windows_ui_xaml_media_animation.AddDeleteThemeTransition",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::AddDeleteThemeTransition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AddDeleteThemeTransition
    };

    // ----- BackEase class --------------------
    static constexpr const char* const type_name_BackEase = "BackEase";

    static PyObject* _new_BackEase(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::BackEase instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BackEase(py::wrapper::Windows::UI::Xaml::Media::Animation::BackEase* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BackEase_get_Amplitude(py::wrapper::Windows::UI::Xaml::Media::Animation::BackEase* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.BackEase", L"Amplitude"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Amplitude());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackEase_put_Amplitude(py::wrapper::Windows::UI::Xaml::Media::Animation::BackEase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.BackEase", L"Amplitude"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Amplitude(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackEase_get_AmplitudeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.BackEase", L"AmplitudeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::BackEase::AmplitudeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BackEase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::BackEase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BackEase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::BackEase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackEase[] = {
        { "_assign_array_", _assign_array_BackEase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BackEase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BackEase[] = {
        { "amplitude", reinterpret_cast<getter>(BackEase_get_Amplitude), reinterpret_cast<setter>(BackEase_put_Amplitude), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BackEase[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BackEase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BackEase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BackEase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BackEase) },
        { },
    };

    static PyType_Spec type_spec_BackEase =
    {
        "_winrt_windows_ui_xaml_media_animation.BackEase",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::BackEase),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackEase
    };

    static PyGetSetDef getset_BackEase_Meta[] = {
        { "amplitude_property", reinterpret_cast<getter>(BackEase_get_AmplitudeProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_BackEase_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BackEase_Meta) },
        { }
    };

    static PyType_Spec type_spec_BackEase_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.BackEase_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_BackEase_Meta
    };

    // ----- BasicConnectedAnimationConfiguration class --------------------
    static constexpr const char* const type_name_BasicConnectedAnimationConfiguration = "BasicConnectedAnimationConfiguration";

    static PyObject* _new_BasicConnectedAnimationConfiguration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::BasicConnectedAnimationConfiguration instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BasicConnectedAnimationConfiguration(py::wrapper::Windows::UI::Xaml::Media::Animation::BasicConnectedAnimationConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_BasicConnectedAnimationConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::BasicConnectedAnimationConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BasicConnectedAnimationConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::BasicConnectedAnimationConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BasicConnectedAnimationConfiguration[] = {
        { "_assign_array_", _assign_array_BasicConnectedAnimationConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BasicConnectedAnimationConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BasicConnectedAnimationConfiguration[] = {
        { }
    };

    static PyType_Slot _type_slots_BasicConnectedAnimationConfiguration[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BasicConnectedAnimationConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BasicConnectedAnimationConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BasicConnectedAnimationConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BasicConnectedAnimationConfiguration) },
        { },
    };

    static PyType_Spec type_spec_BasicConnectedAnimationConfiguration =
    {
        "_winrt_windows_ui_xaml_media_animation.BasicConnectedAnimationConfiguration",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::BasicConnectedAnimationConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BasicConnectedAnimationConfiguration
    };

    // ----- BeginStoryboard class --------------------
    static constexpr const char* const type_name_BeginStoryboard = "BeginStoryboard";

    static PyObject* _new_BeginStoryboard(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::BeginStoryboard instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BeginStoryboard(py::wrapper::Windows::UI::Xaml::Media::Animation::BeginStoryboard* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BeginStoryboard_get_Storyboard(py::wrapper::Windows::UI::Xaml::Media::Animation::BeginStoryboard* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.BeginStoryboard", L"Storyboard"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Storyboard());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BeginStoryboard_put_Storyboard(py::wrapper::Windows::UI::Xaml::Media::Animation::BeginStoryboard* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.BeginStoryboard", L"Storyboard"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::Storyboard>(arg);

            self->obj.Storyboard(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BeginStoryboard_get_StoryboardProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.BeginStoryboard", L"StoryboardProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::BeginStoryboard::StoryboardProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BeginStoryboard(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::BeginStoryboard>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BeginStoryboard(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::BeginStoryboard>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BeginStoryboard[] = {
        { "_assign_array_", _assign_array_BeginStoryboard, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BeginStoryboard), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BeginStoryboard[] = {
        { "storyboard", reinterpret_cast<getter>(BeginStoryboard_get_Storyboard), reinterpret_cast<setter>(BeginStoryboard_put_Storyboard), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BeginStoryboard[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BeginStoryboard) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BeginStoryboard) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BeginStoryboard) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BeginStoryboard) },
        { },
    };

    static PyType_Spec type_spec_BeginStoryboard =
    {
        "_winrt_windows_ui_xaml_media_animation.BeginStoryboard",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::BeginStoryboard),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BeginStoryboard
    };

    static PyGetSetDef getset_BeginStoryboard_Meta[] = {
        { "storyboard_property", reinterpret_cast<getter>(BeginStoryboard_get_StoryboardProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_BeginStoryboard_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BeginStoryboard_Meta) },
        { }
    };

    static PyType_Spec type_spec_BeginStoryboard_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.BeginStoryboard_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_BeginStoryboard_Meta
    };

    // ----- BounceEase class --------------------
    static constexpr const char* const type_name_BounceEase = "BounceEase";

    static PyObject* _new_BounceEase(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::BounceEase instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BounceEase(py::wrapper::Windows::UI::Xaml::Media::Animation::BounceEase* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BounceEase_get_Bounciness(py::wrapper::Windows::UI::Xaml::Media::Animation::BounceEase* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.BounceEase", L"Bounciness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Bounciness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BounceEase_put_Bounciness(py::wrapper::Windows::UI::Xaml::Media::Animation::BounceEase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.BounceEase", L"Bounciness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Bounciness(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BounceEase_get_Bounces(py::wrapper::Windows::UI::Xaml::Media::Animation::BounceEase* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.BounceEase", L"Bounces"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Bounces());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BounceEase_put_Bounces(py::wrapper::Windows::UI::Xaml::Media::Animation::BounceEase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.BounceEase", L"Bounces"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Bounces(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BounceEase_get_BouncesProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.BounceEase", L"BouncesProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::BounceEase::BouncesProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BounceEase_get_BouncinessProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.BounceEase", L"BouncinessProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::BounceEase::BouncinessProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BounceEase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::BounceEase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BounceEase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::BounceEase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BounceEase[] = {
        { "_assign_array_", _assign_array_BounceEase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BounceEase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BounceEase[] = {
        { "bounciness", reinterpret_cast<getter>(BounceEase_get_Bounciness), reinterpret_cast<setter>(BounceEase_put_Bounciness), nullptr, nullptr },
        { "bounces", reinterpret_cast<getter>(BounceEase_get_Bounces), reinterpret_cast<setter>(BounceEase_put_Bounces), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BounceEase[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BounceEase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BounceEase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BounceEase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BounceEase) },
        { },
    };

    static PyType_Spec type_spec_BounceEase =
    {
        "_winrt_windows_ui_xaml_media_animation.BounceEase",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::BounceEase),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BounceEase
    };

    static PyGetSetDef getset_BounceEase_Meta[] = {
        { "bounces_property", reinterpret_cast<getter>(BounceEase_get_BouncesProperty), nullptr, nullptr, nullptr },
        { "bounciness_property", reinterpret_cast<getter>(BounceEase_get_BouncinessProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_BounceEase_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BounceEase_Meta) },
        { }
    };

    static PyType_Spec type_spec_BounceEase_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.BounceEase_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_BounceEase_Meta
    };

    // ----- CircleEase class --------------------
    static constexpr const char* const type_name_CircleEase = "CircleEase";

    static PyObject* _new_CircleEase(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::CircleEase instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CircleEase(py::wrapper::Windows::UI::Xaml::Media::Animation::CircleEase* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_CircleEase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::CircleEase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CircleEase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::CircleEase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CircleEase[] = {
        { "_assign_array_", _assign_array_CircleEase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CircleEase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CircleEase[] = {
        { }
    };

    static PyType_Slot _type_slots_CircleEase[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CircleEase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CircleEase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CircleEase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CircleEase) },
        { },
    };

    static PyType_Spec type_spec_CircleEase =
    {
        "_winrt_windows_ui_xaml_media_animation.CircleEase",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::CircleEase),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CircleEase
    };

    // ----- ColorAnimation class --------------------
    static constexpr const char* const type_name_ColorAnimation = "ColorAnimation";

    static PyObject* _new_ColorAnimation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::ColorAnimation instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ColorAnimation(py::wrapper::Windows::UI::Xaml::Media::Animation::ColorAnimation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ColorAnimation_get_To(py::wrapper::Windows::UI::Xaml::Media::Animation::ColorAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ColorAnimation", L"To"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.To());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorAnimation_put_To(py::wrapper::Windows::UI::Xaml::Media::Animation::ColorAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ColorAnimation", L"To"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.To(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorAnimation_get_From(py::wrapper::Windows::UI::Xaml::Media::Animation::ColorAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ColorAnimation", L"From"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.From());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorAnimation_put_From(py::wrapper::Windows::UI::Xaml::Media::Animation::ColorAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ColorAnimation", L"From"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.From(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorAnimation_get_EnableDependentAnimation(py::wrapper::Windows::UI::Xaml::Media::Animation::ColorAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ColorAnimation", L"EnableDependentAnimation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EnableDependentAnimation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorAnimation_put_EnableDependentAnimation(py::wrapper::Windows::UI::Xaml::Media::Animation::ColorAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ColorAnimation", L"EnableDependentAnimation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.EnableDependentAnimation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorAnimation_get_EasingFunction(py::wrapper::Windows::UI::Xaml::Media::Animation::ColorAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ColorAnimation", L"EasingFunction"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EasingFunction());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorAnimation_put_EasingFunction(py::wrapper::Windows::UI::Xaml::Media::Animation::ColorAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ColorAnimation", L"EasingFunction"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::EasingFunctionBase>(arg);

            self->obj.EasingFunction(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorAnimation_get_By(py::wrapper::Windows::UI::Xaml::Media::Animation::ColorAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ColorAnimation", L"By"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.By());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorAnimation_put_By(py::wrapper::Windows::UI::Xaml::Media::Animation::ColorAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ColorAnimation", L"By"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.By(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorAnimation_get_ByProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ColorAnimation", L"ByProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::ColorAnimation::ByProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorAnimation_get_EasingFunctionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ColorAnimation", L"EasingFunctionProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::ColorAnimation::EasingFunctionProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorAnimation_get_EnableDependentAnimationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ColorAnimation", L"EnableDependentAnimationProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::ColorAnimation::EnableDependentAnimationProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorAnimation_get_FromProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ColorAnimation", L"FromProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::ColorAnimation::FromProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorAnimation_get_ToProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ColorAnimation", L"ToProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::ColorAnimation::ToProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ColorAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::ColorAnimation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ColorAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::ColorAnimation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ColorAnimation[] = {
        { "_assign_array_", _assign_array_ColorAnimation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ColorAnimation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ColorAnimation[] = {
        { "to", reinterpret_cast<getter>(ColorAnimation_get_To), reinterpret_cast<setter>(ColorAnimation_put_To), nullptr, nullptr },
        { "from_", reinterpret_cast<getter>(ColorAnimation_get_From), reinterpret_cast<setter>(ColorAnimation_put_From), nullptr, nullptr },
        { "enable_dependent_animation", reinterpret_cast<getter>(ColorAnimation_get_EnableDependentAnimation), reinterpret_cast<setter>(ColorAnimation_put_EnableDependentAnimation), nullptr, nullptr },
        { "easing_function", reinterpret_cast<getter>(ColorAnimation_get_EasingFunction), reinterpret_cast<setter>(ColorAnimation_put_EasingFunction), nullptr, nullptr },
        { "by", reinterpret_cast<getter>(ColorAnimation_get_By), reinterpret_cast<setter>(ColorAnimation_put_By), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ColorAnimation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ColorAnimation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ColorAnimation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ColorAnimation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ColorAnimation) },
        { },
    };

    static PyType_Spec type_spec_ColorAnimation =
    {
        "_winrt_windows_ui_xaml_media_animation.ColorAnimation",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::ColorAnimation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ColorAnimation
    };

    static PyGetSetDef getset_ColorAnimation_Meta[] = {
        { "by_property", reinterpret_cast<getter>(ColorAnimation_get_ByProperty), nullptr, nullptr, nullptr },
        { "easing_function_property", reinterpret_cast<getter>(ColorAnimation_get_EasingFunctionProperty), nullptr, nullptr, nullptr },
        { "enable_dependent_animation_property", reinterpret_cast<getter>(ColorAnimation_get_EnableDependentAnimationProperty), nullptr, nullptr, nullptr },
        { "from_property", reinterpret_cast<getter>(ColorAnimation_get_FromProperty), nullptr, nullptr, nullptr },
        { "to_property", reinterpret_cast<getter>(ColorAnimation_get_ToProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_ColorAnimation_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ColorAnimation_Meta) },
        { }
    };

    static PyType_Spec type_spec_ColorAnimation_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.ColorAnimation_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ColorAnimation_Meta
    };

    // ----- ColorAnimationUsingKeyFrames class --------------------
    static constexpr const char* const type_name_ColorAnimationUsingKeyFrames = "ColorAnimationUsingKeyFrames";

    static PyObject* _new_ColorAnimationUsingKeyFrames(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::ColorAnimationUsingKeyFrames instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ColorAnimationUsingKeyFrames(py::wrapper::Windows::UI::Xaml::Media::Animation::ColorAnimationUsingKeyFrames* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ColorAnimationUsingKeyFrames_get_EnableDependentAnimation(py::wrapper::Windows::UI::Xaml::Media::Animation::ColorAnimationUsingKeyFrames* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ColorAnimationUsingKeyFrames", L"EnableDependentAnimation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EnableDependentAnimation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorAnimationUsingKeyFrames_put_EnableDependentAnimation(py::wrapper::Windows::UI::Xaml::Media::Animation::ColorAnimationUsingKeyFrames* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ColorAnimationUsingKeyFrames", L"EnableDependentAnimation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.EnableDependentAnimation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorAnimationUsingKeyFrames_get_KeyFrames(py::wrapper::Windows::UI::Xaml::Media::Animation::ColorAnimationUsingKeyFrames* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ColorAnimationUsingKeyFrames", L"KeyFrames"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyFrames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorAnimationUsingKeyFrames_get_EnableDependentAnimationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ColorAnimationUsingKeyFrames", L"EnableDependentAnimationProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::ColorAnimationUsingKeyFrames::EnableDependentAnimationProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ColorAnimationUsingKeyFrames(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::ColorAnimationUsingKeyFrames>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ColorAnimationUsingKeyFrames(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::ColorAnimationUsingKeyFrames>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ColorAnimationUsingKeyFrames[] = {
        { "_assign_array_", _assign_array_ColorAnimationUsingKeyFrames, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ColorAnimationUsingKeyFrames), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ColorAnimationUsingKeyFrames[] = {
        { "enable_dependent_animation", reinterpret_cast<getter>(ColorAnimationUsingKeyFrames_get_EnableDependentAnimation), reinterpret_cast<setter>(ColorAnimationUsingKeyFrames_put_EnableDependentAnimation), nullptr, nullptr },
        { "key_frames", reinterpret_cast<getter>(ColorAnimationUsingKeyFrames_get_KeyFrames), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ColorAnimationUsingKeyFrames[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ColorAnimationUsingKeyFrames) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ColorAnimationUsingKeyFrames) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ColorAnimationUsingKeyFrames) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ColorAnimationUsingKeyFrames) },
        { },
    };

    static PyType_Spec type_spec_ColorAnimationUsingKeyFrames =
    {
        "_winrt_windows_ui_xaml_media_animation.ColorAnimationUsingKeyFrames",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::ColorAnimationUsingKeyFrames),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ColorAnimationUsingKeyFrames
    };

    static PyGetSetDef getset_ColorAnimationUsingKeyFrames_Meta[] = {
        { "enable_dependent_animation_property", reinterpret_cast<getter>(ColorAnimationUsingKeyFrames_get_EnableDependentAnimationProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_ColorAnimationUsingKeyFrames_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ColorAnimationUsingKeyFrames_Meta) },
        { }
    };

    static PyType_Spec type_spec_ColorAnimationUsingKeyFrames_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.ColorAnimationUsingKeyFrames_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ColorAnimationUsingKeyFrames_Meta
    };

    // ----- ColorKeyFrame class --------------------
    static constexpr const char* const type_name_ColorKeyFrame = "ColorKeyFrame";

    static PyObject* _new_ColorKeyFrame(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ColorKeyFrame);
        return nullptr;
    }

    static void _dealloc_ColorKeyFrame(py::wrapper::Windows::UI::Xaml::Media::Animation::ColorKeyFrame* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ColorKeyFrame_get_Value(py::wrapper::Windows::UI::Xaml::Media::Animation::ColorKeyFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ColorKeyFrame", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorKeyFrame_put_Value(py::wrapper::Windows::UI::Xaml::Media::Animation::ColorKeyFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ColorKeyFrame", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorKeyFrame_get_KeyTime(py::wrapper::Windows::UI::Xaml::Media::Animation::ColorKeyFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ColorKeyFrame", L"KeyTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorKeyFrame_put_KeyTime(py::wrapper::Windows::UI::Xaml::Media::Animation::ColorKeyFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ColorKeyFrame", L"KeyTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::KeyTime>(arg);

            self->obj.KeyTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorKeyFrame_get_KeyTimeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ColorKeyFrame", L"KeyTimeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::ColorKeyFrame::KeyTimeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorKeyFrame_get_ValueProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ColorKeyFrame", L"ValueProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::ColorKeyFrame::ValueProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ColorKeyFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::ColorKeyFrame>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ColorKeyFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::ColorKeyFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ColorKeyFrame[] = {
        { "_assign_array_", _assign_array_ColorKeyFrame, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ColorKeyFrame), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ColorKeyFrame[] = {
        { "value", reinterpret_cast<getter>(ColorKeyFrame_get_Value), reinterpret_cast<setter>(ColorKeyFrame_put_Value), nullptr, nullptr },
        { "key_time", reinterpret_cast<getter>(ColorKeyFrame_get_KeyTime), reinterpret_cast<setter>(ColorKeyFrame_put_KeyTime), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ColorKeyFrame[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ColorKeyFrame) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ColorKeyFrame) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ColorKeyFrame) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ColorKeyFrame) },
        { },
    };

    static PyType_Spec type_spec_ColorKeyFrame =
    {
        "_winrt_windows_ui_xaml_media_animation.ColorKeyFrame",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::ColorKeyFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ColorKeyFrame
    };

    static PyGetSetDef getset_ColorKeyFrame_Meta[] = {
        { "key_time_property", reinterpret_cast<getter>(ColorKeyFrame_get_KeyTimeProperty), nullptr, nullptr, nullptr },
        { "value_property", reinterpret_cast<getter>(ColorKeyFrame_get_ValueProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_ColorKeyFrame_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ColorKeyFrame_Meta) },
        { }
    };

    static PyType_Spec type_spec_ColorKeyFrame_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.ColorKeyFrame_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ColorKeyFrame_Meta
    };

    // ----- ColorKeyFrameCollection class --------------------
    static constexpr const char* const type_name_ColorKeyFrameCollection = "ColorKeyFrameCollection";

    static PyObject* _new_ColorKeyFrameCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::ColorKeyFrameCollection instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ColorKeyFrameCollection(py::wrapper::Windows::UI::Xaml::Media::Animation::ColorKeyFrameCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ColorKeyFrameCollection_Append(py::wrapper::Windows::UI::Xaml::Media::Animation::ColorKeyFrameCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.ColorKeyFrameCollection", L"Append", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::ColorKeyFrame>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ColorKeyFrameCollection_Clear(py::wrapper::Windows::UI::Xaml::Media::Animation::ColorKeyFrameCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.ColorKeyFrameCollection", L"Clear", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ColorKeyFrameCollection_First(py::wrapper::Windows::UI::Xaml::Media::Animation::ColorKeyFrameCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.ColorKeyFrameCollection", L"First", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ColorKeyFrameCollection_GetAt(py::wrapper::Windows::UI::Xaml::Media::Animation::ColorKeyFrameCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.ColorKeyFrameCollection", L"GetAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ColorKeyFrameCollection_GetMany(py::wrapper::Windows::UI::Xaml::Media::Animation::ColorKeyFrameCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.ColorKeyFrameCollection", L"GetMany", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::Media::Animation::ColorKeyFrame, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ColorKeyFrameCollection_GetView(py::wrapper::Windows::UI::Xaml::Media::Animation::ColorKeyFrameCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.ColorKeyFrameCollection", L"GetView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ColorKeyFrameCollection_IndexOf(py::wrapper::Windows::UI::Xaml::Media::Animation::ColorKeyFrameCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.ColorKeyFrameCollection", L"IndexOf", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::ColorKeyFrame>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ColorKeyFrameCollection_InsertAt(py::wrapper::Windows::UI::Xaml::Media::Animation::ColorKeyFrameCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.ColorKeyFrameCollection", L"InsertAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::ColorKeyFrame>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ColorKeyFrameCollection_RemoveAt(py::wrapper::Windows::UI::Xaml::Media::Animation::ColorKeyFrameCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.ColorKeyFrameCollection", L"RemoveAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ColorKeyFrameCollection_RemoveAtEnd(py::wrapper::Windows::UI::Xaml::Media::Animation::ColorKeyFrameCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.ColorKeyFrameCollection", L"RemoveAtEnd", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ColorKeyFrameCollection_ReplaceAll(py::wrapper::Windows::UI::Xaml::Media::Animation::ColorKeyFrameCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.ColorKeyFrameCollection", L"ReplaceAll", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::Media::Animation::ColorKeyFrame, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ColorKeyFrameCollection_SetAt(py::wrapper::Windows::UI::Xaml::Media::Animation::ColorKeyFrameCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.ColorKeyFrameCollection", L"SetAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::ColorKeyFrame>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ColorKeyFrameCollection_get_Size(py::wrapper::Windows::UI::Xaml::Media::Animation::ColorKeyFrameCollection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ColorKeyFrameCollection", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ColorKeyFrameCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::ColorKeyFrameCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ColorKeyFrameCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::ColorKeyFrameCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_ColorKeyFrameCollection(py::wrapper::Windows::UI::Xaml::Media::Animation::ColorKeyFrameCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_ColorKeyFrameCollection(py::wrapper::Windows::UI::Xaml::Media::Animation::ColorKeyFrameCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_ColorKeyFrameCollection(py::wrapper::Windows::UI::Xaml::Media::Animation::ColorKeyFrameCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_ColorKeyFrameCollection(py::wrapper::Windows::UI::Xaml::Media::Animation::ColorKeyFrameCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_ColorKeyFrameCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(
                    PyExc_TypeError,
                    "indicies must be integers, not '%s'",
                    Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(
                    slice, self->obj.Size(), &start, &stop, &step, &length)
                < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(
                    PyExc_NotImplementedError,
                    "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::UI::Xaml::Media::Animation::ColorKeyFrame> items(length, empty_instance<winrt::Windows::UI::Xaml::Media::Animation::ColorKeyFrame>::get());

            auto count = self->obj.GetMany(start, items);

            if (count != length)
            {
                PyErr_Format(
                    PyExc_RuntimeError,
                    "returned count %d did not match requested length %zd",
                    count,
                    length);
                return nullptr;
            }

            return convert(items);}
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_ColorKeyFrameCollection(py::wrapper::Windows::UI::Xaml::Media::Animation::ColorKeyFrameCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (value == nullptr) { self->obj.RemoveAt(static_cast<uint32_t>(i)); }
            else { self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::ColorKeyFrame>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_ColorKeyFrameCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(ColorKeyFrameCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(ColorKeyFrameCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(ColorKeyFrameCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(ColorKeyFrameCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(ColorKeyFrameCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(ColorKeyFrameCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(ColorKeyFrameCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(ColorKeyFrameCollection_InsertAt), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(ColorKeyFrameCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(ColorKeyFrameCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(ColorKeyFrameCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(ColorKeyFrameCollection_SetAt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ColorKeyFrameCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ColorKeyFrameCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ColorKeyFrameCollection[] = {
        { "size", reinterpret_cast<getter>(ColorKeyFrameCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ColorKeyFrameCollection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ColorKeyFrameCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ColorKeyFrameCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ColorKeyFrameCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ColorKeyFrameCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_ColorKeyFrameCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_ColorKeyFrameCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_ColorKeyFrameCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_ColorKeyFrameCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_ColorKeyFrameCollection) },
        { },
    };

    static PyType_Spec type_spec_ColorKeyFrameCollection =
    {
        "_winrt_windows_ui_xaml_media_animation.ColorKeyFrameCollection",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::ColorKeyFrameCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ColorKeyFrameCollection
    };

    // ----- CommonNavigationTransitionInfo class --------------------
    static constexpr const char* const type_name_CommonNavigationTransitionInfo = "CommonNavigationTransitionInfo";

    static PyObject* _new_CommonNavigationTransitionInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::CommonNavigationTransitionInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CommonNavigationTransitionInfo(py::wrapper::Windows::UI::Xaml::Media::Animation::CommonNavigationTransitionInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CommonNavigationTransitionInfo_GetIsStaggerElement(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.CommonNavigationTransitionInfo", L"GetIsStaggerElement", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Media::Animation::CommonNavigationTransitionInfo::GetIsStaggerElement(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CommonNavigationTransitionInfo_SetIsStaggerElement(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.CommonNavigationTransitionInfo", L"SetIsStaggerElement", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Windows::UI::Xaml::Media::Animation::CommonNavigationTransitionInfo::SetIsStaggerElement(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CommonNavigationTransitionInfo_get_IsStaggeringEnabled(py::wrapper::Windows::UI::Xaml::Media::Animation::CommonNavigationTransitionInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.CommonNavigationTransitionInfo", L"IsStaggeringEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsStaggeringEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CommonNavigationTransitionInfo_put_IsStaggeringEnabled(py::wrapper::Windows::UI::Xaml::Media::Animation::CommonNavigationTransitionInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.CommonNavigationTransitionInfo", L"IsStaggeringEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsStaggeringEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CommonNavigationTransitionInfo_get_IsStaggerElementProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.CommonNavigationTransitionInfo", L"IsStaggerElementProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::CommonNavigationTransitionInfo::IsStaggerElementProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommonNavigationTransitionInfo_get_IsStaggeringEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.CommonNavigationTransitionInfo", L"IsStaggeringEnabledProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::CommonNavigationTransitionInfo::IsStaggeringEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CommonNavigationTransitionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::CommonNavigationTransitionInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CommonNavigationTransitionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::CommonNavigationTransitionInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CommonNavigationTransitionInfo[] = {
        { "get_is_stagger_element", reinterpret_cast<PyCFunction>(CommonNavigationTransitionInfo_GetIsStaggerElement), METH_VARARGS | METH_STATIC, nullptr },
        { "set_is_stagger_element", reinterpret_cast<PyCFunction>(CommonNavigationTransitionInfo_SetIsStaggerElement), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_CommonNavigationTransitionInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CommonNavigationTransitionInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CommonNavigationTransitionInfo[] = {
        { "is_staggering_enabled", reinterpret_cast<getter>(CommonNavigationTransitionInfo_get_IsStaggeringEnabled), reinterpret_cast<setter>(CommonNavigationTransitionInfo_put_IsStaggeringEnabled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CommonNavigationTransitionInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CommonNavigationTransitionInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CommonNavigationTransitionInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CommonNavigationTransitionInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CommonNavigationTransitionInfo) },
        { },
    };

    static PyType_Spec type_spec_CommonNavigationTransitionInfo =
    {
        "_winrt_windows_ui_xaml_media_animation.CommonNavigationTransitionInfo",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::CommonNavigationTransitionInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CommonNavigationTransitionInfo
    };

    static PyGetSetDef getset_CommonNavigationTransitionInfo_Meta[] = {
        { "is_stagger_element_property", reinterpret_cast<getter>(CommonNavigationTransitionInfo_get_IsStaggerElementProperty), nullptr, nullptr, nullptr },
        { "is_staggering_enabled_property", reinterpret_cast<getter>(CommonNavigationTransitionInfo_get_IsStaggeringEnabledProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_CommonNavigationTransitionInfo_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CommonNavigationTransitionInfo_Meta) },
        { }
    };

    static PyType_Spec type_spec_CommonNavigationTransitionInfo_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.CommonNavigationTransitionInfo_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CommonNavigationTransitionInfo_Meta
    };

    // ----- ConnectedAnimation class --------------------
    static constexpr const char* const type_name_ConnectedAnimation = "ConnectedAnimation";

    static PyObject* _new_ConnectedAnimation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ConnectedAnimation);
        return nullptr;
    }

    static void _dealloc_ConnectedAnimation(py::wrapper::Windows::UI::Xaml::Media::Animation::ConnectedAnimation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ConnectedAnimation_Cancel(py::wrapper::Windows::UI::Xaml::Media::Animation::ConnectedAnimation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.ConnectedAnimation", L"Cancel", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Cancel();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectedAnimation_SetAnimationComponent(py::wrapper::Windows::UI::Xaml::Media::Animation::ConnectedAnimation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.ConnectedAnimation", L"SetAnimationComponent", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::ConnectedAnimationComponent>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Composition::ICompositionAnimationBase>(args, 1);

                self->obj.SetAnimationComponent(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectedAnimation_TryStart(py::wrapper::Windows::UI::Xaml::Media::Animation::ConnectedAnimation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.ConnectedAnimation", L"TryStart", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 0);

                return py::convert(self->obj.TryStart(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.ConnectedAnimation", L"TryStart", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::UI::Xaml::UIElement>>(args, 1);

                return py::convert(self->obj.TryStart(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectedAnimation_get_IsScaleAnimationEnabled(py::wrapper::Windows::UI::Xaml::Media::Animation::ConnectedAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ConnectedAnimation", L"IsScaleAnimationEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsScaleAnimationEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConnectedAnimation_put_IsScaleAnimationEnabled(py::wrapper::Windows::UI::Xaml::Media::Animation::ConnectedAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ConnectedAnimation", L"IsScaleAnimationEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsScaleAnimationEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConnectedAnimation_get_Configuration(py::wrapper::Windows::UI::Xaml::Media::Animation::ConnectedAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ConnectedAnimation", L"Configuration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Configuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConnectedAnimation_put_Configuration(py::wrapper::Windows::UI::Xaml::Media::Animation::ConnectedAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ConnectedAnimation", L"Configuration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::ConnectedAnimationConfiguration>(arg);

            self->obj.Configuration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConnectedAnimation_add_Completed(py::wrapper::Windows::UI::Xaml::Media::Animation::ConnectedAnimation* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Media.Animation.ConnectedAnimation", L"Completed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Media::Animation::ConnectedAnimation, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Completed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectedAnimation_remove_Completed(py::wrapper::Windows::UI::Xaml::Media::Animation::ConnectedAnimation* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Media.Animation.ConnectedAnimation", L"Completed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Completed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ConnectedAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::ConnectedAnimation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ConnectedAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::ConnectedAnimation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConnectedAnimation[] = {
        { "cancel", reinterpret_cast<PyCFunction>(ConnectedAnimation_Cancel), METH_VARARGS, nullptr },
        { "set_animation_component", reinterpret_cast<PyCFunction>(ConnectedAnimation_SetAnimationComponent), METH_VARARGS, nullptr },
        { "try_start", reinterpret_cast<PyCFunction>(ConnectedAnimation_TryStart), METH_VARARGS, nullptr },
        { "add_completed", reinterpret_cast<PyCFunction>(ConnectedAnimation_add_Completed), METH_O, nullptr },
        { "remove_completed", reinterpret_cast<PyCFunction>(ConnectedAnimation_remove_Completed), METH_O, nullptr },
        { "_assign_array_", _assign_array_ConnectedAnimation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ConnectedAnimation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ConnectedAnimation[] = {
        { "is_scale_animation_enabled", reinterpret_cast<getter>(ConnectedAnimation_get_IsScaleAnimationEnabled), reinterpret_cast<setter>(ConnectedAnimation_put_IsScaleAnimationEnabled), nullptr, nullptr },
        { "configuration", reinterpret_cast<getter>(ConnectedAnimation_get_Configuration), reinterpret_cast<setter>(ConnectedAnimation_put_Configuration), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ConnectedAnimation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ConnectedAnimation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ConnectedAnimation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ConnectedAnimation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ConnectedAnimation) },
        { },
    };

    static PyType_Spec type_spec_ConnectedAnimation =
    {
        "_winrt_windows_ui_xaml_media_animation.ConnectedAnimation",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::ConnectedAnimation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConnectedAnimation
    };

    // ----- ConnectedAnimationConfiguration class --------------------
    static constexpr const char* const type_name_ConnectedAnimationConfiguration = "ConnectedAnimationConfiguration";

    static PyObject* _new_ConnectedAnimationConfiguration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ConnectedAnimationConfiguration);
        return nullptr;
    }

    static void _dealloc_ConnectedAnimationConfiguration(py::wrapper::Windows::UI::Xaml::Media::Animation::ConnectedAnimationConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ConnectedAnimationConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::ConnectedAnimationConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ConnectedAnimationConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::ConnectedAnimationConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConnectedAnimationConfiguration[] = {
        { "_assign_array_", _assign_array_ConnectedAnimationConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ConnectedAnimationConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ConnectedAnimationConfiguration[] = {
        { }
    };

    static PyType_Slot _type_slots_ConnectedAnimationConfiguration[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ConnectedAnimationConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ConnectedAnimationConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ConnectedAnimationConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ConnectedAnimationConfiguration) },
        { },
    };

    static PyType_Spec type_spec_ConnectedAnimationConfiguration =
    {
        "_winrt_windows_ui_xaml_media_animation.ConnectedAnimationConfiguration",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::ConnectedAnimationConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConnectedAnimationConfiguration
    };

    // ----- ConnectedAnimationService class --------------------
    static constexpr const char* const type_name_ConnectedAnimationService = "ConnectedAnimationService";

    static PyObject* _new_ConnectedAnimationService(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ConnectedAnimationService);
        return nullptr;
    }

    static void _dealloc_ConnectedAnimationService(py::wrapper::Windows::UI::Xaml::Media::Animation::ConnectedAnimationService* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ConnectedAnimationService_GetAnimation(py::wrapper::Windows::UI::Xaml::Media::Animation::ConnectedAnimationService* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.ConnectedAnimationService", L"GetAnimation", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetAnimation(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectedAnimationService_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.ConnectedAnimationService", L"GetForCurrentView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::UI::Xaml::Media::Animation::ConnectedAnimationService::GetForCurrentView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectedAnimationService_PrepareToAnimate(py::wrapper::Windows::UI::Xaml::Media::Animation::ConnectedAnimationService* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.ConnectedAnimationService", L"PrepareToAnimate", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 1);

                return py::convert(self->obj.PrepareToAnimate(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectedAnimationService_get_DefaultEasingFunction(py::wrapper::Windows::UI::Xaml::Media::Animation::ConnectedAnimationService* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ConnectedAnimationService", L"DefaultEasingFunction"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultEasingFunction());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConnectedAnimationService_put_DefaultEasingFunction(py::wrapper::Windows::UI::Xaml::Media::Animation::ConnectedAnimationService* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ConnectedAnimationService", L"DefaultEasingFunction"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Composition::CompositionEasingFunction>(arg);

            self->obj.DefaultEasingFunction(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConnectedAnimationService_get_DefaultDuration(py::wrapper::Windows::UI::Xaml::Media::Animation::ConnectedAnimationService* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ConnectedAnimationService", L"DefaultDuration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConnectedAnimationService_put_DefaultDuration(py::wrapper::Windows::UI::Xaml::Media::Animation::ConnectedAnimationService* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ConnectedAnimationService", L"DefaultDuration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.DefaultDuration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ConnectedAnimationService(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::ConnectedAnimationService>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ConnectedAnimationService(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::ConnectedAnimationService>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConnectedAnimationService[] = {
        { "get_animation", reinterpret_cast<PyCFunction>(ConnectedAnimationService_GetAnimation), METH_VARARGS, nullptr },
        { "get_for_current_view", reinterpret_cast<PyCFunction>(ConnectedAnimationService_GetForCurrentView), METH_VARARGS | METH_STATIC, nullptr },
        { "prepare_to_animate", reinterpret_cast<PyCFunction>(ConnectedAnimationService_PrepareToAnimate), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ConnectedAnimationService, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ConnectedAnimationService), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ConnectedAnimationService[] = {
        { "default_easing_function", reinterpret_cast<getter>(ConnectedAnimationService_get_DefaultEasingFunction), reinterpret_cast<setter>(ConnectedAnimationService_put_DefaultEasingFunction), nullptr, nullptr },
        { "default_duration", reinterpret_cast<getter>(ConnectedAnimationService_get_DefaultDuration), reinterpret_cast<setter>(ConnectedAnimationService_put_DefaultDuration), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ConnectedAnimationService[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ConnectedAnimationService) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ConnectedAnimationService) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ConnectedAnimationService) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ConnectedAnimationService) },
        { },
    };

    static PyType_Spec type_spec_ConnectedAnimationService =
    {
        "_winrt_windows_ui_xaml_media_animation.ConnectedAnimationService",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::ConnectedAnimationService),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConnectedAnimationService
    };

    // ----- ContentThemeTransition class --------------------
    static constexpr const char* const type_name_ContentThemeTransition = "ContentThemeTransition";

    static PyObject* _new_ContentThemeTransition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::ContentThemeTransition instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContentThemeTransition(py::wrapper::Windows::UI::Xaml::Media::Animation::ContentThemeTransition* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContentThemeTransition_get_VerticalOffset(py::wrapper::Windows::UI::Xaml::Media::Animation::ContentThemeTransition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ContentThemeTransition", L"VerticalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VerticalOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContentThemeTransition_put_VerticalOffset(py::wrapper::Windows::UI::Xaml::Media::Animation::ContentThemeTransition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ContentThemeTransition", L"VerticalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.VerticalOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContentThemeTransition_get_HorizontalOffset(py::wrapper::Windows::UI::Xaml::Media::Animation::ContentThemeTransition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ContentThemeTransition", L"HorizontalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HorizontalOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContentThemeTransition_put_HorizontalOffset(py::wrapper::Windows::UI::Xaml::Media::Animation::ContentThemeTransition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ContentThemeTransition", L"HorizontalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.HorizontalOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContentThemeTransition_get_HorizontalOffsetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ContentThemeTransition", L"HorizontalOffsetProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::ContentThemeTransition::HorizontalOffsetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentThemeTransition_get_VerticalOffsetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ContentThemeTransition", L"VerticalOffsetProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::ContentThemeTransition::VerticalOffsetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContentThemeTransition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::ContentThemeTransition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContentThemeTransition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::ContentThemeTransition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContentThemeTransition[] = {
        { "_assign_array_", _assign_array_ContentThemeTransition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContentThemeTransition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContentThemeTransition[] = {
        { "vertical_offset", reinterpret_cast<getter>(ContentThemeTransition_get_VerticalOffset), reinterpret_cast<setter>(ContentThemeTransition_put_VerticalOffset), nullptr, nullptr },
        { "horizontal_offset", reinterpret_cast<getter>(ContentThemeTransition_get_HorizontalOffset), reinterpret_cast<setter>(ContentThemeTransition_put_HorizontalOffset), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContentThemeTransition[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContentThemeTransition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContentThemeTransition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContentThemeTransition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContentThemeTransition) },
        { },
    };

    static PyType_Spec type_spec_ContentThemeTransition =
    {
        "_winrt_windows_ui_xaml_media_animation.ContentThemeTransition",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::ContentThemeTransition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContentThemeTransition
    };

    static PyGetSetDef getset_ContentThemeTransition_Meta[] = {
        { "horizontal_offset_property", reinterpret_cast<getter>(ContentThemeTransition_get_HorizontalOffsetProperty), nullptr, nullptr, nullptr },
        { "vertical_offset_property", reinterpret_cast<getter>(ContentThemeTransition_get_VerticalOffsetProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_ContentThemeTransition_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ContentThemeTransition_Meta) },
        { }
    };

    static PyType_Spec type_spec_ContentThemeTransition_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.ContentThemeTransition_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ContentThemeTransition_Meta
    };

    // ----- ContinuumNavigationTransitionInfo class --------------------
    static constexpr const char* const type_name_ContinuumNavigationTransitionInfo = "ContinuumNavigationTransitionInfo";

    static PyObject* _new_ContinuumNavigationTransitionInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::ContinuumNavigationTransitionInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContinuumNavigationTransitionInfo(py::wrapper::Windows::UI::Xaml::Media::Animation::ContinuumNavigationTransitionInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContinuumNavigationTransitionInfo_GetExitElementContainer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.ContinuumNavigationTransitionInfo", L"GetExitElementContainer", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ListViewBase>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Media::Animation::ContinuumNavigationTransitionInfo::GetExitElementContainer(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContinuumNavigationTransitionInfo_GetIsEntranceElement(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.ContinuumNavigationTransitionInfo", L"GetIsEntranceElement", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Media::Animation::ContinuumNavigationTransitionInfo::GetIsEntranceElement(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContinuumNavigationTransitionInfo_GetIsExitElement(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.ContinuumNavigationTransitionInfo", L"GetIsExitElement", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Media::Animation::ContinuumNavigationTransitionInfo::GetIsExitElement(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContinuumNavigationTransitionInfo_SetExitElementContainer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.ContinuumNavigationTransitionInfo", L"SetExitElementContainer", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ListViewBase>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Windows::UI::Xaml::Media::Animation::ContinuumNavigationTransitionInfo::SetExitElementContainer(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContinuumNavigationTransitionInfo_SetIsEntranceElement(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.ContinuumNavigationTransitionInfo", L"SetIsEntranceElement", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Windows::UI::Xaml::Media::Animation::ContinuumNavigationTransitionInfo::SetIsEntranceElement(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContinuumNavigationTransitionInfo_SetIsExitElement(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.ContinuumNavigationTransitionInfo", L"SetIsExitElement", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Windows::UI::Xaml::Media::Animation::ContinuumNavigationTransitionInfo::SetIsExitElement(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContinuumNavigationTransitionInfo_get_ExitElement(py::wrapper::Windows::UI::Xaml::Media::Animation::ContinuumNavigationTransitionInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ContinuumNavigationTransitionInfo", L"ExitElement"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExitElement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContinuumNavigationTransitionInfo_put_ExitElement(py::wrapper::Windows::UI::Xaml::Media::Animation::ContinuumNavigationTransitionInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ContinuumNavigationTransitionInfo", L"ExitElement"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(arg);

            self->obj.ExitElement(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContinuumNavigationTransitionInfo_get_ExitElementContainerProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ContinuumNavigationTransitionInfo", L"ExitElementContainerProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::ContinuumNavigationTransitionInfo::ExitElementContainerProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContinuumNavigationTransitionInfo_get_ExitElementProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ContinuumNavigationTransitionInfo", L"ExitElementProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::ContinuumNavigationTransitionInfo::ExitElementProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContinuumNavigationTransitionInfo_get_IsEntranceElementProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ContinuumNavigationTransitionInfo", L"IsEntranceElementProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::ContinuumNavigationTransitionInfo::IsEntranceElementProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContinuumNavigationTransitionInfo_get_IsExitElementProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ContinuumNavigationTransitionInfo", L"IsExitElementProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::ContinuumNavigationTransitionInfo::IsExitElementProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContinuumNavigationTransitionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::ContinuumNavigationTransitionInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContinuumNavigationTransitionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::ContinuumNavigationTransitionInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContinuumNavigationTransitionInfo[] = {
        { "get_exit_element_container", reinterpret_cast<PyCFunction>(ContinuumNavigationTransitionInfo_GetExitElementContainer), METH_VARARGS | METH_STATIC, nullptr },
        { "get_is_entrance_element", reinterpret_cast<PyCFunction>(ContinuumNavigationTransitionInfo_GetIsEntranceElement), METH_VARARGS | METH_STATIC, nullptr },
        { "get_is_exit_element", reinterpret_cast<PyCFunction>(ContinuumNavigationTransitionInfo_GetIsExitElement), METH_VARARGS | METH_STATIC, nullptr },
        { "set_exit_element_container", reinterpret_cast<PyCFunction>(ContinuumNavigationTransitionInfo_SetExitElementContainer), METH_VARARGS | METH_STATIC, nullptr },
        { "set_is_entrance_element", reinterpret_cast<PyCFunction>(ContinuumNavigationTransitionInfo_SetIsEntranceElement), METH_VARARGS | METH_STATIC, nullptr },
        { "set_is_exit_element", reinterpret_cast<PyCFunction>(ContinuumNavigationTransitionInfo_SetIsExitElement), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_ContinuumNavigationTransitionInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContinuumNavigationTransitionInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContinuumNavigationTransitionInfo[] = {
        { "exit_element", reinterpret_cast<getter>(ContinuumNavigationTransitionInfo_get_ExitElement), reinterpret_cast<setter>(ContinuumNavigationTransitionInfo_put_ExitElement), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContinuumNavigationTransitionInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContinuumNavigationTransitionInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContinuumNavigationTransitionInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContinuumNavigationTransitionInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContinuumNavigationTransitionInfo) },
        { },
    };

    static PyType_Spec type_spec_ContinuumNavigationTransitionInfo =
    {
        "_winrt_windows_ui_xaml_media_animation.ContinuumNavigationTransitionInfo",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::ContinuumNavigationTransitionInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContinuumNavigationTransitionInfo
    };

    static PyGetSetDef getset_ContinuumNavigationTransitionInfo_Meta[] = {
        { "exit_element_container_property", reinterpret_cast<getter>(ContinuumNavigationTransitionInfo_get_ExitElementContainerProperty), nullptr, nullptr, nullptr },
        { "exit_element_property", reinterpret_cast<getter>(ContinuumNavigationTransitionInfo_get_ExitElementProperty), nullptr, nullptr, nullptr },
        { "is_entrance_element_property", reinterpret_cast<getter>(ContinuumNavigationTransitionInfo_get_IsEntranceElementProperty), nullptr, nullptr, nullptr },
        { "is_exit_element_property", reinterpret_cast<getter>(ContinuumNavigationTransitionInfo_get_IsExitElementProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_ContinuumNavigationTransitionInfo_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ContinuumNavigationTransitionInfo_Meta) },
        { }
    };

    static PyType_Spec type_spec_ContinuumNavigationTransitionInfo_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.ContinuumNavigationTransitionInfo_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ContinuumNavigationTransitionInfo_Meta
    };

    // ----- CubicEase class --------------------
    static constexpr const char* const type_name_CubicEase = "CubicEase";

    static PyObject* _new_CubicEase(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::CubicEase instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CubicEase(py::wrapper::Windows::UI::Xaml::Media::Animation::CubicEase* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_CubicEase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::CubicEase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CubicEase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::CubicEase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CubicEase[] = {
        { "_assign_array_", _assign_array_CubicEase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CubicEase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CubicEase[] = {
        { }
    };

    static PyType_Slot _type_slots_CubicEase[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CubicEase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CubicEase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CubicEase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CubicEase) },
        { },
    };

    static PyType_Spec type_spec_CubicEase =
    {
        "_winrt_windows_ui_xaml_media_animation.CubicEase",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::CubicEase),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CubicEase
    };

    // ----- DirectConnectedAnimationConfiguration class --------------------
    static constexpr const char* const type_name_DirectConnectedAnimationConfiguration = "DirectConnectedAnimationConfiguration";

    static PyObject* _new_DirectConnectedAnimationConfiguration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::DirectConnectedAnimationConfiguration instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DirectConnectedAnimationConfiguration(py::wrapper::Windows::UI::Xaml::Media::Animation::DirectConnectedAnimationConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_DirectConnectedAnimationConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::DirectConnectedAnimationConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DirectConnectedAnimationConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::DirectConnectedAnimationConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DirectConnectedAnimationConfiguration[] = {
        { "_assign_array_", _assign_array_DirectConnectedAnimationConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DirectConnectedAnimationConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DirectConnectedAnimationConfiguration[] = {
        { }
    };

    static PyType_Slot _type_slots_DirectConnectedAnimationConfiguration[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DirectConnectedAnimationConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DirectConnectedAnimationConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DirectConnectedAnimationConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DirectConnectedAnimationConfiguration) },
        { },
    };

    static PyType_Spec type_spec_DirectConnectedAnimationConfiguration =
    {
        "_winrt_windows_ui_xaml_media_animation.DirectConnectedAnimationConfiguration",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::DirectConnectedAnimationConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DirectConnectedAnimationConfiguration
    };

    // ----- DiscreteColorKeyFrame class --------------------
    static constexpr const char* const type_name_DiscreteColorKeyFrame = "DiscreteColorKeyFrame";

    static PyObject* _new_DiscreteColorKeyFrame(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::DiscreteColorKeyFrame instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DiscreteColorKeyFrame(py::wrapper::Windows::UI::Xaml::Media::Animation::DiscreteColorKeyFrame* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_DiscreteColorKeyFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::DiscreteColorKeyFrame>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DiscreteColorKeyFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::DiscreteColorKeyFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DiscreteColorKeyFrame[] = {
        { "_assign_array_", _assign_array_DiscreteColorKeyFrame, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DiscreteColorKeyFrame), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DiscreteColorKeyFrame[] = {
        { }
    };

    static PyType_Slot _type_slots_DiscreteColorKeyFrame[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DiscreteColorKeyFrame) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DiscreteColorKeyFrame) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DiscreteColorKeyFrame) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DiscreteColorKeyFrame) },
        { },
    };

    static PyType_Spec type_spec_DiscreteColorKeyFrame =
    {
        "_winrt_windows_ui_xaml_media_animation.DiscreteColorKeyFrame",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::DiscreteColorKeyFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DiscreteColorKeyFrame
    };

    // ----- DiscreteDoubleKeyFrame class --------------------
    static constexpr const char* const type_name_DiscreteDoubleKeyFrame = "DiscreteDoubleKeyFrame";

    static PyObject* _new_DiscreteDoubleKeyFrame(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::DiscreteDoubleKeyFrame instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DiscreteDoubleKeyFrame(py::wrapper::Windows::UI::Xaml::Media::Animation::DiscreteDoubleKeyFrame* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_DiscreteDoubleKeyFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::DiscreteDoubleKeyFrame>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DiscreteDoubleKeyFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::DiscreteDoubleKeyFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DiscreteDoubleKeyFrame[] = {
        { "_assign_array_", _assign_array_DiscreteDoubleKeyFrame, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DiscreteDoubleKeyFrame), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DiscreteDoubleKeyFrame[] = {
        { }
    };

    static PyType_Slot _type_slots_DiscreteDoubleKeyFrame[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DiscreteDoubleKeyFrame) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DiscreteDoubleKeyFrame) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DiscreteDoubleKeyFrame) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DiscreteDoubleKeyFrame) },
        { },
    };

    static PyType_Spec type_spec_DiscreteDoubleKeyFrame =
    {
        "_winrt_windows_ui_xaml_media_animation.DiscreteDoubleKeyFrame",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::DiscreteDoubleKeyFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DiscreteDoubleKeyFrame
    };

    // ----- DiscreteObjectKeyFrame class --------------------
    static constexpr const char* const type_name_DiscreteObjectKeyFrame = "DiscreteObjectKeyFrame";

    static PyObject* _new_DiscreteObjectKeyFrame(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::DiscreteObjectKeyFrame instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DiscreteObjectKeyFrame(py::wrapper::Windows::UI::Xaml::Media::Animation::DiscreteObjectKeyFrame* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_DiscreteObjectKeyFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::DiscreteObjectKeyFrame>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DiscreteObjectKeyFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::DiscreteObjectKeyFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DiscreteObjectKeyFrame[] = {
        { "_assign_array_", _assign_array_DiscreteObjectKeyFrame, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DiscreteObjectKeyFrame), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DiscreteObjectKeyFrame[] = {
        { }
    };

    static PyType_Slot _type_slots_DiscreteObjectKeyFrame[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DiscreteObjectKeyFrame) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DiscreteObjectKeyFrame) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DiscreteObjectKeyFrame) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DiscreteObjectKeyFrame) },
        { },
    };

    static PyType_Spec type_spec_DiscreteObjectKeyFrame =
    {
        "_winrt_windows_ui_xaml_media_animation.DiscreteObjectKeyFrame",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::DiscreteObjectKeyFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DiscreteObjectKeyFrame
    };

    // ----- DiscretePointKeyFrame class --------------------
    static constexpr const char* const type_name_DiscretePointKeyFrame = "DiscretePointKeyFrame";

    static PyObject* _new_DiscretePointKeyFrame(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::DiscretePointKeyFrame instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DiscretePointKeyFrame(py::wrapper::Windows::UI::Xaml::Media::Animation::DiscretePointKeyFrame* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_DiscretePointKeyFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::DiscretePointKeyFrame>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DiscretePointKeyFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::DiscretePointKeyFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DiscretePointKeyFrame[] = {
        { "_assign_array_", _assign_array_DiscretePointKeyFrame, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DiscretePointKeyFrame), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DiscretePointKeyFrame[] = {
        { }
    };

    static PyType_Slot _type_slots_DiscretePointKeyFrame[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DiscretePointKeyFrame) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DiscretePointKeyFrame) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DiscretePointKeyFrame) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DiscretePointKeyFrame) },
        { },
    };

    static PyType_Spec type_spec_DiscretePointKeyFrame =
    {
        "_winrt_windows_ui_xaml_media_animation.DiscretePointKeyFrame",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::DiscretePointKeyFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DiscretePointKeyFrame
    };

    // ----- DoubleAnimation class --------------------
    static constexpr const char* const type_name_DoubleAnimation = "DoubleAnimation";

    static PyObject* _new_DoubleAnimation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::DoubleAnimation instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DoubleAnimation(py::wrapper::Windows::UI::Xaml::Media::Animation::DoubleAnimation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DoubleAnimation_get_To(py::wrapper::Windows::UI::Xaml::Media::Animation::DoubleAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DoubleAnimation", L"To"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.To());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DoubleAnimation_put_To(py::wrapper::Windows::UI::Xaml::Media::Animation::DoubleAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DoubleAnimation", L"To"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<double>>(arg);

            self->obj.To(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DoubleAnimation_get_From(py::wrapper::Windows::UI::Xaml::Media::Animation::DoubleAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DoubleAnimation", L"From"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.From());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DoubleAnimation_put_From(py::wrapper::Windows::UI::Xaml::Media::Animation::DoubleAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DoubleAnimation", L"From"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<double>>(arg);

            self->obj.From(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DoubleAnimation_get_EnableDependentAnimation(py::wrapper::Windows::UI::Xaml::Media::Animation::DoubleAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DoubleAnimation", L"EnableDependentAnimation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EnableDependentAnimation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DoubleAnimation_put_EnableDependentAnimation(py::wrapper::Windows::UI::Xaml::Media::Animation::DoubleAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DoubleAnimation", L"EnableDependentAnimation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.EnableDependentAnimation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DoubleAnimation_get_EasingFunction(py::wrapper::Windows::UI::Xaml::Media::Animation::DoubleAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DoubleAnimation", L"EasingFunction"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EasingFunction());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DoubleAnimation_put_EasingFunction(py::wrapper::Windows::UI::Xaml::Media::Animation::DoubleAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DoubleAnimation", L"EasingFunction"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::EasingFunctionBase>(arg);

            self->obj.EasingFunction(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DoubleAnimation_get_By(py::wrapper::Windows::UI::Xaml::Media::Animation::DoubleAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DoubleAnimation", L"By"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.By());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DoubleAnimation_put_By(py::wrapper::Windows::UI::Xaml::Media::Animation::DoubleAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DoubleAnimation", L"By"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<double>>(arg);

            self->obj.By(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DoubleAnimation_get_ByProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DoubleAnimation", L"ByProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::DoubleAnimation::ByProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DoubleAnimation_get_EasingFunctionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DoubleAnimation", L"EasingFunctionProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::DoubleAnimation::EasingFunctionProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DoubleAnimation_get_EnableDependentAnimationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DoubleAnimation", L"EnableDependentAnimationProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::DoubleAnimation::EnableDependentAnimationProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DoubleAnimation_get_FromProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DoubleAnimation", L"FromProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::DoubleAnimation::FromProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DoubleAnimation_get_ToProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DoubleAnimation", L"ToProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::DoubleAnimation::ToProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DoubleAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::DoubleAnimation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DoubleAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::DoubleAnimation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DoubleAnimation[] = {
        { "_assign_array_", _assign_array_DoubleAnimation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DoubleAnimation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DoubleAnimation[] = {
        { "to", reinterpret_cast<getter>(DoubleAnimation_get_To), reinterpret_cast<setter>(DoubleAnimation_put_To), nullptr, nullptr },
        { "from_", reinterpret_cast<getter>(DoubleAnimation_get_From), reinterpret_cast<setter>(DoubleAnimation_put_From), nullptr, nullptr },
        { "enable_dependent_animation", reinterpret_cast<getter>(DoubleAnimation_get_EnableDependentAnimation), reinterpret_cast<setter>(DoubleAnimation_put_EnableDependentAnimation), nullptr, nullptr },
        { "easing_function", reinterpret_cast<getter>(DoubleAnimation_get_EasingFunction), reinterpret_cast<setter>(DoubleAnimation_put_EasingFunction), nullptr, nullptr },
        { "by", reinterpret_cast<getter>(DoubleAnimation_get_By), reinterpret_cast<setter>(DoubleAnimation_put_By), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DoubleAnimation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DoubleAnimation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DoubleAnimation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DoubleAnimation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DoubleAnimation) },
        { },
    };

    static PyType_Spec type_spec_DoubleAnimation =
    {
        "_winrt_windows_ui_xaml_media_animation.DoubleAnimation",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::DoubleAnimation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DoubleAnimation
    };

    static PyGetSetDef getset_DoubleAnimation_Meta[] = {
        { "by_property", reinterpret_cast<getter>(DoubleAnimation_get_ByProperty), nullptr, nullptr, nullptr },
        { "easing_function_property", reinterpret_cast<getter>(DoubleAnimation_get_EasingFunctionProperty), nullptr, nullptr, nullptr },
        { "enable_dependent_animation_property", reinterpret_cast<getter>(DoubleAnimation_get_EnableDependentAnimationProperty), nullptr, nullptr, nullptr },
        { "from_property", reinterpret_cast<getter>(DoubleAnimation_get_FromProperty), nullptr, nullptr, nullptr },
        { "to_property", reinterpret_cast<getter>(DoubleAnimation_get_ToProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_DoubleAnimation_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DoubleAnimation_Meta) },
        { }
    };

    static PyType_Spec type_spec_DoubleAnimation_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.DoubleAnimation_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_DoubleAnimation_Meta
    };

    // ----- DoubleAnimationUsingKeyFrames class --------------------
    static constexpr const char* const type_name_DoubleAnimationUsingKeyFrames = "DoubleAnimationUsingKeyFrames";

    static PyObject* _new_DoubleAnimationUsingKeyFrames(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::DoubleAnimationUsingKeyFrames instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DoubleAnimationUsingKeyFrames(py::wrapper::Windows::UI::Xaml::Media::Animation::DoubleAnimationUsingKeyFrames* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DoubleAnimationUsingKeyFrames_get_EnableDependentAnimation(py::wrapper::Windows::UI::Xaml::Media::Animation::DoubleAnimationUsingKeyFrames* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DoubleAnimationUsingKeyFrames", L"EnableDependentAnimation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EnableDependentAnimation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DoubleAnimationUsingKeyFrames_put_EnableDependentAnimation(py::wrapper::Windows::UI::Xaml::Media::Animation::DoubleAnimationUsingKeyFrames* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DoubleAnimationUsingKeyFrames", L"EnableDependentAnimation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.EnableDependentAnimation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DoubleAnimationUsingKeyFrames_get_KeyFrames(py::wrapper::Windows::UI::Xaml::Media::Animation::DoubleAnimationUsingKeyFrames* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DoubleAnimationUsingKeyFrames", L"KeyFrames"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyFrames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DoubleAnimationUsingKeyFrames_get_EnableDependentAnimationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DoubleAnimationUsingKeyFrames", L"EnableDependentAnimationProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::DoubleAnimationUsingKeyFrames::EnableDependentAnimationProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DoubleAnimationUsingKeyFrames(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::DoubleAnimationUsingKeyFrames>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DoubleAnimationUsingKeyFrames(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::DoubleAnimationUsingKeyFrames>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DoubleAnimationUsingKeyFrames[] = {
        { "_assign_array_", _assign_array_DoubleAnimationUsingKeyFrames, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DoubleAnimationUsingKeyFrames), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DoubleAnimationUsingKeyFrames[] = {
        { "enable_dependent_animation", reinterpret_cast<getter>(DoubleAnimationUsingKeyFrames_get_EnableDependentAnimation), reinterpret_cast<setter>(DoubleAnimationUsingKeyFrames_put_EnableDependentAnimation), nullptr, nullptr },
        { "key_frames", reinterpret_cast<getter>(DoubleAnimationUsingKeyFrames_get_KeyFrames), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DoubleAnimationUsingKeyFrames[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DoubleAnimationUsingKeyFrames) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DoubleAnimationUsingKeyFrames) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DoubleAnimationUsingKeyFrames) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DoubleAnimationUsingKeyFrames) },
        { },
    };

    static PyType_Spec type_spec_DoubleAnimationUsingKeyFrames =
    {
        "_winrt_windows_ui_xaml_media_animation.DoubleAnimationUsingKeyFrames",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::DoubleAnimationUsingKeyFrames),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DoubleAnimationUsingKeyFrames
    };

    static PyGetSetDef getset_DoubleAnimationUsingKeyFrames_Meta[] = {
        { "enable_dependent_animation_property", reinterpret_cast<getter>(DoubleAnimationUsingKeyFrames_get_EnableDependentAnimationProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_DoubleAnimationUsingKeyFrames_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DoubleAnimationUsingKeyFrames_Meta) },
        { }
    };

    static PyType_Spec type_spec_DoubleAnimationUsingKeyFrames_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.DoubleAnimationUsingKeyFrames_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_DoubleAnimationUsingKeyFrames_Meta
    };

    // ----- DoubleKeyFrame class --------------------
    static constexpr const char* const type_name_DoubleKeyFrame = "DoubleKeyFrame";

    static PyObject* _new_DoubleKeyFrame(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DoubleKeyFrame);
        return nullptr;
    }

    static void _dealloc_DoubleKeyFrame(py::wrapper::Windows::UI::Xaml::Media::Animation::DoubleKeyFrame* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DoubleKeyFrame_get_Value(py::wrapper::Windows::UI::Xaml::Media::Animation::DoubleKeyFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DoubleKeyFrame", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DoubleKeyFrame_put_Value(py::wrapper::Windows::UI::Xaml::Media::Animation::DoubleKeyFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DoubleKeyFrame", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DoubleKeyFrame_get_KeyTime(py::wrapper::Windows::UI::Xaml::Media::Animation::DoubleKeyFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DoubleKeyFrame", L"KeyTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DoubleKeyFrame_put_KeyTime(py::wrapper::Windows::UI::Xaml::Media::Animation::DoubleKeyFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DoubleKeyFrame", L"KeyTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::KeyTime>(arg);

            self->obj.KeyTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DoubleKeyFrame_get_KeyTimeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DoubleKeyFrame", L"KeyTimeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::DoubleKeyFrame::KeyTimeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DoubleKeyFrame_get_ValueProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DoubleKeyFrame", L"ValueProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::DoubleKeyFrame::ValueProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DoubleKeyFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::DoubleKeyFrame>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DoubleKeyFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::DoubleKeyFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DoubleKeyFrame[] = {
        { "_assign_array_", _assign_array_DoubleKeyFrame, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DoubleKeyFrame), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DoubleKeyFrame[] = {
        { "value", reinterpret_cast<getter>(DoubleKeyFrame_get_Value), reinterpret_cast<setter>(DoubleKeyFrame_put_Value), nullptr, nullptr },
        { "key_time", reinterpret_cast<getter>(DoubleKeyFrame_get_KeyTime), reinterpret_cast<setter>(DoubleKeyFrame_put_KeyTime), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DoubleKeyFrame[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DoubleKeyFrame) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DoubleKeyFrame) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DoubleKeyFrame) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DoubleKeyFrame) },
        { },
    };

    static PyType_Spec type_spec_DoubleKeyFrame =
    {
        "_winrt_windows_ui_xaml_media_animation.DoubleKeyFrame",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::DoubleKeyFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DoubleKeyFrame
    };

    static PyGetSetDef getset_DoubleKeyFrame_Meta[] = {
        { "key_time_property", reinterpret_cast<getter>(DoubleKeyFrame_get_KeyTimeProperty), nullptr, nullptr, nullptr },
        { "value_property", reinterpret_cast<getter>(DoubleKeyFrame_get_ValueProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_DoubleKeyFrame_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DoubleKeyFrame_Meta) },
        { }
    };

    static PyType_Spec type_spec_DoubleKeyFrame_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.DoubleKeyFrame_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_DoubleKeyFrame_Meta
    };

    // ----- DoubleKeyFrameCollection class --------------------
    static constexpr const char* const type_name_DoubleKeyFrameCollection = "DoubleKeyFrameCollection";

    static PyObject* _new_DoubleKeyFrameCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::DoubleKeyFrameCollection instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DoubleKeyFrameCollection(py::wrapper::Windows::UI::Xaml::Media::Animation::DoubleKeyFrameCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DoubleKeyFrameCollection_Append(py::wrapper::Windows::UI::Xaml::Media::Animation::DoubleKeyFrameCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.DoubleKeyFrameCollection", L"Append", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::DoubleKeyFrame>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DoubleKeyFrameCollection_Clear(py::wrapper::Windows::UI::Xaml::Media::Animation::DoubleKeyFrameCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.DoubleKeyFrameCollection", L"Clear", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DoubleKeyFrameCollection_First(py::wrapper::Windows::UI::Xaml::Media::Animation::DoubleKeyFrameCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.DoubleKeyFrameCollection", L"First", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DoubleKeyFrameCollection_GetAt(py::wrapper::Windows::UI::Xaml::Media::Animation::DoubleKeyFrameCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.DoubleKeyFrameCollection", L"GetAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DoubleKeyFrameCollection_GetMany(py::wrapper::Windows::UI::Xaml::Media::Animation::DoubleKeyFrameCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.DoubleKeyFrameCollection", L"GetMany", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::Media::Animation::DoubleKeyFrame, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DoubleKeyFrameCollection_GetView(py::wrapper::Windows::UI::Xaml::Media::Animation::DoubleKeyFrameCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.DoubleKeyFrameCollection", L"GetView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DoubleKeyFrameCollection_IndexOf(py::wrapper::Windows::UI::Xaml::Media::Animation::DoubleKeyFrameCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.DoubleKeyFrameCollection", L"IndexOf", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::DoubleKeyFrame>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DoubleKeyFrameCollection_InsertAt(py::wrapper::Windows::UI::Xaml::Media::Animation::DoubleKeyFrameCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.DoubleKeyFrameCollection", L"InsertAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::DoubleKeyFrame>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DoubleKeyFrameCollection_RemoveAt(py::wrapper::Windows::UI::Xaml::Media::Animation::DoubleKeyFrameCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.DoubleKeyFrameCollection", L"RemoveAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DoubleKeyFrameCollection_RemoveAtEnd(py::wrapper::Windows::UI::Xaml::Media::Animation::DoubleKeyFrameCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.DoubleKeyFrameCollection", L"RemoveAtEnd", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DoubleKeyFrameCollection_ReplaceAll(py::wrapper::Windows::UI::Xaml::Media::Animation::DoubleKeyFrameCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.DoubleKeyFrameCollection", L"ReplaceAll", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::Media::Animation::DoubleKeyFrame, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DoubleKeyFrameCollection_SetAt(py::wrapper::Windows::UI::Xaml::Media::Animation::DoubleKeyFrameCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.DoubleKeyFrameCollection", L"SetAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::DoubleKeyFrame>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DoubleKeyFrameCollection_get_Size(py::wrapper::Windows::UI::Xaml::Media::Animation::DoubleKeyFrameCollection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DoubleKeyFrameCollection", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DoubleKeyFrameCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::DoubleKeyFrameCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DoubleKeyFrameCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::DoubleKeyFrameCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_DoubleKeyFrameCollection(py::wrapper::Windows::UI::Xaml::Media::Animation::DoubleKeyFrameCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_DoubleKeyFrameCollection(py::wrapper::Windows::UI::Xaml::Media::Animation::DoubleKeyFrameCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_DoubleKeyFrameCollection(py::wrapper::Windows::UI::Xaml::Media::Animation::DoubleKeyFrameCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_DoubleKeyFrameCollection(py::wrapper::Windows::UI::Xaml::Media::Animation::DoubleKeyFrameCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_DoubleKeyFrameCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(
                    PyExc_TypeError,
                    "indicies must be integers, not '%s'",
                    Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(
                    slice, self->obj.Size(), &start, &stop, &step, &length)
                < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(
                    PyExc_NotImplementedError,
                    "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::UI::Xaml::Media::Animation::DoubleKeyFrame> items(length, empty_instance<winrt::Windows::UI::Xaml::Media::Animation::DoubleKeyFrame>::get());

            auto count = self->obj.GetMany(start, items);

            if (count != length)
            {
                PyErr_Format(
                    PyExc_RuntimeError,
                    "returned count %d did not match requested length %zd",
                    count,
                    length);
                return nullptr;
            }

            return convert(items);}
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_DoubleKeyFrameCollection(py::wrapper::Windows::UI::Xaml::Media::Animation::DoubleKeyFrameCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (value == nullptr) { self->obj.RemoveAt(static_cast<uint32_t>(i)); }
            else { self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::DoubleKeyFrame>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_DoubleKeyFrameCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(DoubleKeyFrameCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(DoubleKeyFrameCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(DoubleKeyFrameCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(DoubleKeyFrameCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(DoubleKeyFrameCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(DoubleKeyFrameCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(DoubleKeyFrameCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(DoubleKeyFrameCollection_InsertAt), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(DoubleKeyFrameCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(DoubleKeyFrameCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(DoubleKeyFrameCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(DoubleKeyFrameCollection_SetAt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DoubleKeyFrameCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DoubleKeyFrameCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DoubleKeyFrameCollection[] = {
        { "size", reinterpret_cast<getter>(DoubleKeyFrameCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DoubleKeyFrameCollection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DoubleKeyFrameCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DoubleKeyFrameCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DoubleKeyFrameCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DoubleKeyFrameCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_DoubleKeyFrameCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_DoubleKeyFrameCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_DoubleKeyFrameCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_DoubleKeyFrameCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_DoubleKeyFrameCollection) },
        { },
    };

    static PyType_Spec type_spec_DoubleKeyFrameCollection =
    {
        "_winrt_windows_ui_xaml_media_animation.DoubleKeyFrameCollection",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::DoubleKeyFrameCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DoubleKeyFrameCollection
    };

    // ----- DragItemThemeAnimation class --------------------
    static constexpr const char* const type_name_DragItemThemeAnimation = "DragItemThemeAnimation";

    static PyObject* _new_DragItemThemeAnimation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::DragItemThemeAnimation instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DragItemThemeAnimation(py::wrapper::Windows::UI::Xaml::Media::Animation::DragItemThemeAnimation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DragItemThemeAnimation_get_TargetName(py::wrapper::Windows::UI::Xaml::Media::Animation::DragItemThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DragItemThemeAnimation", L"TargetName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TargetName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DragItemThemeAnimation_put_TargetName(py::wrapper::Windows::UI::Xaml::Media::Animation::DragItemThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DragItemThemeAnimation", L"TargetName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.TargetName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DragItemThemeAnimation_get_TargetNameProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DragItemThemeAnimation", L"TargetNameProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::DragItemThemeAnimation::TargetNameProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DragItemThemeAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::DragItemThemeAnimation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DragItemThemeAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::DragItemThemeAnimation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DragItemThemeAnimation[] = {
        { "_assign_array_", _assign_array_DragItemThemeAnimation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DragItemThemeAnimation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DragItemThemeAnimation[] = {
        { "target_name", reinterpret_cast<getter>(DragItemThemeAnimation_get_TargetName), reinterpret_cast<setter>(DragItemThemeAnimation_put_TargetName), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DragItemThemeAnimation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DragItemThemeAnimation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DragItemThemeAnimation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DragItemThemeAnimation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DragItemThemeAnimation) },
        { },
    };

    static PyType_Spec type_spec_DragItemThemeAnimation =
    {
        "_winrt_windows_ui_xaml_media_animation.DragItemThemeAnimation",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::DragItemThemeAnimation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DragItemThemeAnimation
    };

    static PyGetSetDef getset_DragItemThemeAnimation_Meta[] = {
        { "target_name_property", reinterpret_cast<getter>(DragItemThemeAnimation_get_TargetNameProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_DragItemThemeAnimation_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DragItemThemeAnimation_Meta) },
        { }
    };

    static PyType_Spec type_spec_DragItemThemeAnimation_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.DragItemThemeAnimation_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_DragItemThemeAnimation_Meta
    };

    // ----- DragOverThemeAnimation class --------------------
    static constexpr const char* const type_name_DragOverThemeAnimation = "DragOverThemeAnimation";

    static PyObject* _new_DragOverThemeAnimation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::DragOverThemeAnimation instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DragOverThemeAnimation(py::wrapper::Windows::UI::Xaml::Media::Animation::DragOverThemeAnimation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DragOverThemeAnimation_get_ToOffset(py::wrapper::Windows::UI::Xaml::Media::Animation::DragOverThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DragOverThemeAnimation", L"ToOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ToOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DragOverThemeAnimation_put_ToOffset(py::wrapper::Windows::UI::Xaml::Media::Animation::DragOverThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DragOverThemeAnimation", L"ToOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.ToOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DragOverThemeAnimation_get_TargetName(py::wrapper::Windows::UI::Xaml::Media::Animation::DragOverThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DragOverThemeAnimation", L"TargetName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TargetName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DragOverThemeAnimation_put_TargetName(py::wrapper::Windows::UI::Xaml::Media::Animation::DragOverThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DragOverThemeAnimation", L"TargetName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.TargetName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DragOverThemeAnimation_get_Direction(py::wrapper::Windows::UI::Xaml::Media::Animation::DragOverThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DragOverThemeAnimation", L"Direction"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Direction());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DragOverThemeAnimation_put_Direction(py::wrapper::Windows::UI::Xaml::Media::Animation::DragOverThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DragOverThemeAnimation", L"Direction"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::AnimationDirection>(arg);

            self->obj.Direction(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DragOverThemeAnimation_get_DirectionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DragOverThemeAnimation", L"DirectionProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::DragOverThemeAnimation::DirectionProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DragOverThemeAnimation_get_TargetNameProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DragOverThemeAnimation", L"TargetNameProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::DragOverThemeAnimation::TargetNameProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DragOverThemeAnimation_get_ToOffsetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DragOverThemeAnimation", L"ToOffsetProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::DragOverThemeAnimation::ToOffsetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DragOverThemeAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::DragOverThemeAnimation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DragOverThemeAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::DragOverThemeAnimation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DragOverThemeAnimation[] = {
        { "_assign_array_", _assign_array_DragOverThemeAnimation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DragOverThemeAnimation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DragOverThemeAnimation[] = {
        { "to_offset", reinterpret_cast<getter>(DragOverThemeAnimation_get_ToOffset), reinterpret_cast<setter>(DragOverThemeAnimation_put_ToOffset), nullptr, nullptr },
        { "target_name", reinterpret_cast<getter>(DragOverThemeAnimation_get_TargetName), reinterpret_cast<setter>(DragOverThemeAnimation_put_TargetName), nullptr, nullptr },
        { "direction", reinterpret_cast<getter>(DragOverThemeAnimation_get_Direction), reinterpret_cast<setter>(DragOverThemeAnimation_put_Direction), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DragOverThemeAnimation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DragOverThemeAnimation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DragOverThemeAnimation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DragOverThemeAnimation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DragOverThemeAnimation) },
        { },
    };

    static PyType_Spec type_spec_DragOverThemeAnimation =
    {
        "_winrt_windows_ui_xaml_media_animation.DragOverThemeAnimation",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::DragOverThemeAnimation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DragOverThemeAnimation
    };

    static PyGetSetDef getset_DragOverThemeAnimation_Meta[] = {
        { "direction_property", reinterpret_cast<getter>(DragOverThemeAnimation_get_DirectionProperty), nullptr, nullptr, nullptr },
        { "target_name_property", reinterpret_cast<getter>(DragOverThemeAnimation_get_TargetNameProperty), nullptr, nullptr, nullptr },
        { "to_offset_property", reinterpret_cast<getter>(DragOverThemeAnimation_get_ToOffsetProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_DragOverThemeAnimation_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DragOverThemeAnimation_Meta) },
        { }
    };

    static PyType_Spec type_spec_DragOverThemeAnimation_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.DragOverThemeAnimation_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_DragOverThemeAnimation_Meta
    };

    // ----- DrillInNavigationTransitionInfo class --------------------
    static constexpr const char* const type_name_DrillInNavigationTransitionInfo = "DrillInNavigationTransitionInfo";

    static PyObject* _new_DrillInNavigationTransitionInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::DrillInNavigationTransitionInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DrillInNavigationTransitionInfo(py::wrapper::Windows::UI::Xaml::Media::Animation::DrillInNavigationTransitionInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_DrillInNavigationTransitionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::DrillInNavigationTransitionInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DrillInNavigationTransitionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::DrillInNavigationTransitionInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DrillInNavigationTransitionInfo[] = {
        { "_assign_array_", _assign_array_DrillInNavigationTransitionInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DrillInNavigationTransitionInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DrillInNavigationTransitionInfo[] = {
        { }
    };

    static PyType_Slot _type_slots_DrillInNavigationTransitionInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DrillInNavigationTransitionInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DrillInNavigationTransitionInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DrillInNavigationTransitionInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DrillInNavigationTransitionInfo) },
        { },
    };

    static PyType_Spec type_spec_DrillInNavigationTransitionInfo =
    {
        "_winrt_windows_ui_xaml_media_animation.DrillInNavigationTransitionInfo",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::DrillInNavigationTransitionInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DrillInNavigationTransitionInfo
    };

    // ----- DrillInThemeAnimation class --------------------
    static constexpr const char* const type_name_DrillInThemeAnimation = "DrillInThemeAnimation";

    static PyObject* _new_DrillInThemeAnimation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::DrillInThemeAnimation instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DrillInThemeAnimation(py::wrapper::Windows::UI::Xaml::Media::Animation::DrillInThemeAnimation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DrillInThemeAnimation_get_ExitTargetName(py::wrapper::Windows::UI::Xaml::Media::Animation::DrillInThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DrillInThemeAnimation", L"ExitTargetName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExitTargetName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DrillInThemeAnimation_put_ExitTargetName(py::wrapper::Windows::UI::Xaml::Media::Animation::DrillInThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DrillInThemeAnimation", L"ExitTargetName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ExitTargetName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DrillInThemeAnimation_get_ExitTarget(py::wrapper::Windows::UI::Xaml::Media::Animation::DrillInThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DrillInThemeAnimation", L"ExitTarget"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExitTarget());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DrillInThemeAnimation_put_ExitTarget(py::wrapper::Windows::UI::Xaml::Media::Animation::DrillInThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DrillInThemeAnimation", L"ExitTarget"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(arg);

            self->obj.ExitTarget(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DrillInThemeAnimation_get_EntranceTargetName(py::wrapper::Windows::UI::Xaml::Media::Animation::DrillInThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DrillInThemeAnimation", L"EntranceTargetName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EntranceTargetName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DrillInThemeAnimation_put_EntranceTargetName(py::wrapper::Windows::UI::Xaml::Media::Animation::DrillInThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DrillInThemeAnimation", L"EntranceTargetName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.EntranceTargetName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DrillInThemeAnimation_get_EntranceTarget(py::wrapper::Windows::UI::Xaml::Media::Animation::DrillInThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DrillInThemeAnimation", L"EntranceTarget"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EntranceTarget());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DrillInThemeAnimation_put_EntranceTarget(py::wrapper::Windows::UI::Xaml::Media::Animation::DrillInThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DrillInThemeAnimation", L"EntranceTarget"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(arg);

            self->obj.EntranceTarget(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DrillInThemeAnimation_get_EntranceTargetNameProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DrillInThemeAnimation", L"EntranceTargetNameProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::DrillInThemeAnimation::EntranceTargetNameProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DrillInThemeAnimation_get_EntranceTargetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DrillInThemeAnimation", L"EntranceTargetProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::DrillInThemeAnimation::EntranceTargetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DrillInThemeAnimation_get_ExitTargetNameProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DrillInThemeAnimation", L"ExitTargetNameProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::DrillInThemeAnimation::ExitTargetNameProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DrillInThemeAnimation_get_ExitTargetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DrillInThemeAnimation", L"ExitTargetProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::DrillInThemeAnimation::ExitTargetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DrillInThemeAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::DrillInThemeAnimation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DrillInThemeAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::DrillInThemeAnimation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DrillInThemeAnimation[] = {
        { "_assign_array_", _assign_array_DrillInThemeAnimation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DrillInThemeAnimation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DrillInThemeAnimation[] = {
        { "exit_target_name", reinterpret_cast<getter>(DrillInThemeAnimation_get_ExitTargetName), reinterpret_cast<setter>(DrillInThemeAnimation_put_ExitTargetName), nullptr, nullptr },
        { "exit_target", reinterpret_cast<getter>(DrillInThemeAnimation_get_ExitTarget), reinterpret_cast<setter>(DrillInThemeAnimation_put_ExitTarget), nullptr, nullptr },
        { "entrance_target_name", reinterpret_cast<getter>(DrillInThemeAnimation_get_EntranceTargetName), reinterpret_cast<setter>(DrillInThemeAnimation_put_EntranceTargetName), nullptr, nullptr },
        { "entrance_target", reinterpret_cast<getter>(DrillInThemeAnimation_get_EntranceTarget), reinterpret_cast<setter>(DrillInThemeAnimation_put_EntranceTarget), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DrillInThemeAnimation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DrillInThemeAnimation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DrillInThemeAnimation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DrillInThemeAnimation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DrillInThemeAnimation) },
        { },
    };

    static PyType_Spec type_spec_DrillInThemeAnimation =
    {
        "_winrt_windows_ui_xaml_media_animation.DrillInThemeAnimation",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::DrillInThemeAnimation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DrillInThemeAnimation
    };

    static PyGetSetDef getset_DrillInThemeAnimation_Meta[] = {
        { "entrance_target_name_property", reinterpret_cast<getter>(DrillInThemeAnimation_get_EntranceTargetNameProperty), nullptr, nullptr, nullptr },
        { "entrance_target_property", reinterpret_cast<getter>(DrillInThemeAnimation_get_EntranceTargetProperty), nullptr, nullptr, nullptr },
        { "exit_target_name_property", reinterpret_cast<getter>(DrillInThemeAnimation_get_ExitTargetNameProperty), nullptr, nullptr, nullptr },
        { "exit_target_property", reinterpret_cast<getter>(DrillInThemeAnimation_get_ExitTargetProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_DrillInThemeAnimation_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DrillInThemeAnimation_Meta) },
        { }
    };

    static PyType_Spec type_spec_DrillInThemeAnimation_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.DrillInThemeAnimation_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_DrillInThemeAnimation_Meta
    };

    // ----- DrillOutThemeAnimation class --------------------
    static constexpr const char* const type_name_DrillOutThemeAnimation = "DrillOutThemeAnimation";

    static PyObject* _new_DrillOutThemeAnimation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::DrillOutThemeAnimation instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DrillOutThemeAnimation(py::wrapper::Windows::UI::Xaml::Media::Animation::DrillOutThemeAnimation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DrillOutThemeAnimation_get_ExitTargetName(py::wrapper::Windows::UI::Xaml::Media::Animation::DrillOutThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DrillOutThemeAnimation", L"ExitTargetName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExitTargetName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DrillOutThemeAnimation_put_ExitTargetName(py::wrapper::Windows::UI::Xaml::Media::Animation::DrillOutThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DrillOutThemeAnimation", L"ExitTargetName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ExitTargetName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DrillOutThemeAnimation_get_ExitTarget(py::wrapper::Windows::UI::Xaml::Media::Animation::DrillOutThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DrillOutThemeAnimation", L"ExitTarget"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExitTarget());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DrillOutThemeAnimation_put_ExitTarget(py::wrapper::Windows::UI::Xaml::Media::Animation::DrillOutThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DrillOutThemeAnimation", L"ExitTarget"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(arg);

            self->obj.ExitTarget(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DrillOutThemeAnimation_get_EntranceTargetName(py::wrapper::Windows::UI::Xaml::Media::Animation::DrillOutThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DrillOutThemeAnimation", L"EntranceTargetName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EntranceTargetName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DrillOutThemeAnimation_put_EntranceTargetName(py::wrapper::Windows::UI::Xaml::Media::Animation::DrillOutThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DrillOutThemeAnimation", L"EntranceTargetName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.EntranceTargetName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DrillOutThemeAnimation_get_EntranceTarget(py::wrapper::Windows::UI::Xaml::Media::Animation::DrillOutThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DrillOutThemeAnimation", L"EntranceTarget"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EntranceTarget());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DrillOutThemeAnimation_put_EntranceTarget(py::wrapper::Windows::UI::Xaml::Media::Animation::DrillOutThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DrillOutThemeAnimation", L"EntranceTarget"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(arg);

            self->obj.EntranceTarget(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DrillOutThemeAnimation_get_EntranceTargetNameProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DrillOutThemeAnimation", L"EntranceTargetNameProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::DrillOutThemeAnimation::EntranceTargetNameProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DrillOutThemeAnimation_get_EntranceTargetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DrillOutThemeAnimation", L"EntranceTargetProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::DrillOutThemeAnimation::EntranceTargetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DrillOutThemeAnimation_get_ExitTargetNameProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DrillOutThemeAnimation", L"ExitTargetNameProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::DrillOutThemeAnimation::ExitTargetNameProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DrillOutThemeAnimation_get_ExitTargetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DrillOutThemeAnimation", L"ExitTargetProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::DrillOutThemeAnimation::ExitTargetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DrillOutThemeAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::DrillOutThemeAnimation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DrillOutThemeAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::DrillOutThemeAnimation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DrillOutThemeAnimation[] = {
        { "_assign_array_", _assign_array_DrillOutThemeAnimation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DrillOutThemeAnimation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DrillOutThemeAnimation[] = {
        { "exit_target_name", reinterpret_cast<getter>(DrillOutThemeAnimation_get_ExitTargetName), reinterpret_cast<setter>(DrillOutThemeAnimation_put_ExitTargetName), nullptr, nullptr },
        { "exit_target", reinterpret_cast<getter>(DrillOutThemeAnimation_get_ExitTarget), reinterpret_cast<setter>(DrillOutThemeAnimation_put_ExitTarget), nullptr, nullptr },
        { "entrance_target_name", reinterpret_cast<getter>(DrillOutThemeAnimation_get_EntranceTargetName), reinterpret_cast<setter>(DrillOutThemeAnimation_put_EntranceTargetName), nullptr, nullptr },
        { "entrance_target", reinterpret_cast<getter>(DrillOutThemeAnimation_get_EntranceTarget), reinterpret_cast<setter>(DrillOutThemeAnimation_put_EntranceTarget), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DrillOutThemeAnimation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DrillOutThemeAnimation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DrillOutThemeAnimation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DrillOutThemeAnimation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DrillOutThemeAnimation) },
        { },
    };

    static PyType_Spec type_spec_DrillOutThemeAnimation =
    {
        "_winrt_windows_ui_xaml_media_animation.DrillOutThemeAnimation",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::DrillOutThemeAnimation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DrillOutThemeAnimation
    };

    static PyGetSetDef getset_DrillOutThemeAnimation_Meta[] = {
        { "entrance_target_name_property", reinterpret_cast<getter>(DrillOutThemeAnimation_get_EntranceTargetNameProperty), nullptr, nullptr, nullptr },
        { "entrance_target_property", reinterpret_cast<getter>(DrillOutThemeAnimation_get_EntranceTargetProperty), nullptr, nullptr, nullptr },
        { "exit_target_name_property", reinterpret_cast<getter>(DrillOutThemeAnimation_get_ExitTargetNameProperty), nullptr, nullptr, nullptr },
        { "exit_target_property", reinterpret_cast<getter>(DrillOutThemeAnimation_get_ExitTargetProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_DrillOutThemeAnimation_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DrillOutThemeAnimation_Meta) },
        { }
    };

    static PyType_Spec type_spec_DrillOutThemeAnimation_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.DrillOutThemeAnimation_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_DrillOutThemeAnimation_Meta
    };

    // ----- DropTargetItemThemeAnimation class --------------------
    static constexpr const char* const type_name_DropTargetItemThemeAnimation = "DropTargetItemThemeAnimation";

    static PyObject* _new_DropTargetItemThemeAnimation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::DropTargetItemThemeAnimation instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DropTargetItemThemeAnimation(py::wrapper::Windows::UI::Xaml::Media::Animation::DropTargetItemThemeAnimation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DropTargetItemThemeAnimation_get_TargetName(py::wrapper::Windows::UI::Xaml::Media::Animation::DropTargetItemThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DropTargetItemThemeAnimation", L"TargetName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TargetName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DropTargetItemThemeAnimation_put_TargetName(py::wrapper::Windows::UI::Xaml::Media::Animation::DropTargetItemThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DropTargetItemThemeAnimation", L"TargetName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.TargetName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DropTargetItemThemeAnimation_get_TargetNameProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.DropTargetItemThemeAnimation", L"TargetNameProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::DropTargetItemThemeAnimation::TargetNameProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DropTargetItemThemeAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::DropTargetItemThemeAnimation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DropTargetItemThemeAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::DropTargetItemThemeAnimation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DropTargetItemThemeAnimation[] = {
        { "_assign_array_", _assign_array_DropTargetItemThemeAnimation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DropTargetItemThemeAnimation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DropTargetItemThemeAnimation[] = {
        { "target_name", reinterpret_cast<getter>(DropTargetItemThemeAnimation_get_TargetName), reinterpret_cast<setter>(DropTargetItemThemeAnimation_put_TargetName), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DropTargetItemThemeAnimation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DropTargetItemThemeAnimation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DropTargetItemThemeAnimation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DropTargetItemThemeAnimation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DropTargetItemThemeAnimation) },
        { },
    };

    static PyType_Spec type_spec_DropTargetItemThemeAnimation =
    {
        "_winrt_windows_ui_xaml_media_animation.DropTargetItemThemeAnimation",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::DropTargetItemThemeAnimation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DropTargetItemThemeAnimation
    };

    static PyGetSetDef getset_DropTargetItemThemeAnimation_Meta[] = {
        { "target_name_property", reinterpret_cast<getter>(DropTargetItemThemeAnimation_get_TargetNameProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_DropTargetItemThemeAnimation_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DropTargetItemThemeAnimation_Meta) },
        { }
    };

    static PyType_Spec type_spec_DropTargetItemThemeAnimation_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.DropTargetItemThemeAnimation_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_DropTargetItemThemeAnimation_Meta
    };

    // ----- EasingColorKeyFrame class --------------------
    static constexpr const char* const type_name_EasingColorKeyFrame = "EasingColorKeyFrame";

    static PyObject* _new_EasingColorKeyFrame(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::EasingColorKeyFrame instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EasingColorKeyFrame(py::wrapper::Windows::UI::Xaml::Media::Animation::EasingColorKeyFrame* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EasingColorKeyFrame_get_EasingFunction(py::wrapper::Windows::UI::Xaml::Media::Animation::EasingColorKeyFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.EasingColorKeyFrame", L"EasingFunction"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EasingFunction());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EasingColorKeyFrame_put_EasingFunction(py::wrapper::Windows::UI::Xaml::Media::Animation::EasingColorKeyFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.EasingColorKeyFrame", L"EasingFunction"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::EasingFunctionBase>(arg);

            self->obj.EasingFunction(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EasingColorKeyFrame_get_EasingFunctionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.EasingColorKeyFrame", L"EasingFunctionProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::EasingColorKeyFrame::EasingFunctionProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EasingColorKeyFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::EasingColorKeyFrame>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EasingColorKeyFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::EasingColorKeyFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EasingColorKeyFrame[] = {
        { "_assign_array_", _assign_array_EasingColorKeyFrame, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EasingColorKeyFrame), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EasingColorKeyFrame[] = {
        { "easing_function", reinterpret_cast<getter>(EasingColorKeyFrame_get_EasingFunction), reinterpret_cast<setter>(EasingColorKeyFrame_put_EasingFunction), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EasingColorKeyFrame[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EasingColorKeyFrame) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EasingColorKeyFrame) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EasingColorKeyFrame) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EasingColorKeyFrame) },
        { },
    };

    static PyType_Spec type_spec_EasingColorKeyFrame =
    {
        "_winrt_windows_ui_xaml_media_animation.EasingColorKeyFrame",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::EasingColorKeyFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EasingColorKeyFrame
    };

    static PyGetSetDef getset_EasingColorKeyFrame_Meta[] = {
        { "easing_function_property", reinterpret_cast<getter>(EasingColorKeyFrame_get_EasingFunctionProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_EasingColorKeyFrame_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_EasingColorKeyFrame_Meta) },
        { }
    };

    static PyType_Spec type_spec_EasingColorKeyFrame_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.EasingColorKeyFrame_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_EasingColorKeyFrame_Meta
    };

    // ----- EasingDoubleKeyFrame class --------------------
    static constexpr const char* const type_name_EasingDoubleKeyFrame = "EasingDoubleKeyFrame";

    static PyObject* _new_EasingDoubleKeyFrame(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::EasingDoubleKeyFrame instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EasingDoubleKeyFrame(py::wrapper::Windows::UI::Xaml::Media::Animation::EasingDoubleKeyFrame* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EasingDoubleKeyFrame_get_EasingFunction(py::wrapper::Windows::UI::Xaml::Media::Animation::EasingDoubleKeyFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.EasingDoubleKeyFrame", L"EasingFunction"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EasingFunction());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EasingDoubleKeyFrame_put_EasingFunction(py::wrapper::Windows::UI::Xaml::Media::Animation::EasingDoubleKeyFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.EasingDoubleKeyFrame", L"EasingFunction"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::EasingFunctionBase>(arg);

            self->obj.EasingFunction(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EasingDoubleKeyFrame_get_EasingFunctionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.EasingDoubleKeyFrame", L"EasingFunctionProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::EasingDoubleKeyFrame::EasingFunctionProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EasingDoubleKeyFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::EasingDoubleKeyFrame>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EasingDoubleKeyFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::EasingDoubleKeyFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EasingDoubleKeyFrame[] = {
        { "_assign_array_", _assign_array_EasingDoubleKeyFrame, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EasingDoubleKeyFrame), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EasingDoubleKeyFrame[] = {
        { "easing_function", reinterpret_cast<getter>(EasingDoubleKeyFrame_get_EasingFunction), reinterpret_cast<setter>(EasingDoubleKeyFrame_put_EasingFunction), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EasingDoubleKeyFrame[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EasingDoubleKeyFrame) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EasingDoubleKeyFrame) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EasingDoubleKeyFrame) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EasingDoubleKeyFrame) },
        { },
    };

    static PyType_Spec type_spec_EasingDoubleKeyFrame =
    {
        "_winrt_windows_ui_xaml_media_animation.EasingDoubleKeyFrame",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::EasingDoubleKeyFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EasingDoubleKeyFrame
    };

    static PyGetSetDef getset_EasingDoubleKeyFrame_Meta[] = {
        { "easing_function_property", reinterpret_cast<getter>(EasingDoubleKeyFrame_get_EasingFunctionProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_EasingDoubleKeyFrame_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_EasingDoubleKeyFrame_Meta) },
        { }
    };

    static PyType_Spec type_spec_EasingDoubleKeyFrame_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.EasingDoubleKeyFrame_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_EasingDoubleKeyFrame_Meta
    };

    // ----- EasingFunctionBase class --------------------
    static constexpr const char* const type_name_EasingFunctionBase = "EasingFunctionBase";

    static PyObject* _new_EasingFunctionBase(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_EasingFunctionBase);
        return nullptr;
    }

    static void _dealloc_EasingFunctionBase(py::wrapper::Windows::UI::Xaml::Media::Animation::EasingFunctionBase* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EasingFunctionBase_Ease(py::wrapper::Windows::UI::Xaml::Media::Animation::EasingFunctionBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.EasingFunctionBase", L"Ease", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);

                return py::convert(self->obj.Ease(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EasingFunctionBase_get_EasingMode(py::wrapper::Windows::UI::Xaml::Media::Animation::EasingFunctionBase* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.EasingFunctionBase", L"EasingMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EasingMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EasingFunctionBase_put_EasingMode(py::wrapper::Windows::UI::Xaml::Media::Animation::EasingFunctionBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.EasingFunctionBase", L"EasingMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::EasingMode>(arg);

            self->obj.EasingMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EasingFunctionBase_get_EasingModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.EasingFunctionBase", L"EasingModeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::EasingFunctionBase::EasingModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EasingFunctionBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::EasingFunctionBase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EasingFunctionBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::EasingFunctionBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EasingFunctionBase[] = {
        { "ease", reinterpret_cast<PyCFunction>(EasingFunctionBase_Ease), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EasingFunctionBase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EasingFunctionBase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EasingFunctionBase[] = {
        { "easing_mode", reinterpret_cast<getter>(EasingFunctionBase_get_EasingMode), reinterpret_cast<setter>(EasingFunctionBase_put_EasingMode), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EasingFunctionBase[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EasingFunctionBase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EasingFunctionBase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EasingFunctionBase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EasingFunctionBase) },
        { },
    };

    static PyType_Spec type_spec_EasingFunctionBase =
    {
        "_winrt_windows_ui_xaml_media_animation.EasingFunctionBase",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::EasingFunctionBase),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EasingFunctionBase
    };

    static PyGetSetDef getset_EasingFunctionBase_Meta[] = {
        { "easing_mode_property", reinterpret_cast<getter>(EasingFunctionBase_get_EasingModeProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_EasingFunctionBase_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_EasingFunctionBase_Meta) },
        { }
    };

    static PyType_Spec type_spec_EasingFunctionBase_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.EasingFunctionBase_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_EasingFunctionBase_Meta
    };

    // ----- EasingPointKeyFrame class --------------------
    static constexpr const char* const type_name_EasingPointKeyFrame = "EasingPointKeyFrame";

    static PyObject* _new_EasingPointKeyFrame(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::EasingPointKeyFrame instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EasingPointKeyFrame(py::wrapper::Windows::UI::Xaml::Media::Animation::EasingPointKeyFrame* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EasingPointKeyFrame_get_EasingFunction(py::wrapper::Windows::UI::Xaml::Media::Animation::EasingPointKeyFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.EasingPointKeyFrame", L"EasingFunction"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EasingFunction());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EasingPointKeyFrame_put_EasingFunction(py::wrapper::Windows::UI::Xaml::Media::Animation::EasingPointKeyFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.EasingPointKeyFrame", L"EasingFunction"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::EasingFunctionBase>(arg);

            self->obj.EasingFunction(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EasingPointKeyFrame_get_EasingFunctionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.EasingPointKeyFrame", L"EasingFunctionProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::EasingPointKeyFrame::EasingFunctionProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EasingPointKeyFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::EasingPointKeyFrame>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EasingPointKeyFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::EasingPointKeyFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EasingPointKeyFrame[] = {
        { "_assign_array_", _assign_array_EasingPointKeyFrame, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EasingPointKeyFrame), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EasingPointKeyFrame[] = {
        { "easing_function", reinterpret_cast<getter>(EasingPointKeyFrame_get_EasingFunction), reinterpret_cast<setter>(EasingPointKeyFrame_put_EasingFunction), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EasingPointKeyFrame[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EasingPointKeyFrame) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EasingPointKeyFrame) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EasingPointKeyFrame) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EasingPointKeyFrame) },
        { },
    };

    static PyType_Spec type_spec_EasingPointKeyFrame =
    {
        "_winrt_windows_ui_xaml_media_animation.EasingPointKeyFrame",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::EasingPointKeyFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EasingPointKeyFrame
    };

    static PyGetSetDef getset_EasingPointKeyFrame_Meta[] = {
        { "easing_function_property", reinterpret_cast<getter>(EasingPointKeyFrame_get_EasingFunctionProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_EasingPointKeyFrame_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_EasingPointKeyFrame_Meta) },
        { }
    };

    static PyType_Spec type_spec_EasingPointKeyFrame_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.EasingPointKeyFrame_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_EasingPointKeyFrame_Meta
    };

    // ----- EdgeUIThemeTransition class --------------------
    static constexpr const char* const type_name_EdgeUIThemeTransition = "EdgeUIThemeTransition";

    static PyObject* _new_EdgeUIThemeTransition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::EdgeUIThemeTransition instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EdgeUIThemeTransition(py::wrapper::Windows::UI::Xaml::Media::Animation::EdgeUIThemeTransition* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EdgeUIThemeTransition_get_Edge(py::wrapper::Windows::UI::Xaml::Media::Animation::EdgeUIThemeTransition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.EdgeUIThemeTransition", L"Edge"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Edge());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EdgeUIThemeTransition_put_Edge(py::wrapper::Windows::UI::Xaml::Media::Animation::EdgeUIThemeTransition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.EdgeUIThemeTransition", L"Edge"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::EdgeTransitionLocation>(arg);

            self->obj.Edge(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EdgeUIThemeTransition_get_EdgeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.EdgeUIThemeTransition", L"EdgeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::EdgeUIThemeTransition::EdgeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EdgeUIThemeTransition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::EdgeUIThemeTransition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EdgeUIThemeTransition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::EdgeUIThemeTransition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EdgeUIThemeTransition[] = {
        { "_assign_array_", _assign_array_EdgeUIThemeTransition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EdgeUIThemeTransition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EdgeUIThemeTransition[] = {
        { "edge", reinterpret_cast<getter>(EdgeUIThemeTransition_get_Edge), reinterpret_cast<setter>(EdgeUIThemeTransition_put_Edge), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EdgeUIThemeTransition[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EdgeUIThemeTransition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EdgeUIThemeTransition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EdgeUIThemeTransition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EdgeUIThemeTransition) },
        { },
    };

    static PyType_Spec type_spec_EdgeUIThemeTransition =
    {
        "_winrt_windows_ui_xaml_media_animation.EdgeUIThemeTransition",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::EdgeUIThemeTransition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EdgeUIThemeTransition
    };

    static PyGetSetDef getset_EdgeUIThemeTransition_Meta[] = {
        { "edge_property", reinterpret_cast<getter>(EdgeUIThemeTransition_get_EdgeProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_EdgeUIThemeTransition_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_EdgeUIThemeTransition_Meta) },
        { }
    };

    static PyType_Spec type_spec_EdgeUIThemeTransition_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.EdgeUIThemeTransition_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_EdgeUIThemeTransition_Meta
    };

    // ----- ElasticEase class --------------------
    static constexpr const char* const type_name_ElasticEase = "ElasticEase";

    static PyObject* _new_ElasticEase(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::ElasticEase instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ElasticEase(py::wrapper::Windows::UI::Xaml::Media::Animation::ElasticEase* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ElasticEase_get_Springiness(py::wrapper::Windows::UI::Xaml::Media::Animation::ElasticEase* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ElasticEase", L"Springiness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Springiness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ElasticEase_put_Springiness(py::wrapper::Windows::UI::Xaml::Media::Animation::ElasticEase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ElasticEase", L"Springiness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Springiness(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ElasticEase_get_Oscillations(py::wrapper::Windows::UI::Xaml::Media::Animation::ElasticEase* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ElasticEase", L"Oscillations"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Oscillations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ElasticEase_put_Oscillations(py::wrapper::Windows::UI::Xaml::Media::Animation::ElasticEase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ElasticEase", L"Oscillations"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Oscillations(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ElasticEase_get_OscillationsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ElasticEase", L"OscillationsProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::ElasticEase::OscillationsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ElasticEase_get_SpringinessProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ElasticEase", L"SpringinessProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::ElasticEase::SpringinessProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ElasticEase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::ElasticEase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ElasticEase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::ElasticEase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ElasticEase[] = {
        { "_assign_array_", _assign_array_ElasticEase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ElasticEase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ElasticEase[] = {
        { "springiness", reinterpret_cast<getter>(ElasticEase_get_Springiness), reinterpret_cast<setter>(ElasticEase_put_Springiness), nullptr, nullptr },
        { "oscillations", reinterpret_cast<getter>(ElasticEase_get_Oscillations), reinterpret_cast<setter>(ElasticEase_put_Oscillations), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ElasticEase[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ElasticEase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ElasticEase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ElasticEase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ElasticEase) },
        { },
    };

    static PyType_Spec type_spec_ElasticEase =
    {
        "_winrt_windows_ui_xaml_media_animation.ElasticEase",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::ElasticEase),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ElasticEase
    };

    static PyGetSetDef getset_ElasticEase_Meta[] = {
        { "oscillations_property", reinterpret_cast<getter>(ElasticEase_get_OscillationsProperty), nullptr, nullptr, nullptr },
        { "springiness_property", reinterpret_cast<getter>(ElasticEase_get_SpringinessProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_ElasticEase_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ElasticEase_Meta) },
        { }
    };

    static PyType_Spec type_spec_ElasticEase_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.ElasticEase_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ElasticEase_Meta
    };

    // ----- EntranceNavigationTransitionInfo class --------------------
    static constexpr const char* const type_name_EntranceNavigationTransitionInfo = "EntranceNavigationTransitionInfo";

    static PyObject* _new_EntranceNavigationTransitionInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::EntranceNavigationTransitionInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EntranceNavigationTransitionInfo(py::wrapper::Windows::UI::Xaml::Media::Animation::EntranceNavigationTransitionInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EntranceNavigationTransitionInfo_GetIsTargetElement(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.EntranceNavigationTransitionInfo", L"GetIsTargetElement", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Media::Animation::EntranceNavigationTransitionInfo::GetIsTargetElement(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EntranceNavigationTransitionInfo_SetIsTargetElement(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.EntranceNavigationTransitionInfo", L"SetIsTargetElement", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Windows::UI::Xaml::Media::Animation::EntranceNavigationTransitionInfo::SetIsTargetElement(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EntranceNavigationTransitionInfo_get_IsTargetElementProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.EntranceNavigationTransitionInfo", L"IsTargetElementProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::EntranceNavigationTransitionInfo::IsTargetElementProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EntranceNavigationTransitionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::EntranceNavigationTransitionInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EntranceNavigationTransitionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::EntranceNavigationTransitionInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EntranceNavigationTransitionInfo[] = {
        { "get_is_target_element", reinterpret_cast<PyCFunction>(EntranceNavigationTransitionInfo_GetIsTargetElement), METH_VARARGS | METH_STATIC, nullptr },
        { "set_is_target_element", reinterpret_cast<PyCFunction>(EntranceNavigationTransitionInfo_SetIsTargetElement), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_EntranceNavigationTransitionInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EntranceNavigationTransitionInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EntranceNavigationTransitionInfo[] = {
        { }
    };

    static PyType_Slot _type_slots_EntranceNavigationTransitionInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EntranceNavigationTransitionInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EntranceNavigationTransitionInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EntranceNavigationTransitionInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EntranceNavigationTransitionInfo) },
        { },
    };

    static PyType_Spec type_spec_EntranceNavigationTransitionInfo =
    {
        "_winrt_windows_ui_xaml_media_animation.EntranceNavigationTransitionInfo",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::EntranceNavigationTransitionInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EntranceNavigationTransitionInfo
    };

    static PyGetSetDef getset_EntranceNavigationTransitionInfo_Meta[] = {
        { "is_target_element_property", reinterpret_cast<getter>(EntranceNavigationTransitionInfo_get_IsTargetElementProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_EntranceNavigationTransitionInfo_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_EntranceNavigationTransitionInfo_Meta) },
        { }
    };

    static PyType_Spec type_spec_EntranceNavigationTransitionInfo_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.EntranceNavigationTransitionInfo_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_EntranceNavigationTransitionInfo_Meta
    };

    // ----- EntranceThemeTransition class --------------------
    static constexpr const char* const type_name_EntranceThemeTransition = "EntranceThemeTransition";

    static PyObject* _new_EntranceThemeTransition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::EntranceThemeTransition instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EntranceThemeTransition(py::wrapper::Windows::UI::Xaml::Media::Animation::EntranceThemeTransition* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EntranceThemeTransition_get_IsStaggeringEnabled(py::wrapper::Windows::UI::Xaml::Media::Animation::EntranceThemeTransition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.EntranceThemeTransition", L"IsStaggeringEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsStaggeringEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EntranceThemeTransition_put_IsStaggeringEnabled(py::wrapper::Windows::UI::Xaml::Media::Animation::EntranceThemeTransition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.EntranceThemeTransition", L"IsStaggeringEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsStaggeringEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EntranceThemeTransition_get_FromVerticalOffset(py::wrapper::Windows::UI::Xaml::Media::Animation::EntranceThemeTransition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.EntranceThemeTransition", L"FromVerticalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FromVerticalOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EntranceThemeTransition_put_FromVerticalOffset(py::wrapper::Windows::UI::Xaml::Media::Animation::EntranceThemeTransition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.EntranceThemeTransition", L"FromVerticalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.FromVerticalOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EntranceThemeTransition_get_FromHorizontalOffset(py::wrapper::Windows::UI::Xaml::Media::Animation::EntranceThemeTransition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.EntranceThemeTransition", L"FromHorizontalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FromHorizontalOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EntranceThemeTransition_put_FromHorizontalOffset(py::wrapper::Windows::UI::Xaml::Media::Animation::EntranceThemeTransition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.EntranceThemeTransition", L"FromHorizontalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.FromHorizontalOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EntranceThemeTransition_get_FromHorizontalOffsetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.EntranceThemeTransition", L"FromHorizontalOffsetProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::EntranceThemeTransition::FromHorizontalOffsetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EntranceThemeTransition_get_FromVerticalOffsetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.EntranceThemeTransition", L"FromVerticalOffsetProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::EntranceThemeTransition::FromVerticalOffsetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EntranceThemeTransition_get_IsStaggeringEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.EntranceThemeTransition", L"IsStaggeringEnabledProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::EntranceThemeTransition::IsStaggeringEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EntranceThemeTransition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::EntranceThemeTransition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EntranceThemeTransition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::EntranceThemeTransition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EntranceThemeTransition[] = {
        { "_assign_array_", _assign_array_EntranceThemeTransition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EntranceThemeTransition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EntranceThemeTransition[] = {
        { "is_staggering_enabled", reinterpret_cast<getter>(EntranceThemeTransition_get_IsStaggeringEnabled), reinterpret_cast<setter>(EntranceThemeTransition_put_IsStaggeringEnabled), nullptr, nullptr },
        { "from_vertical_offset", reinterpret_cast<getter>(EntranceThemeTransition_get_FromVerticalOffset), reinterpret_cast<setter>(EntranceThemeTransition_put_FromVerticalOffset), nullptr, nullptr },
        { "from_horizontal_offset", reinterpret_cast<getter>(EntranceThemeTransition_get_FromHorizontalOffset), reinterpret_cast<setter>(EntranceThemeTransition_put_FromHorizontalOffset), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EntranceThemeTransition[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EntranceThemeTransition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EntranceThemeTransition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EntranceThemeTransition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EntranceThemeTransition) },
        { },
    };

    static PyType_Spec type_spec_EntranceThemeTransition =
    {
        "_winrt_windows_ui_xaml_media_animation.EntranceThemeTransition",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::EntranceThemeTransition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EntranceThemeTransition
    };

    static PyGetSetDef getset_EntranceThemeTransition_Meta[] = {
        { "from_horizontal_offset_property", reinterpret_cast<getter>(EntranceThemeTransition_get_FromHorizontalOffsetProperty), nullptr, nullptr, nullptr },
        { "from_vertical_offset_property", reinterpret_cast<getter>(EntranceThemeTransition_get_FromVerticalOffsetProperty), nullptr, nullptr, nullptr },
        { "is_staggering_enabled_property", reinterpret_cast<getter>(EntranceThemeTransition_get_IsStaggeringEnabledProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_EntranceThemeTransition_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_EntranceThemeTransition_Meta) },
        { }
    };

    static PyType_Spec type_spec_EntranceThemeTransition_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.EntranceThemeTransition_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_EntranceThemeTransition_Meta
    };

    // ----- ExponentialEase class --------------------
    static constexpr const char* const type_name_ExponentialEase = "ExponentialEase";

    static PyObject* _new_ExponentialEase(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::ExponentialEase instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ExponentialEase(py::wrapper::Windows::UI::Xaml::Media::Animation::ExponentialEase* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ExponentialEase_get_Exponent(py::wrapper::Windows::UI::Xaml::Media::Animation::ExponentialEase* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ExponentialEase", L"Exponent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Exponent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ExponentialEase_put_Exponent(py::wrapper::Windows::UI::Xaml::Media::Animation::ExponentialEase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ExponentialEase", L"Exponent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Exponent(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ExponentialEase_get_ExponentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ExponentialEase", L"ExponentProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::ExponentialEase::ExponentProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ExponentialEase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::ExponentialEase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ExponentialEase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::ExponentialEase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ExponentialEase[] = {
        { "_assign_array_", _assign_array_ExponentialEase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ExponentialEase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ExponentialEase[] = {
        { "exponent", reinterpret_cast<getter>(ExponentialEase_get_Exponent), reinterpret_cast<setter>(ExponentialEase_put_Exponent), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ExponentialEase[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ExponentialEase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ExponentialEase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ExponentialEase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ExponentialEase) },
        { },
    };

    static PyType_Spec type_spec_ExponentialEase =
    {
        "_winrt_windows_ui_xaml_media_animation.ExponentialEase",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::ExponentialEase),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ExponentialEase
    };

    static PyGetSetDef getset_ExponentialEase_Meta[] = {
        { "exponent_property", reinterpret_cast<getter>(ExponentialEase_get_ExponentProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_ExponentialEase_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ExponentialEase_Meta) },
        { }
    };

    static PyType_Spec type_spec_ExponentialEase_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.ExponentialEase_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ExponentialEase_Meta
    };

    // ----- FadeInThemeAnimation class --------------------
    static constexpr const char* const type_name_FadeInThemeAnimation = "FadeInThemeAnimation";

    static PyObject* _new_FadeInThemeAnimation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::FadeInThemeAnimation instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FadeInThemeAnimation(py::wrapper::Windows::UI::Xaml::Media::Animation::FadeInThemeAnimation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FadeInThemeAnimation_get_TargetName(py::wrapper::Windows::UI::Xaml::Media::Animation::FadeInThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.FadeInThemeAnimation", L"TargetName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TargetName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FadeInThemeAnimation_put_TargetName(py::wrapper::Windows::UI::Xaml::Media::Animation::FadeInThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.FadeInThemeAnimation", L"TargetName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.TargetName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FadeInThemeAnimation_get_TargetNameProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.FadeInThemeAnimation", L"TargetNameProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::FadeInThemeAnimation::TargetNameProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FadeInThemeAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::FadeInThemeAnimation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FadeInThemeAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::FadeInThemeAnimation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FadeInThemeAnimation[] = {
        { "_assign_array_", _assign_array_FadeInThemeAnimation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FadeInThemeAnimation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FadeInThemeAnimation[] = {
        { "target_name", reinterpret_cast<getter>(FadeInThemeAnimation_get_TargetName), reinterpret_cast<setter>(FadeInThemeAnimation_put_TargetName), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FadeInThemeAnimation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FadeInThemeAnimation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FadeInThemeAnimation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FadeInThemeAnimation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FadeInThemeAnimation) },
        { },
    };

    static PyType_Spec type_spec_FadeInThemeAnimation =
    {
        "_winrt_windows_ui_xaml_media_animation.FadeInThemeAnimation",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::FadeInThemeAnimation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FadeInThemeAnimation
    };

    static PyGetSetDef getset_FadeInThemeAnimation_Meta[] = {
        { "target_name_property", reinterpret_cast<getter>(FadeInThemeAnimation_get_TargetNameProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_FadeInThemeAnimation_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_FadeInThemeAnimation_Meta) },
        { }
    };

    static PyType_Spec type_spec_FadeInThemeAnimation_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.FadeInThemeAnimation_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_FadeInThemeAnimation_Meta
    };

    // ----- FadeOutThemeAnimation class --------------------
    static constexpr const char* const type_name_FadeOutThemeAnimation = "FadeOutThemeAnimation";

    static PyObject* _new_FadeOutThemeAnimation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::FadeOutThemeAnimation instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FadeOutThemeAnimation(py::wrapper::Windows::UI::Xaml::Media::Animation::FadeOutThemeAnimation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FadeOutThemeAnimation_get_TargetName(py::wrapper::Windows::UI::Xaml::Media::Animation::FadeOutThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.FadeOutThemeAnimation", L"TargetName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TargetName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FadeOutThemeAnimation_put_TargetName(py::wrapper::Windows::UI::Xaml::Media::Animation::FadeOutThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.FadeOutThemeAnimation", L"TargetName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.TargetName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FadeOutThemeAnimation_get_TargetNameProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.FadeOutThemeAnimation", L"TargetNameProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::FadeOutThemeAnimation::TargetNameProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FadeOutThemeAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::FadeOutThemeAnimation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FadeOutThemeAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::FadeOutThemeAnimation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FadeOutThemeAnimation[] = {
        { "_assign_array_", _assign_array_FadeOutThemeAnimation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FadeOutThemeAnimation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FadeOutThemeAnimation[] = {
        { "target_name", reinterpret_cast<getter>(FadeOutThemeAnimation_get_TargetName), reinterpret_cast<setter>(FadeOutThemeAnimation_put_TargetName), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FadeOutThemeAnimation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FadeOutThemeAnimation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FadeOutThemeAnimation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FadeOutThemeAnimation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FadeOutThemeAnimation) },
        { },
    };

    static PyType_Spec type_spec_FadeOutThemeAnimation =
    {
        "_winrt_windows_ui_xaml_media_animation.FadeOutThemeAnimation",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::FadeOutThemeAnimation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FadeOutThemeAnimation
    };

    static PyGetSetDef getset_FadeOutThemeAnimation_Meta[] = {
        { "target_name_property", reinterpret_cast<getter>(FadeOutThemeAnimation_get_TargetNameProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_FadeOutThemeAnimation_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_FadeOutThemeAnimation_Meta) },
        { }
    };

    static PyType_Spec type_spec_FadeOutThemeAnimation_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.FadeOutThemeAnimation_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_FadeOutThemeAnimation_Meta
    };

    // ----- GravityConnectedAnimationConfiguration class --------------------
    static constexpr const char* const type_name_GravityConnectedAnimationConfiguration = "GravityConnectedAnimationConfiguration";

    static PyObject* _new_GravityConnectedAnimationConfiguration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::GravityConnectedAnimationConfiguration instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GravityConnectedAnimationConfiguration(py::wrapper::Windows::UI::Xaml::Media::Animation::GravityConnectedAnimationConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GravityConnectedAnimationConfiguration_get_IsShadowEnabled(py::wrapper::Windows::UI::Xaml::Media::Animation::GravityConnectedAnimationConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.GravityConnectedAnimationConfiguration", L"IsShadowEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsShadowEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GravityConnectedAnimationConfiguration_put_IsShadowEnabled(py::wrapper::Windows::UI::Xaml::Media::Animation::GravityConnectedAnimationConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.GravityConnectedAnimationConfiguration", L"IsShadowEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsShadowEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_GravityConnectedAnimationConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::GravityConnectedAnimationConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GravityConnectedAnimationConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::GravityConnectedAnimationConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GravityConnectedAnimationConfiguration[] = {
        { "_assign_array_", _assign_array_GravityConnectedAnimationConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GravityConnectedAnimationConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GravityConnectedAnimationConfiguration[] = {
        { "is_shadow_enabled", reinterpret_cast<getter>(GravityConnectedAnimationConfiguration_get_IsShadowEnabled), reinterpret_cast<setter>(GravityConnectedAnimationConfiguration_put_IsShadowEnabled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GravityConnectedAnimationConfiguration[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GravityConnectedAnimationConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GravityConnectedAnimationConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GravityConnectedAnimationConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GravityConnectedAnimationConfiguration) },
        { },
    };

    static PyType_Spec type_spec_GravityConnectedAnimationConfiguration =
    {
        "_winrt_windows_ui_xaml_media_animation.GravityConnectedAnimationConfiguration",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::GravityConnectedAnimationConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GravityConnectedAnimationConfiguration
    };

    // ----- KeySpline class --------------------
    static constexpr const char* const type_name_KeySpline = "KeySpline";

    static PyObject* _new_KeySpline(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::KeySpline instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_KeySpline(py::wrapper::Windows::UI::Xaml::Media::Animation::KeySpline* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* KeySpline_get_ControlPoint2(py::wrapper::Windows::UI::Xaml::Media::Animation::KeySpline* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.KeySpline", L"ControlPoint2"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ControlPoint2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int KeySpline_put_ControlPoint2(py::wrapper::Windows::UI::Xaml::Media::Animation::KeySpline* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.KeySpline", L"ControlPoint2"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.ControlPoint2(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* KeySpline_get_ControlPoint1(py::wrapper::Windows::UI::Xaml::Media::Animation::KeySpline* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.KeySpline", L"ControlPoint1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ControlPoint1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int KeySpline_put_ControlPoint1(py::wrapper::Windows::UI::Xaml::Media::Animation::KeySpline* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.KeySpline", L"ControlPoint1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.ControlPoint1(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_KeySpline(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::KeySpline>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_KeySpline(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::KeySpline>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KeySpline[] = {
        { "_assign_array_", _assign_array_KeySpline, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_KeySpline), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_KeySpline[] = {
        { "control_point2", reinterpret_cast<getter>(KeySpline_get_ControlPoint2), reinterpret_cast<setter>(KeySpline_put_ControlPoint2), nullptr, nullptr },
        { "control_point1", reinterpret_cast<getter>(KeySpline_get_ControlPoint1), reinterpret_cast<setter>(KeySpline_put_ControlPoint1), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_KeySpline[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_KeySpline) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_KeySpline) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KeySpline) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KeySpline) },
        { },
    };

    static PyType_Spec type_spec_KeySpline =
    {
        "_winrt_windows_ui_xaml_media_animation.KeySpline",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::KeySpline),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KeySpline
    };

    // ----- KeyTimeHelper class --------------------
    static constexpr const char* const type_name_KeyTimeHelper = "KeyTimeHelper";

    static PyObject* _new_KeyTimeHelper(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_KeyTimeHelper);
        return nullptr;
    }

    static void _dealloc_KeyTimeHelper(py::wrapper::Windows::UI::Xaml::Media::Animation::KeyTimeHelper* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* KeyTimeHelper_FromTimeSpan(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.KeyTimeHelper", L"FromTimeSpan", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Media::Animation::KeyTimeHelper::FromTimeSpan(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_KeyTimeHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::KeyTimeHelper>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_KeyTimeHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::KeyTimeHelper>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KeyTimeHelper[] = {
        { "from_time_span", reinterpret_cast<PyCFunction>(KeyTimeHelper_FromTimeSpan), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_KeyTimeHelper, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_KeyTimeHelper), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_KeyTimeHelper[] = {
        { }
    };

    static PyType_Slot _type_slots_KeyTimeHelper[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_KeyTimeHelper) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_KeyTimeHelper) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KeyTimeHelper) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KeyTimeHelper) },
        { },
    };

    static PyType_Spec type_spec_KeyTimeHelper =
    {
        "_winrt_windows_ui_xaml_media_animation.KeyTimeHelper",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::KeyTimeHelper),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KeyTimeHelper
    };

    // ----- LinearColorKeyFrame class --------------------
    static constexpr const char* const type_name_LinearColorKeyFrame = "LinearColorKeyFrame";

    static PyObject* _new_LinearColorKeyFrame(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::LinearColorKeyFrame instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LinearColorKeyFrame(py::wrapper::Windows::UI::Xaml::Media::Animation::LinearColorKeyFrame* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_LinearColorKeyFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::LinearColorKeyFrame>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LinearColorKeyFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::LinearColorKeyFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LinearColorKeyFrame[] = {
        { "_assign_array_", _assign_array_LinearColorKeyFrame, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LinearColorKeyFrame), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LinearColorKeyFrame[] = {
        { }
    };

    static PyType_Slot _type_slots_LinearColorKeyFrame[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LinearColorKeyFrame) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LinearColorKeyFrame) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LinearColorKeyFrame) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LinearColorKeyFrame) },
        { },
    };

    static PyType_Spec type_spec_LinearColorKeyFrame =
    {
        "_winrt_windows_ui_xaml_media_animation.LinearColorKeyFrame",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::LinearColorKeyFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LinearColorKeyFrame
    };

    // ----- LinearDoubleKeyFrame class --------------------
    static constexpr const char* const type_name_LinearDoubleKeyFrame = "LinearDoubleKeyFrame";

    static PyObject* _new_LinearDoubleKeyFrame(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::LinearDoubleKeyFrame instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LinearDoubleKeyFrame(py::wrapper::Windows::UI::Xaml::Media::Animation::LinearDoubleKeyFrame* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_LinearDoubleKeyFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::LinearDoubleKeyFrame>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LinearDoubleKeyFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::LinearDoubleKeyFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LinearDoubleKeyFrame[] = {
        { "_assign_array_", _assign_array_LinearDoubleKeyFrame, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LinearDoubleKeyFrame), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LinearDoubleKeyFrame[] = {
        { }
    };

    static PyType_Slot _type_slots_LinearDoubleKeyFrame[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LinearDoubleKeyFrame) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LinearDoubleKeyFrame) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LinearDoubleKeyFrame) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LinearDoubleKeyFrame) },
        { },
    };

    static PyType_Spec type_spec_LinearDoubleKeyFrame =
    {
        "_winrt_windows_ui_xaml_media_animation.LinearDoubleKeyFrame",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::LinearDoubleKeyFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LinearDoubleKeyFrame
    };

    // ----- LinearPointKeyFrame class --------------------
    static constexpr const char* const type_name_LinearPointKeyFrame = "LinearPointKeyFrame";

    static PyObject* _new_LinearPointKeyFrame(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::LinearPointKeyFrame instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LinearPointKeyFrame(py::wrapper::Windows::UI::Xaml::Media::Animation::LinearPointKeyFrame* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_LinearPointKeyFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::LinearPointKeyFrame>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LinearPointKeyFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::LinearPointKeyFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LinearPointKeyFrame[] = {
        { "_assign_array_", _assign_array_LinearPointKeyFrame, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LinearPointKeyFrame), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LinearPointKeyFrame[] = {
        { }
    };

    static PyType_Slot _type_slots_LinearPointKeyFrame[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LinearPointKeyFrame) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LinearPointKeyFrame) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LinearPointKeyFrame) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LinearPointKeyFrame) },
        { },
    };

    static PyType_Spec type_spec_LinearPointKeyFrame =
    {
        "_winrt_windows_ui_xaml_media_animation.LinearPointKeyFrame",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::LinearPointKeyFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LinearPointKeyFrame
    };

    // ----- NavigationThemeTransition class --------------------
    static constexpr const char* const type_name_NavigationThemeTransition = "NavigationThemeTransition";

    static PyObject* _new_NavigationThemeTransition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::NavigationThemeTransition instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NavigationThemeTransition(py::wrapper::Windows::UI::Xaml::Media::Animation::NavigationThemeTransition* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NavigationThemeTransition_get_DefaultNavigationTransitionInfo(py::wrapper::Windows::UI::Xaml::Media::Animation::NavigationThemeTransition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.NavigationThemeTransition", L"DefaultNavigationTransitionInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultNavigationTransitionInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationThemeTransition_put_DefaultNavigationTransitionInfo(py::wrapper::Windows::UI::Xaml::Media::Animation::NavigationThemeTransition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.NavigationThemeTransition", L"DefaultNavigationTransitionInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::NavigationTransitionInfo>(arg);

            self->obj.DefaultNavigationTransitionInfo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationThemeTransition_get_DefaultNavigationTransitionInfoProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.NavigationThemeTransition", L"DefaultNavigationTransitionInfoProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::NavigationThemeTransition::DefaultNavigationTransitionInfoProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NavigationThemeTransition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::NavigationThemeTransition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NavigationThemeTransition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::NavigationThemeTransition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NavigationThemeTransition[] = {
        { "_assign_array_", _assign_array_NavigationThemeTransition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NavigationThemeTransition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NavigationThemeTransition[] = {
        { "default_navigation_transition_info", reinterpret_cast<getter>(NavigationThemeTransition_get_DefaultNavigationTransitionInfo), reinterpret_cast<setter>(NavigationThemeTransition_put_DefaultNavigationTransitionInfo), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NavigationThemeTransition[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NavigationThemeTransition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NavigationThemeTransition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NavigationThemeTransition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NavigationThemeTransition) },
        { },
    };

    static PyType_Spec type_spec_NavigationThemeTransition =
    {
        "_winrt_windows_ui_xaml_media_animation.NavigationThemeTransition",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::NavigationThemeTransition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NavigationThemeTransition
    };

    static PyGetSetDef getset_NavigationThemeTransition_Meta[] = {
        { "default_navigation_transition_info_property", reinterpret_cast<getter>(NavigationThemeTransition_get_DefaultNavigationTransitionInfoProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_NavigationThemeTransition_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_NavigationThemeTransition_Meta) },
        { }
    };

    static PyType_Spec type_spec_NavigationThemeTransition_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.NavigationThemeTransition_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_NavigationThemeTransition_Meta
    };

    // ----- NavigationTransitionInfo class --------------------
    static constexpr const char* const type_name_NavigationTransitionInfo = "NavigationTransitionInfo";

    static PyObject* _new_NavigationTransitionInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_NavigationTransitionInfo);
        return nullptr;
    }

    static void _dealloc_NavigationTransitionInfo(py::wrapper::Windows::UI::Xaml::Media::Animation::NavigationTransitionInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NavigationTransitionInfo_GetNavigationStateCore(py::wrapper::Windows::UI::Xaml::Media::Animation::NavigationTransitionInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.NavigationTransitionInfo", L"GetNavigationStateCore", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetNavigationStateCore());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NavigationTransitionInfo_SetNavigationStateCore(py::wrapper::Windows::UI::Xaml::Media::Animation::NavigationTransitionInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.NavigationTransitionInfo", L"SetNavigationStateCore", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.SetNavigationStateCore(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_NavigationTransitionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::NavigationTransitionInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NavigationTransitionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::NavigationTransitionInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NavigationTransitionInfo[] = {
        { "get_navigation_state_core", reinterpret_cast<PyCFunction>(NavigationTransitionInfo_GetNavigationStateCore), METH_VARARGS, nullptr },
        { "set_navigation_state_core", reinterpret_cast<PyCFunction>(NavigationTransitionInfo_SetNavigationStateCore), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_NavigationTransitionInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NavigationTransitionInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NavigationTransitionInfo[] = {
        { }
    };

    static PyType_Slot _type_slots_NavigationTransitionInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NavigationTransitionInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NavigationTransitionInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NavigationTransitionInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NavigationTransitionInfo) },
        { },
    };

    static PyType_Spec type_spec_NavigationTransitionInfo =
    {
        "_winrt_windows_ui_xaml_media_animation.NavigationTransitionInfo",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::NavigationTransitionInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NavigationTransitionInfo
    };

    // ----- ObjectAnimationUsingKeyFrames class --------------------
    static constexpr const char* const type_name_ObjectAnimationUsingKeyFrames = "ObjectAnimationUsingKeyFrames";

    static PyObject* _new_ObjectAnimationUsingKeyFrames(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::ObjectAnimationUsingKeyFrames instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ObjectAnimationUsingKeyFrames(py::wrapper::Windows::UI::Xaml::Media::Animation::ObjectAnimationUsingKeyFrames* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ObjectAnimationUsingKeyFrames_get_EnableDependentAnimation(py::wrapper::Windows::UI::Xaml::Media::Animation::ObjectAnimationUsingKeyFrames* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ObjectAnimationUsingKeyFrames", L"EnableDependentAnimation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EnableDependentAnimation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ObjectAnimationUsingKeyFrames_put_EnableDependentAnimation(py::wrapper::Windows::UI::Xaml::Media::Animation::ObjectAnimationUsingKeyFrames* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ObjectAnimationUsingKeyFrames", L"EnableDependentAnimation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.EnableDependentAnimation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ObjectAnimationUsingKeyFrames_get_KeyFrames(py::wrapper::Windows::UI::Xaml::Media::Animation::ObjectAnimationUsingKeyFrames* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ObjectAnimationUsingKeyFrames", L"KeyFrames"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyFrames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ObjectAnimationUsingKeyFrames_get_EnableDependentAnimationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ObjectAnimationUsingKeyFrames", L"EnableDependentAnimationProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::ObjectAnimationUsingKeyFrames::EnableDependentAnimationProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ObjectAnimationUsingKeyFrames(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::ObjectAnimationUsingKeyFrames>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ObjectAnimationUsingKeyFrames(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::ObjectAnimationUsingKeyFrames>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ObjectAnimationUsingKeyFrames[] = {
        { "_assign_array_", _assign_array_ObjectAnimationUsingKeyFrames, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ObjectAnimationUsingKeyFrames), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ObjectAnimationUsingKeyFrames[] = {
        { "enable_dependent_animation", reinterpret_cast<getter>(ObjectAnimationUsingKeyFrames_get_EnableDependentAnimation), reinterpret_cast<setter>(ObjectAnimationUsingKeyFrames_put_EnableDependentAnimation), nullptr, nullptr },
        { "key_frames", reinterpret_cast<getter>(ObjectAnimationUsingKeyFrames_get_KeyFrames), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ObjectAnimationUsingKeyFrames[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ObjectAnimationUsingKeyFrames) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ObjectAnimationUsingKeyFrames) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ObjectAnimationUsingKeyFrames) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ObjectAnimationUsingKeyFrames) },
        { },
    };

    static PyType_Spec type_spec_ObjectAnimationUsingKeyFrames =
    {
        "_winrt_windows_ui_xaml_media_animation.ObjectAnimationUsingKeyFrames",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::ObjectAnimationUsingKeyFrames),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ObjectAnimationUsingKeyFrames
    };

    static PyGetSetDef getset_ObjectAnimationUsingKeyFrames_Meta[] = {
        { "enable_dependent_animation_property", reinterpret_cast<getter>(ObjectAnimationUsingKeyFrames_get_EnableDependentAnimationProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_ObjectAnimationUsingKeyFrames_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ObjectAnimationUsingKeyFrames_Meta) },
        { }
    };

    static PyType_Spec type_spec_ObjectAnimationUsingKeyFrames_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.ObjectAnimationUsingKeyFrames_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ObjectAnimationUsingKeyFrames_Meta
    };

    // ----- ObjectKeyFrame class --------------------
    static constexpr const char* const type_name_ObjectKeyFrame = "ObjectKeyFrame";

    static PyObject* _new_ObjectKeyFrame(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ObjectKeyFrame);
        return nullptr;
    }

    static void _dealloc_ObjectKeyFrame(py::wrapper::Windows::UI::Xaml::Media::Animation::ObjectKeyFrame* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ObjectKeyFrame_get_Value(py::wrapper::Windows::UI::Xaml::Media::Animation::ObjectKeyFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ObjectKeyFrame", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ObjectKeyFrame_put_Value(py::wrapper::Windows::UI::Xaml::Media::Animation::ObjectKeyFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ObjectKeyFrame", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ObjectKeyFrame_get_KeyTime(py::wrapper::Windows::UI::Xaml::Media::Animation::ObjectKeyFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ObjectKeyFrame", L"KeyTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ObjectKeyFrame_put_KeyTime(py::wrapper::Windows::UI::Xaml::Media::Animation::ObjectKeyFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ObjectKeyFrame", L"KeyTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::KeyTime>(arg);

            self->obj.KeyTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ObjectKeyFrame_get_KeyTimeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ObjectKeyFrame", L"KeyTimeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::ObjectKeyFrame::KeyTimeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ObjectKeyFrame_get_ValueProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ObjectKeyFrame", L"ValueProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::ObjectKeyFrame::ValueProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ObjectKeyFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::ObjectKeyFrame>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ObjectKeyFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::ObjectKeyFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ObjectKeyFrame[] = {
        { "_assign_array_", _assign_array_ObjectKeyFrame, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ObjectKeyFrame), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ObjectKeyFrame[] = {
        { "value", reinterpret_cast<getter>(ObjectKeyFrame_get_Value), reinterpret_cast<setter>(ObjectKeyFrame_put_Value), nullptr, nullptr },
        { "key_time", reinterpret_cast<getter>(ObjectKeyFrame_get_KeyTime), reinterpret_cast<setter>(ObjectKeyFrame_put_KeyTime), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ObjectKeyFrame[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ObjectKeyFrame) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ObjectKeyFrame) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ObjectKeyFrame) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ObjectKeyFrame) },
        { },
    };

    static PyType_Spec type_spec_ObjectKeyFrame =
    {
        "_winrt_windows_ui_xaml_media_animation.ObjectKeyFrame",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::ObjectKeyFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ObjectKeyFrame
    };

    static PyGetSetDef getset_ObjectKeyFrame_Meta[] = {
        { "key_time_property", reinterpret_cast<getter>(ObjectKeyFrame_get_KeyTimeProperty), nullptr, nullptr, nullptr },
        { "value_property", reinterpret_cast<getter>(ObjectKeyFrame_get_ValueProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_ObjectKeyFrame_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ObjectKeyFrame_Meta) },
        { }
    };

    static PyType_Spec type_spec_ObjectKeyFrame_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.ObjectKeyFrame_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ObjectKeyFrame_Meta
    };

    // ----- ObjectKeyFrameCollection class --------------------
    static constexpr const char* const type_name_ObjectKeyFrameCollection = "ObjectKeyFrameCollection";

    static PyObject* _new_ObjectKeyFrameCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::ObjectKeyFrameCollection instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ObjectKeyFrameCollection(py::wrapper::Windows::UI::Xaml::Media::Animation::ObjectKeyFrameCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ObjectKeyFrameCollection_Append(py::wrapper::Windows::UI::Xaml::Media::Animation::ObjectKeyFrameCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.ObjectKeyFrameCollection", L"Append", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::ObjectKeyFrame>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ObjectKeyFrameCollection_Clear(py::wrapper::Windows::UI::Xaml::Media::Animation::ObjectKeyFrameCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.ObjectKeyFrameCollection", L"Clear", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ObjectKeyFrameCollection_First(py::wrapper::Windows::UI::Xaml::Media::Animation::ObjectKeyFrameCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.ObjectKeyFrameCollection", L"First", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ObjectKeyFrameCollection_GetAt(py::wrapper::Windows::UI::Xaml::Media::Animation::ObjectKeyFrameCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.ObjectKeyFrameCollection", L"GetAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ObjectKeyFrameCollection_GetMany(py::wrapper::Windows::UI::Xaml::Media::Animation::ObjectKeyFrameCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.ObjectKeyFrameCollection", L"GetMany", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::Media::Animation::ObjectKeyFrame, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ObjectKeyFrameCollection_GetView(py::wrapper::Windows::UI::Xaml::Media::Animation::ObjectKeyFrameCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.ObjectKeyFrameCollection", L"GetView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ObjectKeyFrameCollection_IndexOf(py::wrapper::Windows::UI::Xaml::Media::Animation::ObjectKeyFrameCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.ObjectKeyFrameCollection", L"IndexOf", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::ObjectKeyFrame>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ObjectKeyFrameCollection_InsertAt(py::wrapper::Windows::UI::Xaml::Media::Animation::ObjectKeyFrameCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.ObjectKeyFrameCollection", L"InsertAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::ObjectKeyFrame>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ObjectKeyFrameCollection_RemoveAt(py::wrapper::Windows::UI::Xaml::Media::Animation::ObjectKeyFrameCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.ObjectKeyFrameCollection", L"RemoveAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ObjectKeyFrameCollection_RemoveAtEnd(py::wrapper::Windows::UI::Xaml::Media::Animation::ObjectKeyFrameCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.ObjectKeyFrameCollection", L"RemoveAtEnd", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ObjectKeyFrameCollection_ReplaceAll(py::wrapper::Windows::UI::Xaml::Media::Animation::ObjectKeyFrameCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.ObjectKeyFrameCollection", L"ReplaceAll", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::Media::Animation::ObjectKeyFrame, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ObjectKeyFrameCollection_SetAt(py::wrapper::Windows::UI::Xaml::Media::Animation::ObjectKeyFrameCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.ObjectKeyFrameCollection", L"SetAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::ObjectKeyFrame>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ObjectKeyFrameCollection_get_Size(py::wrapper::Windows::UI::Xaml::Media::Animation::ObjectKeyFrameCollection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.ObjectKeyFrameCollection", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ObjectKeyFrameCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::ObjectKeyFrameCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ObjectKeyFrameCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::ObjectKeyFrameCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_ObjectKeyFrameCollection(py::wrapper::Windows::UI::Xaml::Media::Animation::ObjectKeyFrameCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_ObjectKeyFrameCollection(py::wrapper::Windows::UI::Xaml::Media::Animation::ObjectKeyFrameCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_ObjectKeyFrameCollection(py::wrapper::Windows::UI::Xaml::Media::Animation::ObjectKeyFrameCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_ObjectKeyFrameCollection(py::wrapper::Windows::UI::Xaml::Media::Animation::ObjectKeyFrameCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_ObjectKeyFrameCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(
                    PyExc_TypeError,
                    "indicies must be integers, not '%s'",
                    Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(
                    slice, self->obj.Size(), &start, &stop, &step, &length)
                < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(
                    PyExc_NotImplementedError,
                    "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::UI::Xaml::Media::Animation::ObjectKeyFrame> items(length, empty_instance<winrt::Windows::UI::Xaml::Media::Animation::ObjectKeyFrame>::get());

            auto count = self->obj.GetMany(start, items);

            if (count != length)
            {
                PyErr_Format(
                    PyExc_RuntimeError,
                    "returned count %d did not match requested length %zd",
                    count,
                    length);
                return nullptr;
            }

            return convert(items);}
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_ObjectKeyFrameCollection(py::wrapper::Windows::UI::Xaml::Media::Animation::ObjectKeyFrameCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (value == nullptr) { self->obj.RemoveAt(static_cast<uint32_t>(i)); }
            else { self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::ObjectKeyFrame>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_ObjectKeyFrameCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(ObjectKeyFrameCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(ObjectKeyFrameCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(ObjectKeyFrameCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(ObjectKeyFrameCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(ObjectKeyFrameCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(ObjectKeyFrameCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(ObjectKeyFrameCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(ObjectKeyFrameCollection_InsertAt), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(ObjectKeyFrameCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(ObjectKeyFrameCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(ObjectKeyFrameCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(ObjectKeyFrameCollection_SetAt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ObjectKeyFrameCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ObjectKeyFrameCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ObjectKeyFrameCollection[] = {
        { "size", reinterpret_cast<getter>(ObjectKeyFrameCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ObjectKeyFrameCollection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ObjectKeyFrameCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ObjectKeyFrameCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ObjectKeyFrameCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ObjectKeyFrameCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_ObjectKeyFrameCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_ObjectKeyFrameCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_ObjectKeyFrameCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_ObjectKeyFrameCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_ObjectKeyFrameCollection) },
        { },
    };

    static PyType_Spec type_spec_ObjectKeyFrameCollection =
    {
        "_winrt_windows_ui_xaml_media_animation.ObjectKeyFrameCollection",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::ObjectKeyFrameCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ObjectKeyFrameCollection
    };

    // ----- PaneThemeTransition class --------------------
    static constexpr const char* const type_name_PaneThemeTransition = "PaneThemeTransition";

    static PyObject* _new_PaneThemeTransition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::PaneThemeTransition instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PaneThemeTransition(py::wrapper::Windows::UI::Xaml::Media::Animation::PaneThemeTransition* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaneThemeTransition_get_Edge(py::wrapper::Windows::UI::Xaml::Media::Animation::PaneThemeTransition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PaneThemeTransition", L"Edge"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Edge());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaneThemeTransition_put_Edge(py::wrapper::Windows::UI::Xaml::Media::Animation::PaneThemeTransition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PaneThemeTransition", L"Edge"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::EdgeTransitionLocation>(arg);

            self->obj.Edge(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaneThemeTransition_get_EdgeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PaneThemeTransition", L"EdgeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::PaneThemeTransition::EdgeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PaneThemeTransition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::PaneThemeTransition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaneThemeTransition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::PaneThemeTransition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaneThemeTransition[] = {
        { "_assign_array_", _assign_array_PaneThemeTransition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaneThemeTransition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PaneThemeTransition[] = {
        { "edge", reinterpret_cast<getter>(PaneThemeTransition_get_Edge), reinterpret_cast<setter>(PaneThemeTransition_put_Edge), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PaneThemeTransition[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaneThemeTransition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaneThemeTransition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaneThemeTransition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaneThemeTransition) },
        { },
    };

    static PyType_Spec type_spec_PaneThemeTransition =
    {
        "_winrt_windows_ui_xaml_media_animation.PaneThemeTransition",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::PaneThemeTransition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaneThemeTransition
    };

    static PyGetSetDef getset_PaneThemeTransition_Meta[] = {
        { "edge_property", reinterpret_cast<getter>(PaneThemeTransition_get_EdgeProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_PaneThemeTransition_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PaneThemeTransition_Meta) },
        { }
    };

    static PyType_Spec type_spec_PaneThemeTransition_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.PaneThemeTransition_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PaneThemeTransition_Meta
    };

    // ----- PointAnimation class --------------------
    static constexpr const char* const type_name_PointAnimation = "PointAnimation";

    static PyObject* _new_PointAnimation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::PointAnimation instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PointAnimation(py::wrapper::Windows::UI::Xaml::Media::Animation::PointAnimation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PointAnimation_get_To(py::wrapper::Windows::UI::Xaml::Media::Animation::PointAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PointAnimation", L"To"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.To());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointAnimation_put_To(py::wrapper::Windows::UI::Xaml::Media::Animation::PointAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PointAnimation", L"To"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::Point>>(arg);

            self->obj.To(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PointAnimation_get_From(py::wrapper::Windows::UI::Xaml::Media::Animation::PointAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PointAnimation", L"From"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.From());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointAnimation_put_From(py::wrapper::Windows::UI::Xaml::Media::Animation::PointAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PointAnimation", L"From"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::Point>>(arg);

            self->obj.From(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PointAnimation_get_EnableDependentAnimation(py::wrapper::Windows::UI::Xaml::Media::Animation::PointAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PointAnimation", L"EnableDependentAnimation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EnableDependentAnimation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointAnimation_put_EnableDependentAnimation(py::wrapper::Windows::UI::Xaml::Media::Animation::PointAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PointAnimation", L"EnableDependentAnimation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.EnableDependentAnimation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PointAnimation_get_EasingFunction(py::wrapper::Windows::UI::Xaml::Media::Animation::PointAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PointAnimation", L"EasingFunction"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EasingFunction());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointAnimation_put_EasingFunction(py::wrapper::Windows::UI::Xaml::Media::Animation::PointAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PointAnimation", L"EasingFunction"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::EasingFunctionBase>(arg);

            self->obj.EasingFunction(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PointAnimation_get_By(py::wrapper::Windows::UI::Xaml::Media::Animation::PointAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PointAnimation", L"By"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.By());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointAnimation_put_By(py::wrapper::Windows::UI::Xaml::Media::Animation::PointAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PointAnimation", L"By"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::Point>>(arg);

            self->obj.By(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PointAnimation_get_ByProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PointAnimation", L"ByProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::PointAnimation::ByProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointAnimation_get_EasingFunctionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PointAnimation", L"EasingFunctionProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::PointAnimation::EasingFunctionProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointAnimation_get_EnableDependentAnimationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PointAnimation", L"EnableDependentAnimationProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::PointAnimation::EnableDependentAnimationProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointAnimation_get_FromProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PointAnimation", L"FromProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::PointAnimation::FromProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointAnimation_get_ToProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PointAnimation", L"ToProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::PointAnimation::ToProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PointAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::PointAnimation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PointAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::PointAnimation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PointAnimation[] = {
        { "_assign_array_", _assign_array_PointAnimation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PointAnimation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PointAnimation[] = {
        { "to", reinterpret_cast<getter>(PointAnimation_get_To), reinterpret_cast<setter>(PointAnimation_put_To), nullptr, nullptr },
        { "from_", reinterpret_cast<getter>(PointAnimation_get_From), reinterpret_cast<setter>(PointAnimation_put_From), nullptr, nullptr },
        { "enable_dependent_animation", reinterpret_cast<getter>(PointAnimation_get_EnableDependentAnimation), reinterpret_cast<setter>(PointAnimation_put_EnableDependentAnimation), nullptr, nullptr },
        { "easing_function", reinterpret_cast<getter>(PointAnimation_get_EasingFunction), reinterpret_cast<setter>(PointAnimation_put_EasingFunction), nullptr, nullptr },
        { "by", reinterpret_cast<getter>(PointAnimation_get_By), reinterpret_cast<setter>(PointAnimation_put_By), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PointAnimation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PointAnimation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PointAnimation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PointAnimation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PointAnimation) },
        { },
    };

    static PyType_Spec type_spec_PointAnimation =
    {
        "_winrt_windows_ui_xaml_media_animation.PointAnimation",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::PointAnimation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PointAnimation
    };

    static PyGetSetDef getset_PointAnimation_Meta[] = {
        { "by_property", reinterpret_cast<getter>(PointAnimation_get_ByProperty), nullptr, nullptr, nullptr },
        { "easing_function_property", reinterpret_cast<getter>(PointAnimation_get_EasingFunctionProperty), nullptr, nullptr, nullptr },
        { "enable_dependent_animation_property", reinterpret_cast<getter>(PointAnimation_get_EnableDependentAnimationProperty), nullptr, nullptr, nullptr },
        { "from_property", reinterpret_cast<getter>(PointAnimation_get_FromProperty), nullptr, nullptr, nullptr },
        { "to_property", reinterpret_cast<getter>(PointAnimation_get_ToProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_PointAnimation_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PointAnimation_Meta) },
        { }
    };

    static PyType_Spec type_spec_PointAnimation_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.PointAnimation_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PointAnimation_Meta
    };

    // ----- PointAnimationUsingKeyFrames class --------------------
    static constexpr const char* const type_name_PointAnimationUsingKeyFrames = "PointAnimationUsingKeyFrames";

    static PyObject* _new_PointAnimationUsingKeyFrames(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::PointAnimationUsingKeyFrames instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PointAnimationUsingKeyFrames(py::wrapper::Windows::UI::Xaml::Media::Animation::PointAnimationUsingKeyFrames* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PointAnimationUsingKeyFrames_get_EnableDependentAnimation(py::wrapper::Windows::UI::Xaml::Media::Animation::PointAnimationUsingKeyFrames* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PointAnimationUsingKeyFrames", L"EnableDependentAnimation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EnableDependentAnimation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointAnimationUsingKeyFrames_put_EnableDependentAnimation(py::wrapper::Windows::UI::Xaml::Media::Animation::PointAnimationUsingKeyFrames* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PointAnimationUsingKeyFrames", L"EnableDependentAnimation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.EnableDependentAnimation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PointAnimationUsingKeyFrames_get_KeyFrames(py::wrapper::Windows::UI::Xaml::Media::Animation::PointAnimationUsingKeyFrames* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PointAnimationUsingKeyFrames", L"KeyFrames"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyFrames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointAnimationUsingKeyFrames_get_EnableDependentAnimationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PointAnimationUsingKeyFrames", L"EnableDependentAnimationProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::PointAnimationUsingKeyFrames::EnableDependentAnimationProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PointAnimationUsingKeyFrames(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::PointAnimationUsingKeyFrames>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PointAnimationUsingKeyFrames(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::PointAnimationUsingKeyFrames>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PointAnimationUsingKeyFrames[] = {
        { "_assign_array_", _assign_array_PointAnimationUsingKeyFrames, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PointAnimationUsingKeyFrames), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PointAnimationUsingKeyFrames[] = {
        { "enable_dependent_animation", reinterpret_cast<getter>(PointAnimationUsingKeyFrames_get_EnableDependentAnimation), reinterpret_cast<setter>(PointAnimationUsingKeyFrames_put_EnableDependentAnimation), nullptr, nullptr },
        { "key_frames", reinterpret_cast<getter>(PointAnimationUsingKeyFrames_get_KeyFrames), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PointAnimationUsingKeyFrames[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PointAnimationUsingKeyFrames) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PointAnimationUsingKeyFrames) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PointAnimationUsingKeyFrames) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PointAnimationUsingKeyFrames) },
        { },
    };

    static PyType_Spec type_spec_PointAnimationUsingKeyFrames =
    {
        "_winrt_windows_ui_xaml_media_animation.PointAnimationUsingKeyFrames",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::PointAnimationUsingKeyFrames),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PointAnimationUsingKeyFrames
    };

    static PyGetSetDef getset_PointAnimationUsingKeyFrames_Meta[] = {
        { "enable_dependent_animation_property", reinterpret_cast<getter>(PointAnimationUsingKeyFrames_get_EnableDependentAnimationProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_PointAnimationUsingKeyFrames_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PointAnimationUsingKeyFrames_Meta) },
        { }
    };

    static PyType_Spec type_spec_PointAnimationUsingKeyFrames_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.PointAnimationUsingKeyFrames_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PointAnimationUsingKeyFrames_Meta
    };

    // ----- PointKeyFrame class --------------------
    static constexpr const char* const type_name_PointKeyFrame = "PointKeyFrame";

    static PyObject* _new_PointKeyFrame(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PointKeyFrame);
        return nullptr;
    }

    static void _dealloc_PointKeyFrame(py::wrapper::Windows::UI::Xaml::Media::Animation::PointKeyFrame* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PointKeyFrame_get_Value(py::wrapper::Windows::UI::Xaml::Media::Animation::PointKeyFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PointKeyFrame", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointKeyFrame_put_Value(py::wrapper::Windows::UI::Xaml::Media::Animation::PointKeyFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PointKeyFrame", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PointKeyFrame_get_KeyTime(py::wrapper::Windows::UI::Xaml::Media::Animation::PointKeyFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PointKeyFrame", L"KeyTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointKeyFrame_put_KeyTime(py::wrapper::Windows::UI::Xaml::Media::Animation::PointKeyFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PointKeyFrame", L"KeyTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::KeyTime>(arg);

            self->obj.KeyTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PointKeyFrame_get_KeyTimeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PointKeyFrame", L"KeyTimeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::PointKeyFrame::KeyTimeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointKeyFrame_get_ValueProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PointKeyFrame", L"ValueProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::PointKeyFrame::ValueProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PointKeyFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::PointKeyFrame>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PointKeyFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::PointKeyFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PointKeyFrame[] = {
        { "_assign_array_", _assign_array_PointKeyFrame, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PointKeyFrame), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PointKeyFrame[] = {
        { "value", reinterpret_cast<getter>(PointKeyFrame_get_Value), reinterpret_cast<setter>(PointKeyFrame_put_Value), nullptr, nullptr },
        { "key_time", reinterpret_cast<getter>(PointKeyFrame_get_KeyTime), reinterpret_cast<setter>(PointKeyFrame_put_KeyTime), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PointKeyFrame[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PointKeyFrame) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PointKeyFrame) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PointKeyFrame) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PointKeyFrame) },
        { },
    };

    static PyType_Spec type_spec_PointKeyFrame =
    {
        "_winrt_windows_ui_xaml_media_animation.PointKeyFrame",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::PointKeyFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PointKeyFrame
    };

    static PyGetSetDef getset_PointKeyFrame_Meta[] = {
        { "key_time_property", reinterpret_cast<getter>(PointKeyFrame_get_KeyTimeProperty), nullptr, nullptr, nullptr },
        { "value_property", reinterpret_cast<getter>(PointKeyFrame_get_ValueProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_PointKeyFrame_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PointKeyFrame_Meta) },
        { }
    };

    static PyType_Spec type_spec_PointKeyFrame_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.PointKeyFrame_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PointKeyFrame_Meta
    };

    // ----- PointKeyFrameCollection class --------------------
    static constexpr const char* const type_name_PointKeyFrameCollection = "PointKeyFrameCollection";

    static PyObject* _new_PointKeyFrameCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::PointKeyFrameCollection instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PointKeyFrameCollection(py::wrapper::Windows::UI::Xaml::Media::Animation::PointKeyFrameCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PointKeyFrameCollection_Append(py::wrapper::Windows::UI::Xaml::Media::Animation::PointKeyFrameCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.PointKeyFrameCollection", L"Append", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::PointKeyFrame>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointKeyFrameCollection_Clear(py::wrapper::Windows::UI::Xaml::Media::Animation::PointKeyFrameCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.PointKeyFrameCollection", L"Clear", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointKeyFrameCollection_First(py::wrapper::Windows::UI::Xaml::Media::Animation::PointKeyFrameCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.PointKeyFrameCollection", L"First", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointKeyFrameCollection_GetAt(py::wrapper::Windows::UI::Xaml::Media::Animation::PointKeyFrameCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.PointKeyFrameCollection", L"GetAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointKeyFrameCollection_GetMany(py::wrapper::Windows::UI::Xaml::Media::Animation::PointKeyFrameCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.PointKeyFrameCollection", L"GetMany", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::Media::Animation::PointKeyFrame, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointKeyFrameCollection_GetView(py::wrapper::Windows::UI::Xaml::Media::Animation::PointKeyFrameCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.PointKeyFrameCollection", L"GetView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointKeyFrameCollection_IndexOf(py::wrapper::Windows::UI::Xaml::Media::Animation::PointKeyFrameCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.PointKeyFrameCollection", L"IndexOf", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::PointKeyFrame>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointKeyFrameCollection_InsertAt(py::wrapper::Windows::UI::Xaml::Media::Animation::PointKeyFrameCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.PointKeyFrameCollection", L"InsertAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::PointKeyFrame>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointKeyFrameCollection_RemoveAt(py::wrapper::Windows::UI::Xaml::Media::Animation::PointKeyFrameCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.PointKeyFrameCollection", L"RemoveAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointKeyFrameCollection_RemoveAtEnd(py::wrapper::Windows::UI::Xaml::Media::Animation::PointKeyFrameCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.PointKeyFrameCollection", L"RemoveAtEnd", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointKeyFrameCollection_ReplaceAll(py::wrapper::Windows::UI::Xaml::Media::Animation::PointKeyFrameCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.PointKeyFrameCollection", L"ReplaceAll", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::Media::Animation::PointKeyFrame, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointKeyFrameCollection_SetAt(py::wrapper::Windows::UI::Xaml::Media::Animation::PointKeyFrameCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.PointKeyFrameCollection", L"SetAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::PointKeyFrame>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointKeyFrameCollection_get_Size(py::wrapper::Windows::UI::Xaml::Media::Animation::PointKeyFrameCollection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PointKeyFrameCollection", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PointKeyFrameCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::PointKeyFrameCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PointKeyFrameCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::PointKeyFrameCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_PointKeyFrameCollection(py::wrapper::Windows::UI::Xaml::Media::Animation::PointKeyFrameCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_PointKeyFrameCollection(py::wrapper::Windows::UI::Xaml::Media::Animation::PointKeyFrameCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_PointKeyFrameCollection(py::wrapper::Windows::UI::Xaml::Media::Animation::PointKeyFrameCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_PointKeyFrameCollection(py::wrapper::Windows::UI::Xaml::Media::Animation::PointKeyFrameCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_PointKeyFrameCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(
                    PyExc_TypeError,
                    "indicies must be integers, not '%s'",
                    Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(
                    slice, self->obj.Size(), &start, &stop, &step, &length)
                < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(
                    PyExc_NotImplementedError,
                    "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::UI::Xaml::Media::Animation::PointKeyFrame> items(length, empty_instance<winrt::Windows::UI::Xaml::Media::Animation::PointKeyFrame>::get());

            auto count = self->obj.GetMany(start, items);

            if (count != length)
            {
                PyErr_Format(
                    PyExc_RuntimeError,
                    "returned count %d did not match requested length %zd",
                    count,
                    length);
                return nullptr;
            }

            return convert(items);}
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_PointKeyFrameCollection(py::wrapper::Windows::UI::Xaml::Media::Animation::PointKeyFrameCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (value == nullptr) { self->obj.RemoveAt(static_cast<uint32_t>(i)); }
            else { self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::PointKeyFrame>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_PointKeyFrameCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(PointKeyFrameCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(PointKeyFrameCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(PointKeyFrameCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(PointKeyFrameCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(PointKeyFrameCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(PointKeyFrameCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(PointKeyFrameCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(PointKeyFrameCollection_InsertAt), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(PointKeyFrameCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(PointKeyFrameCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(PointKeyFrameCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(PointKeyFrameCollection_SetAt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PointKeyFrameCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PointKeyFrameCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PointKeyFrameCollection[] = {
        { "size", reinterpret_cast<getter>(PointKeyFrameCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PointKeyFrameCollection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PointKeyFrameCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PointKeyFrameCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PointKeyFrameCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PointKeyFrameCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_PointKeyFrameCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_PointKeyFrameCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_PointKeyFrameCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_PointKeyFrameCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_PointKeyFrameCollection) },
        { },
    };

    static PyType_Spec type_spec_PointKeyFrameCollection =
    {
        "_winrt_windows_ui_xaml_media_animation.PointKeyFrameCollection",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::PointKeyFrameCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PointKeyFrameCollection
    };

    // ----- PointerDownThemeAnimation class --------------------
    static constexpr const char* const type_name_PointerDownThemeAnimation = "PointerDownThemeAnimation";

    static PyObject* _new_PointerDownThemeAnimation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::PointerDownThemeAnimation instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PointerDownThemeAnimation(py::wrapper::Windows::UI::Xaml::Media::Animation::PointerDownThemeAnimation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PointerDownThemeAnimation_get_TargetName(py::wrapper::Windows::UI::Xaml::Media::Animation::PointerDownThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PointerDownThemeAnimation", L"TargetName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TargetName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointerDownThemeAnimation_put_TargetName(py::wrapper::Windows::UI::Xaml::Media::Animation::PointerDownThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PointerDownThemeAnimation", L"TargetName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.TargetName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PointerDownThemeAnimation_get_TargetNameProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PointerDownThemeAnimation", L"TargetNameProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::PointerDownThemeAnimation::TargetNameProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PointerDownThemeAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::PointerDownThemeAnimation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PointerDownThemeAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::PointerDownThemeAnimation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PointerDownThemeAnimation[] = {
        { "_assign_array_", _assign_array_PointerDownThemeAnimation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PointerDownThemeAnimation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PointerDownThemeAnimation[] = {
        { "target_name", reinterpret_cast<getter>(PointerDownThemeAnimation_get_TargetName), reinterpret_cast<setter>(PointerDownThemeAnimation_put_TargetName), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PointerDownThemeAnimation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PointerDownThemeAnimation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PointerDownThemeAnimation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PointerDownThemeAnimation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PointerDownThemeAnimation) },
        { },
    };

    static PyType_Spec type_spec_PointerDownThemeAnimation =
    {
        "_winrt_windows_ui_xaml_media_animation.PointerDownThemeAnimation",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::PointerDownThemeAnimation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PointerDownThemeAnimation
    };

    static PyGetSetDef getset_PointerDownThemeAnimation_Meta[] = {
        { "target_name_property", reinterpret_cast<getter>(PointerDownThemeAnimation_get_TargetNameProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_PointerDownThemeAnimation_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PointerDownThemeAnimation_Meta) },
        { }
    };

    static PyType_Spec type_spec_PointerDownThemeAnimation_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.PointerDownThemeAnimation_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PointerDownThemeAnimation_Meta
    };

    // ----- PointerUpThemeAnimation class --------------------
    static constexpr const char* const type_name_PointerUpThemeAnimation = "PointerUpThemeAnimation";

    static PyObject* _new_PointerUpThemeAnimation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::PointerUpThemeAnimation instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PointerUpThemeAnimation(py::wrapper::Windows::UI::Xaml::Media::Animation::PointerUpThemeAnimation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PointerUpThemeAnimation_get_TargetName(py::wrapper::Windows::UI::Xaml::Media::Animation::PointerUpThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PointerUpThemeAnimation", L"TargetName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TargetName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointerUpThemeAnimation_put_TargetName(py::wrapper::Windows::UI::Xaml::Media::Animation::PointerUpThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PointerUpThemeAnimation", L"TargetName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.TargetName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PointerUpThemeAnimation_get_TargetNameProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PointerUpThemeAnimation", L"TargetNameProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::PointerUpThemeAnimation::TargetNameProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PointerUpThemeAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::PointerUpThemeAnimation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PointerUpThemeAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::PointerUpThemeAnimation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PointerUpThemeAnimation[] = {
        { "_assign_array_", _assign_array_PointerUpThemeAnimation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PointerUpThemeAnimation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PointerUpThemeAnimation[] = {
        { "target_name", reinterpret_cast<getter>(PointerUpThemeAnimation_get_TargetName), reinterpret_cast<setter>(PointerUpThemeAnimation_put_TargetName), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PointerUpThemeAnimation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PointerUpThemeAnimation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PointerUpThemeAnimation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PointerUpThemeAnimation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PointerUpThemeAnimation) },
        { },
    };

    static PyType_Spec type_spec_PointerUpThemeAnimation =
    {
        "_winrt_windows_ui_xaml_media_animation.PointerUpThemeAnimation",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::PointerUpThemeAnimation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PointerUpThemeAnimation
    };

    static PyGetSetDef getset_PointerUpThemeAnimation_Meta[] = {
        { "target_name_property", reinterpret_cast<getter>(PointerUpThemeAnimation_get_TargetNameProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_PointerUpThemeAnimation_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PointerUpThemeAnimation_Meta) },
        { }
    };

    static PyType_Spec type_spec_PointerUpThemeAnimation_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.PointerUpThemeAnimation_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PointerUpThemeAnimation_Meta
    };

    // ----- PopInThemeAnimation class --------------------
    static constexpr const char* const type_name_PopInThemeAnimation = "PopInThemeAnimation";

    static PyObject* _new_PopInThemeAnimation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::PopInThemeAnimation instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PopInThemeAnimation(py::wrapper::Windows::UI::Xaml::Media::Animation::PopInThemeAnimation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PopInThemeAnimation_get_TargetName(py::wrapper::Windows::UI::Xaml::Media::Animation::PopInThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PopInThemeAnimation", L"TargetName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TargetName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PopInThemeAnimation_put_TargetName(py::wrapper::Windows::UI::Xaml::Media::Animation::PopInThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PopInThemeAnimation", L"TargetName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.TargetName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PopInThemeAnimation_get_FromVerticalOffset(py::wrapper::Windows::UI::Xaml::Media::Animation::PopInThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PopInThemeAnimation", L"FromVerticalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FromVerticalOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PopInThemeAnimation_put_FromVerticalOffset(py::wrapper::Windows::UI::Xaml::Media::Animation::PopInThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PopInThemeAnimation", L"FromVerticalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.FromVerticalOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PopInThemeAnimation_get_FromHorizontalOffset(py::wrapper::Windows::UI::Xaml::Media::Animation::PopInThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PopInThemeAnimation", L"FromHorizontalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FromHorizontalOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PopInThemeAnimation_put_FromHorizontalOffset(py::wrapper::Windows::UI::Xaml::Media::Animation::PopInThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PopInThemeAnimation", L"FromHorizontalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.FromHorizontalOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PopInThemeAnimation_get_FromHorizontalOffsetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PopInThemeAnimation", L"FromHorizontalOffsetProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::PopInThemeAnimation::FromHorizontalOffsetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PopInThemeAnimation_get_FromVerticalOffsetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PopInThemeAnimation", L"FromVerticalOffsetProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::PopInThemeAnimation::FromVerticalOffsetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PopInThemeAnimation_get_TargetNameProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PopInThemeAnimation", L"TargetNameProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::PopInThemeAnimation::TargetNameProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PopInThemeAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::PopInThemeAnimation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PopInThemeAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::PopInThemeAnimation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PopInThemeAnimation[] = {
        { "_assign_array_", _assign_array_PopInThemeAnimation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PopInThemeAnimation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PopInThemeAnimation[] = {
        { "target_name", reinterpret_cast<getter>(PopInThemeAnimation_get_TargetName), reinterpret_cast<setter>(PopInThemeAnimation_put_TargetName), nullptr, nullptr },
        { "from_vertical_offset", reinterpret_cast<getter>(PopInThemeAnimation_get_FromVerticalOffset), reinterpret_cast<setter>(PopInThemeAnimation_put_FromVerticalOffset), nullptr, nullptr },
        { "from_horizontal_offset", reinterpret_cast<getter>(PopInThemeAnimation_get_FromHorizontalOffset), reinterpret_cast<setter>(PopInThemeAnimation_put_FromHorizontalOffset), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PopInThemeAnimation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PopInThemeAnimation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PopInThemeAnimation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PopInThemeAnimation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PopInThemeAnimation) },
        { },
    };

    static PyType_Spec type_spec_PopInThemeAnimation =
    {
        "_winrt_windows_ui_xaml_media_animation.PopInThemeAnimation",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::PopInThemeAnimation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PopInThemeAnimation
    };

    static PyGetSetDef getset_PopInThemeAnimation_Meta[] = {
        { "from_horizontal_offset_property", reinterpret_cast<getter>(PopInThemeAnimation_get_FromHorizontalOffsetProperty), nullptr, nullptr, nullptr },
        { "from_vertical_offset_property", reinterpret_cast<getter>(PopInThemeAnimation_get_FromVerticalOffsetProperty), nullptr, nullptr, nullptr },
        { "target_name_property", reinterpret_cast<getter>(PopInThemeAnimation_get_TargetNameProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_PopInThemeAnimation_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PopInThemeAnimation_Meta) },
        { }
    };

    static PyType_Spec type_spec_PopInThemeAnimation_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.PopInThemeAnimation_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PopInThemeAnimation_Meta
    };

    // ----- PopOutThemeAnimation class --------------------
    static constexpr const char* const type_name_PopOutThemeAnimation = "PopOutThemeAnimation";

    static PyObject* _new_PopOutThemeAnimation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::PopOutThemeAnimation instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PopOutThemeAnimation(py::wrapper::Windows::UI::Xaml::Media::Animation::PopOutThemeAnimation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PopOutThemeAnimation_get_TargetName(py::wrapper::Windows::UI::Xaml::Media::Animation::PopOutThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PopOutThemeAnimation", L"TargetName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TargetName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PopOutThemeAnimation_put_TargetName(py::wrapper::Windows::UI::Xaml::Media::Animation::PopOutThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PopOutThemeAnimation", L"TargetName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.TargetName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PopOutThemeAnimation_get_TargetNameProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PopOutThemeAnimation", L"TargetNameProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::PopOutThemeAnimation::TargetNameProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PopOutThemeAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::PopOutThemeAnimation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PopOutThemeAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::PopOutThemeAnimation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PopOutThemeAnimation[] = {
        { "_assign_array_", _assign_array_PopOutThemeAnimation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PopOutThemeAnimation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PopOutThemeAnimation[] = {
        { "target_name", reinterpret_cast<getter>(PopOutThemeAnimation_get_TargetName), reinterpret_cast<setter>(PopOutThemeAnimation_put_TargetName), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PopOutThemeAnimation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PopOutThemeAnimation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PopOutThemeAnimation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PopOutThemeAnimation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PopOutThemeAnimation) },
        { },
    };

    static PyType_Spec type_spec_PopOutThemeAnimation =
    {
        "_winrt_windows_ui_xaml_media_animation.PopOutThemeAnimation",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::PopOutThemeAnimation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PopOutThemeAnimation
    };

    static PyGetSetDef getset_PopOutThemeAnimation_Meta[] = {
        { "target_name_property", reinterpret_cast<getter>(PopOutThemeAnimation_get_TargetNameProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_PopOutThemeAnimation_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PopOutThemeAnimation_Meta) },
        { }
    };

    static PyType_Spec type_spec_PopOutThemeAnimation_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.PopOutThemeAnimation_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PopOutThemeAnimation_Meta
    };

    // ----- PopupThemeTransition class --------------------
    static constexpr const char* const type_name_PopupThemeTransition = "PopupThemeTransition";

    static PyObject* _new_PopupThemeTransition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::PopupThemeTransition instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PopupThemeTransition(py::wrapper::Windows::UI::Xaml::Media::Animation::PopupThemeTransition* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PopupThemeTransition_get_FromVerticalOffset(py::wrapper::Windows::UI::Xaml::Media::Animation::PopupThemeTransition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PopupThemeTransition", L"FromVerticalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FromVerticalOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PopupThemeTransition_put_FromVerticalOffset(py::wrapper::Windows::UI::Xaml::Media::Animation::PopupThemeTransition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PopupThemeTransition", L"FromVerticalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.FromVerticalOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PopupThemeTransition_get_FromHorizontalOffset(py::wrapper::Windows::UI::Xaml::Media::Animation::PopupThemeTransition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PopupThemeTransition", L"FromHorizontalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FromHorizontalOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PopupThemeTransition_put_FromHorizontalOffset(py::wrapper::Windows::UI::Xaml::Media::Animation::PopupThemeTransition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PopupThemeTransition", L"FromHorizontalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.FromHorizontalOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PopupThemeTransition_get_FromHorizontalOffsetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PopupThemeTransition", L"FromHorizontalOffsetProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::PopupThemeTransition::FromHorizontalOffsetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PopupThemeTransition_get_FromVerticalOffsetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PopupThemeTransition", L"FromVerticalOffsetProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::PopupThemeTransition::FromVerticalOffsetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PopupThemeTransition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::PopupThemeTransition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PopupThemeTransition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::PopupThemeTransition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PopupThemeTransition[] = {
        { "_assign_array_", _assign_array_PopupThemeTransition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PopupThemeTransition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PopupThemeTransition[] = {
        { "from_vertical_offset", reinterpret_cast<getter>(PopupThemeTransition_get_FromVerticalOffset), reinterpret_cast<setter>(PopupThemeTransition_put_FromVerticalOffset), nullptr, nullptr },
        { "from_horizontal_offset", reinterpret_cast<getter>(PopupThemeTransition_get_FromHorizontalOffset), reinterpret_cast<setter>(PopupThemeTransition_put_FromHorizontalOffset), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PopupThemeTransition[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PopupThemeTransition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PopupThemeTransition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PopupThemeTransition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PopupThemeTransition) },
        { },
    };

    static PyType_Spec type_spec_PopupThemeTransition =
    {
        "_winrt_windows_ui_xaml_media_animation.PopupThemeTransition",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::PopupThemeTransition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PopupThemeTransition
    };

    static PyGetSetDef getset_PopupThemeTransition_Meta[] = {
        { "from_horizontal_offset_property", reinterpret_cast<getter>(PopupThemeTransition_get_FromHorizontalOffsetProperty), nullptr, nullptr, nullptr },
        { "from_vertical_offset_property", reinterpret_cast<getter>(PopupThemeTransition_get_FromVerticalOffsetProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_PopupThemeTransition_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PopupThemeTransition_Meta) },
        { }
    };

    static PyType_Spec type_spec_PopupThemeTransition_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.PopupThemeTransition_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PopupThemeTransition_Meta
    };

    // ----- PowerEase class --------------------
    static constexpr const char* const type_name_PowerEase = "PowerEase";

    static PyObject* _new_PowerEase(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::PowerEase instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PowerEase(py::wrapper::Windows::UI::Xaml::Media::Animation::PowerEase* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PowerEase_get_Power(py::wrapper::Windows::UI::Xaml::Media::Animation::PowerEase* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PowerEase", L"Power"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Power());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PowerEase_put_Power(py::wrapper::Windows::UI::Xaml::Media::Animation::PowerEase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PowerEase", L"Power"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Power(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PowerEase_get_PowerProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.PowerEase", L"PowerProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::PowerEase::PowerProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PowerEase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::PowerEase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PowerEase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::PowerEase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PowerEase[] = {
        { "_assign_array_", _assign_array_PowerEase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PowerEase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PowerEase[] = {
        { "power", reinterpret_cast<getter>(PowerEase_get_Power), reinterpret_cast<setter>(PowerEase_put_Power), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PowerEase[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PowerEase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PowerEase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PowerEase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PowerEase) },
        { },
    };

    static PyType_Spec type_spec_PowerEase =
    {
        "_winrt_windows_ui_xaml_media_animation.PowerEase",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::PowerEase),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PowerEase
    };

    static PyGetSetDef getset_PowerEase_Meta[] = {
        { "power_property", reinterpret_cast<getter>(PowerEase_get_PowerProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_PowerEase_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PowerEase_Meta) },
        { }
    };

    static PyType_Spec type_spec_PowerEase_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.PowerEase_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PowerEase_Meta
    };

    // ----- QuadraticEase class --------------------
    static constexpr const char* const type_name_QuadraticEase = "QuadraticEase";

    static PyObject* _new_QuadraticEase(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::QuadraticEase instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_QuadraticEase(py::wrapper::Windows::UI::Xaml::Media::Animation::QuadraticEase* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_QuadraticEase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::QuadraticEase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_QuadraticEase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::QuadraticEase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_QuadraticEase[] = {
        { "_assign_array_", _assign_array_QuadraticEase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_QuadraticEase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_QuadraticEase[] = {
        { }
    };

    static PyType_Slot _type_slots_QuadraticEase[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_QuadraticEase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_QuadraticEase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_QuadraticEase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_QuadraticEase) },
        { },
    };

    static PyType_Spec type_spec_QuadraticEase =
    {
        "_winrt_windows_ui_xaml_media_animation.QuadraticEase",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::QuadraticEase),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_QuadraticEase
    };

    // ----- QuarticEase class --------------------
    static constexpr const char* const type_name_QuarticEase = "QuarticEase";

    static PyObject* _new_QuarticEase(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::QuarticEase instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_QuarticEase(py::wrapper::Windows::UI::Xaml::Media::Animation::QuarticEase* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_QuarticEase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::QuarticEase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_QuarticEase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::QuarticEase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_QuarticEase[] = {
        { "_assign_array_", _assign_array_QuarticEase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_QuarticEase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_QuarticEase[] = {
        { }
    };

    static PyType_Slot _type_slots_QuarticEase[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_QuarticEase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_QuarticEase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_QuarticEase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_QuarticEase) },
        { },
    };

    static PyType_Spec type_spec_QuarticEase =
    {
        "_winrt_windows_ui_xaml_media_animation.QuarticEase",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::QuarticEase),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_QuarticEase
    };

    // ----- QuinticEase class --------------------
    static constexpr const char* const type_name_QuinticEase = "QuinticEase";

    static PyObject* _new_QuinticEase(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::QuinticEase instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_QuinticEase(py::wrapper::Windows::UI::Xaml::Media::Animation::QuinticEase* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_QuinticEase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::QuinticEase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_QuinticEase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::QuinticEase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_QuinticEase[] = {
        { "_assign_array_", _assign_array_QuinticEase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_QuinticEase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_QuinticEase[] = {
        { }
    };

    static PyType_Slot _type_slots_QuinticEase[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_QuinticEase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_QuinticEase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_QuinticEase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_QuinticEase) },
        { },
    };

    static PyType_Spec type_spec_QuinticEase =
    {
        "_winrt_windows_ui_xaml_media_animation.QuinticEase",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::QuinticEase),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_QuinticEase
    };

    // ----- ReorderThemeTransition class --------------------
    static constexpr const char* const type_name_ReorderThemeTransition = "ReorderThemeTransition";

    static PyObject* _new_ReorderThemeTransition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::ReorderThemeTransition instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ReorderThemeTransition(py::wrapper::Windows::UI::Xaml::Media::Animation::ReorderThemeTransition* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ReorderThemeTransition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::ReorderThemeTransition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ReorderThemeTransition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::ReorderThemeTransition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ReorderThemeTransition[] = {
        { "_assign_array_", _assign_array_ReorderThemeTransition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ReorderThemeTransition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ReorderThemeTransition[] = {
        { }
    };

    static PyType_Slot _type_slots_ReorderThemeTransition[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ReorderThemeTransition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ReorderThemeTransition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ReorderThemeTransition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ReorderThemeTransition) },
        { },
    };

    static PyType_Spec type_spec_ReorderThemeTransition =
    {
        "_winrt_windows_ui_xaml_media_animation.ReorderThemeTransition",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::ReorderThemeTransition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ReorderThemeTransition
    };

    // ----- RepeatBehaviorHelper class --------------------
    static constexpr const char* const type_name_RepeatBehaviorHelper = "RepeatBehaviorHelper";

    static PyObject* _new_RepeatBehaviorHelper(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_RepeatBehaviorHelper);
        return nullptr;
    }

    static void _dealloc_RepeatBehaviorHelper(py::wrapper::Windows::UI::Xaml::Media::Animation::RepeatBehaviorHelper* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RepeatBehaviorHelper_Equals(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.RepeatBehaviorHelper", L"Equals", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::RepeatBehavior>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::RepeatBehavior>(args, 1);

                return py::convert(winrt::Windows::UI::Xaml::Media::Animation::RepeatBehaviorHelper::Equals(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RepeatBehaviorHelper_FromCount(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.RepeatBehaviorHelper", L"FromCount", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Media::Animation::RepeatBehaviorHelper::FromCount(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RepeatBehaviorHelper_FromDuration(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.RepeatBehaviorHelper", L"FromDuration", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Media::Animation::RepeatBehaviorHelper::FromDuration(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RepeatBehaviorHelper_GetHasCount(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.RepeatBehaviorHelper", L"GetHasCount", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::RepeatBehavior>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Media::Animation::RepeatBehaviorHelper::GetHasCount(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RepeatBehaviorHelper_GetHasDuration(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.RepeatBehaviorHelper", L"GetHasDuration", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::RepeatBehavior>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Media::Animation::RepeatBehaviorHelper::GetHasDuration(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RepeatBehaviorHelper_get_Forever(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.RepeatBehaviorHelper", L"Forever"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::RepeatBehaviorHelper::Forever());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RepeatBehaviorHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::RepeatBehaviorHelper>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RepeatBehaviorHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::RepeatBehaviorHelper>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RepeatBehaviorHelper[] = {
        { "equals", reinterpret_cast<PyCFunction>(RepeatBehaviorHelper_Equals), METH_VARARGS | METH_STATIC, nullptr },
        { "from_count", reinterpret_cast<PyCFunction>(RepeatBehaviorHelper_FromCount), METH_VARARGS | METH_STATIC, nullptr },
        { "from_duration", reinterpret_cast<PyCFunction>(RepeatBehaviorHelper_FromDuration), METH_VARARGS | METH_STATIC, nullptr },
        { "get_has_count", reinterpret_cast<PyCFunction>(RepeatBehaviorHelper_GetHasCount), METH_VARARGS | METH_STATIC, nullptr },
        { "get_has_duration", reinterpret_cast<PyCFunction>(RepeatBehaviorHelper_GetHasDuration), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_RepeatBehaviorHelper, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RepeatBehaviorHelper), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RepeatBehaviorHelper[] = {
        { }
    };

    static PyType_Slot _type_slots_RepeatBehaviorHelper[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RepeatBehaviorHelper) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RepeatBehaviorHelper) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RepeatBehaviorHelper) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RepeatBehaviorHelper) },
        { },
    };

    static PyType_Spec type_spec_RepeatBehaviorHelper =
    {
        "_winrt_windows_ui_xaml_media_animation.RepeatBehaviorHelper",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::RepeatBehaviorHelper),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RepeatBehaviorHelper
    };

    static PyGetSetDef getset_RepeatBehaviorHelper_Meta[] = {
        { "forever", reinterpret_cast<getter>(RepeatBehaviorHelper_get_Forever), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_RepeatBehaviorHelper_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RepeatBehaviorHelper_Meta) },
        { }
    };

    static PyType_Spec type_spec_RepeatBehaviorHelper_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.RepeatBehaviorHelper_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RepeatBehaviorHelper_Meta
    };

    // ----- RepositionThemeAnimation class --------------------
    static constexpr const char* const type_name_RepositionThemeAnimation = "RepositionThemeAnimation";

    static PyObject* _new_RepositionThemeAnimation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::RepositionThemeAnimation instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RepositionThemeAnimation(py::wrapper::Windows::UI::Xaml::Media::Animation::RepositionThemeAnimation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RepositionThemeAnimation_get_TargetName(py::wrapper::Windows::UI::Xaml::Media::Animation::RepositionThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.RepositionThemeAnimation", L"TargetName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TargetName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RepositionThemeAnimation_put_TargetName(py::wrapper::Windows::UI::Xaml::Media::Animation::RepositionThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.RepositionThemeAnimation", L"TargetName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.TargetName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RepositionThemeAnimation_get_FromVerticalOffset(py::wrapper::Windows::UI::Xaml::Media::Animation::RepositionThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.RepositionThemeAnimation", L"FromVerticalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FromVerticalOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RepositionThemeAnimation_put_FromVerticalOffset(py::wrapper::Windows::UI::Xaml::Media::Animation::RepositionThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.RepositionThemeAnimation", L"FromVerticalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.FromVerticalOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RepositionThemeAnimation_get_FromHorizontalOffset(py::wrapper::Windows::UI::Xaml::Media::Animation::RepositionThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.RepositionThemeAnimation", L"FromHorizontalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FromHorizontalOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RepositionThemeAnimation_put_FromHorizontalOffset(py::wrapper::Windows::UI::Xaml::Media::Animation::RepositionThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.RepositionThemeAnimation", L"FromHorizontalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.FromHorizontalOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RepositionThemeAnimation_get_FromHorizontalOffsetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.RepositionThemeAnimation", L"FromHorizontalOffsetProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::RepositionThemeAnimation::FromHorizontalOffsetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RepositionThemeAnimation_get_FromVerticalOffsetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.RepositionThemeAnimation", L"FromVerticalOffsetProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::RepositionThemeAnimation::FromVerticalOffsetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RepositionThemeAnimation_get_TargetNameProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.RepositionThemeAnimation", L"TargetNameProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::RepositionThemeAnimation::TargetNameProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RepositionThemeAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::RepositionThemeAnimation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RepositionThemeAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::RepositionThemeAnimation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RepositionThemeAnimation[] = {
        { "_assign_array_", _assign_array_RepositionThemeAnimation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RepositionThemeAnimation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RepositionThemeAnimation[] = {
        { "target_name", reinterpret_cast<getter>(RepositionThemeAnimation_get_TargetName), reinterpret_cast<setter>(RepositionThemeAnimation_put_TargetName), nullptr, nullptr },
        { "from_vertical_offset", reinterpret_cast<getter>(RepositionThemeAnimation_get_FromVerticalOffset), reinterpret_cast<setter>(RepositionThemeAnimation_put_FromVerticalOffset), nullptr, nullptr },
        { "from_horizontal_offset", reinterpret_cast<getter>(RepositionThemeAnimation_get_FromHorizontalOffset), reinterpret_cast<setter>(RepositionThemeAnimation_put_FromHorizontalOffset), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RepositionThemeAnimation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RepositionThemeAnimation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RepositionThemeAnimation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RepositionThemeAnimation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RepositionThemeAnimation) },
        { },
    };

    static PyType_Spec type_spec_RepositionThemeAnimation =
    {
        "_winrt_windows_ui_xaml_media_animation.RepositionThemeAnimation",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::RepositionThemeAnimation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RepositionThemeAnimation
    };

    static PyGetSetDef getset_RepositionThemeAnimation_Meta[] = {
        { "from_horizontal_offset_property", reinterpret_cast<getter>(RepositionThemeAnimation_get_FromHorizontalOffsetProperty), nullptr, nullptr, nullptr },
        { "from_vertical_offset_property", reinterpret_cast<getter>(RepositionThemeAnimation_get_FromVerticalOffsetProperty), nullptr, nullptr, nullptr },
        { "target_name_property", reinterpret_cast<getter>(RepositionThemeAnimation_get_TargetNameProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_RepositionThemeAnimation_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RepositionThemeAnimation_Meta) },
        { }
    };

    static PyType_Spec type_spec_RepositionThemeAnimation_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.RepositionThemeAnimation_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RepositionThemeAnimation_Meta
    };

    // ----- RepositionThemeTransition class --------------------
    static constexpr const char* const type_name_RepositionThemeTransition = "RepositionThemeTransition";

    static PyObject* _new_RepositionThemeTransition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::RepositionThemeTransition instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RepositionThemeTransition(py::wrapper::Windows::UI::Xaml::Media::Animation::RepositionThemeTransition* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RepositionThemeTransition_get_IsStaggeringEnabled(py::wrapper::Windows::UI::Xaml::Media::Animation::RepositionThemeTransition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.RepositionThemeTransition", L"IsStaggeringEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsStaggeringEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RepositionThemeTransition_put_IsStaggeringEnabled(py::wrapper::Windows::UI::Xaml::Media::Animation::RepositionThemeTransition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.RepositionThemeTransition", L"IsStaggeringEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsStaggeringEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RepositionThemeTransition_get_IsStaggeringEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.RepositionThemeTransition", L"IsStaggeringEnabledProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::RepositionThemeTransition::IsStaggeringEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RepositionThemeTransition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::RepositionThemeTransition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RepositionThemeTransition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::RepositionThemeTransition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RepositionThemeTransition[] = {
        { "_assign_array_", _assign_array_RepositionThemeTransition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RepositionThemeTransition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RepositionThemeTransition[] = {
        { "is_staggering_enabled", reinterpret_cast<getter>(RepositionThemeTransition_get_IsStaggeringEnabled), reinterpret_cast<setter>(RepositionThemeTransition_put_IsStaggeringEnabled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RepositionThemeTransition[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RepositionThemeTransition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RepositionThemeTransition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RepositionThemeTransition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RepositionThemeTransition) },
        { },
    };

    static PyType_Spec type_spec_RepositionThemeTransition =
    {
        "_winrt_windows_ui_xaml_media_animation.RepositionThemeTransition",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::RepositionThemeTransition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RepositionThemeTransition
    };

    static PyGetSetDef getset_RepositionThemeTransition_Meta[] = {
        { "is_staggering_enabled_property", reinterpret_cast<getter>(RepositionThemeTransition_get_IsStaggeringEnabledProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_RepositionThemeTransition_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RepositionThemeTransition_Meta) },
        { }
    };

    static PyType_Spec type_spec_RepositionThemeTransition_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.RepositionThemeTransition_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RepositionThemeTransition_Meta
    };

    // ----- SineEase class --------------------
    static constexpr const char* const type_name_SineEase = "SineEase";

    static PyObject* _new_SineEase(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::SineEase instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SineEase(py::wrapper::Windows::UI::Xaml::Media::Animation::SineEase* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_SineEase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::SineEase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SineEase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::SineEase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SineEase[] = {
        { "_assign_array_", _assign_array_SineEase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SineEase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SineEase[] = {
        { }
    };

    static PyType_Slot _type_slots_SineEase[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SineEase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SineEase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SineEase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SineEase) },
        { },
    };

    static PyType_Spec type_spec_SineEase =
    {
        "_winrt_windows_ui_xaml_media_animation.SineEase",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::SineEase),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SineEase
    };

    // ----- SlideNavigationTransitionInfo class --------------------
    static constexpr const char* const type_name_SlideNavigationTransitionInfo = "SlideNavigationTransitionInfo";

    static PyObject* _new_SlideNavigationTransitionInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::SlideNavigationTransitionInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SlideNavigationTransitionInfo(py::wrapper::Windows::UI::Xaml::Media::Animation::SlideNavigationTransitionInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SlideNavigationTransitionInfo_get_Effect(py::wrapper::Windows::UI::Xaml::Media::Animation::SlideNavigationTransitionInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SlideNavigationTransitionInfo", L"Effect"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Effect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SlideNavigationTransitionInfo_put_Effect(py::wrapper::Windows::UI::Xaml::Media::Animation::SlideNavigationTransitionInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SlideNavigationTransitionInfo", L"Effect"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::SlideNavigationTransitionEffect>(arg);

            self->obj.Effect(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SlideNavigationTransitionInfo_get_EffectProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SlideNavigationTransitionInfo", L"EffectProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::SlideNavigationTransitionInfo::EffectProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SlideNavigationTransitionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::SlideNavigationTransitionInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SlideNavigationTransitionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::SlideNavigationTransitionInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SlideNavigationTransitionInfo[] = {
        { "_assign_array_", _assign_array_SlideNavigationTransitionInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SlideNavigationTransitionInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SlideNavigationTransitionInfo[] = {
        { "effect", reinterpret_cast<getter>(SlideNavigationTransitionInfo_get_Effect), reinterpret_cast<setter>(SlideNavigationTransitionInfo_put_Effect), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SlideNavigationTransitionInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SlideNavigationTransitionInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SlideNavigationTransitionInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SlideNavigationTransitionInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SlideNavigationTransitionInfo) },
        { },
    };

    static PyType_Spec type_spec_SlideNavigationTransitionInfo =
    {
        "_winrt_windows_ui_xaml_media_animation.SlideNavigationTransitionInfo",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::SlideNavigationTransitionInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SlideNavigationTransitionInfo
    };

    static PyGetSetDef getset_SlideNavigationTransitionInfo_Meta[] = {
        { "effect_property", reinterpret_cast<getter>(SlideNavigationTransitionInfo_get_EffectProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_SlideNavigationTransitionInfo_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SlideNavigationTransitionInfo_Meta) },
        { }
    };

    static PyType_Spec type_spec_SlideNavigationTransitionInfo_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.SlideNavigationTransitionInfo_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SlideNavigationTransitionInfo_Meta
    };

    // ----- SplineColorKeyFrame class --------------------
    static constexpr const char* const type_name_SplineColorKeyFrame = "SplineColorKeyFrame";

    static PyObject* _new_SplineColorKeyFrame(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::SplineColorKeyFrame instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SplineColorKeyFrame(py::wrapper::Windows::UI::Xaml::Media::Animation::SplineColorKeyFrame* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SplineColorKeyFrame_get_KeySpline(py::wrapper::Windows::UI::Xaml::Media::Animation::SplineColorKeyFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplineColorKeyFrame", L"KeySpline"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeySpline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SplineColorKeyFrame_put_KeySpline(py::wrapper::Windows::UI::Xaml::Media::Animation::SplineColorKeyFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplineColorKeyFrame", L"KeySpline"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::KeySpline>(arg);

            self->obj.KeySpline(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SplineColorKeyFrame_get_KeySplineProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplineColorKeyFrame", L"KeySplineProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::SplineColorKeyFrame::KeySplineProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SplineColorKeyFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::SplineColorKeyFrame>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SplineColorKeyFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::SplineColorKeyFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SplineColorKeyFrame[] = {
        { "_assign_array_", _assign_array_SplineColorKeyFrame, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SplineColorKeyFrame), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SplineColorKeyFrame[] = {
        { "key_spline", reinterpret_cast<getter>(SplineColorKeyFrame_get_KeySpline), reinterpret_cast<setter>(SplineColorKeyFrame_put_KeySpline), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SplineColorKeyFrame[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SplineColorKeyFrame) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SplineColorKeyFrame) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SplineColorKeyFrame) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SplineColorKeyFrame) },
        { },
    };

    static PyType_Spec type_spec_SplineColorKeyFrame =
    {
        "_winrt_windows_ui_xaml_media_animation.SplineColorKeyFrame",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::SplineColorKeyFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SplineColorKeyFrame
    };

    static PyGetSetDef getset_SplineColorKeyFrame_Meta[] = {
        { "key_spline_property", reinterpret_cast<getter>(SplineColorKeyFrame_get_KeySplineProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_SplineColorKeyFrame_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SplineColorKeyFrame_Meta) },
        { }
    };

    static PyType_Spec type_spec_SplineColorKeyFrame_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.SplineColorKeyFrame_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SplineColorKeyFrame_Meta
    };

    // ----- SplineDoubleKeyFrame class --------------------
    static constexpr const char* const type_name_SplineDoubleKeyFrame = "SplineDoubleKeyFrame";

    static PyObject* _new_SplineDoubleKeyFrame(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::SplineDoubleKeyFrame instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SplineDoubleKeyFrame(py::wrapper::Windows::UI::Xaml::Media::Animation::SplineDoubleKeyFrame* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SplineDoubleKeyFrame_get_KeySpline(py::wrapper::Windows::UI::Xaml::Media::Animation::SplineDoubleKeyFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplineDoubleKeyFrame", L"KeySpline"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeySpline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SplineDoubleKeyFrame_put_KeySpline(py::wrapper::Windows::UI::Xaml::Media::Animation::SplineDoubleKeyFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplineDoubleKeyFrame", L"KeySpline"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::KeySpline>(arg);

            self->obj.KeySpline(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SplineDoubleKeyFrame_get_KeySplineProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplineDoubleKeyFrame", L"KeySplineProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::SplineDoubleKeyFrame::KeySplineProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SplineDoubleKeyFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::SplineDoubleKeyFrame>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SplineDoubleKeyFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::SplineDoubleKeyFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SplineDoubleKeyFrame[] = {
        { "_assign_array_", _assign_array_SplineDoubleKeyFrame, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SplineDoubleKeyFrame), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SplineDoubleKeyFrame[] = {
        { "key_spline", reinterpret_cast<getter>(SplineDoubleKeyFrame_get_KeySpline), reinterpret_cast<setter>(SplineDoubleKeyFrame_put_KeySpline), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SplineDoubleKeyFrame[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SplineDoubleKeyFrame) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SplineDoubleKeyFrame) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SplineDoubleKeyFrame) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SplineDoubleKeyFrame) },
        { },
    };

    static PyType_Spec type_spec_SplineDoubleKeyFrame =
    {
        "_winrt_windows_ui_xaml_media_animation.SplineDoubleKeyFrame",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::SplineDoubleKeyFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SplineDoubleKeyFrame
    };

    static PyGetSetDef getset_SplineDoubleKeyFrame_Meta[] = {
        { "key_spline_property", reinterpret_cast<getter>(SplineDoubleKeyFrame_get_KeySplineProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_SplineDoubleKeyFrame_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SplineDoubleKeyFrame_Meta) },
        { }
    };

    static PyType_Spec type_spec_SplineDoubleKeyFrame_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.SplineDoubleKeyFrame_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SplineDoubleKeyFrame_Meta
    };

    // ----- SplinePointKeyFrame class --------------------
    static constexpr const char* const type_name_SplinePointKeyFrame = "SplinePointKeyFrame";

    static PyObject* _new_SplinePointKeyFrame(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::SplinePointKeyFrame instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SplinePointKeyFrame(py::wrapper::Windows::UI::Xaml::Media::Animation::SplinePointKeyFrame* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SplinePointKeyFrame_get_KeySpline(py::wrapper::Windows::UI::Xaml::Media::Animation::SplinePointKeyFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplinePointKeyFrame", L"KeySpline"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeySpline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SplinePointKeyFrame_put_KeySpline(py::wrapper::Windows::UI::Xaml::Media::Animation::SplinePointKeyFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplinePointKeyFrame", L"KeySpline"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::KeySpline>(arg);

            self->obj.KeySpline(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SplinePointKeyFrame_get_KeySplineProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplinePointKeyFrame", L"KeySplineProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::SplinePointKeyFrame::KeySplineProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SplinePointKeyFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::SplinePointKeyFrame>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SplinePointKeyFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::SplinePointKeyFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SplinePointKeyFrame[] = {
        { "_assign_array_", _assign_array_SplinePointKeyFrame, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SplinePointKeyFrame), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SplinePointKeyFrame[] = {
        { "key_spline", reinterpret_cast<getter>(SplinePointKeyFrame_get_KeySpline), reinterpret_cast<setter>(SplinePointKeyFrame_put_KeySpline), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SplinePointKeyFrame[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SplinePointKeyFrame) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SplinePointKeyFrame) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SplinePointKeyFrame) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SplinePointKeyFrame) },
        { },
    };

    static PyType_Spec type_spec_SplinePointKeyFrame =
    {
        "_winrt_windows_ui_xaml_media_animation.SplinePointKeyFrame",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::SplinePointKeyFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SplinePointKeyFrame
    };

    static PyGetSetDef getset_SplinePointKeyFrame_Meta[] = {
        { "key_spline_property", reinterpret_cast<getter>(SplinePointKeyFrame_get_KeySplineProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_SplinePointKeyFrame_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SplinePointKeyFrame_Meta) },
        { }
    };

    static PyType_Spec type_spec_SplinePointKeyFrame_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.SplinePointKeyFrame_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SplinePointKeyFrame_Meta
    };

    // ----- SplitCloseThemeAnimation class --------------------
    static constexpr const char* const type_name_SplitCloseThemeAnimation = "SplitCloseThemeAnimation";

    static PyObject* _new_SplitCloseThemeAnimation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::SplitCloseThemeAnimation instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SplitCloseThemeAnimation(py::wrapper::Windows::UI::Xaml::Media::Animation::SplitCloseThemeAnimation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SplitCloseThemeAnimation_get_OpenedTargetName(py::wrapper::Windows::UI::Xaml::Media::Animation::SplitCloseThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitCloseThemeAnimation", L"OpenedTargetName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OpenedTargetName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SplitCloseThemeAnimation_put_OpenedTargetName(py::wrapper::Windows::UI::Xaml::Media::Animation::SplitCloseThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitCloseThemeAnimation", L"OpenedTargetName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.OpenedTargetName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SplitCloseThemeAnimation_get_OpenedTarget(py::wrapper::Windows::UI::Xaml::Media::Animation::SplitCloseThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitCloseThemeAnimation", L"OpenedTarget"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OpenedTarget());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SplitCloseThemeAnimation_put_OpenedTarget(py::wrapper::Windows::UI::Xaml::Media::Animation::SplitCloseThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitCloseThemeAnimation", L"OpenedTarget"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(arg);

            self->obj.OpenedTarget(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SplitCloseThemeAnimation_get_OpenedLength(py::wrapper::Windows::UI::Xaml::Media::Animation::SplitCloseThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitCloseThemeAnimation", L"OpenedLength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OpenedLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SplitCloseThemeAnimation_put_OpenedLength(py::wrapper::Windows::UI::Xaml::Media::Animation::SplitCloseThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitCloseThemeAnimation", L"OpenedLength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OpenedLength(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SplitCloseThemeAnimation_get_OffsetFromCenter(py::wrapper::Windows::UI::Xaml::Media::Animation::SplitCloseThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitCloseThemeAnimation", L"OffsetFromCenter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OffsetFromCenter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SplitCloseThemeAnimation_put_OffsetFromCenter(py::wrapper::Windows::UI::Xaml::Media::Animation::SplitCloseThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitCloseThemeAnimation", L"OffsetFromCenter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OffsetFromCenter(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SplitCloseThemeAnimation_get_ContentTranslationOffset(py::wrapper::Windows::UI::Xaml::Media::Animation::SplitCloseThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitCloseThemeAnimation", L"ContentTranslationOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContentTranslationOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SplitCloseThemeAnimation_put_ContentTranslationOffset(py::wrapper::Windows::UI::Xaml::Media::Animation::SplitCloseThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitCloseThemeAnimation", L"ContentTranslationOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.ContentTranslationOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SplitCloseThemeAnimation_get_ContentTranslationDirection(py::wrapper::Windows::UI::Xaml::Media::Animation::SplitCloseThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitCloseThemeAnimation", L"ContentTranslationDirection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContentTranslationDirection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SplitCloseThemeAnimation_put_ContentTranslationDirection(py::wrapper::Windows::UI::Xaml::Media::Animation::SplitCloseThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitCloseThemeAnimation", L"ContentTranslationDirection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::AnimationDirection>(arg);

            self->obj.ContentTranslationDirection(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SplitCloseThemeAnimation_get_ContentTargetName(py::wrapper::Windows::UI::Xaml::Media::Animation::SplitCloseThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitCloseThemeAnimation", L"ContentTargetName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContentTargetName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SplitCloseThemeAnimation_put_ContentTargetName(py::wrapper::Windows::UI::Xaml::Media::Animation::SplitCloseThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitCloseThemeAnimation", L"ContentTargetName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContentTargetName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SplitCloseThemeAnimation_get_ContentTarget(py::wrapper::Windows::UI::Xaml::Media::Animation::SplitCloseThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitCloseThemeAnimation", L"ContentTarget"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContentTarget());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SplitCloseThemeAnimation_put_ContentTarget(py::wrapper::Windows::UI::Xaml::Media::Animation::SplitCloseThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitCloseThemeAnimation", L"ContentTarget"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(arg);

            self->obj.ContentTarget(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SplitCloseThemeAnimation_get_ClosedTargetName(py::wrapper::Windows::UI::Xaml::Media::Animation::SplitCloseThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitCloseThemeAnimation", L"ClosedTargetName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ClosedTargetName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SplitCloseThemeAnimation_put_ClosedTargetName(py::wrapper::Windows::UI::Xaml::Media::Animation::SplitCloseThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitCloseThemeAnimation", L"ClosedTargetName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ClosedTargetName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SplitCloseThemeAnimation_get_ClosedTarget(py::wrapper::Windows::UI::Xaml::Media::Animation::SplitCloseThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitCloseThemeAnimation", L"ClosedTarget"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ClosedTarget());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SplitCloseThemeAnimation_put_ClosedTarget(py::wrapper::Windows::UI::Xaml::Media::Animation::SplitCloseThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitCloseThemeAnimation", L"ClosedTarget"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(arg);

            self->obj.ClosedTarget(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SplitCloseThemeAnimation_get_ClosedLength(py::wrapper::Windows::UI::Xaml::Media::Animation::SplitCloseThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitCloseThemeAnimation", L"ClosedLength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ClosedLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SplitCloseThemeAnimation_put_ClosedLength(py::wrapper::Windows::UI::Xaml::Media::Animation::SplitCloseThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitCloseThemeAnimation", L"ClosedLength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.ClosedLength(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SplitCloseThemeAnimation_get_ClosedLengthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitCloseThemeAnimation", L"ClosedLengthProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::SplitCloseThemeAnimation::ClosedLengthProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SplitCloseThemeAnimation_get_ClosedTargetNameProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitCloseThemeAnimation", L"ClosedTargetNameProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::SplitCloseThemeAnimation::ClosedTargetNameProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SplitCloseThemeAnimation_get_ClosedTargetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitCloseThemeAnimation", L"ClosedTargetProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::SplitCloseThemeAnimation::ClosedTargetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SplitCloseThemeAnimation_get_ContentTargetNameProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitCloseThemeAnimation", L"ContentTargetNameProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::SplitCloseThemeAnimation::ContentTargetNameProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SplitCloseThemeAnimation_get_ContentTargetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitCloseThemeAnimation", L"ContentTargetProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::SplitCloseThemeAnimation::ContentTargetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SplitCloseThemeAnimation_get_ContentTranslationDirectionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitCloseThemeAnimation", L"ContentTranslationDirectionProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::SplitCloseThemeAnimation::ContentTranslationDirectionProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SplitCloseThemeAnimation_get_ContentTranslationOffsetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitCloseThemeAnimation", L"ContentTranslationOffsetProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::SplitCloseThemeAnimation::ContentTranslationOffsetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SplitCloseThemeAnimation_get_OffsetFromCenterProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitCloseThemeAnimation", L"OffsetFromCenterProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::SplitCloseThemeAnimation::OffsetFromCenterProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SplitCloseThemeAnimation_get_OpenedLengthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitCloseThemeAnimation", L"OpenedLengthProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::SplitCloseThemeAnimation::OpenedLengthProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SplitCloseThemeAnimation_get_OpenedTargetNameProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitCloseThemeAnimation", L"OpenedTargetNameProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::SplitCloseThemeAnimation::OpenedTargetNameProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SplitCloseThemeAnimation_get_OpenedTargetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitCloseThemeAnimation", L"OpenedTargetProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::SplitCloseThemeAnimation::OpenedTargetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SplitCloseThemeAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::SplitCloseThemeAnimation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SplitCloseThemeAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::SplitCloseThemeAnimation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SplitCloseThemeAnimation[] = {
        { "_assign_array_", _assign_array_SplitCloseThemeAnimation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SplitCloseThemeAnimation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SplitCloseThemeAnimation[] = {
        { "opened_target_name", reinterpret_cast<getter>(SplitCloseThemeAnimation_get_OpenedTargetName), reinterpret_cast<setter>(SplitCloseThemeAnimation_put_OpenedTargetName), nullptr, nullptr },
        { "opened_target", reinterpret_cast<getter>(SplitCloseThemeAnimation_get_OpenedTarget), reinterpret_cast<setter>(SplitCloseThemeAnimation_put_OpenedTarget), nullptr, nullptr },
        { "opened_length", reinterpret_cast<getter>(SplitCloseThemeAnimation_get_OpenedLength), reinterpret_cast<setter>(SplitCloseThemeAnimation_put_OpenedLength), nullptr, nullptr },
        { "offset_from_center", reinterpret_cast<getter>(SplitCloseThemeAnimation_get_OffsetFromCenter), reinterpret_cast<setter>(SplitCloseThemeAnimation_put_OffsetFromCenter), nullptr, nullptr },
        { "content_translation_offset", reinterpret_cast<getter>(SplitCloseThemeAnimation_get_ContentTranslationOffset), reinterpret_cast<setter>(SplitCloseThemeAnimation_put_ContentTranslationOffset), nullptr, nullptr },
        { "content_translation_direction", reinterpret_cast<getter>(SplitCloseThemeAnimation_get_ContentTranslationDirection), reinterpret_cast<setter>(SplitCloseThemeAnimation_put_ContentTranslationDirection), nullptr, nullptr },
        { "content_target_name", reinterpret_cast<getter>(SplitCloseThemeAnimation_get_ContentTargetName), reinterpret_cast<setter>(SplitCloseThemeAnimation_put_ContentTargetName), nullptr, nullptr },
        { "content_target", reinterpret_cast<getter>(SplitCloseThemeAnimation_get_ContentTarget), reinterpret_cast<setter>(SplitCloseThemeAnimation_put_ContentTarget), nullptr, nullptr },
        { "closed_target_name", reinterpret_cast<getter>(SplitCloseThemeAnimation_get_ClosedTargetName), reinterpret_cast<setter>(SplitCloseThemeAnimation_put_ClosedTargetName), nullptr, nullptr },
        { "closed_target", reinterpret_cast<getter>(SplitCloseThemeAnimation_get_ClosedTarget), reinterpret_cast<setter>(SplitCloseThemeAnimation_put_ClosedTarget), nullptr, nullptr },
        { "closed_length", reinterpret_cast<getter>(SplitCloseThemeAnimation_get_ClosedLength), reinterpret_cast<setter>(SplitCloseThemeAnimation_put_ClosedLength), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SplitCloseThemeAnimation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SplitCloseThemeAnimation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SplitCloseThemeAnimation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SplitCloseThemeAnimation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SplitCloseThemeAnimation) },
        { },
    };

    static PyType_Spec type_spec_SplitCloseThemeAnimation =
    {
        "_winrt_windows_ui_xaml_media_animation.SplitCloseThemeAnimation",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::SplitCloseThemeAnimation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SplitCloseThemeAnimation
    };

    static PyGetSetDef getset_SplitCloseThemeAnimation_Meta[] = {
        { "closed_length_property", reinterpret_cast<getter>(SplitCloseThemeAnimation_get_ClosedLengthProperty), nullptr, nullptr, nullptr },
        { "closed_target_name_property", reinterpret_cast<getter>(SplitCloseThemeAnimation_get_ClosedTargetNameProperty), nullptr, nullptr, nullptr },
        { "closed_target_property", reinterpret_cast<getter>(SplitCloseThemeAnimation_get_ClosedTargetProperty), nullptr, nullptr, nullptr },
        { "content_target_name_property", reinterpret_cast<getter>(SplitCloseThemeAnimation_get_ContentTargetNameProperty), nullptr, nullptr, nullptr },
        { "content_target_property", reinterpret_cast<getter>(SplitCloseThemeAnimation_get_ContentTargetProperty), nullptr, nullptr, nullptr },
        { "content_translation_direction_property", reinterpret_cast<getter>(SplitCloseThemeAnimation_get_ContentTranslationDirectionProperty), nullptr, nullptr, nullptr },
        { "content_translation_offset_property", reinterpret_cast<getter>(SplitCloseThemeAnimation_get_ContentTranslationOffsetProperty), nullptr, nullptr, nullptr },
        { "offset_from_center_property", reinterpret_cast<getter>(SplitCloseThemeAnimation_get_OffsetFromCenterProperty), nullptr, nullptr, nullptr },
        { "opened_length_property", reinterpret_cast<getter>(SplitCloseThemeAnimation_get_OpenedLengthProperty), nullptr, nullptr, nullptr },
        { "opened_target_name_property", reinterpret_cast<getter>(SplitCloseThemeAnimation_get_OpenedTargetNameProperty), nullptr, nullptr, nullptr },
        { "opened_target_property", reinterpret_cast<getter>(SplitCloseThemeAnimation_get_OpenedTargetProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_SplitCloseThemeAnimation_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SplitCloseThemeAnimation_Meta) },
        { }
    };

    static PyType_Spec type_spec_SplitCloseThemeAnimation_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.SplitCloseThemeAnimation_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SplitCloseThemeAnimation_Meta
    };

    // ----- SplitOpenThemeAnimation class --------------------
    static constexpr const char* const type_name_SplitOpenThemeAnimation = "SplitOpenThemeAnimation";

    static PyObject* _new_SplitOpenThemeAnimation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::SplitOpenThemeAnimation instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SplitOpenThemeAnimation(py::wrapper::Windows::UI::Xaml::Media::Animation::SplitOpenThemeAnimation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SplitOpenThemeAnimation_get_OpenedTargetName(py::wrapper::Windows::UI::Xaml::Media::Animation::SplitOpenThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitOpenThemeAnimation", L"OpenedTargetName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OpenedTargetName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SplitOpenThemeAnimation_put_OpenedTargetName(py::wrapper::Windows::UI::Xaml::Media::Animation::SplitOpenThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitOpenThemeAnimation", L"OpenedTargetName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.OpenedTargetName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SplitOpenThemeAnimation_get_OpenedTarget(py::wrapper::Windows::UI::Xaml::Media::Animation::SplitOpenThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitOpenThemeAnimation", L"OpenedTarget"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OpenedTarget());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SplitOpenThemeAnimation_put_OpenedTarget(py::wrapper::Windows::UI::Xaml::Media::Animation::SplitOpenThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitOpenThemeAnimation", L"OpenedTarget"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(arg);

            self->obj.OpenedTarget(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SplitOpenThemeAnimation_get_OpenedLength(py::wrapper::Windows::UI::Xaml::Media::Animation::SplitOpenThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitOpenThemeAnimation", L"OpenedLength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OpenedLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SplitOpenThemeAnimation_put_OpenedLength(py::wrapper::Windows::UI::Xaml::Media::Animation::SplitOpenThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitOpenThemeAnimation", L"OpenedLength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OpenedLength(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SplitOpenThemeAnimation_get_OffsetFromCenter(py::wrapper::Windows::UI::Xaml::Media::Animation::SplitOpenThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitOpenThemeAnimation", L"OffsetFromCenter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OffsetFromCenter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SplitOpenThemeAnimation_put_OffsetFromCenter(py::wrapper::Windows::UI::Xaml::Media::Animation::SplitOpenThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitOpenThemeAnimation", L"OffsetFromCenter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OffsetFromCenter(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SplitOpenThemeAnimation_get_ContentTranslationOffset(py::wrapper::Windows::UI::Xaml::Media::Animation::SplitOpenThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitOpenThemeAnimation", L"ContentTranslationOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContentTranslationOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SplitOpenThemeAnimation_put_ContentTranslationOffset(py::wrapper::Windows::UI::Xaml::Media::Animation::SplitOpenThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitOpenThemeAnimation", L"ContentTranslationOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.ContentTranslationOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SplitOpenThemeAnimation_get_ContentTranslationDirection(py::wrapper::Windows::UI::Xaml::Media::Animation::SplitOpenThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitOpenThemeAnimation", L"ContentTranslationDirection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContentTranslationDirection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SplitOpenThemeAnimation_put_ContentTranslationDirection(py::wrapper::Windows::UI::Xaml::Media::Animation::SplitOpenThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitOpenThemeAnimation", L"ContentTranslationDirection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::AnimationDirection>(arg);

            self->obj.ContentTranslationDirection(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SplitOpenThemeAnimation_get_ContentTargetName(py::wrapper::Windows::UI::Xaml::Media::Animation::SplitOpenThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitOpenThemeAnimation", L"ContentTargetName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContentTargetName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SplitOpenThemeAnimation_put_ContentTargetName(py::wrapper::Windows::UI::Xaml::Media::Animation::SplitOpenThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitOpenThemeAnimation", L"ContentTargetName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContentTargetName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SplitOpenThemeAnimation_get_ContentTarget(py::wrapper::Windows::UI::Xaml::Media::Animation::SplitOpenThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitOpenThemeAnimation", L"ContentTarget"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContentTarget());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SplitOpenThemeAnimation_put_ContentTarget(py::wrapper::Windows::UI::Xaml::Media::Animation::SplitOpenThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitOpenThemeAnimation", L"ContentTarget"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(arg);

            self->obj.ContentTarget(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SplitOpenThemeAnimation_get_ClosedTargetName(py::wrapper::Windows::UI::Xaml::Media::Animation::SplitOpenThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitOpenThemeAnimation", L"ClosedTargetName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ClosedTargetName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SplitOpenThemeAnimation_put_ClosedTargetName(py::wrapper::Windows::UI::Xaml::Media::Animation::SplitOpenThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitOpenThemeAnimation", L"ClosedTargetName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ClosedTargetName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SplitOpenThemeAnimation_get_ClosedTarget(py::wrapper::Windows::UI::Xaml::Media::Animation::SplitOpenThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitOpenThemeAnimation", L"ClosedTarget"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ClosedTarget());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SplitOpenThemeAnimation_put_ClosedTarget(py::wrapper::Windows::UI::Xaml::Media::Animation::SplitOpenThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitOpenThemeAnimation", L"ClosedTarget"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(arg);

            self->obj.ClosedTarget(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SplitOpenThemeAnimation_get_ClosedLength(py::wrapper::Windows::UI::Xaml::Media::Animation::SplitOpenThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitOpenThemeAnimation", L"ClosedLength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ClosedLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SplitOpenThemeAnimation_put_ClosedLength(py::wrapper::Windows::UI::Xaml::Media::Animation::SplitOpenThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitOpenThemeAnimation", L"ClosedLength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.ClosedLength(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SplitOpenThemeAnimation_get_ClosedLengthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitOpenThemeAnimation", L"ClosedLengthProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::SplitOpenThemeAnimation::ClosedLengthProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SplitOpenThemeAnimation_get_ClosedTargetNameProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitOpenThemeAnimation", L"ClosedTargetNameProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::SplitOpenThemeAnimation::ClosedTargetNameProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SplitOpenThemeAnimation_get_ClosedTargetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitOpenThemeAnimation", L"ClosedTargetProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::SplitOpenThemeAnimation::ClosedTargetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SplitOpenThemeAnimation_get_ContentTargetNameProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitOpenThemeAnimation", L"ContentTargetNameProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::SplitOpenThemeAnimation::ContentTargetNameProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SplitOpenThemeAnimation_get_ContentTargetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitOpenThemeAnimation", L"ContentTargetProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::SplitOpenThemeAnimation::ContentTargetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SplitOpenThemeAnimation_get_ContentTranslationDirectionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitOpenThemeAnimation", L"ContentTranslationDirectionProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::SplitOpenThemeAnimation::ContentTranslationDirectionProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SplitOpenThemeAnimation_get_ContentTranslationOffsetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitOpenThemeAnimation", L"ContentTranslationOffsetProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::SplitOpenThemeAnimation::ContentTranslationOffsetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SplitOpenThemeAnimation_get_OffsetFromCenterProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitOpenThemeAnimation", L"OffsetFromCenterProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::SplitOpenThemeAnimation::OffsetFromCenterProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SplitOpenThemeAnimation_get_OpenedLengthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitOpenThemeAnimation", L"OpenedLengthProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::SplitOpenThemeAnimation::OpenedLengthProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SplitOpenThemeAnimation_get_OpenedTargetNameProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitOpenThemeAnimation", L"OpenedTargetNameProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::SplitOpenThemeAnimation::OpenedTargetNameProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SplitOpenThemeAnimation_get_OpenedTargetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SplitOpenThemeAnimation", L"OpenedTargetProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::SplitOpenThemeAnimation::OpenedTargetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SplitOpenThemeAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::SplitOpenThemeAnimation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SplitOpenThemeAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::SplitOpenThemeAnimation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SplitOpenThemeAnimation[] = {
        { "_assign_array_", _assign_array_SplitOpenThemeAnimation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SplitOpenThemeAnimation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SplitOpenThemeAnimation[] = {
        { "opened_target_name", reinterpret_cast<getter>(SplitOpenThemeAnimation_get_OpenedTargetName), reinterpret_cast<setter>(SplitOpenThemeAnimation_put_OpenedTargetName), nullptr, nullptr },
        { "opened_target", reinterpret_cast<getter>(SplitOpenThemeAnimation_get_OpenedTarget), reinterpret_cast<setter>(SplitOpenThemeAnimation_put_OpenedTarget), nullptr, nullptr },
        { "opened_length", reinterpret_cast<getter>(SplitOpenThemeAnimation_get_OpenedLength), reinterpret_cast<setter>(SplitOpenThemeAnimation_put_OpenedLength), nullptr, nullptr },
        { "offset_from_center", reinterpret_cast<getter>(SplitOpenThemeAnimation_get_OffsetFromCenter), reinterpret_cast<setter>(SplitOpenThemeAnimation_put_OffsetFromCenter), nullptr, nullptr },
        { "content_translation_offset", reinterpret_cast<getter>(SplitOpenThemeAnimation_get_ContentTranslationOffset), reinterpret_cast<setter>(SplitOpenThemeAnimation_put_ContentTranslationOffset), nullptr, nullptr },
        { "content_translation_direction", reinterpret_cast<getter>(SplitOpenThemeAnimation_get_ContentTranslationDirection), reinterpret_cast<setter>(SplitOpenThemeAnimation_put_ContentTranslationDirection), nullptr, nullptr },
        { "content_target_name", reinterpret_cast<getter>(SplitOpenThemeAnimation_get_ContentTargetName), reinterpret_cast<setter>(SplitOpenThemeAnimation_put_ContentTargetName), nullptr, nullptr },
        { "content_target", reinterpret_cast<getter>(SplitOpenThemeAnimation_get_ContentTarget), reinterpret_cast<setter>(SplitOpenThemeAnimation_put_ContentTarget), nullptr, nullptr },
        { "closed_target_name", reinterpret_cast<getter>(SplitOpenThemeAnimation_get_ClosedTargetName), reinterpret_cast<setter>(SplitOpenThemeAnimation_put_ClosedTargetName), nullptr, nullptr },
        { "closed_target", reinterpret_cast<getter>(SplitOpenThemeAnimation_get_ClosedTarget), reinterpret_cast<setter>(SplitOpenThemeAnimation_put_ClosedTarget), nullptr, nullptr },
        { "closed_length", reinterpret_cast<getter>(SplitOpenThemeAnimation_get_ClosedLength), reinterpret_cast<setter>(SplitOpenThemeAnimation_put_ClosedLength), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SplitOpenThemeAnimation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SplitOpenThemeAnimation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SplitOpenThemeAnimation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SplitOpenThemeAnimation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SplitOpenThemeAnimation) },
        { },
    };

    static PyType_Spec type_spec_SplitOpenThemeAnimation =
    {
        "_winrt_windows_ui_xaml_media_animation.SplitOpenThemeAnimation",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::SplitOpenThemeAnimation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SplitOpenThemeAnimation
    };

    static PyGetSetDef getset_SplitOpenThemeAnimation_Meta[] = {
        { "closed_length_property", reinterpret_cast<getter>(SplitOpenThemeAnimation_get_ClosedLengthProperty), nullptr, nullptr, nullptr },
        { "closed_target_name_property", reinterpret_cast<getter>(SplitOpenThemeAnimation_get_ClosedTargetNameProperty), nullptr, nullptr, nullptr },
        { "closed_target_property", reinterpret_cast<getter>(SplitOpenThemeAnimation_get_ClosedTargetProperty), nullptr, nullptr, nullptr },
        { "content_target_name_property", reinterpret_cast<getter>(SplitOpenThemeAnimation_get_ContentTargetNameProperty), nullptr, nullptr, nullptr },
        { "content_target_property", reinterpret_cast<getter>(SplitOpenThemeAnimation_get_ContentTargetProperty), nullptr, nullptr, nullptr },
        { "content_translation_direction_property", reinterpret_cast<getter>(SplitOpenThemeAnimation_get_ContentTranslationDirectionProperty), nullptr, nullptr, nullptr },
        { "content_translation_offset_property", reinterpret_cast<getter>(SplitOpenThemeAnimation_get_ContentTranslationOffsetProperty), nullptr, nullptr, nullptr },
        { "offset_from_center_property", reinterpret_cast<getter>(SplitOpenThemeAnimation_get_OffsetFromCenterProperty), nullptr, nullptr, nullptr },
        { "opened_length_property", reinterpret_cast<getter>(SplitOpenThemeAnimation_get_OpenedLengthProperty), nullptr, nullptr, nullptr },
        { "opened_target_name_property", reinterpret_cast<getter>(SplitOpenThemeAnimation_get_OpenedTargetNameProperty), nullptr, nullptr, nullptr },
        { "opened_target_property", reinterpret_cast<getter>(SplitOpenThemeAnimation_get_OpenedTargetProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_SplitOpenThemeAnimation_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SplitOpenThemeAnimation_Meta) },
        { }
    };

    static PyType_Spec type_spec_SplitOpenThemeAnimation_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.SplitOpenThemeAnimation_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SplitOpenThemeAnimation_Meta
    };

    // ----- Storyboard class --------------------
    static constexpr const char* const type_name_Storyboard = "Storyboard";

    static PyObject* _new_Storyboard(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::Storyboard instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Storyboard(py::wrapper::Windows::UI::Xaml::Media::Animation::Storyboard* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Storyboard_Begin(py::wrapper::Windows::UI::Xaml::Media::Animation::Storyboard* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.Storyboard", L"Begin", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Begin();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Storyboard_GetCurrentState(py::wrapper::Windows::UI::Xaml::Media::Animation::Storyboard* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.Storyboard", L"GetCurrentState", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetCurrentState());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Storyboard_GetCurrentTime(py::wrapper::Windows::UI::Xaml::Media::Animation::Storyboard* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.Storyboard", L"GetCurrentTime", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetCurrentTime());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Storyboard_GetTargetName(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.Storyboard", L"GetTargetName", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::Timeline>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Media::Animation::Storyboard::GetTargetName(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Storyboard_GetTargetProperty(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.Storyboard", L"GetTargetProperty", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::Timeline>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Media::Animation::Storyboard::GetTargetProperty(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Storyboard_Pause(py::wrapper::Windows::UI::Xaml::Media::Animation::Storyboard* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.Storyboard", L"Pause", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Pause();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Storyboard_Resume(py::wrapper::Windows::UI::Xaml::Media::Animation::Storyboard* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.Storyboard", L"Resume", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Resume();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Storyboard_Seek(py::wrapper::Windows::UI::Xaml::Media::Animation::Storyboard* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.Storyboard", L"Seek", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                self->obj.Seek(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Storyboard_SeekAlignedToLastTick(py::wrapper::Windows::UI::Xaml::Media::Animation::Storyboard* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.Storyboard", L"SeekAlignedToLastTick", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                self->obj.SeekAlignedToLastTick(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Storyboard_SetTarget(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.Storyboard", L"SetTarget", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::Timeline>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(args, 1);

                winrt::Windows::UI::Xaml::Media::Animation::Storyboard::SetTarget(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Storyboard_SetTargetName(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.Storyboard", L"SetTargetName", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::Timeline>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::UI::Xaml::Media::Animation::Storyboard::SetTargetName(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Storyboard_SetTargetProperty(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.Storyboard", L"SetTargetProperty", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::Timeline>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::UI::Xaml::Media::Animation::Storyboard::SetTargetProperty(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Storyboard_SkipToFill(py::wrapper::Windows::UI::Xaml::Media::Animation::Storyboard* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.Storyboard", L"SkipToFill", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.SkipToFill();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Storyboard_Stop(py::wrapper::Windows::UI::Xaml::Media::Animation::Storyboard* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.Storyboard", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Storyboard_get_Children(py::wrapper::Windows::UI::Xaml::Media::Animation::Storyboard* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.Storyboard", L"Children"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Children());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Storyboard_get_TargetNameProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.Storyboard", L"TargetNameProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::Storyboard::TargetNameProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Storyboard_get_TargetPropertyProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.Storyboard", L"TargetPropertyProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::Storyboard::TargetPropertyProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Storyboard(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::Storyboard>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Storyboard(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::Storyboard>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Storyboard[] = {
        { "begin", reinterpret_cast<PyCFunction>(Storyboard_Begin), METH_VARARGS, nullptr },
        { "get_current_state", reinterpret_cast<PyCFunction>(Storyboard_GetCurrentState), METH_VARARGS, nullptr },
        { "get_current_time", reinterpret_cast<PyCFunction>(Storyboard_GetCurrentTime), METH_VARARGS, nullptr },
        { "get_target_name", reinterpret_cast<PyCFunction>(Storyboard_GetTargetName), METH_VARARGS | METH_STATIC, nullptr },
        { "get_target_property", reinterpret_cast<PyCFunction>(Storyboard_GetTargetProperty), METH_VARARGS | METH_STATIC, nullptr },
        { "pause", reinterpret_cast<PyCFunction>(Storyboard_Pause), METH_VARARGS, nullptr },
        { "resume", reinterpret_cast<PyCFunction>(Storyboard_Resume), METH_VARARGS, nullptr },
        { "seek", reinterpret_cast<PyCFunction>(Storyboard_Seek), METH_VARARGS, nullptr },
        { "seek_aligned_to_last_tick", reinterpret_cast<PyCFunction>(Storyboard_SeekAlignedToLastTick), METH_VARARGS, nullptr },
        { "set_target", reinterpret_cast<PyCFunction>(Storyboard_SetTarget), METH_VARARGS | METH_STATIC, nullptr },
        { "set_target_name", reinterpret_cast<PyCFunction>(Storyboard_SetTargetName), METH_VARARGS | METH_STATIC, nullptr },
        { "set_target_property", reinterpret_cast<PyCFunction>(Storyboard_SetTargetProperty), METH_VARARGS | METH_STATIC, nullptr },
        { "skip_to_fill", reinterpret_cast<PyCFunction>(Storyboard_SkipToFill), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(Storyboard_Stop), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_Storyboard, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Storyboard), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Storyboard[] = {
        { "children", reinterpret_cast<getter>(Storyboard_get_Children), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Storyboard[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Storyboard) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Storyboard) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Storyboard) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Storyboard) },
        { },
    };

    static PyType_Spec type_spec_Storyboard =
    {
        "_winrt_windows_ui_xaml_media_animation.Storyboard",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::Storyboard),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Storyboard
    };

    static PyGetSetDef getset_Storyboard_Meta[] = {
        { "target_name_property", reinterpret_cast<getter>(Storyboard_get_TargetNameProperty), nullptr, nullptr, nullptr },
        { "target_property_property", reinterpret_cast<getter>(Storyboard_get_TargetPropertyProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_Storyboard_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Storyboard_Meta) },
        { }
    };

    static PyType_Spec type_spec_Storyboard_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.Storyboard_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Storyboard_Meta
    };

    // ----- SuppressNavigationTransitionInfo class --------------------
    static constexpr const char* const type_name_SuppressNavigationTransitionInfo = "SuppressNavigationTransitionInfo";

    static PyObject* _new_SuppressNavigationTransitionInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::SuppressNavigationTransitionInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SuppressNavigationTransitionInfo(py::wrapper::Windows::UI::Xaml::Media::Animation::SuppressNavigationTransitionInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_SuppressNavigationTransitionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::SuppressNavigationTransitionInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SuppressNavigationTransitionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::SuppressNavigationTransitionInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SuppressNavigationTransitionInfo[] = {
        { "_assign_array_", _assign_array_SuppressNavigationTransitionInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SuppressNavigationTransitionInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SuppressNavigationTransitionInfo[] = {
        { }
    };

    static PyType_Slot _type_slots_SuppressNavigationTransitionInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SuppressNavigationTransitionInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SuppressNavigationTransitionInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SuppressNavigationTransitionInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SuppressNavigationTransitionInfo) },
        { },
    };

    static PyType_Spec type_spec_SuppressNavigationTransitionInfo =
    {
        "_winrt_windows_ui_xaml_media_animation.SuppressNavigationTransitionInfo",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::SuppressNavigationTransitionInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SuppressNavigationTransitionInfo
    };

    // ----- SwipeBackThemeAnimation class --------------------
    static constexpr const char* const type_name_SwipeBackThemeAnimation = "SwipeBackThemeAnimation";

    static PyObject* _new_SwipeBackThemeAnimation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::SwipeBackThemeAnimation instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SwipeBackThemeAnimation(py::wrapper::Windows::UI::Xaml::Media::Animation::SwipeBackThemeAnimation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SwipeBackThemeAnimation_get_TargetName(py::wrapper::Windows::UI::Xaml::Media::Animation::SwipeBackThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SwipeBackThemeAnimation", L"TargetName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TargetName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SwipeBackThemeAnimation_put_TargetName(py::wrapper::Windows::UI::Xaml::Media::Animation::SwipeBackThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SwipeBackThemeAnimation", L"TargetName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.TargetName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SwipeBackThemeAnimation_get_FromVerticalOffset(py::wrapper::Windows::UI::Xaml::Media::Animation::SwipeBackThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SwipeBackThemeAnimation", L"FromVerticalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FromVerticalOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SwipeBackThemeAnimation_put_FromVerticalOffset(py::wrapper::Windows::UI::Xaml::Media::Animation::SwipeBackThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SwipeBackThemeAnimation", L"FromVerticalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.FromVerticalOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SwipeBackThemeAnimation_get_FromHorizontalOffset(py::wrapper::Windows::UI::Xaml::Media::Animation::SwipeBackThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SwipeBackThemeAnimation", L"FromHorizontalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FromHorizontalOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SwipeBackThemeAnimation_put_FromHorizontalOffset(py::wrapper::Windows::UI::Xaml::Media::Animation::SwipeBackThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SwipeBackThemeAnimation", L"FromHorizontalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.FromHorizontalOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SwipeBackThemeAnimation_get_FromHorizontalOffsetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SwipeBackThemeAnimation", L"FromHorizontalOffsetProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::SwipeBackThemeAnimation::FromHorizontalOffsetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SwipeBackThemeAnimation_get_FromVerticalOffsetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SwipeBackThemeAnimation", L"FromVerticalOffsetProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::SwipeBackThemeAnimation::FromVerticalOffsetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SwipeBackThemeAnimation_get_TargetNameProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SwipeBackThemeAnimation", L"TargetNameProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::SwipeBackThemeAnimation::TargetNameProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SwipeBackThemeAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::SwipeBackThemeAnimation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SwipeBackThemeAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::SwipeBackThemeAnimation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SwipeBackThemeAnimation[] = {
        { "_assign_array_", _assign_array_SwipeBackThemeAnimation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SwipeBackThemeAnimation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SwipeBackThemeAnimation[] = {
        { "target_name", reinterpret_cast<getter>(SwipeBackThemeAnimation_get_TargetName), reinterpret_cast<setter>(SwipeBackThemeAnimation_put_TargetName), nullptr, nullptr },
        { "from_vertical_offset", reinterpret_cast<getter>(SwipeBackThemeAnimation_get_FromVerticalOffset), reinterpret_cast<setter>(SwipeBackThemeAnimation_put_FromVerticalOffset), nullptr, nullptr },
        { "from_horizontal_offset", reinterpret_cast<getter>(SwipeBackThemeAnimation_get_FromHorizontalOffset), reinterpret_cast<setter>(SwipeBackThemeAnimation_put_FromHorizontalOffset), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SwipeBackThemeAnimation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SwipeBackThemeAnimation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SwipeBackThemeAnimation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SwipeBackThemeAnimation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SwipeBackThemeAnimation) },
        { },
    };

    static PyType_Spec type_spec_SwipeBackThemeAnimation =
    {
        "_winrt_windows_ui_xaml_media_animation.SwipeBackThemeAnimation",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::SwipeBackThemeAnimation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SwipeBackThemeAnimation
    };

    static PyGetSetDef getset_SwipeBackThemeAnimation_Meta[] = {
        { "from_horizontal_offset_property", reinterpret_cast<getter>(SwipeBackThemeAnimation_get_FromHorizontalOffsetProperty), nullptr, nullptr, nullptr },
        { "from_vertical_offset_property", reinterpret_cast<getter>(SwipeBackThemeAnimation_get_FromVerticalOffsetProperty), nullptr, nullptr, nullptr },
        { "target_name_property", reinterpret_cast<getter>(SwipeBackThemeAnimation_get_TargetNameProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_SwipeBackThemeAnimation_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SwipeBackThemeAnimation_Meta) },
        { }
    };

    static PyType_Spec type_spec_SwipeBackThemeAnimation_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.SwipeBackThemeAnimation_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SwipeBackThemeAnimation_Meta
    };

    // ----- SwipeHintThemeAnimation class --------------------
    static constexpr const char* const type_name_SwipeHintThemeAnimation = "SwipeHintThemeAnimation";

    static PyObject* _new_SwipeHintThemeAnimation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::SwipeHintThemeAnimation instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SwipeHintThemeAnimation(py::wrapper::Windows::UI::Xaml::Media::Animation::SwipeHintThemeAnimation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SwipeHintThemeAnimation_get_ToVerticalOffset(py::wrapper::Windows::UI::Xaml::Media::Animation::SwipeHintThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SwipeHintThemeAnimation", L"ToVerticalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ToVerticalOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SwipeHintThemeAnimation_put_ToVerticalOffset(py::wrapper::Windows::UI::Xaml::Media::Animation::SwipeHintThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SwipeHintThemeAnimation", L"ToVerticalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.ToVerticalOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SwipeHintThemeAnimation_get_ToHorizontalOffset(py::wrapper::Windows::UI::Xaml::Media::Animation::SwipeHintThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SwipeHintThemeAnimation", L"ToHorizontalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ToHorizontalOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SwipeHintThemeAnimation_put_ToHorizontalOffset(py::wrapper::Windows::UI::Xaml::Media::Animation::SwipeHintThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SwipeHintThemeAnimation", L"ToHorizontalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.ToHorizontalOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SwipeHintThemeAnimation_get_TargetName(py::wrapper::Windows::UI::Xaml::Media::Animation::SwipeHintThemeAnimation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SwipeHintThemeAnimation", L"TargetName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TargetName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SwipeHintThemeAnimation_put_TargetName(py::wrapper::Windows::UI::Xaml::Media::Animation::SwipeHintThemeAnimation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SwipeHintThemeAnimation", L"TargetName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.TargetName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SwipeHintThemeAnimation_get_TargetNameProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SwipeHintThemeAnimation", L"TargetNameProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::SwipeHintThemeAnimation::TargetNameProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SwipeHintThemeAnimation_get_ToHorizontalOffsetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SwipeHintThemeAnimation", L"ToHorizontalOffsetProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::SwipeHintThemeAnimation::ToHorizontalOffsetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SwipeHintThemeAnimation_get_ToVerticalOffsetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.SwipeHintThemeAnimation", L"ToVerticalOffsetProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::SwipeHintThemeAnimation::ToVerticalOffsetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SwipeHintThemeAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::SwipeHintThemeAnimation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SwipeHintThemeAnimation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::SwipeHintThemeAnimation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SwipeHintThemeAnimation[] = {
        { "_assign_array_", _assign_array_SwipeHintThemeAnimation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SwipeHintThemeAnimation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SwipeHintThemeAnimation[] = {
        { "to_vertical_offset", reinterpret_cast<getter>(SwipeHintThemeAnimation_get_ToVerticalOffset), reinterpret_cast<setter>(SwipeHintThemeAnimation_put_ToVerticalOffset), nullptr, nullptr },
        { "to_horizontal_offset", reinterpret_cast<getter>(SwipeHintThemeAnimation_get_ToHorizontalOffset), reinterpret_cast<setter>(SwipeHintThemeAnimation_put_ToHorizontalOffset), nullptr, nullptr },
        { "target_name", reinterpret_cast<getter>(SwipeHintThemeAnimation_get_TargetName), reinterpret_cast<setter>(SwipeHintThemeAnimation_put_TargetName), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SwipeHintThemeAnimation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SwipeHintThemeAnimation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SwipeHintThemeAnimation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SwipeHintThemeAnimation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SwipeHintThemeAnimation) },
        { },
    };

    static PyType_Spec type_spec_SwipeHintThemeAnimation =
    {
        "_winrt_windows_ui_xaml_media_animation.SwipeHintThemeAnimation",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::SwipeHintThemeAnimation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SwipeHintThemeAnimation
    };

    static PyGetSetDef getset_SwipeHintThemeAnimation_Meta[] = {
        { "target_name_property", reinterpret_cast<getter>(SwipeHintThemeAnimation_get_TargetNameProperty), nullptr, nullptr, nullptr },
        { "to_horizontal_offset_property", reinterpret_cast<getter>(SwipeHintThemeAnimation_get_ToHorizontalOffsetProperty), nullptr, nullptr, nullptr },
        { "to_vertical_offset_property", reinterpret_cast<getter>(SwipeHintThemeAnimation_get_ToVerticalOffsetProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_SwipeHintThemeAnimation_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SwipeHintThemeAnimation_Meta) },
        { }
    };

    static PyType_Spec type_spec_SwipeHintThemeAnimation_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.SwipeHintThemeAnimation_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SwipeHintThemeAnimation_Meta
    };

    // ----- Timeline class --------------------
    static constexpr const char* const type_name_Timeline = "Timeline";

    static PyObject* _new_Timeline(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_Timeline);
        return nullptr;
    }

    static void _dealloc_Timeline(py::wrapper::Windows::UI::Xaml::Media::Animation::Timeline* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Timeline_get_SpeedRatio(py::wrapper::Windows::UI::Xaml::Media::Animation::Timeline* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.Timeline", L"SpeedRatio"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SpeedRatio());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Timeline_put_SpeedRatio(py::wrapper::Windows::UI::Xaml::Media::Animation::Timeline* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.Timeline", L"SpeedRatio"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.SpeedRatio(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Timeline_get_RepeatBehavior(py::wrapper::Windows::UI::Xaml::Media::Animation::Timeline* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.Timeline", L"RepeatBehavior"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RepeatBehavior());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Timeline_put_RepeatBehavior(py::wrapper::Windows::UI::Xaml::Media::Animation::Timeline* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.Timeline", L"RepeatBehavior"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::RepeatBehavior>(arg);

            self->obj.RepeatBehavior(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Timeline_get_FillBehavior(py::wrapper::Windows::UI::Xaml::Media::Animation::Timeline* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.Timeline", L"FillBehavior"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FillBehavior());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Timeline_put_FillBehavior(py::wrapper::Windows::UI::Xaml::Media::Animation::Timeline* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.Timeline", L"FillBehavior"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::FillBehavior>(arg);

            self->obj.FillBehavior(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Timeline_get_Duration(py::wrapper::Windows::UI::Xaml::Media::Animation::Timeline* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.Timeline", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Timeline_put_Duration(py::wrapper::Windows::UI::Xaml::Media::Animation::Timeline* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.Timeline", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Duration>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Timeline_get_BeginTime(py::wrapper::Windows::UI::Xaml::Media::Animation::Timeline* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.Timeline", L"BeginTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BeginTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Timeline_put_BeginTime(py::wrapper::Windows::UI::Xaml::Media::Animation::Timeline* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.Timeline", L"BeginTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.BeginTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Timeline_get_AutoReverse(py::wrapper::Windows::UI::Xaml::Media::Animation::Timeline* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.Timeline", L"AutoReverse"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AutoReverse());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Timeline_put_AutoReverse(py::wrapper::Windows::UI::Xaml::Media::Animation::Timeline* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.Timeline", L"AutoReverse"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AutoReverse(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Timeline_get_AllowDependentAnimations(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.Timeline", L"AllowDependentAnimations"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::Timeline::AllowDependentAnimations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Timeline_put_AllowDependentAnimations(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.Timeline", L"AllowDependentAnimations"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            winrt::Windows::UI::Xaml::Media::Animation::Timeline::AllowDependentAnimations(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Timeline_get_AutoReverseProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.Timeline", L"AutoReverseProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::Timeline::AutoReverseProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Timeline_get_BeginTimeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.Timeline", L"BeginTimeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::Timeline::BeginTimeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Timeline_get_DurationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.Timeline", L"DurationProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::Timeline::DurationProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Timeline_get_FillBehaviorProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.Timeline", L"FillBehaviorProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::Timeline::FillBehaviorProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Timeline_get_RepeatBehaviorProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.Timeline", L"RepeatBehaviorProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::Timeline::RepeatBehaviorProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Timeline_get_SpeedRatioProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.Timeline", L"SpeedRatioProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Media::Animation::Timeline::SpeedRatioProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Timeline_add_Completed(py::wrapper::Windows::UI::Xaml::Media::Animation::Timeline* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Media.Animation.Timeline", L"Completed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Completed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Timeline_remove_Completed(py::wrapper::Windows::UI::Xaml::Media::Animation::Timeline* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Media.Animation.Timeline", L"Completed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Completed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Timeline(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::Timeline>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Timeline(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::Timeline>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Timeline[] = {
        { "add_completed", reinterpret_cast<PyCFunction>(Timeline_add_Completed), METH_O, nullptr },
        { "remove_completed", reinterpret_cast<PyCFunction>(Timeline_remove_Completed), METH_O, nullptr },
        { "_assign_array_", _assign_array_Timeline, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Timeline), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Timeline[] = {
        { "speed_ratio", reinterpret_cast<getter>(Timeline_get_SpeedRatio), reinterpret_cast<setter>(Timeline_put_SpeedRatio), nullptr, nullptr },
        { "repeat_behavior", reinterpret_cast<getter>(Timeline_get_RepeatBehavior), reinterpret_cast<setter>(Timeline_put_RepeatBehavior), nullptr, nullptr },
        { "fill_behavior", reinterpret_cast<getter>(Timeline_get_FillBehavior), reinterpret_cast<setter>(Timeline_put_FillBehavior), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(Timeline_get_Duration), reinterpret_cast<setter>(Timeline_put_Duration), nullptr, nullptr },
        { "begin_time", reinterpret_cast<getter>(Timeline_get_BeginTime), reinterpret_cast<setter>(Timeline_put_BeginTime), nullptr, nullptr },
        { "auto_reverse", reinterpret_cast<getter>(Timeline_get_AutoReverse), reinterpret_cast<setter>(Timeline_put_AutoReverse), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Timeline[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Timeline) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Timeline) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Timeline) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Timeline) },
        { },
    };

    static PyType_Spec type_spec_Timeline =
    {
        "_winrt_windows_ui_xaml_media_animation.Timeline",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::Timeline),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Timeline
    };

    static PyGetSetDef getset_Timeline_Meta[] = {
        { "allow_dependent_animations", reinterpret_cast<getter>(Timeline_get_AllowDependentAnimations), reinterpret_cast<setter>(Timeline_put_AllowDependentAnimations), nullptr, nullptr },
        { "auto_reverse_property", reinterpret_cast<getter>(Timeline_get_AutoReverseProperty), nullptr, nullptr, nullptr },
        { "begin_time_property", reinterpret_cast<getter>(Timeline_get_BeginTimeProperty), nullptr, nullptr, nullptr },
        { "duration_property", reinterpret_cast<getter>(Timeline_get_DurationProperty), nullptr, nullptr, nullptr },
        { "fill_behavior_property", reinterpret_cast<getter>(Timeline_get_FillBehaviorProperty), nullptr, nullptr, nullptr },
        { "repeat_behavior_property", reinterpret_cast<getter>(Timeline_get_RepeatBehaviorProperty), nullptr, nullptr, nullptr },
        { "speed_ratio_property", reinterpret_cast<getter>(Timeline_get_SpeedRatioProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_Timeline_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Timeline_Meta) },
        { }
    };

    static PyType_Spec type_spec_Timeline_Meta =
    {
        "_winrt_windows_ui_xaml_media_animation.Timeline_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Timeline_Meta
    };

    // ----- TimelineCollection class --------------------
    static constexpr const char* const type_name_TimelineCollection = "TimelineCollection";

    static PyObject* _new_TimelineCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::TimelineCollection instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimelineCollection(py::wrapper::Windows::UI::Xaml::Media::Animation::TimelineCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimelineCollection_Append(py::wrapper::Windows::UI::Xaml::Media::Animation::TimelineCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.TimelineCollection", L"Append", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::Timeline>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimelineCollection_Clear(py::wrapper::Windows::UI::Xaml::Media::Animation::TimelineCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.TimelineCollection", L"Clear", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimelineCollection_First(py::wrapper::Windows::UI::Xaml::Media::Animation::TimelineCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.TimelineCollection", L"First", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimelineCollection_GetAt(py::wrapper::Windows::UI::Xaml::Media::Animation::TimelineCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.TimelineCollection", L"GetAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimelineCollection_GetMany(py::wrapper::Windows::UI::Xaml::Media::Animation::TimelineCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.TimelineCollection", L"GetMany", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::Media::Animation::Timeline, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimelineCollection_GetView(py::wrapper::Windows::UI::Xaml::Media::Animation::TimelineCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.TimelineCollection", L"GetView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimelineCollection_IndexOf(py::wrapper::Windows::UI::Xaml::Media::Animation::TimelineCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.TimelineCollection", L"IndexOf", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::Timeline>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimelineCollection_InsertAt(py::wrapper::Windows::UI::Xaml::Media::Animation::TimelineCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.TimelineCollection", L"InsertAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::Timeline>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimelineCollection_RemoveAt(py::wrapper::Windows::UI::Xaml::Media::Animation::TimelineCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.TimelineCollection", L"RemoveAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimelineCollection_RemoveAtEnd(py::wrapper::Windows::UI::Xaml::Media::Animation::TimelineCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.TimelineCollection", L"RemoveAtEnd", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimelineCollection_ReplaceAll(py::wrapper::Windows::UI::Xaml::Media::Animation::TimelineCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.TimelineCollection", L"ReplaceAll", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::Media::Animation::Timeline, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimelineCollection_SetAt(py::wrapper::Windows::UI::Xaml::Media::Animation::TimelineCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.TimelineCollection", L"SetAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::Timeline>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimelineCollection_get_Size(py::wrapper::Windows::UI::Xaml::Media::Animation::TimelineCollection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.TimelineCollection", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TimelineCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::TimelineCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TimelineCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::TimelineCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_TimelineCollection(py::wrapper::Windows::UI::Xaml::Media::Animation::TimelineCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_TimelineCollection(py::wrapper::Windows::UI::Xaml::Media::Animation::TimelineCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_TimelineCollection(py::wrapper::Windows::UI::Xaml::Media::Animation::TimelineCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_TimelineCollection(py::wrapper::Windows::UI::Xaml::Media::Animation::TimelineCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_TimelineCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(
                    PyExc_TypeError,
                    "indicies must be integers, not '%s'",
                    Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(
                    slice, self->obj.Size(), &start, &stop, &step, &length)
                < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(
                    PyExc_NotImplementedError,
                    "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::UI::Xaml::Media::Animation::Timeline> items(length, empty_instance<winrt::Windows::UI::Xaml::Media::Animation::Timeline>::get());

            auto count = self->obj.GetMany(start, items);

            if (count != length)
            {
                PyErr_Format(
                    PyExc_RuntimeError,
                    "returned count %d did not match requested length %zd",
                    count,
                    length);
                return nullptr;
            }

            return convert(items);}
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_TimelineCollection(py::wrapper::Windows::UI::Xaml::Media::Animation::TimelineCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (value == nullptr) { self->obj.RemoveAt(static_cast<uint32_t>(i)); }
            else { self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::Timeline>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_TimelineCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(TimelineCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(TimelineCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(TimelineCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(TimelineCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(TimelineCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(TimelineCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(TimelineCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(TimelineCollection_InsertAt), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(TimelineCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(TimelineCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(TimelineCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(TimelineCollection_SetAt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TimelineCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimelineCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimelineCollection[] = {
        { "size", reinterpret_cast<getter>(TimelineCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimelineCollection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimelineCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimelineCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimelineCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimelineCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_TimelineCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_TimelineCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_TimelineCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_TimelineCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_TimelineCollection) },
        { },
    };

    static PyType_Spec type_spec_TimelineCollection =
    {
        "_winrt_windows_ui_xaml_media_animation.TimelineCollection",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::TimelineCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimelineCollection
    };

    // ----- Transition class --------------------
    static constexpr const char* const type_name_Transition = "Transition";

    static PyObject* _new_Transition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_Transition);
        return nullptr;
    }

    static void _dealloc_Transition(py::wrapper::Windows::UI::Xaml::Media::Animation::Transition* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_Transition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::Transition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Transition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::Transition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Transition[] = {
        { "_assign_array_", _assign_array_Transition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Transition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Transition[] = {
        { }
    };

    static PyType_Slot _type_slots_Transition[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Transition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Transition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Transition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Transition) },
        { },
    };

    static PyType_Spec type_spec_Transition =
    {
        "_winrt_windows_ui_xaml_media_animation.Transition",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::Transition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Transition
    };

    // ----- TransitionCollection class --------------------
    static constexpr const char* const type_name_TransitionCollection = "TransitionCollection";

    static PyObject* _new_TransitionCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::TransitionCollection instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TransitionCollection(py::wrapper::Windows::UI::Xaml::Media::Animation::TransitionCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TransitionCollection_Append(py::wrapper::Windows::UI::Xaml::Media::Animation::TransitionCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.TransitionCollection", L"Append", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::Transition>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TransitionCollection_Clear(py::wrapper::Windows::UI::Xaml::Media::Animation::TransitionCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.TransitionCollection", L"Clear", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TransitionCollection_First(py::wrapper::Windows::UI::Xaml::Media::Animation::TransitionCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.TransitionCollection", L"First", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TransitionCollection_GetAt(py::wrapper::Windows::UI::Xaml::Media::Animation::TransitionCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.TransitionCollection", L"GetAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TransitionCollection_GetMany(py::wrapper::Windows::UI::Xaml::Media::Animation::TransitionCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.TransitionCollection", L"GetMany", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::Media::Animation::Transition, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TransitionCollection_GetView(py::wrapper::Windows::UI::Xaml::Media::Animation::TransitionCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.TransitionCollection", L"GetView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TransitionCollection_IndexOf(py::wrapper::Windows::UI::Xaml::Media::Animation::TransitionCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.TransitionCollection", L"IndexOf", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::Transition>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TransitionCollection_InsertAt(py::wrapper::Windows::UI::Xaml::Media::Animation::TransitionCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.TransitionCollection", L"InsertAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::Transition>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TransitionCollection_RemoveAt(py::wrapper::Windows::UI::Xaml::Media::Animation::TransitionCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.TransitionCollection", L"RemoveAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TransitionCollection_RemoveAtEnd(py::wrapper::Windows::UI::Xaml::Media::Animation::TransitionCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.TransitionCollection", L"RemoveAtEnd", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TransitionCollection_ReplaceAll(py::wrapper::Windows::UI::Xaml::Media::Animation::TransitionCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.TransitionCollection", L"ReplaceAll", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::Media::Animation::Transition, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TransitionCollection_SetAt(py::wrapper::Windows::UI::Xaml::Media::Animation::TransitionCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Animation.TransitionCollection", L"SetAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::Transition>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TransitionCollection_get_Size(py::wrapper::Windows::UI::Xaml::Media::Animation::TransitionCollection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Animation.TransitionCollection", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TransitionCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Animation::TransitionCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TransitionCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Animation::TransitionCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_TransitionCollection(py::wrapper::Windows::UI::Xaml::Media::Animation::TransitionCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_TransitionCollection(py::wrapper::Windows::UI::Xaml::Media::Animation::TransitionCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_TransitionCollection(py::wrapper::Windows::UI::Xaml::Media::Animation::TransitionCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_TransitionCollection(py::wrapper::Windows::UI::Xaml::Media::Animation::TransitionCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_TransitionCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(
                    PyExc_TypeError,
                    "indicies must be integers, not '%s'",
                    Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(
                    slice, self->obj.Size(), &start, &stop, &step, &length)
                < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(
                    PyExc_NotImplementedError,
                    "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::UI::Xaml::Media::Animation::Transition> items(length, empty_instance<winrt::Windows::UI::Xaml::Media::Animation::Transition>::get());

            auto count = self->obj.GetMany(start, items);

            if (count != length)
            {
                PyErr_Format(
                    PyExc_RuntimeError,
                    "returned count %d did not match requested length %zd",
                    count,
                    length);
                return nullptr;
            }

            return convert(items);}
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_TransitionCollection(py::wrapper::Windows::UI::Xaml::Media::Animation::TransitionCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (value == nullptr) { self->obj.RemoveAt(static_cast<uint32_t>(i)); }
            else { self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::Transition>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_TransitionCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(TransitionCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(TransitionCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(TransitionCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(TransitionCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(TransitionCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(TransitionCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(TransitionCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(TransitionCollection_InsertAt), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(TransitionCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(TransitionCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(TransitionCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(TransitionCollection_SetAt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TransitionCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TransitionCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TransitionCollection[] = {
        { "size", reinterpret_cast<getter>(TransitionCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TransitionCollection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TransitionCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TransitionCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TransitionCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TransitionCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_TransitionCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_TransitionCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_TransitionCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_TransitionCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_TransitionCollection) },
        { },
    };

    static PyType_Spec type_spec_TransitionCollection =
    {
        "_winrt_windows_ui_xaml_media_animation.TransitionCollection",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::TransitionCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TransitionCollection
    };

    // ----- KeyTime struct --------------------
    static constexpr const char* const type_name_KeyTime = "KeyTime";

    PyObject* _new_KeyTime(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::KeyTime return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        PyObject* _TimeSpan{};

        static const char* kwlist[] = {"time_span", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "O", const_cast<char**>(kwlist), &_TimeSpan))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::UI::Xaml::Media::Animation::KeyTime return_value{ py::converter<winrt::Windows::Foundation::TimeSpan>::convert_to(_TimeSpan) };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_KeyTime(py::wrapper::Windows::UI::Xaml::Media::Animation::KeyTime* self) noexcept
    {
    }

    static PyObject* KeyTime_get_TimeSpan(py::wrapper::Windows::UI::Xaml::Media::Animation::KeyTime* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TimeSpan);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int KeyTime_set_TimeSpan(py::wrapper::Windows::UI::Xaml::Media::Animation::KeyTime* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.TimeSpan = py::converter<winrt::Windows::Foundation::TimeSpan>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_KeyTime[] = {
        { "time_span", reinterpret_cast<getter>(KeyTime_get_TimeSpan), reinterpret_cast<setter>(KeyTime_set_TimeSpan), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_KeyTime[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_KeyTime) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_KeyTime) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KeyTime) },
        { },
    };

    static PyType_Spec type_spec_KeyTime =
    {
        "_winrt_windows_ui_xaml_media_animation.KeyTime",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::KeyTime),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KeyTime
    };

    // ----- RepeatBehavior struct --------------------
    static constexpr const char* const type_name_RepeatBehavior = "RepeatBehavior";

    PyObject* _new_RepeatBehavior(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Animation::RepeatBehavior return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        double _Count{};
        PyObject* _Duration{};
        int32_t _Type{};

        static const char* kwlist[] = {"count", "duration", "type", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "dOi", const_cast<char**>(kwlist), &_Count, &_Duration, &_Type))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::UI::Xaml::Media::Animation::RepeatBehavior return_value{ _Count, py::converter<winrt::Windows::Foundation::TimeSpan>::convert_to(_Duration), static_cast<winrt::Windows::UI::Xaml::Media::Animation::RepeatBehaviorType>(_Type) };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_RepeatBehavior(py::wrapper::Windows::UI::Xaml::Media::Animation::RepeatBehavior* self) noexcept
    {
    }

    static PyObject* RepeatBehavior_get_Count(py::wrapper::Windows::UI::Xaml::Media::Animation::RepeatBehavior* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Count);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RepeatBehavior_set_Count(py::wrapper::Windows::UI::Xaml::Media::Animation::RepeatBehavior* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Count = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RepeatBehavior_get_Duration(py::wrapper::Windows::UI::Xaml::Media::Animation::RepeatBehavior* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RepeatBehavior_set_Duration(py::wrapper::Windows::UI::Xaml::Media::Animation::RepeatBehavior* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Duration = py::converter<winrt::Windows::Foundation::TimeSpan>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RepeatBehavior_get_Type(py::wrapper::Windows::UI::Xaml::Media::Animation::RepeatBehavior* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RepeatBehavior_set_Type(py::wrapper::Windows::UI::Xaml::Media::Animation::RepeatBehavior* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Type = py::converter<winrt::Windows::UI::Xaml::Media::Animation::RepeatBehaviorType>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_RepeatBehavior[] = {
        { "count", reinterpret_cast<getter>(RepeatBehavior_get_Count), reinterpret_cast<setter>(RepeatBehavior_set_Count), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(RepeatBehavior_get_Duration), reinterpret_cast<setter>(RepeatBehavior_set_Duration), nullptr, nullptr },
        { "type", reinterpret_cast<getter>(RepeatBehavior_get_Type), reinterpret_cast<setter>(RepeatBehavior_set_Type), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RepeatBehavior[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RepeatBehavior) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RepeatBehavior) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RepeatBehavior) },
        { },
    };

    static PyType_Spec type_spec_RepeatBehavior =
    {
        "_winrt_windows_ui_xaml_media_animation.RepeatBehavior",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Animation::RepeatBehavior),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RepeatBehavior
    };

    // ----- Windows.UI.Xaml.Media.Animation Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::UI::Xaml::Media::Animation");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_ui_xaml_media_animation",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::UI::Xaml::Media::Animation

PyMODINIT_FUNC PyInit__winrt_windows_ui_xaml_media_animation(void) noexcept
{
    using namespace py::cpp::Windows::UI::Xaml::Media::Animation;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_AddDeleteThemeTransition, &type_spec_AddDeleteThemeTransition, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_AddDeleteThemeTransition, &type_spec_AddDeleteThemeTransition, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_BackEase_Meta{PyType_FromSpec(&type_spec_BackEase_Meta)};
    if (!type_BackEase_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_BackEase, &type_spec_BackEase, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_BackEase_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_BackEase, &type_spec_BackEase, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_BackEase_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_BasicConnectedAnimationConfiguration, &type_spec_BasicConnectedAnimationConfiguration, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_BasicConnectedAnimationConfiguration, &type_spec_BasicConnectedAnimationConfiguration, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_BeginStoryboard_Meta{PyType_FromSpec(&type_spec_BeginStoryboard_Meta)};
    if (!type_BeginStoryboard_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_BeginStoryboard, &type_spec_BeginStoryboard, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_BeginStoryboard_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_BeginStoryboard, &type_spec_BeginStoryboard, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_BeginStoryboard_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_BounceEase_Meta{PyType_FromSpec(&type_spec_BounceEase_Meta)};
    if (!type_BounceEase_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_BounceEase, &type_spec_BounceEase, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_BounceEase_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_BounceEase, &type_spec_BounceEase, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_BounceEase_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_CircleEase, &type_spec_CircleEase, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_CircleEase, &type_spec_CircleEase, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_ColorAnimation_Meta{PyType_FromSpec(&type_spec_ColorAnimation_Meta)};
    if (!type_ColorAnimation_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ColorAnimation, &type_spec_ColorAnimation, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ColorAnimation_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ColorAnimation, &type_spec_ColorAnimation, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ColorAnimation_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_ColorAnimationUsingKeyFrames_Meta{PyType_FromSpec(&type_spec_ColorAnimationUsingKeyFrames_Meta)};
    if (!type_ColorAnimationUsingKeyFrames_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ColorAnimationUsingKeyFrames, &type_spec_ColorAnimationUsingKeyFrames, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ColorAnimationUsingKeyFrames_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ColorAnimationUsingKeyFrames, &type_spec_ColorAnimationUsingKeyFrames, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ColorAnimationUsingKeyFrames_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_ColorKeyFrame_Meta{PyType_FromSpec(&type_spec_ColorKeyFrame_Meta)};
    if (!type_ColorKeyFrame_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ColorKeyFrame, &type_spec_ColorKeyFrame, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ColorKeyFrame_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ColorKeyFrame, &type_spec_ColorKeyFrame, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ColorKeyFrame_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ColorKeyFrameCollection, &type_spec_ColorKeyFrameCollection, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ColorKeyFrameCollection, &type_spec_ColorKeyFrameCollection, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_CommonNavigationTransitionInfo_Meta{PyType_FromSpec(&type_spec_CommonNavigationTransitionInfo_Meta)};
    if (!type_CommonNavigationTransitionInfo_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_CommonNavigationTransitionInfo, &type_spec_CommonNavigationTransitionInfo, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CommonNavigationTransitionInfo_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_CommonNavigationTransitionInfo, &type_spec_CommonNavigationTransitionInfo, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CommonNavigationTransitionInfo_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ConnectedAnimation, &type_spec_ConnectedAnimation, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ConnectedAnimation, &type_spec_ConnectedAnimation, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ConnectedAnimationConfiguration, &type_spec_ConnectedAnimationConfiguration, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ConnectedAnimationConfiguration, &type_spec_ConnectedAnimationConfiguration, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ConnectedAnimationService, &type_spec_ConnectedAnimationService, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ConnectedAnimationService, &type_spec_ConnectedAnimationService, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_ContentThemeTransition_Meta{PyType_FromSpec(&type_spec_ContentThemeTransition_Meta)};
    if (!type_ContentThemeTransition_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ContentThemeTransition, &type_spec_ContentThemeTransition, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ContentThemeTransition_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ContentThemeTransition, &type_spec_ContentThemeTransition, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ContentThemeTransition_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_ContinuumNavigationTransitionInfo_Meta{PyType_FromSpec(&type_spec_ContinuumNavigationTransitionInfo_Meta)};
    if (!type_ContinuumNavigationTransitionInfo_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ContinuumNavigationTransitionInfo, &type_spec_ContinuumNavigationTransitionInfo, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ContinuumNavigationTransitionInfo_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ContinuumNavigationTransitionInfo, &type_spec_ContinuumNavigationTransitionInfo, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ContinuumNavigationTransitionInfo_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_CubicEase, &type_spec_CubicEase, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_CubicEase, &type_spec_CubicEase, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_DirectConnectedAnimationConfiguration, &type_spec_DirectConnectedAnimationConfiguration, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_DirectConnectedAnimationConfiguration, &type_spec_DirectConnectedAnimationConfiguration, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_DiscreteColorKeyFrame, &type_spec_DiscreteColorKeyFrame, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_DiscreteColorKeyFrame, &type_spec_DiscreteColorKeyFrame, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_DiscreteDoubleKeyFrame, &type_spec_DiscreteDoubleKeyFrame, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_DiscreteDoubleKeyFrame, &type_spec_DiscreteDoubleKeyFrame, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_DiscreteObjectKeyFrame, &type_spec_DiscreteObjectKeyFrame, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_DiscreteObjectKeyFrame, &type_spec_DiscreteObjectKeyFrame, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_DiscretePointKeyFrame, &type_spec_DiscretePointKeyFrame, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_DiscretePointKeyFrame, &type_spec_DiscretePointKeyFrame, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_DoubleAnimation_Meta{PyType_FromSpec(&type_spec_DoubleAnimation_Meta)};
    if (!type_DoubleAnimation_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_DoubleAnimation, &type_spec_DoubleAnimation, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_DoubleAnimation_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_DoubleAnimation, &type_spec_DoubleAnimation, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_DoubleAnimation_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_DoubleAnimationUsingKeyFrames_Meta{PyType_FromSpec(&type_spec_DoubleAnimationUsingKeyFrames_Meta)};
    if (!type_DoubleAnimationUsingKeyFrames_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_DoubleAnimationUsingKeyFrames, &type_spec_DoubleAnimationUsingKeyFrames, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_DoubleAnimationUsingKeyFrames_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_DoubleAnimationUsingKeyFrames, &type_spec_DoubleAnimationUsingKeyFrames, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_DoubleAnimationUsingKeyFrames_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_DoubleKeyFrame_Meta{PyType_FromSpec(&type_spec_DoubleKeyFrame_Meta)};
    if (!type_DoubleKeyFrame_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_DoubleKeyFrame, &type_spec_DoubleKeyFrame, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_DoubleKeyFrame_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_DoubleKeyFrame, &type_spec_DoubleKeyFrame, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_DoubleKeyFrame_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_DoubleKeyFrameCollection, &type_spec_DoubleKeyFrameCollection, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_DoubleKeyFrameCollection, &type_spec_DoubleKeyFrameCollection, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_DragItemThemeAnimation_Meta{PyType_FromSpec(&type_spec_DragItemThemeAnimation_Meta)};
    if (!type_DragItemThemeAnimation_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_DragItemThemeAnimation, &type_spec_DragItemThemeAnimation, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_DragItemThemeAnimation_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_DragItemThemeAnimation, &type_spec_DragItemThemeAnimation, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_DragItemThemeAnimation_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_DragOverThemeAnimation_Meta{PyType_FromSpec(&type_spec_DragOverThemeAnimation_Meta)};
    if (!type_DragOverThemeAnimation_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_DragOverThemeAnimation, &type_spec_DragOverThemeAnimation, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_DragOverThemeAnimation_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_DragOverThemeAnimation, &type_spec_DragOverThemeAnimation, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_DragOverThemeAnimation_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_DrillInNavigationTransitionInfo, &type_spec_DrillInNavigationTransitionInfo, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_DrillInNavigationTransitionInfo, &type_spec_DrillInNavigationTransitionInfo, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_DrillInThemeAnimation_Meta{PyType_FromSpec(&type_spec_DrillInThemeAnimation_Meta)};
    if (!type_DrillInThemeAnimation_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_DrillInThemeAnimation, &type_spec_DrillInThemeAnimation, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_DrillInThemeAnimation_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_DrillInThemeAnimation, &type_spec_DrillInThemeAnimation, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_DrillInThemeAnimation_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_DrillOutThemeAnimation_Meta{PyType_FromSpec(&type_spec_DrillOutThemeAnimation_Meta)};
    if (!type_DrillOutThemeAnimation_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_DrillOutThemeAnimation, &type_spec_DrillOutThemeAnimation, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_DrillOutThemeAnimation_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_DrillOutThemeAnimation, &type_spec_DrillOutThemeAnimation, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_DrillOutThemeAnimation_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_DropTargetItemThemeAnimation_Meta{PyType_FromSpec(&type_spec_DropTargetItemThemeAnimation_Meta)};
    if (!type_DropTargetItemThemeAnimation_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_DropTargetItemThemeAnimation, &type_spec_DropTargetItemThemeAnimation, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_DropTargetItemThemeAnimation_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_DropTargetItemThemeAnimation, &type_spec_DropTargetItemThemeAnimation, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_DropTargetItemThemeAnimation_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_EasingColorKeyFrame_Meta{PyType_FromSpec(&type_spec_EasingColorKeyFrame_Meta)};
    if (!type_EasingColorKeyFrame_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_EasingColorKeyFrame, &type_spec_EasingColorKeyFrame, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_EasingColorKeyFrame_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_EasingColorKeyFrame, &type_spec_EasingColorKeyFrame, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_EasingColorKeyFrame_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_EasingDoubleKeyFrame_Meta{PyType_FromSpec(&type_spec_EasingDoubleKeyFrame_Meta)};
    if (!type_EasingDoubleKeyFrame_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_EasingDoubleKeyFrame, &type_spec_EasingDoubleKeyFrame, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_EasingDoubleKeyFrame_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_EasingDoubleKeyFrame, &type_spec_EasingDoubleKeyFrame, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_EasingDoubleKeyFrame_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_EasingFunctionBase_Meta{PyType_FromSpec(&type_spec_EasingFunctionBase_Meta)};
    if (!type_EasingFunctionBase_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_EasingFunctionBase, &type_spec_EasingFunctionBase, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_EasingFunctionBase_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_EasingFunctionBase, &type_spec_EasingFunctionBase, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_EasingFunctionBase_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_EasingPointKeyFrame_Meta{PyType_FromSpec(&type_spec_EasingPointKeyFrame_Meta)};
    if (!type_EasingPointKeyFrame_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_EasingPointKeyFrame, &type_spec_EasingPointKeyFrame, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_EasingPointKeyFrame_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_EasingPointKeyFrame, &type_spec_EasingPointKeyFrame, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_EasingPointKeyFrame_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_EdgeUIThemeTransition_Meta{PyType_FromSpec(&type_spec_EdgeUIThemeTransition_Meta)};
    if (!type_EdgeUIThemeTransition_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_EdgeUIThemeTransition, &type_spec_EdgeUIThemeTransition, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_EdgeUIThemeTransition_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_EdgeUIThemeTransition, &type_spec_EdgeUIThemeTransition, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_EdgeUIThemeTransition_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_ElasticEase_Meta{PyType_FromSpec(&type_spec_ElasticEase_Meta)};
    if (!type_ElasticEase_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ElasticEase, &type_spec_ElasticEase, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ElasticEase_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ElasticEase, &type_spec_ElasticEase, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ElasticEase_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_EntranceNavigationTransitionInfo_Meta{PyType_FromSpec(&type_spec_EntranceNavigationTransitionInfo_Meta)};
    if (!type_EntranceNavigationTransitionInfo_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_EntranceNavigationTransitionInfo, &type_spec_EntranceNavigationTransitionInfo, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_EntranceNavigationTransitionInfo_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_EntranceNavigationTransitionInfo, &type_spec_EntranceNavigationTransitionInfo, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_EntranceNavigationTransitionInfo_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_EntranceThemeTransition_Meta{PyType_FromSpec(&type_spec_EntranceThemeTransition_Meta)};
    if (!type_EntranceThemeTransition_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_EntranceThemeTransition, &type_spec_EntranceThemeTransition, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_EntranceThemeTransition_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_EntranceThemeTransition, &type_spec_EntranceThemeTransition, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_EntranceThemeTransition_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_ExponentialEase_Meta{PyType_FromSpec(&type_spec_ExponentialEase_Meta)};
    if (!type_ExponentialEase_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ExponentialEase, &type_spec_ExponentialEase, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ExponentialEase_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ExponentialEase, &type_spec_ExponentialEase, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ExponentialEase_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_FadeInThemeAnimation_Meta{PyType_FromSpec(&type_spec_FadeInThemeAnimation_Meta)};
    if (!type_FadeInThemeAnimation_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_FadeInThemeAnimation, &type_spec_FadeInThemeAnimation, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_FadeInThemeAnimation_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_FadeInThemeAnimation, &type_spec_FadeInThemeAnimation, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_FadeInThemeAnimation_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_FadeOutThemeAnimation_Meta{PyType_FromSpec(&type_spec_FadeOutThemeAnimation_Meta)};
    if (!type_FadeOutThemeAnimation_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_FadeOutThemeAnimation, &type_spec_FadeOutThemeAnimation, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_FadeOutThemeAnimation_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_FadeOutThemeAnimation, &type_spec_FadeOutThemeAnimation, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_FadeOutThemeAnimation_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_GravityConnectedAnimationConfiguration, &type_spec_GravityConnectedAnimationConfiguration, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_GravityConnectedAnimationConfiguration, &type_spec_GravityConnectedAnimationConfiguration, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_KeySpline, &type_spec_KeySpline, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_KeySpline, &type_spec_KeySpline, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_KeyTimeHelper, &type_spec_KeyTimeHelper, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_KeyTimeHelper, &type_spec_KeyTimeHelper, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_LinearColorKeyFrame, &type_spec_LinearColorKeyFrame, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_LinearColorKeyFrame, &type_spec_LinearColorKeyFrame, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_LinearDoubleKeyFrame, &type_spec_LinearDoubleKeyFrame, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_LinearDoubleKeyFrame, &type_spec_LinearDoubleKeyFrame, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_LinearPointKeyFrame, &type_spec_LinearPointKeyFrame, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_LinearPointKeyFrame, &type_spec_LinearPointKeyFrame, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_NavigationThemeTransition_Meta{PyType_FromSpec(&type_spec_NavigationThemeTransition_Meta)};
    if (!type_NavigationThemeTransition_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_NavigationThemeTransition, &type_spec_NavigationThemeTransition, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_NavigationThemeTransition_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_NavigationThemeTransition, &type_spec_NavigationThemeTransition, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_NavigationThemeTransition_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_NavigationTransitionInfo, &type_spec_NavigationTransitionInfo, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_NavigationTransitionInfo, &type_spec_NavigationTransitionInfo, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_ObjectAnimationUsingKeyFrames_Meta{PyType_FromSpec(&type_spec_ObjectAnimationUsingKeyFrames_Meta)};
    if (!type_ObjectAnimationUsingKeyFrames_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ObjectAnimationUsingKeyFrames, &type_spec_ObjectAnimationUsingKeyFrames, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ObjectAnimationUsingKeyFrames_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ObjectAnimationUsingKeyFrames, &type_spec_ObjectAnimationUsingKeyFrames, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ObjectAnimationUsingKeyFrames_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_ObjectKeyFrame_Meta{PyType_FromSpec(&type_spec_ObjectKeyFrame_Meta)};
    if (!type_ObjectKeyFrame_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ObjectKeyFrame, &type_spec_ObjectKeyFrame, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ObjectKeyFrame_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ObjectKeyFrame, &type_spec_ObjectKeyFrame, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ObjectKeyFrame_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ObjectKeyFrameCollection, &type_spec_ObjectKeyFrameCollection, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ObjectKeyFrameCollection, &type_spec_ObjectKeyFrameCollection, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_PaneThemeTransition_Meta{PyType_FromSpec(&type_spec_PaneThemeTransition_Meta)};
    if (!type_PaneThemeTransition_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_PaneThemeTransition, &type_spec_PaneThemeTransition, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PaneThemeTransition_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_PaneThemeTransition, &type_spec_PaneThemeTransition, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PaneThemeTransition_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_PointAnimation_Meta{PyType_FromSpec(&type_spec_PointAnimation_Meta)};
    if (!type_PointAnimation_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_PointAnimation, &type_spec_PointAnimation, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PointAnimation_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_PointAnimation, &type_spec_PointAnimation, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PointAnimation_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_PointAnimationUsingKeyFrames_Meta{PyType_FromSpec(&type_spec_PointAnimationUsingKeyFrames_Meta)};
    if (!type_PointAnimationUsingKeyFrames_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_PointAnimationUsingKeyFrames, &type_spec_PointAnimationUsingKeyFrames, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PointAnimationUsingKeyFrames_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_PointAnimationUsingKeyFrames, &type_spec_PointAnimationUsingKeyFrames, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PointAnimationUsingKeyFrames_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_PointKeyFrame_Meta{PyType_FromSpec(&type_spec_PointKeyFrame_Meta)};
    if (!type_PointKeyFrame_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_PointKeyFrame, &type_spec_PointKeyFrame, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PointKeyFrame_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_PointKeyFrame, &type_spec_PointKeyFrame, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PointKeyFrame_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_PointKeyFrameCollection, &type_spec_PointKeyFrameCollection, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_PointKeyFrameCollection, &type_spec_PointKeyFrameCollection, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_PointerDownThemeAnimation_Meta{PyType_FromSpec(&type_spec_PointerDownThemeAnimation_Meta)};
    if (!type_PointerDownThemeAnimation_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_PointerDownThemeAnimation, &type_spec_PointerDownThemeAnimation, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PointerDownThemeAnimation_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_PointerDownThemeAnimation, &type_spec_PointerDownThemeAnimation, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PointerDownThemeAnimation_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_PointerUpThemeAnimation_Meta{PyType_FromSpec(&type_spec_PointerUpThemeAnimation_Meta)};
    if (!type_PointerUpThemeAnimation_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_PointerUpThemeAnimation, &type_spec_PointerUpThemeAnimation, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PointerUpThemeAnimation_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_PointerUpThemeAnimation, &type_spec_PointerUpThemeAnimation, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PointerUpThemeAnimation_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_PopInThemeAnimation_Meta{PyType_FromSpec(&type_spec_PopInThemeAnimation_Meta)};
    if (!type_PopInThemeAnimation_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_PopInThemeAnimation, &type_spec_PopInThemeAnimation, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PopInThemeAnimation_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_PopInThemeAnimation, &type_spec_PopInThemeAnimation, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PopInThemeAnimation_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_PopOutThemeAnimation_Meta{PyType_FromSpec(&type_spec_PopOutThemeAnimation_Meta)};
    if (!type_PopOutThemeAnimation_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_PopOutThemeAnimation, &type_spec_PopOutThemeAnimation, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PopOutThemeAnimation_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_PopOutThemeAnimation, &type_spec_PopOutThemeAnimation, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PopOutThemeAnimation_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_PopupThemeTransition_Meta{PyType_FromSpec(&type_spec_PopupThemeTransition_Meta)};
    if (!type_PopupThemeTransition_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_PopupThemeTransition, &type_spec_PopupThemeTransition, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PopupThemeTransition_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_PopupThemeTransition, &type_spec_PopupThemeTransition, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PopupThemeTransition_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_PowerEase_Meta{PyType_FromSpec(&type_spec_PowerEase_Meta)};
    if (!type_PowerEase_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_PowerEase, &type_spec_PowerEase, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PowerEase_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_PowerEase, &type_spec_PowerEase, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PowerEase_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_QuadraticEase, &type_spec_QuadraticEase, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_QuadraticEase, &type_spec_QuadraticEase, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_QuarticEase, &type_spec_QuarticEase, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_QuarticEase, &type_spec_QuarticEase, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_QuinticEase, &type_spec_QuinticEase, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_QuinticEase, &type_spec_QuinticEase, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ReorderThemeTransition, &type_spec_ReorderThemeTransition, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ReorderThemeTransition, &type_spec_ReorderThemeTransition, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_RepeatBehaviorHelper_Meta{PyType_FromSpec(&type_spec_RepeatBehaviorHelper_Meta)};
    if (!type_RepeatBehaviorHelper_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RepeatBehaviorHelper, &type_spec_RepeatBehaviorHelper, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RepeatBehaviorHelper_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RepeatBehaviorHelper, &type_spec_RepeatBehaviorHelper, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RepeatBehaviorHelper_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_RepositionThemeAnimation_Meta{PyType_FromSpec(&type_spec_RepositionThemeAnimation_Meta)};
    if (!type_RepositionThemeAnimation_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RepositionThemeAnimation, &type_spec_RepositionThemeAnimation, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RepositionThemeAnimation_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RepositionThemeAnimation, &type_spec_RepositionThemeAnimation, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RepositionThemeAnimation_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_RepositionThemeTransition_Meta{PyType_FromSpec(&type_spec_RepositionThemeTransition_Meta)};
    if (!type_RepositionThemeTransition_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RepositionThemeTransition, &type_spec_RepositionThemeTransition, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RepositionThemeTransition_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RepositionThemeTransition, &type_spec_RepositionThemeTransition, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RepositionThemeTransition_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_SineEase, &type_spec_SineEase, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_SineEase, &type_spec_SineEase, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_SlideNavigationTransitionInfo_Meta{PyType_FromSpec(&type_spec_SlideNavigationTransitionInfo_Meta)};
    if (!type_SlideNavigationTransitionInfo_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_SlideNavigationTransitionInfo, &type_spec_SlideNavigationTransitionInfo, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SlideNavigationTransitionInfo_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_SlideNavigationTransitionInfo, &type_spec_SlideNavigationTransitionInfo, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SlideNavigationTransitionInfo_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_SplineColorKeyFrame_Meta{PyType_FromSpec(&type_spec_SplineColorKeyFrame_Meta)};
    if (!type_SplineColorKeyFrame_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_SplineColorKeyFrame, &type_spec_SplineColorKeyFrame, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SplineColorKeyFrame_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_SplineColorKeyFrame, &type_spec_SplineColorKeyFrame, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SplineColorKeyFrame_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_SplineDoubleKeyFrame_Meta{PyType_FromSpec(&type_spec_SplineDoubleKeyFrame_Meta)};
    if (!type_SplineDoubleKeyFrame_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_SplineDoubleKeyFrame, &type_spec_SplineDoubleKeyFrame, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SplineDoubleKeyFrame_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_SplineDoubleKeyFrame, &type_spec_SplineDoubleKeyFrame, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SplineDoubleKeyFrame_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_SplinePointKeyFrame_Meta{PyType_FromSpec(&type_spec_SplinePointKeyFrame_Meta)};
    if (!type_SplinePointKeyFrame_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_SplinePointKeyFrame, &type_spec_SplinePointKeyFrame, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SplinePointKeyFrame_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_SplinePointKeyFrame, &type_spec_SplinePointKeyFrame, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SplinePointKeyFrame_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_SplitCloseThemeAnimation_Meta{PyType_FromSpec(&type_spec_SplitCloseThemeAnimation_Meta)};
    if (!type_SplitCloseThemeAnimation_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_SplitCloseThemeAnimation, &type_spec_SplitCloseThemeAnimation, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SplitCloseThemeAnimation_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_SplitCloseThemeAnimation, &type_spec_SplitCloseThemeAnimation, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SplitCloseThemeAnimation_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_SplitOpenThemeAnimation_Meta{PyType_FromSpec(&type_spec_SplitOpenThemeAnimation_Meta)};
    if (!type_SplitOpenThemeAnimation_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_SplitOpenThemeAnimation, &type_spec_SplitOpenThemeAnimation, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SplitOpenThemeAnimation_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_SplitOpenThemeAnimation, &type_spec_SplitOpenThemeAnimation, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SplitOpenThemeAnimation_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_Storyboard_Meta{PyType_FromSpec(&type_spec_Storyboard_Meta)};
    if (!type_Storyboard_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_Storyboard, &type_spec_Storyboard, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Storyboard_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_Storyboard, &type_spec_Storyboard, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Storyboard_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_SuppressNavigationTransitionInfo, &type_spec_SuppressNavigationTransitionInfo, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_SuppressNavigationTransitionInfo, &type_spec_SuppressNavigationTransitionInfo, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_SwipeBackThemeAnimation_Meta{PyType_FromSpec(&type_spec_SwipeBackThemeAnimation_Meta)};
    if (!type_SwipeBackThemeAnimation_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_SwipeBackThemeAnimation, &type_spec_SwipeBackThemeAnimation, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SwipeBackThemeAnimation_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_SwipeBackThemeAnimation, &type_spec_SwipeBackThemeAnimation, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SwipeBackThemeAnimation_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_SwipeHintThemeAnimation_Meta{PyType_FromSpec(&type_spec_SwipeHintThemeAnimation_Meta)};
    if (!type_SwipeHintThemeAnimation_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_SwipeHintThemeAnimation, &type_spec_SwipeHintThemeAnimation, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SwipeHintThemeAnimation_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_SwipeHintThemeAnimation, &type_spec_SwipeHintThemeAnimation, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SwipeHintThemeAnimation_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_Timeline_Meta{PyType_FromSpec(&type_spec_Timeline_Meta)};
    if (!type_Timeline_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_Timeline, &type_spec_Timeline, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Timeline_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_Timeline, &type_spec_Timeline, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Timeline_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_TimelineCollection, &type_spec_TimelineCollection, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_TimelineCollection, &type_spec_TimelineCollection, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_Transition, &type_spec_Transition, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_Transition, &type_spec_Transition, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_TransitionCollection, &type_spec_TransitionCollection, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_TransitionCollection, &type_spec_TransitionCollection, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_KeyTime, &type_spec_KeyTime, nullptr, nullptr, nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_KeyTime, &type_spec_KeyTime, nullptr, nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RepeatBehavior, &type_spec_RepeatBehavior, nullptr, nullptr, nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RepeatBehavior, &type_spec_RepeatBehavior, nullptr, nullptr) == -1)
    #endif
    {
        return nullptr;
    }


    return module.detach();
}
