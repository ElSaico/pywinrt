# WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt.system
import winrt.windows.devices.bluetooth.genericattributeprofile
import winrt.windows.devices.bluetooth.rfcomm
import winrt.windows.devices.enumeration
import winrt.windows.devices.radios
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.networking
import winrt.windows.storage.streams

from winrt.windows.devices.bluetooth import BluetoothAddressType, BluetoothCacheMode, BluetoothConnectionStatus, BluetoothError, BluetoothLEPreferredConnectionParametersRequestStatus, BluetoothMajorClass, BluetoothMinorClass, BluetoothServiceCapabilities

Self = typing.TypeVar('Self')

class BluetoothAdapter(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BluetoothAdapter: ...
    @staticmethod
    def from_id_async(device_id: str, /) -> winrt.windows.foundation.IAsyncOperation[BluetoothAdapter]: ...
    @staticmethod
    def get_default_async() -> winrt.windows.foundation.IAsyncOperation[BluetoothAdapter]: ...
    @staticmethod
    def get_device_selector() -> str: ...
    def get_radio_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.devices.radios.Radio]: ...
    @_property
    def bluetooth_address(self) -> winrt.system.UInt64: ...
    @_property
    def device_id(self) -> str: ...
    @_property
    def is_advertisement_offload_supported(self) -> bool: ...
    @_property
    def is_central_role_supported(self) -> bool: ...
    @_property
    def is_classic_supported(self) -> bool: ...
    @_property
    def is_low_energy_supported(self) -> bool: ...
    @_property
    def is_peripheral_role_supported(self) -> bool: ...
    @_property
    def are_classic_secure_connections_supported(self) -> bool: ...
    @_property
    def are_low_energy_secure_connections_supported(self) -> bool: ...
    @_property
    def is_extended_advertising_supported(self) -> bool: ...
    @_property
    def max_advertisement_data_length(self) -> winrt.system.UInt32: ...

class BluetoothClassOfDevice(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BluetoothClassOfDevice: ...
    @staticmethod
    def from_parts(major_class: BluetoothMajorClass, minor_class: BluetoothMinorClass, service_capabilities: BluetoothServiceCapabilities, /) -> typing.Optional[BluetoothClassOfDevice]: ...
    @staticmethod
    def from_raw_value(raw_value: winrt.system.UInt32, /) -> typing.Optional[BluetoothClassOfDevice]: ...
    @_property
    def major_class(self) -> BluetoothMajorClass: ...
    @_property
    def minor_class(self) -> BluetoothMinorClass: ...
    @_property
    def raw_value(self) -> winrt.system.UInt32: ...
    @_property
    def service_capabilities(self) -> BluetoothServiceCapabilities: ...

class BluetoothDevice(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BluetoothDevice: ...
    def close(self) -> None: ...
    @staticmethod
    def from_bluetooth_address_async(address: winrt.system.UInt64, /) -> winrt.windows.foundation.IAsyncOperation[BluetoothDevice]: ...
    @staticmethod
    def from_host_name_async(host_name: typing.Optional[winrt.windows.networking.HostName], /) -> winrt.windows.foundation.IAsyncOperation[BluetoothDevice]: ...
    @staticmethod
    def from_id_async(device_id: str, /) -> winrt.windows.foundation.IAsyncOperation[BluetoothDevice]: ...
    @staticmethod
    def get_device_selector() -> str: ...
    @staticmethod
    def get_device_selector_from_bluetooth_address(bluetooth_address: winrt.system.UInt64, /) -> str: ...
    @staticmethod
    def get_device_selector_from_class_of_device(class_of_device: typing.Optional[BluetoothClassOfDevice], /) -> str: ...
    @staticmethod
    def get_device_selector_from_connection_status(connection_status: BluetoothConnectionStatus, /) -> str: ...
    @staticmethod
    def get_device_selector_from_device_name(device_name: str, /) -> str: ...
    @staticmethod
    def get_device_selector_from_pairing_state(pairing_state: bool, /) -> str: ...
    @typing.overload
    def get_rfcomm_services_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.devices.bluetooth.rfcomm.RfcommDeviceServicesResult]: ...
    @typing.overload
    def get_rfcomm_services_async(self, cache_mode: BluetoothCacheMode, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.devices.bluetooth.rfcomm.RfcommDeviceServicesResult]: ...
    @typing.overload
    def get_rfcomm_services_for_id_async(self, service_id: typing.Optional[winrt.windows.devices.bluetooth.rfcomm.RfcommServiceId], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.devices.bluetooth.rfcomm.RfcommDeviceServicesResult]: ...
    @typing.overload
    def get_rfcomm_services_for_id_async(self, service_id: typing.Optional[winrt.windows.devices.bluetooth.rfcomm.RfcommServiceId], cache_mode: BluetoothCacheMode, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.devices.bluetooth.rfcomm.RfcommDeviceServicesResult]: ...
    def request_access_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.devices.enumeration.DeviceAccessStatus]: ...
    def add_connection_status_changed(self, handler: winrt.windows.foundation.TypedEventHandler[BluetoothDevice, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_connection_status_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_name_changed(self, handler: winrt.windows.foundation.TypedEventHandler[BluetoothDevice, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_name_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_sdp_records_changed(self, handler: winrt.windows.foundation.TypedEventHandler[BluetoothDevice, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_sdp_records_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def bluetooth_address(self) -> winrt.system.UInt64: ...
    @_property
    def class_of_device(self) -> typing.Optional[BluetoothClassOfDevice]: ...
    @_property
    def connection_status(self) -> BluetoothConnectionStatus: ...
    @_property
    def device_id(self) -> str: ...
    @_property
    def host_name(self) -> typing.Optional[winrt.windows.networking.HostName]: ...
    @_property
    def name(self) -> str: ...
    @_property
    def rfcomm_services(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.devices.bluetooth.rfcomm.RfcommDeviceService]]: ...
    @_property
    def sdp_records(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.storage.streams.IBuffer]]: ...
    @_property
    def device_information(self) -> typing.Optional[winrt.windows.devices.enumeration.DeviceInformation]: ...
    @_property
    def device_access_information(self) -> typing.Optional[winrt.windows.devices.enumeration.DeviceAccessInformation]: ...
    @_property
    def bluetooth_device_id(self) -> typing.Optional[BluetoothDeviceId]: ...
    @_property
    def was_secure_connection_used_for_pairing(self) -> bool: ...

class BluetoothDeviceId(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BluetoothDeviceId: ...
    @staticmethod
    def from_id(device_id: str, /) -> typing.Optional[BluetoothDeviceId]: ...
    @_property
    def id(self) -> str: ...
    @_property
    def is_classic_device(self) -> bool: ...
    @_property
    def is_low_energy_device(self) -> bool: ...

class BluetoothLEAppearance(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BluetoothLEAppearance: ...
    @staticmethod
    def from_parts(appearance_category: winrt.system.UInt16, appearance_sub_category: winrt.system.UInt16, /) -> typing.Optional[BluetoothLEAppearance]: ...
    @staticmethod
    def from_raw_value(raw_value: winrt.system.UInt16, /) -> typing.Optional[BluetoothLEAppearance]: ...
    @_property
    def category(self) -> winrt.system.UInt16: ...
    @_property
    def raw_value(self) -> winrt.system.UInt16: ...
    @_property
    def sub_category(self) -> winrt.system.UInt16: ...

class BluetoothLEAppearanceCategories(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BluetoothLEAppearanceCategories: ...
    barcode_scanner: typing.ClassVar[winrt.system.UInt16]
    blood_pressure: typing.ClassVar[winrt.system.UInt16]
    clock: typing.ClassVar[winrt.system.UInt16]
    computer: typing.ClassVar[winrt.system.UInt16]
    cycling: typing.ClassVar[winrt.system.UInt16]
    display: typing.ClassVar[winrt.system.UInt16]
    eye_glasses: typing.ClassVar[winrt.system.UInt16]
    glucose_meter: typing.ClassVar[winrt.system.UInt16]
    heart_rate: typing.ClassVar[winrt.system.UInt16]
    human_interface_device: typing.ClassVar[winrt.system.UInt16]
    keyring: typing.ClassVar[winrt.system.UInt16]
    media_player: typing.ClassVar[winrt.system.UInt16]
    outdoor_sport_activity: typing.ClassVar[winrt.system.UInt16]
    phone: typing.ClassVar[winrt.system.UInt16]
    pulse_oximeter: typing.ClassVar[winrt.system.UInt16]
    remote_control: typing.ClassVar[winrt.system.UInt16]
    running_walking: typing.ClassVar[winrt.system.UInt16]
    tag: typing.ClassVar[winrt.system.UInt16]
    thermometer: typing.ClassVar[winrt.system.UInt16]
    uncategorized: typing.ClassVar[winrt.system.UInt16]
    watch: typing.ClassVar[winrt.system.UInt16]
    weight_scale: typing.ClassVar[winrt.system.UInt16]

class BluetoothLEAppearanceSubcategories(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BluetoothLEAppearanceSubcategories: ...
    barcode_scanner: typing.ClassVar[winrt.system.UInt16]
    blood_pressure_arm: typing.ClassVar[winrt.system.UInt16]
    blood_pressure_wrist: typing.ClassVar[winrt.system.UInt16]
    card_reader: typing.ClassVar[winrt.system.UInt16]
    cycling_cadence_sensor: typing.ClassVar[winrt.system.UInt16]
    cycling_computer: typing.ClassVar[winrt.system.UInt16]
    cycling_power_sensor: typing.ClassVar[winrt.system.UInt16]
    cycling_speed_cadence_sensor: typing.ClassVar[winrt.system.UInt16]
    cycling_speed_sensor: typing.ClassVar[winrt.system.UInt16]
    digital_pen: typing.ClassVar[winrt.system.UInt16]
    digitizer_tablet: typing.ClassVar[winrt.system.UInt16]
    gamepad: typing.ClassVar[winrt.system.UInt16]
    generic: typing.ClassVar[winrt.system.UInt16]
    heart_rate_belt: typing.ClassVar[winrt.system.UInt16]
    joystick: typing.ClassVar[winrt.system.UInt16]
    keyboard: typing.ClassVar[winrt.system.UInt16]
    location_display: typing.ClassVar[winrt.system.UInt16]
    location_navigation_display: typing.ClassVar[winrt.system.UInt16]
    location_navigation_pod: typing.ClassVar[winrt.system.UInt16]
    location_pod: typing.ClassVar[winrt.system.UInt16]
    mouse: typing.ClassVar[winrt.system.UInt16]
    oximeter_fingertip: typing.ClassVar[winrt.system.UInt16]
    oximeter_wrist_worn: typing.ClassVar[winrt.system.UInt16]
    running_walking_in_shoe: typing.ClassVar[winrt.system.UInt16]
    running_walking_on_hip: typing.ClassVar[winrt.system.UInt16]
    running_walking_on_shoe: typing.ClassVar[winrt.system.UInt16]
    sports_watch: typing.ClassVar[winrt.system.UInt16]
    thermometer_ear: typing.ClassVar[winrt.system.UInt16]

class BluetoothLEConnectionParameters(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BluetoothLEConnectionParameters: ...
    @_property
    def connection_interval(self) -> winrt.system.UInt16: ...
    @_property
    def connection_latency(self) -> winrt.system.UInt16: ...
    @_property
    def link_timeout(self) -> winrt.system.UInt16: ...

class BluetoothLEConnectionPhy(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BluetoothLEConnectionPhy: ...
    @_property
    def receive_info(self) -> typing.Optional[BluetoothLEConnectionPhyInfo]: ...
    @_property
    def transmit_info(self) -> typing.Optional[BluetoothLEConnectionPhyInfo]: ...

class BluetoothLEConnectionPhyInfo(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BluetoothLEConnectionPhyInfo: ...
    @_property
    def is_coded_phy(self) -> bool: ...
    @_property
    def is_uncoded1_m_phy(self) -> bool: ...
    @_property
    def is_uncoded2_m_phy(self) -> bool: ...

class BluetoothLEDevice(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BluetoothLEDevice: ...
    def close(self) -> None: ...
    @typing.overload
    @staticmethod
    def from_bluetooth_address_async(bluetooth_address: winrt.system.UInt64, /) -> winrt.windows.foundation.IAsyncOperation[BluetoothLEDevice]: ...
    @typing.overload
    @staticmethod
    def from_bluetooth_address_async(bluetooth_address: winrt.system.UInt64, bluetooth_address_type: BluetoothAddressType, /) -> winrt.windows.foundation.IAsyncOperation[BluetoothLEDevice]: ...
    @staticmethod
    def from_id_async(device_id: str, /) -> winrt.windows.foundation.IAsyncOperation[BluetoothLEDevice]: ...
    def get_connection_parameters(self) -> typing.Optional[BluetoothLEConnectionParameters]: ...
    def get_connection_phy(self) -> typing.Optional[BluetoothLEConnectionPhy]: ...
    @staticmethod
    def get_device_selector() -> str: ...
    @staticmethod
    def get_device_selector_from_appearance(appearance: typing.Optional[BluetoothLEAppearance], /) -> str: ...
    @typing.overload
    @staticmethod
    def get_device_selector_from_bluetooth_address(bluetooth_address: winrt.system.UInt64, /) -> str: ...
    @typing.overload
    @staticmethod
    def get_device_selector_from_bluetooth_address(bluetooth_address: winrt.system.UInt64, bluetooth_address_type: BluetoothAddressType, /) -> str: ...
    @staticmethod
    def get_device_selector_from_connection_status(connection_status: BluetoothConnectionStatus, /) -> str: ...
    @staticmethod
    def get_device_selector_from_device_name(device_name: str, /) -> str: ...
    @staticmethod
    def get_device_selector_from_pairing_state(pairing_state: bool, /) -> str: ...
    def get_gatt_service(self, service_uuid: _uuid.UUID, /) -> typing.Optional[winrt.windows.devices.bluetooth.genericattributeprofile.GattDeviceService]: ...
    @typing.overload
    def get_gatt_services_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.devices.bluetooth.genericattributeprofile.GattDeviceServicesResult]: ...
    @typing.overload
    def get_gatt_services_async(self, cache_mode: BluetoothCacheMode, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.devices.bluetooth.genericattributeprofile.GattDeviceServicesResult]: ...
    @typing.overload
    def get_gatt_services_for_uuid_async(self, service_uuid: _uuid.UUID, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.devices.bluetooth.genericattributeprofile.GattDeviceServicesResult]: ...
    @typing.overload
    def get_gatt_services_for_uuid_async(self, service_uuid: _uuid.UUID, cache_mode: BluetoothCacheMode, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.devices.bluetooth.genericattributeprofile.GattDeviceServicesResult]: ...
    def request_access_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.devices.enumeration.DeviceAccessStatus]: ...
    def request_preferred_connection_parameters(self, preferred_connection_parameters: typing.Optional[BluetoothLEPreferredConnectionParameters], /) -> typing.Optional[BluetoothLEPreferredConnectionParametersRequest]: ...
    def add_connection_status_changed(self, handler: winrt.windows.foundation.TypedEventHandler[BluetoothLEDevice, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_connection_status_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_gatt_services_changed(self, handler: winrt.windows.foundation.TypedEventHandler[BluetoothLEDevice, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_gatt_services_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_name_changed(self, handler: winrt.windows.foundation.TypedEventHandler[BluetoothLEDevice, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_name_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_connection_parameters_changed(self, handler: winrt.windows.foundation.TypedEventHandler[BluetoothLEDevice, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_connection_parameters_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_connection_phy_changed(self, handler: winrt.windows.foundation.TypedEventHandler[BluetoothLEDevice, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_connection_phy_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def bluetooth_address(self) -> winrt.system.UInt64: ...
    @_property
    def connection_status(self) -> BluetoothConnectionStatus: ...
    @_property
    def device_id(self) -> str: ...
    @_property
    def gatt_services(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.devices.bluetooth.genericattributeprofile.GattDeviceService]]: ...
    @_property
    def name(self) -> str: ...
    @_property
    def appearance(self) -> typing.Optional[BluetoothLEAppearance]: ...
    @_property
    def bluetooth_address_type(self) -> BluetoothAddressType: ...
    @_property
    def device_information(self) -> typing.Optional[winrt.windows.devices.enumeration.DeviceInformation]: ...
    @_property
    def device_access_information(self) -> typing.Optional[winrt.windows.devices.enumeration.DeviceAccessInformation]: ...
    @_property
    def bluetooth_device_id(self) -> typing.Optional[BluetoothDeviceId]: ...
    @_property
    def was_secure_connection_used_for_pairing(self) -> bool: ...

class BluetoothLEPreferredConnectionParameters(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BluetoothLEPreferredConnectionParameters: ...
    @_property
    def connection_latency(self) -> winrt.system.UInt16: ...
    @_property
    def link_timeout(self) -> winrt.system.UInt16: ...
    @_property
    def max_connection_interval(self) -> winrt.system.UInt16: ...
    @_property
    def min_connection_interval(self) -> winrt.system.UInt16: ...
    balanced: typing.ClassVar[typing.Optional[BluetoothLEPreferredConnectionParameters]]
    power_optimized: typing.ClassVar[typing.Optional[BluetoothLEPreferredConnectionParameters]]
    throughput_optimized: typing.ClassVar[typing.Optional[BluetoothLEPreferredConnectionParameters]]

class BluetoothLEPreferredConnectionParametersRequest(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BluetoothLEPreferredConnectionParametersRequest: ...
    def close(self) -> None: ...
    @_property
    def status(self) -> BluetoothLEPreferredConnectionParametersRequestStatus: ...

class BluetoothSignalStrengthFilter(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BluetoothSignalStrengthFilter: ...
    def __new__(cls: typing.Type[BluetoothSignalStrengthFilter]) -> BluetoothSignalStrengthFilter:...
    @_property
    def sampling_interval(self) -> typing.Optional[typing.Optional[datetime.timedelta]]: ...
    @sampling_interval.setter
    def sampling_interval(self, value: typing.Optional[typing.Optional[datetime.timedelta]]) -> None: ...
    @_property
    def out_of_range_timeout(self) -> typing.Optional[typing.Optional[datetime.timedelta]]: ...
    @out_of_range_timeout.setter
    def out_of_range_timeout(self, value: typing.Optional[typing.Optional[datetime.timedelta]]) -> None: ...
    @_property
    def out_of_range_threshold_in_d_bm(self) -> typing.Optional[typing.Optional[winrt.system.Int16]]: ...
    @out_of_range_threshold_in_d_bm.setter
    def out_of_range_threshold_in_d_bm(self, value: typing.Optional[typing.Optional[winrt.system.Int16]]) -> None: ...
    @_property
    def in_range_threshold_in_d_bm(self) -> typing.Optional[typing.Optional[winrt.system.Int16]]: ...
    @in_range_threshold_in_d_bm.setter
    def in_range_threshold_in_d_bm(self, value: typing.Optional[typing.Optional[winrt.system.Int16]]) -> None: ...

class BluetoothUuidHelper(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BluetoothUuidHelper: ...
    @staticmethod
    def from_short_id(short_id: winrt.system.UInt32, /) -> _uuid.UUID: ...
    @staticmethod
    def try_get_short_id(uuid: _uuid.UUID, /) -> typing.Optional[typing.Optional[winrt.system.UInt32]]: ...

