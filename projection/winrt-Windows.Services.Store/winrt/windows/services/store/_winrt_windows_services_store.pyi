# WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

import datetime
import sys
import types
import typing
import uuid

import winrt.system
import winrt.windows.applicationmodel
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.system
import winrt.windows.web.http

from . import StoreCanLicenseStatus, StoreConsumableStatus, StoreDurationUnit, StorePackageUpdateState, StorePurchaseStatus, StoreQueueItemExtendedState, StoreQueueItemKind, StoreQueueItemState, StoreRateAndReviewStatus, StoreUninstallStorePackageStatus

Self = typing.TypeVar('Self')

class StorePackageUpdateStatus:
    package_family_name: str
    package_download_size_in_bytes: winrt.system.UInt64
    package_bytes_downloaded: winrt.system.UInt64
    package_download_progress: winrt.system.Double
    total_download_progress: winrt.system.Double
    package_update_state: StorePackageUpdateState
    def __new__(cls: typing.Type[StorePackageUpdateStatus], package_family_name: str, package_download_size_in_bytes: winrt.system.UInt64, package_bytes_downloaded: winrt.system.UInt64, package_download_progress: winrt.system.Double, total_download_progress: winrt.system.Double, package_update_state: StorePackageUpdateState) -> StorePackageUpdateStatus: ...

class StoreAcquireLicenseResult(winrt.system.Object):
    extended_error: winrt.windows.foundation.HResult
    store_package_license: typing.Optional[StorePackageLicense]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StoreAcquireLicenseResult: ...

class StoreAppLicense(winrt.system.Object):
    add_on_licenses: typing.Optional[winrt.windows.foundation.collections.IMapView[str, StoreLicense]]
    expiration_date: datetime.datetime
    extended_json_data: str
    is_active: bool
    is_trial: bool
    is_trial_owned_by_this_user: bool
    sku_store_id: str
    trial_time_remaining: datetime.timedelta
    trial_unique_id: str
    is_disc_license: bool
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StoreAppLicense: ...

class StoreAvailability(winrt.system.Object):
    end_date: datetime.datetime
    extended_json_data: str
    price: typing.Optional[StorePrice]
    store_id: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StoreAvailability: ...
    @typing.overload
    def request_purchase_async(self) -> winrt.windows.foundation.IAsyncOperation[StorePurchaseResult]: ...
    @typing.overload
    def request_purchase_async(self, store_purchase_properties: typing.Optional[StorePurchaseProperties], /) -> winrt.windows.foundation.IAsyncOperation[StorePurchaseResult]: ...

class StoreCanAcquireLicenseResult(winrt.system.Object):
    extended_error: winrt.windows.foundation.HResult
    licensable_sku: str
    status: StoreCanLicenseStatus
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StoreCanAcquireLicenseResult: ...

class StoreCollectionData(winrt.system.Object):
    acquired_date: datetime.datetime
    campaign_id: str
    developer_offer_id: str
    end_date: datetime.datetime
    extended_json_data: str
    is_trial: bool
    start_date: datetime.datetime
    trial_time_remaining: datetime.timedelta
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StoreCollectionData: ...

class StoreConsumableResult(winrt.system.Object):
    balance_remaining: winrt.system.UInt32
    extended_error: winrt.windows.foundation.HResult
    status: StoreConsumableStatus
    tracking_id: uuid.UUID
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StoreConsumableResult: ...

class StoreContext(winrt.system.Object):
    user: typing.Optional[winrt.windows.system.User]
    can_silently_download_store_package_updates: bool
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StoreContext: ...
    def acquire_store_license_for_optional_package_async(self, optional_package: typing.Optional[winrt.windows.applicationmodel.Package], /) -> winrt.windows.foundation.IAsyncOperation[StoreAcquireLicenseResult]: ...
    def can_acquire_store_license_async(self, product_store_id: str, /) -> winrt.windows.foundation.IAsyncOperation[StoreCanAcquireLicenseResult]: ...
    def can_acquire_store_license_for_optional_package_async(self, optional_package: typing.Optional[winrt.windows.applicationmodel.Package], /) -> winrt.windows.foundation.IAsyncOperation[StoreCanAcquireLicenseResult]: ...
    def download_and_install_store_packages_async(self, store_ids: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[StorePackageUpdateResult, StorePackageUpdateStatus]: ...
    def find_store_product_for_package_async(self, product_kinds: typing.Iterable[str], package: typing.Optional[winrt.windows.applicationmodel.Package], /) -> winrt.windows.foundation.IAsyncOperation[StoreProductResult]: ...
    def get_app_and_optional_store_package_updates_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[StorePackageUpdate]]: ...
    def get_app_license_async(self) -> winrt.windows.foundation.IAsyncOperation[StoreAppLicense]: ...
    def get_associated_store_products_async(self, product_kinds: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncOperation[StoreProductQueryResult]: ...
    def get_associated_store_products_by_in_app_offer_token_async(self, in_app_offer_tokens: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncOperation[StoreProductQueryResult]: ...
    def get_associated_store_products_with_paging_async(self, product_kinds: typing.Iterable[str], max_items_to_retrieve_per_page: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[StoreProductPagedQueryResult]: ...
    def get_associated_store_queue_items_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[StoreQueueItem]]: ...
    def get_consumable_balance_remaining_async(self, product_store_id: str, /) -> winrt.windows.foundation.IAsyncOperation[StoreConsumableResult]: ...
    def get_customer_collections_id_async(self, service_ticket: str, publisher_user_id: str, /) -> winrt.windows.foundation.IAsyncOperation[str]: ...
    def get_customer_purchase_id_async(self, service_ticket: str, publisher_user_id: str, /) -> winrt.windows.foundation.IAsyncOperation[str]: ...
    @staticmethod
    def get_default() -> typing.Optional[StoreContext]: ...
    @staticmethod
    def get_for_user(user: typing.Optional[winrt.windows.system.User], /) -> typing.Optional[StoreContext]: ...
    def get_store_product_for_current_app_async(self) -> winrt.windows.foundation.IAsyncOperation[StoreProductResult]: ...
    @typing.overload
    def get_store_products_async(self, product_kinds: typing.Iterable[str], store_ids: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncOperation[StoreProductQueryResult]: ...
    @typing.overload
    def get_store_products_async(self, product_kinds: typing.Iterable[str], store_ids: typing.Iterable[str], store_product_options: typing.Optional[StoreProductOptions], /) -> winrt.windows.foundation.IAsyncOperation[StoreProductQueryResult]: ...
    def get_store_queue_items_async(self, store_ids: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[StoreQueueItem]]: ...
    def get_user_collection_async(self, product_kinds: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncOperation[StoreProductQueryResult]: ...
    def get_user_collection_with_paging_async(self, product_kinds: typing.Iterable[str], max_items_to_retrieve_per_page: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[StoreProductPagedQueryResult]: ...
    def get_user_purchase_history_async(self, product_kinds: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncOperation[StoreProductQueryResult]: ...
    def report_consumable_fulfillment_async(self, product_store_id: str, quantity: winrt.system.UInt32, tracking_id: uuid.UUID, /) -> winrt.windows.foundation.IAsyncOperation[StoreConsumableResult]: ...
    def request_download_and_install_store_package_updates_async(self, store_package_updates: typing.Iterable[StorePackageUpdate], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[StorePackageUpdateResult, StorePackageUpdateStatus]: ...
    @typing.overload
    def request_download_and_install_store_packages_async(self, store_ids: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[StorePackageUpdateResult, StorePackageUpdateStatus]: ...
    @typing.overload
    def request_download_and_install_store_packages_async(self, store_ids: typing.Iterable[str], store_package_install_options: typing.Optional[StorePackageInstallOptions], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[StorePackageUpdateResult, StorePackageUpdateStatus]: ...
    def request_download_store_package_updates_async(self, store_package_updates: typing.Iterable[StorePackageUpdate], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[StorePackageUpdateResult, StorePackageUpdateStatus]: ...
    @typing.overload
    def request_purchase_async(self, store_id: str, /) -> winrt.windows.foundation.IAsyncOperation[StorePurchaseResult]: ...
    @typing.overload
    def request_purchase_async(self, store_id: str, store_purchase_properties: typing.Optional[StorePurchaseProperties], /) -> winrt.windows.foundation.IAsyncOperation[StorePurchaseResult]: ...
    def request_purchase_by_in_app_offer_token_async(self, in_app_offer_token: str, /) -> winrt.windows.foundation.IAsyncOperation[StorePurchaseResult]: ...
    def request_rate_and_review_app_async(self) -> winrt.windows.foundation.IAsyncOperation[StoreRateAndReviewResult]: ...
    def request_uninstall_store_package_async(self, package: typing.Optional[winrt.windows.applicationmodel.Package], /) -> winrt.windows.foundation.IAsyncOperation[StoreUninstallStorePackageResult]: ...
    def request_uninstall_store_package_by_store_id_async(self, store_id: str, /) -> winrt.windows.foundation.IAsyncOperation[StoreUninstallStorePackageResult]: ...
    def set_install_order_for_associated_store_queue_items_async(self, items: typing.Iterable[StoreQueueItem], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[StoreQueueItem]]: ...
    def try_silent_download_and_install_store_package_updates_async(self, store_package_updates: typing.Iterable[StorePackageUpdate], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[StorePackageUpdateResult, StorePackageUpdateStatus]: ...
    def try_silent_download_store_package_updates_async(self, store_package_updates: typing.Iterable[StorePackageUpdate], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[StorePackageUpdateResult, StorePackageUpdateStatus]: ...
    def uninstall_store_package_async(self, package: typing.Optional[winrt.windows.applicationmodel.Package], /) -> winrt.windows.foundation.IAsyncOperation[StoreUninstallStorePackageResult]: ...
    def uninstall_store_package_by_store_id_async(self, store_id: str, /) -> winrt.windows.foundation.IAsyncOperation[StoreUninstallStorePackageResult]: ...
    def add_offline_licenses_changed(self, handler: winrt.windows.foundation.TypedEventHandler[StoreContext, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_offline_licenses_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class StoreImage(winrt.system.Object):
    caption: str
    height: winrt.system.UInt32
    image_purpose_tag: str
    uri: typing.Optional[winrt.windows.foundation.Uri]
    width: winrt.system.UInt32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StoreImage: ...

class StoreLicense(winrt.system.Object):
    expiration_date: datetime.datetime
    extended_json_data: str
    in_app_offer_token: str
    is_active: bool
    sku_store_id: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StoreLicense: ...

class StorePackageInstallOptions(winrt.system.Object):
    allow_forced_app_restart: bool
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StorePackageInstallOptions: ...
    def __new__(cls: typing.Type[StorePackageInstallOptions]) -> StorePackageInstallOptions:...

class StorePackageLicense(winrt.system.Object):
    is_valid: bool
    package: typing.Optional[winrt.windows.applicationmodel.Package]
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StorePackageLicense: ...
    def close(self) -> None: ...
    def release_license(self) -> None: ...
    def add_license_lost(self, handler: winrt.windows.foundation.TypedEventHandler[StorePackageLicense, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_license_lost(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class StorePackageUpdate(winrt.system.Object):
    mandatory: bool
    package: typing.Optional[winrt.windows.applicationmodel.Package]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StorePackageUpdate: ...

class StorePackageUpdateResult(winrt.system.Object):
    overall_state: StorePackageUpdateState
    store_package_update_statuses: typing.Optional[winrt.windows.foundation.collections.IVectorView[StorePackageUpdateStatus]]
    store_queue_items: typing.Optional[winrt.windows.foundation.collections.IVectorView[StoreQueueItem]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StorePackageUpdateResult: ...

class StorePrice(winrt.system.Object):
    currency_code: str
    formatted_base_price: str
    formatted_price: str
    formatted_recurrence_price: str
    is_on_sale: bool
    sale_end_date: datetime.datetime
    unformatted_base_price: str
    unformatted_price: str
    unformatted_recurrence_price: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StorePrice: ...

class StoreProduct(winrt.system.Object):
    description: str
    extended_json_data: str
    has_digital_download: bool
    images: typing.Optional[winrt.windows.foundation.collections.IVectorView[StoreImage]]
    in_app_offer_token: str
    is_in_user_collection: bool
    keywords: typing.Optional[winrt.windows.foundation.collections.IVectorView[str]]
    language: str
    link_uri: typing.Optional[winrt.windows.foundation.Uri]
    price: typing.Optional[StorePrice]
    product_kind: str
    skus: typing.Optional[winrt.windows.foundation.collections.IVectorView[StoreSku]]
    store_id: str
    title: str
    videos: typing.Optional[winrt.windows.foundation.collections.IVectorView[StoreVideo]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StoreProduct: ...
    def get_is_any_sku_installed_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @typing.overload
    def request_purchase_async(self) -> winrt.windows.foundation.IAsyncOperation[StorePurchaseResult]: ...
    @typing.overload
    def request_purchase_async(self, store_purchase_properties: typing.Optional[StorePurchaseProperties], /) -> winrt.windows.foundation.IAsyncOperation[StorePurchaseResult]: ...

class StoreProductOptions(winrt.system.Object):
    action_filters: typing.Optional[winrt.windows.foundation.collections.IVector[str]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StoreProductOptions: ...
    def __new__(cls: typing.Type[StoreProductOptions]) -> StoreProductOptions:...

class StoreProductPagedQueryResult(winrt.system.Object):
    extended_error: winrt.windows.foundation.HResult
    has_more_results: bool
    products: typing.Optional[winrt.windows.foundation.collections.IMapView[str, StoreProduct]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StoreProductPagedQueryResult: ...
    def get_next_async(self) -> winrt.windows.foundation.IAsyncOperation[StoreProductPagedQueryResult]: ...

class StoreProductQueryResult(winrt.system.Object):
    extended_error: winrt.windows.foundation.HResult
    products: typing.Optional[winrt.windows.foundation.collections.IMapView[str, StoreProduct]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StoreProductQueryResult: ...

class StoreProductResult(winrt.system.Object):
    extended_error: winrt.windows.foundation.HResult
    product: typing.Optional[StoreProduct]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StoreProductResult: ...

class StorePurchaseProperties(winrt.system.Object):
    name: str
    extended_json_data: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StorePurchaseProperties: ...
    @typing.overload
    def __new__(cls: typing.Type[StorePurchaseProperties], name: str) -> StorePurchaseProperties:...
    @typing.overload
    def __new__(cls: typing.Type[StorePurchaseProperties]) -> StorePurchaseProperties:...

class StorePurchaseResult(winrt.system.Object):
    extended_error: winrt.windows.foundation.HResult
    status: StorePurchaseStatus
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StorePurchaseResult: ...

class StoreQueueItem(winrt.system.Object):
    install_kind: StoreQueueItemKind
    package_family_name: str
    product_id: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StoreQueueItem: ...
    def cancel_install_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def get_current_status(self) -> typing.Optional[StoreQueueItemStatus]: ...
    def pause_install_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def resume_install_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def add_completed(self, handler: winrt.windows.foundation.TypedEventHandler[StoreQueueItem, StoreQueueItemCompletedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_status_changed(self, handler: winrt.windows.foundation.TypedEventHandler[StoreQueueItem, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_status_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

class StoreQueueItemCompletedEventArgs(winrt.system.Object):
    status: typing.Optional[StoreQueueItemStatus]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StoreQueueItemCompletedEventArgs: ...

class StoreQueueItemStatus(winrt.system.Object):
    extended_error: winrt.windows.foundation.HResult
    package_install_extended_state: StoreQueueItemExtendedState
    package_install_state: StoreQueueItemState
    update_status: StorePackageUpdateStatus
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StoreQueueItemStatus: ...

class StoreRateAndReviewResult(winrt.system.Object):
    extended_error: winrt.windows.foundation.HResult
    extended_json_data: str
    status: StoreRateAndReviewStatus
    was_updated: bool
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StoreRateAndReviewResult: ...

class StoreRequestHelper(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StoreRequestHelper: ...
    @staticmethod
    def send_request_async(context: typing.Optional[StoreContext], request_kind: winrt.system.UInt32, parameters_as_json: str, /) -> winrt.windows.foundation.IAsyncOperation[StoreSendRequestResult]: ...

class StoreSendRequestResult(winrt.system.Object):
    extended_error: winrt.windows.foundation.HResult
    response: str
    http_status_code: winrt.windows.web.http.HttpStatusCode
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StoreSendRequestResult: ...

class StoreSku(winrt.system.Object):
    availabilities: typing.Optional[winrt.windows.foundation.collections.IVectorView[StoreAvailability]]
    bundled_skus: typing.Optional[winrt.windows.foundation.collections.IVectorView[str]]
    collection_data: typing.Optional[StoreCollectionData]
    custom_developer_data: str
    description: str
    extended_json_data: str
    images: typing.Optional[winrt.windows.foundation.collections.IVectorView[StoreImage]]
    is_in_user_collection: bool
    is_subscription: bool
    is_trial: bool
    language: str
    price: typing.Optional[StorePrice]
    store_id: str
    subscription_info: typing.Optional[StoreSubscriptionInfo]
    title: str
    videos: typing.Optional[winrt.windows.foundation.collections.IVectorView[StoreVideo]]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StoreSku: ...
    def get_is_installed_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @typing.overload
    def request_purchase_async(self) -> winrt.windows.foundation.IAsyncOperation[StorePurchaseResult]: ...
    @typing.overload
    def request_purchase_async(self, store_purchase_properties: typing.Optional[StorePurchaseProperties], /) -> winrt.windows.foundation.IAsyncOperation[StorePurchaseResult]: ...

class StoreSubscriptionInfo(winrt.system.Object):
    billing_period: winrt.system.UInt32
    billing_period_unit: StoreDurationUnit
    has_trial_period: bool
    trial_period: winrt.system.UInt32
    trial_period_unit: StoreDurationUnit
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StoreSubscriptionInfo: ...

class StoreUninstallStorePackageResult(winrt.system.Object):
    extended_error: winrt.windows.foundation.HResult
    status: StoreUninstallStorePackageStatus
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StoreUninstallStorePackageResult: ...

class StoreVideo(winrt.system.Object):
    caption: str
    height: winrt.system.UInt32
    preview_image: typing.Optional[StoreImage]
    uri: typing.Optional[winrt.windows.foundation.Uri]
    video_purpose_tag: str
    width: winrt.system.UInt32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StoreVideo: ...

