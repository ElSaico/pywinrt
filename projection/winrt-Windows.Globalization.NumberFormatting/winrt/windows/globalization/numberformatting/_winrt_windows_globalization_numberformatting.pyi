# WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

import datetime
import sys
import types
import typing
import uuid

import winrt.system
import winrt.windows.foundation
import winrt.windows.foundation.collections

from . import CurrencyFormatterMode, RoundingAlgorithm

Self = typing.TypeVar('Self')

class CurrencyFormatter(winrt.system.Object):
    currency: str
    mode: CurrencyFormatterMode
    numeral_system: str
    is_grouped: bool
    is_decimal_point_always_displayed: bool
    integer_digits: winrt.system.Int32
    fraction_digits: winrt.system.Int32
    geographic_region: str
    resolved_geographic_region: str
    resolved_language: str
    languages: typing.Optional[winrt.windows.foundation.collections.IVectorView[str]]
    number_rounder: typing.Optional[INumberRounder]
    is_zero_signed: bool
    significant_digits: winrt.system.Int32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CurrencyFormatter: ...
    @typing.overload
    def __new__(cls: typing.Type[CurrencyFormatter], currency_code: str) -> CurrencyFormatter:...
    @typing.overload
    def __new__(cls: typing.Type[CurrencyFormatter], currency_code: str, languages: typing.Iterable[str], geographic_region: str) -> CurrencyFormatter:...
    def apply_rounding_for_currency(self, rounding_algorithm: RoundingAlgorithm, /) -> None: ...
    def format(self, value: winrt.system.Double, /) -> str: ...
    def format_double(self, value: winrt.system.Double, /) -> str: ...
    def format_int(self, value: winrt.system.Int64, /) -> str: ...
    def format_uint(self, value: winrt.system.UInt64, /) -> str: ...
    def parse_double(self, text: str, /) -> typing.Optional[typing.Optional[winrt.system.Double]]: ...
    def parse_int(self, text: str, /) -> typing.Optional[typing.Optional[winrt.system.Int64]]: ...
    def parse_uint(self, text: str, /) -> typing.Optional[typing.Optional[winrt.system.UInt64]]: ...

class DecimalFormatter(winrt.system.Object):
    is_decimal_point_always_displayed: bool
    integer_digits: winrt.system.Int32
    is_grouped: bool
    numeral_system: str
    fraction_digits: winrt.system.Int32
    geographic_region: str
    languages: typing.Optional[winrt.windows.foundation.collections.IVectorView[str]]
    resolved_geographic_region: str
    resolved_language: str
    number_rounder: typing.Optional[INumberRounder]
    is_zero_signed: bool
    significant_digits: winrt.system.Int32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DecimalFormatter: ...
    @typing.overload
    def __new__(cls: typing.Type[DecimalFormatter], languages: typing.Iterable[str], geographic_region: str) -> DecimalFormatter:...
    @typing.overload
    def __new__(cls: typing.Type[DecimalFormatter]) -> DecimalFormatter:...
    def format(self, value: winrt.system.Double, /) -> str: ...
    def format_double(self, value: winrt.system.Double, /) -> str: ...
    def format_int(self, value: winrt.system.Int64, /) -> str: ...
    def format_uint(self, value: winrt.system.UInt64, /) -> str: ...
    def parse_double(self, text: str, /) -> typing.Optional[typing.Optional[winrt.system.Double]]: ...
    def parse_int(self, text: str, /) -> typing.Optional[typing.Optional[winrt.system.Int64]]: ...
    def parse_uint(self, text: str, /) -> typing.Optional[typing.Optional[winrt.system.UInt64]]: ...

class IncrementNumberRounder(winrt.system.Object):
    rounding_algorithm: RoundingAlgorithm
    increment: winrt.system.Double
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IncrementNumberRounder: ...
    def __new__(cls: typing.Type[IncrementNumberRounder]) -> IncrementNumberRounder:...
    def round_double(self, value: winrt.system.Double, /) -> winrt.system.Double: ...
    def round_int32(self, value: winrt.system.Int32, /) -> winrt.system.Int32: ...
    def round_int64(self, value: winrt.system.Int64, /) -> winrt.system.Int64: ...
    def round_single(self, value: winrt.system.Single, /) -> winrt.system.Single: ...
    def round_uint32(self, value: winrt.system.UInt32, /) -> winrt.system.UInt32: ...
    def round_uint64(self, value: winrt.system.UInt64, /) -> winrt.system.UInt64: ...

class NumeralSystemTranslator(winrt.system.Object):
    numeral_system: str
    languages: typing.Optional[winrt.windows.foundation.collections.IVectorView[str]]
    resolved_language: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> NumeralSystemTranslator: ...
    @typing.overload
    def __new__(cls: typing.Type[NumeralSystemTranslator], languages: typing.Iterable[str]) -> NumeralSystemTranslator:...
    @typing.overload
    def __new__(cls: typing.Type[NumeralSystemTranslator]) -> NumeralSystemTranslator:...
    def translate_numerals(self, value: str, /) -> str: ...

class PercentFormatter(winrt.system.Object):
    is_decimal_point_always_displayed: bool
    integer_digits: winrt.system.Int32
    is_grouped: bool
    numeral_system: str
    fraction_digits: winrt.system.Int32
    geographic_region: str
    languages: typing.Optional[winrt.windows.foundation.collections.IVectorView[str]]
    resolved_geographic_region: str
    resolved_language: str
    number_rounder: typing.Optional[INumberRounder]
    is_zero_signed: bool
    significant_digits: winrt.system.Int32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PercentFormatter: ...
    @typing.overload
    def __new__(cls: typing.Type[PercentFormatter], languages: typing.Iterable[str], geographic_region: str) -> PercentFormatter:...
    @typing.overload
    def __new__(cls: typing.Type[PercentFormatter]) -> PercentFormatter:...
    def format(self, value: winrt.system.Double, /) -> str: ...
    def format_double(self, value: winrt.system.Double, /) -> str: ...
    def format_int(self, value: winrt.system.Int64, /) -> str: ...
    def format_uint(self, value: winrt.system.UInt64, /) -> str: ...
    def parse_double(self, text: str, /) -> typing.Optional[typing.Optional[winrt.system.Double]]: ...
    def parse_int(self, text: str, /) -> typing.Optional[typing.Optional[winrt.system.Int64]]: ...
    def parse_uint(self, text: str, /) -> typing.Optional[typing.Optional[winrt.system.UInt64]]: ...

class PermilleFormatter(winrt.system.Object):
    is_decimal_point_always_displayed: bool
    integer_digits: winrt.system.Int32
    is_grouped: bool
    numeral_system: str
    fraction_digits: winrt.system.Int32
    geographic_region: str
    languages: typing.Optional[winrt.windows.foundation.collections.IVectorView[str]]
    resolved_geographic_region: str
    resolved_language: str
    number_rounder: typing.Optional[INumberRounder]
    is_zero_signed: bool
    significant_digits: winrt.system.Int32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PermilleFormatter: ...
    @typing.overload
    def __new__(cls: typing.Type[PermilleFormatter], languages: typing.Iterable[str], geographic_region: str) -> PermilleFormatter:...
    @typing.overload
    def __new__(cls: typing.Type[PermilleFormatter]) -> PermilleFormatter:...
    def format(self, value: winrt.system.Double, /) -> str: ...
    def format_double(self, value: winrt.system.Double, /) -> str: ...
    def format_int(self, value: winrt.system.Int64, /) -> str: ...
    def format_uint(self, value: winrt.system.UInt64, /) -> str: ...
    def parse_double(self, text: str, /) -> typing.Optional[typing.Optional[winrt.system.Double]]: ...
    def parse_int(self, text: str, /) -> typing.Optional[typing.Optional[winrt.system.Int64]]: ...
    def parse_uint(self, text: str, /) -> typing.Optional[typing.Optional[winrt.system.UInt64]]: ...

class SignificantDigitsNumberRounder(winrt.system.Object):
    significant_digits: winrt.system.UInt32
    rounding_algorithm: RoundingAlgorithm
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SignificantDigitsNumberRounder: ...
    def __new__(cls: typing.Type[SignificantDigitsNumberRounder]) -> SignificantDigitsNumberRounder:...
    def round_double(self, value: winrt.system.Double, /) -> winrt.system.Double: ...
    def round_int32(self, value: winrt.system.Int32, /) -> winrt.system.Int32: ...
    def round_int64(self, value: winrt.system.Int64, /) -> winrt.system.Int64: ...
    def round_single(self, value: winrt.system.Single, /) -> winrt.system.Single: ...
    def round_uint32(self, value: winrt.system.UInt32, /) -> winrt.system.UInt32: ...
    def round_uint64(self, value: winrt.system.UInt64, /) -> winrt.system.UInt64: ...

class INumberFormatter(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> INumberFormatter: ...
    def format(self, value: winrt.system.Double, /) -> str: ...

class INumberFormatter2(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> INumberFormatter2: ...
    def format_double(self, value: winrt.system.Double, /) -> str: ...
    def format_int(self, value: winrt.system.Int64, /) -> str: ...
    def format_uint(self, value: winrt.system.UInt64, /) -> str: ...

class INumberFormatterOptions(winrt.system.Object):
    fraction_digits: winrt.system.Int32
    geographic_region: str
    integer_digits: winrt.system.Int32
    is_decimal_point_always_displayed: bool
    is_grouped: bool
    languages: typing.Optional[winrt.windows.foundation.collections.IVectorView[str]]
    numeral_system: str
    resolved_geographic_region: str
    resolved_language: str
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> INumberFormatterOptions: ...

class INumberParser(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> INumberParser: ...
    def parse_double(self, text: str, /) -> typing.Optional[typing.Optional[winrt.system.Double]]: ...
    def parse_int(self, text: str, /) -> typing.Optional[typing.Optional[winrt.system.Int64]]: ...
    def parse_uint(self, text: str, /) -> typing.Optional[typing.Optional[winrt.system.UInt64]]: ...

class INumberRounder(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> INumberRounder: ...
    def round_double(self, value: winrt.system.Double, /) -> winrt.system.Double: ...
    def round_int32(self, value: winrt.system.Int32, /) -> winrt.system.Int32: ...
    def round_int64(self, value: winrt.system.Int64, /) -> winrt.system.Int64: ...
    def round_single(self, value: winrt.system.Single, /) -> winrt.system.Single: ...
    def round_uint32(self, value: winrt.system.UInt32, /) -> winrt.system.UInt32: ...
    def round_uint64(self, value: winrt.system.UInt64, /) -> winrt.system.UInt64: ...

class INumberRounderOption(winrt.system.Object):
    number_rounder: typing.Optional[INumberRounder]
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> INumberRounderOption: ...

class ISignedZeroOption(winrt.system.Object):
    is_zero_signed: bool
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ISignedZeroOption: ...

class ISignificantDigitsOption(winrt.system.Object):
    significant_digits: winrt.system.Int32
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ISignificantDigitsOption: ...

